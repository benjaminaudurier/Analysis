From 6c80c4dda9d90ddcac5db217c7e24c7ad23930cb Mon Sep 17 00:00:00 2001
From: baudurie <benjamin.audurier@cern.ch>
Date: Thu, 29 Jan 2015 18:34:38 +0100
Subject: [PATCH] Editing and implementing the MuMu Framework

---
 .../AccEffTemplates/GenParamCustomRadiativeDecay.C |   81 +
 .../AccEffTemplates/GenParamCustomSingleBen.C      |   94 +
 PWG/muondep/AliAnalysisMuMu.cxx                    | 3019 ++++++++++--------
 PWG/muondep/AliAnalysisMuMu.h                      |  102 +-
 PWG/muondep/AliAnalysisMuMuConfig.cxx              |    0
 PWG/muondep/AliAnalysisMuMuConfig.h                |    2 +
 PWG/muondep/AliAnalysisMuMuFnorm.cxx               |  416 ++-
 PWG/muondep/AliAnalysisMuMuFnorm.h                 |   13 +-
 PWG/muondep/AliAnalysisMuMuFnormBeta.cxx           | 1857 +++++++++++
 PWG/muondep/AliAnalysisMuMuFnormBeta.h             |  148 +
 PWG/muondep/AliAnalysisMuMuJpsiResult.cxx          | 3312 ++++++++++++++++----
 PWG/muondep/AliAnalysisMuMuJpsiResult.h            |   26 +
 PWG/muondep/AliAnalysisMuMuSpectra.cxx             |    3 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx      |  201 ++
 PWG/muondep/AliAnalysisMuMuSpectraCapsule.h        |   67 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx    |  446 +++
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h      |   80 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx   |  819 +++++
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h     |   87 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx  |  806 +++++
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h    |   89 +
 PWG/muondep/AliMuonAccEffSubmitter.cxx             |   14 +
 PWG/muondep/CMakeLists.txt                         |    6 +-
 PWG/muondep/PWGmuondepLinkDef.h                    |    4 +
 24 files changed, 9704 insertions(+), 1988 deletions(-)
 create mode 100644 PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C
 create mode 100644 PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C
 create mode 100644 PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuFnormBeta.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h

diff --git a/PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C b/PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C
new file mode 100644
index 0000000..d2cd660
--- /dev/null
+++ b/PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C
@@ -0,0 +1,81 @@
+#if !defined(__CINT__) || defined(__MAKECINT__)
+#include <Riostream.h>
+#include "TRandom.h"
+#include "AliGenerator.h"
+#include "AliGenParam.h"
+#endif
+
+static Int_t IpCustom( TRandom *ran);
+static Double_t PtCustom( const Double_t *px, const Double_t */*dummy*/ );
+static Double_t YCustom( const Double_t *py, const Double_t */*dummy*/ );
+static Double_t V2Custom( const Double_t *pv, const Double_t */*dummy*/ );
+
+//-------------------------------------------------------------------------
+AliGenerator* GenParamCustom()
+{
+  
+  AliGenCocktail *gener = new AliGenCocktail();
+  
+  gener->UsePerEventRates();
+  AliGenParam *jpsiGener = new AliGenParam(1,-1,PtCustom,YCustom,V2Custom,IpCustom);
+  jpsiGener->SetMomentumRange(0,1e6);
+  jpsiGener->SetPtRange(0,999.);
+  jpsiGener->SetYRange(-4.2, -2.3);
+  jpsiGener->SetPhiRange(0., 360.);
+  
+  jpsiGener->SetTrackingFlag(1);
+  jpsiGener->SetForceDecay(kNoDecay);  // Jpsi particles decay are switched-off for Pythia
+  
+  // evtGen (for radiative decays)
+  AliGenEvtGen *evtGener = new AliGenEvtGen();
+  evtGener->SetForceDecay(kDiMuon);
+  evtGener->SetParticleSwitchedOff(AliGenEvtGen::kCharmPart);
+  
+  // add Jpsi generator to cocktail
+  gener->AddGenerator(jpsiGener,"Jpsi",1);
+  // add EvtGen generator to cocktail
+  gener->AddGenerator(evtGener,"EvtGen",1);
+  
+  return gener;
+  
+  return gener;
+}
+
+//-------------------------------------------------------------------------
+Int_t IpCustom( TRandom *)
+{
+  // particle to simulate (e.g. 443 for J/psi)
+  return VAR_GENPARAMCUSTOM_PDGPARTICLECODE;
+}
+
+//-------------------------------------------------------------------------
+Double_t PtCustom( const Double_t *px, const Double_t */*dummy*/ )
+{
+  // pT distribution
+  Double_t x=*px;
+  Float_t p0,p1,p2,p3;
+  p0 = VAR_GENPARAMCUSTOM_PT_P0; // 1.13e9;
+  p1 = VAR_GENPARAMCUSTOM_PT_P1; // 18.05;
+  p2 = VAR_GENPARAMCUSTOM_PT_P2; // 2.05;
+  p3 = VAR_GENPARAMCUSTOM_PT_P3; // 3.34;
+  return p0 *x / TMath::Power( p1 + TMath::Power(x,p2), p3 );
+}
+
+//-------------------------------------------------------------------------
+Double_t YCustom( const Double_t *py, const Double_t */*dummy*/ )
+{
+  // y distribution
+  Double_t y = *py;
+  Float_t p0,p1;
+  p0 = VAR_GENPARAMCUSTOM_Y_P0; // 4.08e5;
+  p1 = VAR_GENPARAMCUSTOM_Y_P1; // 7.1e4;
+  return p0 + p1*y;
+}
+
+//-------------------------------------------------------------------------
+Double_t V2Custom( const Double_t */*dummy*/, const Double_t */*dummy*/ )
+{
+  // v2
+  return 0.;
+}
+
diff --git a/PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C b/PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C
new file mode 100644
index 0000000..3f4daae
--- /dev/null
+++ b/PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C
@@ -0,0 +1,94 @@
+/*
+ *  MuonGenerator.C
+ *  aliroot_dev
+ *
+ *  Created by philippe pillot on 05/03/13.
+ *  Copyright 2013 SUBATECH. All rights reserved.
+ *
+ */
+
+
+#if !defined(__CINT__) || defined(__MAKECINT__)
+#include <Riostream.h>
+#include "TRandom.h"
+#include "AliGenerator.h"
+#include "AliGenParam.h"
+#endif
+
+
+static Int_t IpMuon( TRandom *ran);
+static Double_t PtMuon( const Double_t *px, const Double_t */*dummy*/ );
+static Double_t YMuon( const Double_t *py, const Double_t */*dummy*/ );
+static Double_t V2Muon( const Double_t *pv, const Double_t */*dummy*/ );
+
+
+//-------------------------------------------------------------------------
+AliGenerator* GenParamCustomSingle()
+{
+  AliGenParam *singleMu = new AliGenParam(1,-1,PtMuon,YMuon,V2Muon,IpMuon);
+  singleMu->SetMomentumRange(0,1e6);
+  singleMu->SetPtRange(VAR_GENPARAMCUSTOMSINGLE_PTMIN,999.);
+  singleMu->SetYRange(-4.2, -2.3);
+  singleMu->SetPhiRange(0., 360.);
+  singleMu->SetForceDecay(kNoDecay);
+  singleMu->SetTrackingFlag(1);
+  return singleMu;
+}
+
+//-------------------------------------------------------------------------
+Int_t IpMuon(TRandom *ran)
+{
+  // muon composition
+
+  if (ran->Rndm() < 0.5 )
+  {
+    return 13;
+  }
+  else
+  {
+    return -13;
+  }
+}
+
+//-------------------------------------------------------------------------
+Double_t PtMuon( const Double_t *px, const Double_t */*dummy*/ )
+{
+  // muon pT
+
+  Double_t x=*px;
+  Float_t p0,p1,p2,p3,p4,p5;
+
+  //Default param. = tuned MSL LHC15n
+  p0= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P0;//135.137
+  p1= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P1;//0.555323
+  p2= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P2;//0.578374
+  p3= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P3;//10.1345
+  p4= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P4;//0.000232233
+  p5= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P5;//-0.924726
+
+
+  return p0 * (1. / TMath::Power(p1 + TMath::Power(x,p2), p3) + p4 * TMath::Exp(p5*x));
+}
+
+//-------------------------------------------------------------------------
+Double_t YMuon( const Double_t *py, const Double_t */*dummy*/ )
+{
+  // muon y
+
+  Double_t y = *py;
+  //pol4 only valid in y= -4;-2.5
+  Float_t p0,p1,p2;
+
+  //Default param. = tuned MSL LHC15n
+  p0= VAR_GENPARAMCUSTOMSINGLEBEN_Y_P0;//1.95551
+  p1= VAR_GENPARAMCUSTOMSINGLEBEN_Y_P1;//-0.104761
+  p2= VAR_GENPARAMCUSTOMSINGLEBEN_Y_P2;//0.00311324
+  return p0 * (1. + p1*y*y + p2*y*y*y*y);
+}
+
+//-------------------------------------------------------------------------
+Double_t V2Muon( const Double_t */*dummy*/, const Double_t */*dummy*/ )
+{
+  //muon v2
+  return 0.;
+}
diff --git a/PWG/muondep/AliAnalysisMuMu.cxx b/PWG/muondep/AliAnalysisMuMu.cxx
index 6113205..4864e2c 100644
--- a/PWG/muondep/AliAnalysisMuMu.cxx
+++ b/PWG/muondep/AliAnalysisMuMu.cxx
@@ -25,6 +25,9 @@
 #include "AliAnalysisMuMuGraphUtil.h"
 #include "AliAnalysisMuMuJpsiResult.h"
 #include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+#include "AliAnalysisMuMuSpectraCapsulePP.h"
 #include "AliAnalysisTriggerScalers.h"
 #include "AliCounterCollection.h"
 #include "AliHistogramCollection.h"
@@ -51,6 +54,7 @@
 #include "TList.h"
 #include "TMap.h"
 #include "TMath.h"
+#include "TMethodCall.h"
 #include "TObjArray.h"
 #include "TObjString.h"
 #include "TParameter.h"
@@ -63,7 +67,7 @@
 #include <cassert>
 #include <map>
 #include <set>
-#include <string>
+#include <vector>
 #include "TLatex.h"
 
 using std::cout;
@@ -296,6 +300,15 @@ void AliAnalysisMuMu::CleanAllSpectra()
     Update();
 }
 
+//_____________________________________________________________________________
+void AliAnalysisMuMu::CleanFNorm()
+{
+    /// Delete all the spectra we may have
+
+    OC()->Prune("/FNORM");
+    Update();
+}
+
 
 //_____________________________________________________________________________
 TObjArray* AliAnalysisMuMu::CompareJpsiPerCMUUWithBackground(const char* jpsiresults,
@@ -449,10 +462,342 @@ TGraph* AliAnalysisMuMu::CompareJpsiPerCMUUWithSimu(const char* realjpsiresults,
 }
 
 //_____________________________________________________________________________
-AliAnalysisMuMuConfig* AliAnalysisMuMu::Config()
+void AliAnalysisMuMu::DrawFitResults(const char* particle,
+                                     const char* binType,
+                                     const char* printDirectoryPath,
+                                     Bool_t Print,
+                                     Bool_t AccEffCorr
+                                     )const
+{
+    /// A function to use after JPsi()
+    /// Draw all results/subresults (i.e fit functions) spectras on a single canvas for every combination of Trigger / event Type / centrality / Pair cut.
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterater for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextBinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    AliAnalysisMuMuSpectra * spectra=0x0;
+
+    //Loop on particle
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextCentrality.Reset();
+
+                // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                    AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+                    nextPairCut.Reset();
+
+                    // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                        {
+                        AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+                        nextBinType.Reset();
+
+                        // Loop on each binType (PT or Y)
+                        //==============================================================================
+                        while ( ( sbinType = static_cast<TObjString*>(nextBinType()) ) )
+                            {
+                            AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
+                            // Output message
+                            cout << "---------------------" << endl;
+                            cout << "Looking for spectras ..."<< endl;
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+
+                            // Create pointer on fitted spectra. Any kind of capsule do the job
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,"","");
+                            if(!capsule)
+                                {
+                                AliError("Could not find spetra !");
+                                return;
+                                }
+                            // Draw results
+                            capsule->DrawResults(printDirectoryPath,Print,particle);
+                            delete capsule;
+
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+
+    return ;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::PrintFitParam( const char* particle,
+                                     const char* param,
+                                     const char* binType,
+                                     const char* subresult,
+                                     const char* printDirectoryPath,
+                                     Bool_t AccEffCorr
+                                     )const
+{
+    /// Draw fit parameter versus bin
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* paramArray    = TString(param).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* subresultArray     = TString(subresult).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterater for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextparam(paramArray);
+    TIter nextBinType(binTypeArray);
+    TIter nextSubResult(subresultArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparam;
+    TObjString* sbinType;
+    TObjString* ssubresult;
+    TObjString* scentrality;
+
+    AliAnalysisMuMuSpectra* spectra=0x0;
+    TH1                   *h =0x0;
+    TH1                   *href =0x0;
+
+
+    //Loop on param
+    while ( ( sparam = static_cast<TObjString*>(nextparam()) ) )
+        {
+        AliDebug(1,Form("param %s",sparam->String().Data()));
+        nextEventType.Reset();
+
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextCentrality.Reset();
+
+                // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                    AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+                    nextPairCut.Reset();
+
+                    // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                        {
+                        AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+                        nextBinType.Reset();
+
+
+                        // Loop on each binType (PT or Y)
+                        //==============================================================================
+                        while ( ( sbinType = static_cast<TObjString*>(nextBinType()) ) )
+                            {
+                            AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
+                            // Output message
+                            cout << "---------------------" << endl;
+                            cout << "Looking for spectras ..."<< endl;
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),particle,sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+
+                            TCanvas *c = new TCanvas;
+                            c->Divide(1,2,0,0);
+                            TLegend * leg = new TLegend(0.4,0.7,0.70,0.9);
+                            leg->SetHeader(Form("Fit Parameters %s ",sparam->String().Data()));
+                            leg->SetTextSize(0.03);
+
+                            c->cd(1);
+
+                            nextSubResult.Reset();
+                            int i= 1;
+                            while ( ( ssubresult = static_cast<TObjString*>(nextSubResult()) ) )
+                            {
+
+                              AliDebug(1,Form("-----SubResults %s",ssubresult->String().Data()));
+                              if(sparam->String().Contains("NofJPsi") &&  sbinType->String().Contains("PT"))h = spectra->Plot(param,ssubresult->String().Data(),kTRUE);
+                              else h = spectra->Plot(param,ssubresult->String().Data(),kFALSE);
+                              if(!h)
+                              {
+                                AliError(Form("Cannot find histo for SubResults %s",ssubresult->String().Data()));
+                                return;
+                              }
+                              if(i!=3 &&i!=5 )h->SetMarkerColor(i); //nobody likes green and yellow
+                              h->SetMarkerSize(1.);
+                              h->SetMarkerStyle(20+i);
+                              h->SetName(Form(" %s for result %s and bin %s",param,ssubresult->String().Data(),sbinType->String().Data()));
+                              if(i==1) h->DrawCopy();
+                              else h->DrawCopy("same");
+                              leg->AddEntry(h,Form("%s with %s",param,ssubresult->String().Data()),"pe");
+                              if (h)
+                              {
+                                printf("Replacing %s",h->GetName());
+                                OC()->Remove(Form("/%s/%s/%s/%s/FITPARAM/%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),h->GetName()));
+                              }
+                              Bool_t adoptOK = OC()->Adopt(Form("/%s/%s/%s/%s/FITPARAM",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data()),h);
+                              if ( adoptOK ) std::cout << "+++projection histo " << h->GetName() << " adopted" << std::endl;
+                              i++;
+
+                            }
+                            leg->Draw("same");
+
+                            c->cd(2);
+
+                            nextSubResult.Reset();
+                            TLegend * leg2 = new TLegend(0.4,0.75,0.70,0.9);
+                            leg2->SetHeader(Form("Ratio"));
+                            leg2->SetTextSize(0.03);
+                            int j= 1;
+                            TString refName;
+                            while ( ( ssubresult = static_cast<TObjString*>(nextSubResult()) ) )
+                            {
+                              if(j==1){
+                                href = spectra->Plot(param,ssubresult->String().Data(),kFALSE);
+                                refName = href->GetName();
+                                j++;
+                                continue;
+                              }
+
+                              AliDebug(1,Form("-----SubResults %s",ssubresult->String().Data()));
+                              h = spectra->Plot(param,ssubresult->String().Data(),kFALSE);
+
+                              if(!h || !href )
+                              {
+                                AliError(Form("Cannot find histos for SubResults  ratio "));
+                                return;
+                              }
+                              if(j!=3 &&j!=5 )h->SetMarkerColor(j); //nobody likes green and yellow
+                              h->SetMarkerSize(1.);
+                              h->SetMarkerStyle(20+j);
+                              h->SetName(Form(" %s %s over %s for %s",param,ssubresult->String().Data(),refName.Data(),sbinType->String().Data()));
+                              h->Divide(href);
+                              if(j==2)h->DrawCopy();
+                              else h->DrawCopy("same");
+
+                              leg2->AddEntry(h,Form("Results %d over Result 1",j),"pe");
+                              j++;
+                              if (h)
                               {
-  /// Return the configuration
-  return fConfig;
+                                printf("Replacing %s",h->GetName());
+                                OC()->Remove(Form("/%s/%s/%s/%s/FITPARAM/%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),h->GetName()));
+                              }
+                              Bool_t adoptOK = OC()->Adopt(Form("/%s/%s/%s/%s/FITPARAM",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data()),h);
+                              if ( adoptOK ) std::cout << "+++projection histo " << h->GetName() << " adopted" << std::endl;
+
+                            }
+                            leg2->Draw("same");
+                        }
+                    }
+                }
+            }
+        }
+    }
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete paramArray ;
+    delete binTypeArray ;
+
+    return ;
 }
 
 //_____________________________________________________________________________
@@ -668,6 +1013,300 @@ void AliAnalysisMuMu::ExecuteCanvasEvent(Int_t event, Int_t /*px*/, Int_t /*py*/
 
 }
 
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::RAAasGraphic(const char* particle,
+                                   const char* binType,
+                                   const char* externfile,
+                                   const char* externfile2,
+                                   const char* RefCent,
+                                   Bool_t AccEffCorr
+                                   )const
+{
+    /**
+     * Function to use after fitting procedur ( Jpsi() for instance ).
+     * Loops over all combination of /eventype/trigger/centrality (etc.), compute, store and print RAA on terminal.
+     * <binType> can be either "PT"/"Y"/"INTEGRATED" for the moment.
+     *
+     * Some comments: In case of PT/Y/CENTRALITY(single bin), the method implemented in AliAnalysisMuMuSpectraCapsulePbPb does the job, but for RAAvsCENTRALITY,
+     * we have to create a new TGraph (see inside for details)
+     */
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                             Computing RAA                             " << endl;
+        cout <<      " ================================================================ " << endl;
+        }
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    // Pointers
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphErr=0x0;
+    TGraphErrors* graphCent=0x0;
+    TGraphErrors* graphCentErr=0x0;
+    TList* list=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+
+    //Loop on particle type
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+
+                        //canvas
+                        TCanvas *c1 = new TCanvas;
+                        c1->Draw();
+                        //Divide canvas for pt and y bin
+                        if (!sbinType->String().Contains("INTEGRATED"))
+                            {
+                            Int_t nx(1);
+                            Int_t ny(1);
+                            Int_t nofGraph = centralityArray->GetEntries(); // # of histo
+                            if ( nofGraph == 2 )
+                                {
+                                nx=2;
+                                ny=0;
+                                }
+                            else if ( nofGraph > 2 )
+                                {
+                                ny = TMath::Nint(TMath::Sqrt(nofGraph));
+                                nx = TMath::Nint((nofGraph/ny) +0.6);
+                                }
+                            c1->Divide(nx,ny);
+                            }
+                        else if (sbinType->String().Contains("INTEGRATED"))
+                            {
+                            graphCent = new TGraphErrors(centralityArray->GetEntries());
+                            graphCent->SetMinimum(0.);
+                            graphCent->SetMaximum(1.2);
+                            graphCentErr = new TGraphErrors(centralityArray->GetEntries());
+                            graphCentErr->SetMinimum(0.);
+                            graphCentErr->SetMaximum(1.2);
+                            }
+                        gStyle->SetOptStat(0);
+
+                        cout << Form("  __________________________________________________________ ") << endl;
+                        cout << Form("  |         bin      |   JPsi  Stat.  Syst. | RAA  Stat.  Syst. | <NPART>  d<NPART> |") << endl;
+
+                        Int_t n=1; // counter
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) ) {
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+
+                            //________Get Trigger sum
+                            Int_t NofMUL = TMath::Nint(CC()->GetSum(Form("trigger:%s/event:%s/centrality:%s",strigger->String().Data(),seventType->String().Data(),RefCent)));
+                            //________
+
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,externfile,externfile2);
+                            if(!capsule) continue;
+                            AliDebug(1,Form("Spectra = %p",capsule));
+                            // capsule->PrintConst();
+
+                            // Get Graph with RAA results
+                            list = capsule->RAAasGraphic(NofMUL);
+
+                            if(!list) continue;
+                            AliDebug(1,Form("list = %p",list));
+
+                            // Draw Graph according to bin type
+                            if (!sbinType->String().Contains("INTEGRATED")){ // PT/Y/single centrality
+                                // Select subcanvas
+                                c1->cd(n);
+                                //legend
+                                TLegend * leg = new TLegend(0.2,0.8,0.90,0.9);
+                                leg->SetTextSize(0.04);
+                                leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=5.02 TeV, L_{int}=222 #mub^{-1}, %s",scentrality->String().Data()));
+                                //Draw it
+                                graph = static_cast<TGraphErrors*>(list->At(0)->Clone());
+                                graphErr = static_cast<TGraphErrors*>(list->At(1)->Clone());
+                                if (!graph || ! graphErr) {
+                                    printf("Did not find graph in the list");
+                                    return;
+                                }
+                                leg->AddEntry(graph,"Inclusive J/#psi","pe");
+                                graph->GetYaxis()->SetRangeUser(0,1.41);
+                                graphErr->SetFillColorAlpha(4,0.);
+                                graph->Draw("ap");
+                                graphErr->Draw("same5");
+                                leg->Draw();
+                                }
+                            else {
+                                //Check point
+                                if(!sbinType->String().Contains("INTEGRATED")) {
+                                    cout << "Cannot plot INTEGRATED  ! Check it please :) " << endl;
+                                    delete c1;
+                                    return;
+                                    }
+                                Double_t x=0;
+                                Double_t y=0;
+                                graph = static_cast<TGraphErrors*>(list->At(0)->Clone());
+                                graphErr = static_cast<TGraphErrors*>(list->At(1)->Clone());
+                                if (!graph || ! graphErr) {
+                                    printf("Did not find graph in the list");
+                                    return;
+                                }
+                                // Get point for each centrality
+                                Double_t dx = graph->GetErrorX(0);
+                                Double_t dy = graph->GetErrorY(0);
+                                Double_t dysys = graphErr->GetErrorY(0);
+                                graph->GetPoint(0,x,y);
+                                // Set them to a new graphic
+                                graphCent->SetPoint(n-1,x,y);
+                                graphCent->SetPointError(n-1,dx,dy);
+                                graphCent->SetTitle(graph->GetTitle());
+                                graphCentErr->SetPoint(n-1,x,y);
+                                graphCentErr->SetPointError(n-1,2.5,dysys);
+                                }
+                            n++;
+                            delete capsule;
+                            }
+                        cout << "" << endl;
+                        if (sbinType->String().Contains("INTEGRATED")) {
+                            //Print
+                            graphCent->GetXaxis()->SetTitle("<N_{part}>");
+                            graphCent->GetYaxis()->SetTitle("R_{AA}");
+                            graphCent->GetYaxis()->SetRangeUser(0,1.41);
+                            graphCent->SetMarkerColor(4);
+                            graphCent->SetMarkerStyle(21);
+                            graphCentErr->SetFillColorAlpha(4,0.);
+                            graphCent->SetTitle(Form("%s/%s/%s/%s/%s",seventType->String().Data(),
+                                                     strigger->String().Data(),
+                                                     spairCut->String().Data(),
+                                                     sparticle->String().Data(),
+                                                     sbinType->String().Data()));
+                            TLegend * leg = new TLegend(0.2,0.8,0.90,0.9);
+                            leg->SetHeader("ALICE, Pb-Pb #sqrt{s_{NN}}=5.02 TeV, L_{int}=222 #mub^{-1}, PT/Y integrated");
+                            leg->SetTextSize(0.03);
+                            leg->AddEntry(graphCent,"Inclusive J/#psi","pe");
+                            graphCent->Draw("ap");
+                            graphCentErr->Draw("same5");
+                            leg->Draw();
+                            }
+                        //________ Update resultes in Mergeable collection
+                        TString id(Form("/RAA-%s/%s/%s/%s/%s",strigger->String().Data(),seventType->String().Data(),spairCut->String().Data(),sbinType->String().Data(),sparticle->String().Data()));
+
+
+                        TObject* o = 0x0;
+
+                        if (graph)// first graph
+                            {
+                            o = fMergeableCollection->GetObject(Form("%s/%s",id.Data(),graph->GetName()));
+
+                            if (o)
+                                {
+                                AliWarning(Form("Replacing %s/%s",id.Data(),graph->GetName()));
+                                fMergeableCollection->Remove(Form("%s/%s",id.Data(),graph->GetName()));
+                                }
+
+                            Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),graph);
+
+                            if ( adoptOK ) std::cout << "+++RAA graph " << graph->GetName() << " adopted" << std::endl;
+                            else AliError(Form("Could not adopt RAA grap %s",graph->GetName()));
+                            }
+
+
+                        if (graphCent)// second graph
+                            {
+                            o = fMergeableCollection->GetObject(Form("%s/%s",id.Data(),graphCent->GetName()));
+
+                            if (o)
+                                {
+                                AliWarning(Form("Replacing %s/%s",id.Data(),graphCent->GetName()));
+                                fMergeableCollection->Remove(Form("%s/%s",id.Data(),graphCent->GetName()));
+                                }
+
+                            Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),graphCent);
+
+                            if ( adoptOK ) std::cout << "+++RAA graph " << graphCent->GetName() << " adopted" << std::endl;
+                            else AliError(Form("Could not adopt RAA graph %s",graphCent->GetName()));
+                            }
+                        //________
+                        }
+                    }
+                }
+            }
+        }
+    delete list;
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+
+    return ;
+
+}
+
 //_____________________________________________________________________________
 TString
 AliAnalysisMuMu::ExpandPathName(const char* file)
@@ -814,9 +1453,22 @@ AliAnalysisMuMu::FileOpen(const char* file)
 }
 
 //_____________________________________________________________________________
-AliAnalysisMuMuSpectra*
-AliAnalysisMuMu::FitParticle(const char* particle,
-                             const char* trigger,
+TString AliAnalysisMuMu::First(const TString& list) const
+{
+    TObjArray* a = list.Tokenize(",");
+    if ( a->GetLast() < 0 ) return "";
+
+    TString rv = static_cast<TObjString*>(a->First())->String();
+
+    delete a;
+
+    return rv;
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectra*
+AliAnalysisMuMu::FitParticle(const char* particle,
+                             const char* trigger,
                              const char* eventType,
                              const char* pairCut,
                              const char* centrality,
@@ -831,6 +1483,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 
     static int n(0);
 
+    //Check Binning list
     TObjArray* bins = binning.CreateBinObjArray(particle);
     if (!bins)
         {
@@ -838,6 +1491,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
         return 0x0;
         }
 
+    //Check trigger list
     TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
     if ( !triggers->FindObject(trigger) )
         {
@@ -848,6 +1502,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
         }
     delete triggers;
 
+    //Check event list
     TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
     if ( !events->FindObject(eventType) )
         {
@@ -860,6 +1515,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 
     Int_t ntrigger = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s",trigger,eventType)));
 
+    //Check trigger
     if  (ntrigger<=0)
         {
         AliError(Form("No trigger for trigger:%s/event:%s",trigger,eventType));
@@ -867,26 +1523,31 @@ AliAnalysisMuMu::FitParticle(const char* particle,
         return 0x0;
         }
 
+    //Get number of runs and store it in nruns
     TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
     Int_t nruns = runs->GetEntries();
     delete runs;
 
-  
+    // Create ID for the fit which will be used to name results
     TString id(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut));
 
     //  binning.Print();
 
+    //The result pointer, will be return at the end
     AliAnalysisMuMuSpectra* spectra(0x0);
 
+    // The binning pointer, which point at Pt binning, Y binning etc.
     AliAnalysisMuMuBinning::Range* bin;
     TIter next(bins);
 
+    // Create an array (fitTypeArray) pointing on AliAnalysisMuMuConfig and store kFitTypeList.  Also create pointers and strings for several pointers
     TObjArray* fitTypeArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());
-  TIter nextFitType(fitTypeArray);
-  TObjString* fitType;
-  TString flavour;
-  TString sSpectraType(spectraType);
+    TIter nextFitType(fitTypeArray);// Iterater for every fit types, i.e fitting functions and their config.
+    TObjString* fitType;// To point to the array (??)
+    TString flavour;// Flavour of the binning (ex: "JAVI","IGOR" ...)
+    TString sSpectraType(spectraType);// Make spectratype a string
 
+    // Add some element to ID
     TString spectraName(binning.GetName());
     if ( flavour.Length() > 0 )
         {
@@ -900,16 +1561,21 @@ AliAnalysisMuMu::FitParticle(const char* particle,
         }
 
     //  Int_t binN(0);
+
+    //MAIN PART : Loop on every binning range
+    //==============================================================================
     while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
         {
+
+        // Choose correct histo type with <spectraType> and set it in <hname>
         TString hname;
         if (!sSpectraType.CompareTo("minv"))
             {
-      hname = corrected ? Form("MinvUS%s_AccEffCorr",bin->AsString().Data()) : Form("MinvUS+%s",bin->AsString().Data());
+            hname = corrected ? Form("MinvUS+%s_AccEffCorr",bin->AsString().Data()) : Form("MinvUS+%s",bin->AsString().Data());
             }
         else if (!sSpectraType.CompareTo("mpt"))
             {
-      hname = corrected ? Form("MeanPtVsMinvUS%s_AccEffCorr",bin->AsString().Data()) : Form("MeanPtVsMinvUS%s",bin->AsString().Data());
+            hname = corrected ? Form("MeanPtVsMinvUS%s",bin->AsString().Data()) : Form("MeanPtVsMinvUS%s",bin->AsString().Data());
             }
         else
             {
@@ -917,12 +1583,13 @@ AliAnalysisMuMu::FitParticle(const char* particle,
             return 0x0;
             }
 
+        // Print the fitting process on the terminal
         TString isCorr(corrected ? " AccEffCorr " : " ");
         std::cout << "---------------------------------//---------------------------------" << std::endl;
         std::cout << "Fitting" << isCorr.Data() << sSpectraType.Data() << " spectra in " << id.Data() << std::endl;
 
+        // Pointer to the histo from histo collection
         TH1* histo = OC()->Histo(id.Data(),hname.Data());
-
         if (!histo)
             {
             //      if (!fBinning && bin->IsIntegrated() )
@@ -938,12 +1605,16 @@ AliAnalysisMuMu::FitParticle(const char* particle,
             //      }
             }
 
+        // Make a clone of the histo to work with. Pointer changes for every iteration (n++)
         histo = static_cast<TH1*>(histo->Clone(Form("%s%d",sSpectraType.Data(),n++)));
 
         const char* particleTmp = IsSimulation() ? GetParticleName() : "JPsi"; //At some point particleTmp should become particle (but for now particle is always = "psi")
 
-    TString sparticleTmp(particleTmp);
+        cout << "particleTmp =" << particleTmp << endl;
+
+        TString sparticleTmp(particleTmp);// Make a string of it
 
+        // Object that fit/work on the histo
         AliAnalysisMuMuJpsiResult* r = new AliAnalysisMuMuJpsiResult(particleTmp,
                                                                      *histo, // Result for current bin
                                                                      trigger,
@@ -959,13 +1630,13 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 
         Int_t added(0);
 
+        // Loop on every fittype and create a subresult inside the spectra.
         while ( ( fitType = static_cast<TObjString*>(nextFitType())) )
             {
             // In this loop we create a Subresult for each fit inside the Result for current bin (AddFit will do)
+            TString sFitType(fitType->String());// Get fitType as a string
 
-      TString sFitType(fitType->String());
-      
-      if ( !sFitType.Contains(sSpectraType.Data()) ) continue;
+            if ( !sFitType.Contains(sSpectraType.Data()) ) continue;// Checkpoint
 
             AliDebug(1,Form("<<<<<< fitType=%s bin=%s",sFitType.Data(),bin->Flavour().Data()));
 
@@ -974,6 +1645,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
             std::cout << "Fitting " << hname.Data() << " with " << sFitType.Data() << std::endl;
             std::cout << "" << std::endl;
 
+            // Conf. for MC Tails (see function type)
             if ( sFitType.Contains("mctails",TString::kIgnoreCase) ) //FIXME: Find a univoque way to determine the correctly the fit type
                 {
                 TString sbin = bin->AsString();
@@ -1035,6 +1707,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
                     }
                 }
 
+            //Config. for mpt (see function type)
             else if ( sFitType.Contains("mpt",TString::kIgnoreCase) && !sFitType.Contains("minv",TString::kIgnoreCase) )
                 {
                 std::cout << "++The Minv parameters will be taken from " << spectraName.Data() << std::endl;
@@ -1083,12 +1756,14 @@ AliAnalysisMuMu::FitParticle(const char* particle,
                     }
                 }
 
+            //Config. for mpt and minv (see function type)
             else if ( sFitType.Contains("minv&mpt",TString::kIgnoreCase) )
                 {
                 AliWarning("Implement here the method to do the combined minv mpt fits");
                 //FIXME: Shall we use the fitType or spectraType to choose to perform combined fits? Cause we have to check what kind of object is returned by the combined fit in order to decide if we put it in a different spectra(spectraType would be the flag,and here we should update the spectraName) or as a subresult(fitType in this case)
                 }
 
+            //Config. for the rest (see function type)
             else
                 {
                 if ( sFitType.Contains("PSICB2",TString::kIgnoreCase) || sFitType.Contains("PSINA60NEW",TString::kIgnoreCase)) std::cout << "+Free tails fit... " << std::endl;
@@ -1106,20 +1781,22 @@ AliAnalysisMuMu::FitParticle(const char* particle,
                     continue;
                     }
 
-        added += ( r->AddFit(sFitType.Data()) == kTRUE );
+                added += ( r->AddFit(sFitType.Data()) == kTRUE );// Here we call the fit functions
+                // printf("Signal over background : %f\n",r->GetValue("SignalOverBkg3s"));
                 }
 
             std::cout << "-------------------------------------" << std::endl;
             std::cout << "" << std::endl;
             }
 
-    if ( !added ) continue;
+        if ( !added ) continue;// checkpoint
 
         //    TObjArray* a = r->SubResults(); // TEST
         //    a->Print();
 
-    flavour = bin->Flavour();
+        flavour = bin->Flavour();// Get >flavour>
 
+        // Implement <spectra> and set its name
         if (!spectra)
             {
             TString spectraSaveName = spectraName;
@@ -1140,6 +1817,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 
         if ( IsSimulation() )
             {
+             std::cout << "Computing AccEff Value Spectra " << std::endl;
             SetNofInputParticles(*r);
             }
 
@@ -1655,12 +2333,44 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::GetSpectra(const char* what, const char
     swhat.ToUpper();
     sflavour.ToUpper();
 
-  TString spectraName(Form("/%s/%s/PP/%s/PSI-%s",
-                           Config()->First(Config()->EventSelectionKey(),IsSimulation()).Data(),
-                           Config()->First(Config()->DimuonTriggerKey(),IsSimulation()).Data(),
-                           Config()->First(Config()->PairSelectionKey(),IsSimulation()).Data(),
+    TString spectraName(Form("/%s/%s/%s/%s/PSI-%s",
+                             Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
+                             Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
+                             Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
+                             Config()->First(Config()->PairSelectionKey(),kFALSE).Data(),
+                             swhat.Data()));
+
+    cout << "spectraName : " << spectraName.Data() << endl;
+
+    if (sflavour.Length()>0)
+        {
+        spectraName += "-";
+        spectraName += sflavour.Data();
+        }
+
+    return SPECTRA(spectraName.Data());
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::GetMCSpectra(const char* what , const char* EventSelection,  const char* DimuonTrigger,
+  const char* Centrality, const char* PairSelectionKey, const char* flavour) const
+{
+    /// get a given spectra
+
+    TString swhat(what);
+    TString sflavour(flavour);
+    swhat.ToUpper();
+    sflavour.ToUpper();
+
+    TString spectraName(Form("/%s/%s/%s/%s/PSI-%s",
+                             EventSelection,
+                             DimuonTrigger,
+                             Centrality,
+                             PairSelectionKey,
                              swhat.Data()));
 
+    cout << "spectraName : " << spectraName.Data() << endl;
+
     if (sflavour.Length()>0)
         {
         spectraName += "-";
@@ -1730,24 +2440,21 @@ void AliAnalysisMuMu::ComputeRelativeValueAndSESystematics(const char* quantity,
         AliError("Cannot compute J/Psi yield: Is a simulation file");
         return;
         }
-
     TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
     TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
     TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
 
-  //Path to get/store integrated results from Mergeable Collection
     TString intPath(Form("%s/%s/%s/%s",
                          sevSelInt.Data(),
                          dimuonTriggerClassName.Data(),
                          centralitySelection.Data(),
-                       pairSelection.Data()));
+                         pairSelection.Data())); //Path to get/store integrated results from Mergeable Collection
 
-  //Path to get/store differential results from Mergeable Collection
     TString diffPath(Form("%s/%s/%s/%s",
                           sevSelDiff.Data(),
                           dimuonTriggerClassName.Data(),
                           centralitySelection.Data(),
-                        pairSelection.Data()));
+                          pairSelection.Data())); //Path to get/store differential results from Mergeable Collection
 
     TString striggerCluster(triggerCluster);
     if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
@@ -2292,7 +2999,7 @@ TH1* AliAnalysisMuMu::PlotJpsiYield(const char* whatever)
                       Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
                       Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
 
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/%s",path.Data(),whatever)));
+    AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/PSI-%s",path.Data(),whatever)));
     if ( !s )
         {
         AliError(Form("No spectra %s found in %s",whatever,path.Data()));
@@ -2371,54 +3078,6 @@ UInt_t AliAnalysisMuMu::GetSum(AliCounterCollection& cc, const char* triggerList
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::GetCollectionsFromAnySubdir(TDirectory& dir,
-                                                    AliMergeableCollection*& oc,
-                                                    AliCounterCollection*& cc,
-                                                    AliAnalysisMuMuBinning*& bin)
-{
-  /// Find, within dir and its sub-directories, the objects OC,CC and BIN
-  
-  TList* keys = dir.GetListOfKeys();
-  TIter next(keys);
-  
-  TKey* k;
-  
-  while ( ( k = static_cast<TKey*>(next()) ) )
-  {
-    TObject* object = k->ReadObj();
-    
-    if ( object->InheritsFrom("TDirectory") )
-    {
-      TDirectory* d = static_cast<TDirectory*>(object);
-      GetCollectionsFromAnySubdir(*d,oc,cc,bin);
-      continue;
-    }
-    
-    if ( ( object->InheritsFrom("AliMergeableCollection") ) &&
-        ( strcmp(object->GetName(),"OC")==0 ) )
-    {
-      oc = dynamic_cast<AliMergeableCollection*>(object);
-      fDirectory = dir.GetName();
-    }
-
-    if ( ( object->InheritsFrom("AliCounterCollection") ) &&
-        ( strcmp(object->GetName(),"CC")==0 ) )
-    {
-      cc = dynamic_cast<AliCounterCollection*>(object);
-      fDirectory = dir.GetName();
-    }
-
-    if ( ( object->InheritsFrom("AliAnalysisMuMuBinning") ) &&
-        ( strncmp(object->GetName(),"BIN",3)==0 ) )
-    {
-      bin = dynamic_cast<AliAnalysisMuMuBinning*>(object);
-      fDirectory = dir.GetName();
-    }
-
-  }
-}
-
-//_____________________________________________________________________________
 Bool_t
 AliAnalysisMuMu::GetCollections(const char* rootfile,
                                 const char* subdir,
@@ -2548,11 +3207,11 @@ AliAnalysisMuMu::Jpsi(const char* what, const char* binningFlavour, Bool_t fitmP
 
     Int_t nfits(0);
 
-  TObjArray* triggerArray = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
     TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
     TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
-  TObjArray* whatArray = TString(what).Tokenize(",");
     TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
 
     TIter nextTrigger(triggerArray);
     TIter nextEventType(eventTypeArray);
@@ -2570,12 +3229,9 @@ AliAnalysisMuMu::Jpsi(const char* what, const char* binningFlavour, Bool_t fitmP
         {
         AliAnalysisMuMuBinning* binning(0x0);
 
-    if ( fBinning && swhat->String().Length() > 0 )
-    {
+        if ( fBinning && swhat->String().Length() > 0 ) {
           binning = fBinning->Project("psi",swhat->String().Data(),binningFlavour);
-    }
-    else
-    {
+        } else {
           binning = new AliAnalysisMuMuBinning;
           binning->AddBin("psi",swhat->String().Data());
         }
@@ -2591,8 +3247,7 @@ AliAnalysisMuMu::Jpsi(const char* what, const char* binningFlavour, Bool_t fitmP
         std::cout << "" << std::endl;
         std::cout << "" << std::endl;
 
-    if (!binning)
-    {
+        if (!binning) {
           AliError("oups. binning is NULL");
           continue;
         }
@@ -3048,59 +3703,192 @@ void AliAnalysisMuMu::Print(Option_t* opt) const
 }
 
 //_____________________________________________________________________________
-TFile* AliAnalysisMuMu::ReOpen(const char* filename, const char* mode) const
+void AliAnalysisMuMu::PrintNofParticle(const char* particle, const char* what, const char* binType, Bool_t AccEffCorr) const
 {
-  /// Tries to reopen the file with a new mode
+    ///
+    /// Function to use after JPsi(). It loops over all combination of centrality/enventype/ trigger (etc.) and
+    /// print RAA on terminal accordingly. Fnorm / <T_AA> / other constants are written in AliAnalysisMuMuSpectraCapsulePbPb.
+    /// <binType> can be either "PT" or "Y" for the moment. This method reads sigma_pp value
+    /// from extern file who's line must be written as :
+    ///
+    /// intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff;
+    ///
+    /// WATCH OUT FOR UNITS !! Function is written for cross-section in microbarn in externFile
+    ///
+    /// note : For now, this method is set for a single centrality bin 0-90
+    /// TODO : Make it work with different centrality, i.e  need to read also an extra externfile with value who are function of centrality (<T_AA> for instance...)
+    ///
+    ///
 
-  TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(filename));
 
-  if (f)
+    if (!OC() || !CC())
         {
-    delete f;
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       Number of "<< particle << endl;
+        cout <<      " ================================================================ " << endl;
         }
 
-  f = TFile::Open(filename,mode);
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
 
-  if ( !f || !f->IsOpen() )
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    //Loop on particle type
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
         {
-    AliError(Form("Cannot open file %s in mode %s",filename,mode));
-    return 0x0;
-  }
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextCentrality.Reset();
+                // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                    AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+                    nextPairCut.Reset();
+                    // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                        {
+                        AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+                        nextbinType.Reset();
+                        // Loop on each type (pt or y)
+                        //==============================================================================
+                        while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                            {
+                            AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
 
-  return f;
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                continue;
                                 }
+                            //________
 
-//_____________________________________________________________________________
-void AliAnalysisMuMu::SetCentralitySelectionList(const char* centralitySelectionList)
+                            // Create pointer on fitted spectra
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,"","");
+                            if(!capsule)
                                 {
-  /// Set centralities to be used during fitting
-  /// centralitySelectionList is a regular expression.
+                                AliError("Could not find spetra !");
+                                continue;
+                                }
+                            if(!capsule) continue;
+                            AliDebug(1,Form("Spectra = %p",capsule));
+                            // Print RAA on terminal
+                            capsule->PrintNofWhat(what);
+                            delete capsule;
+                            }
+                        }
+                    }
+                }
+            }
+        }
 
-  TObjArray* centralities = BIN()->CreateBinObjArray("centrality");
-  TIter next(centralities);
-  AliAnalysisMuMuBinning::Range* r;
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
 
-  TString csl;
+    return ;
 
-  TPRegexp re(centralitySelectionList);
+}
 
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+//_____________________________________________________________________________
+TFile* AliAnalysisMuMu::ReOpen(const char* filename, const char* mode) const
 {
-    AliDebug(1,Form("r=%s",r->AsString().Data()));
-    if ( re.MatchB(r->AsString()) )
+    /// Tries to reopen the file with a new mode
+
+    TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(filename));
+
+    if (f)
         {
-      csl += r->AsString();
-      csl += ",";
-    }
+        delete f;
         }
 
-  if ( IsSimulation() )  csl += " sim";
+    f = TFile::Open(filename,mode);
 
-  Config()->Add(Config()->CentralitySelectionKey(),csl);
+    if ( !f || !f->IsOpen() )
+        {
+        AliError(Form("Cannot open file %s in mode %s",filename,mode));
+        return 0x0;
+        }
 
-  delete centralities;
+    return f;
 }
 
+////_____________________________________________________________________________
+//void AliAnalysisMuMu::SetCentralitySelectionList(const char* centralitySelectionList)
+//{
+//  /// Set centralities to be used during fitting
+//  /// centralitySelectionList is a regular expression.
+//
+//  TObjArray* centralities = BIN()->CreateBinObjArray("centrality");
+//  TIter next(centralities);
+//  AliAnalysisMuMuBinning::Range* r;
+//
+//  TString csl;
+//
+//  TPRegexp re(centralitySelectionList);
+//
+//  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+//  {
+//    AliDebug(1,Form("r=%s",r->AsString().Data()));
+//    if ( re.MatchB(r->AsString()) )
+//    {
+//      csl += r->AsString();
+//      csl += ",";
+//    }
+//  }
+//
+//  Config()->SetList(AliAnalysisMuMuConfig::kCentralitySelectionList,IsSimulation(),csl);
+//
+//  delete centralities;
+//}
+
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMu::SetCorrectionPerRun(const TGraph& corr, const char* formula)
 {
@@ -3156,9 +3944,9 @@ void AliAnalysisMuMu::SetNofInputParticles(AliAnalysisMuMuJpsiResult& r)
 {
     /// Set the "NofInput" variable(s) of one result
 
-  TString hname(Form("MinvUS%s",r.Bin().AsString().Data()));
+    TString hname(Form("MinvUS+%s",r.Bin().AsString().Data()));
 
-  TH1* hinput = fMergeableCollection->Histo(Form("/%s/ALL/ANY/V0A/INYRANGE",AliAnalysisMuMuBase::MCInputPrefix()),hname.Data());
+    TH1* hinput = fMergeableCollection->Histo(Form("/%s/ALL/ANY/PP/INYRANGE",AliAnalysisMuMuBase::MCInputPrefix()),hname.Data());
 
     if (!hinput)
     {
@@ -3201,6 +3989,11 @@ void AliAnalysisMuMu::SelectRunByTrigger(const char* triggerList)
   while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
   {
 
+    TList* runList = new TList();
+
+    while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
+    {
+
       nextTrigger.Reset();
 
       while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
@@ -3216,6 +4009,7 @@ void AliAnalysisMuMu::SelectRunByTrigger(const char* triggerList)
 
       }
     }
+  }
     runList->Sort();
     TIter nextRunOK(runList);
     while ( ( srun = static_cast<TObjString*>(nextRunOK()) ) )
@@ -3332,6 +4126,18 @@ void AliAnalysisMuMu::TriggerCountCoverage(const char* triggerList,
                     total,totalExpected,totalExpected ? total*100.0/totalExpected : 0.0) << std::endl;
 
 
+    for ( it = messages.rbegin(); it != messages.rend(); ++it )
+        {
+        ++n;
+        current += it->first;
+        Double_t percent = ( total > 0.0 ? current*100.0/total : 0.0);
+        std::cout << Form("%10lld",it->first) << " " << it->second << " percentage of total = " << Form("%7.2f %% %3d",percent,n ) << std::endl;
+        }
+
+    std::cout << Form("--- TOTAL %lld expected %lld fraction %5.1f %%",
+                      total,totalExpected,totalExpected ? total*100.0/totalExpected : 0.0) << std::endl;
+
+
 
     AliLog::SetGlobalLogLevel(oldLevel);
     delete triggers;
@@ -3353,8 +4159,6 @@ void AliAnalysisMuMu::Update()
 
   if (!CC() || !OC()) return;
 
-  std::cout << "fDirectory=" << fDirectory.Data() << std::endl;
-  
   ReOpen(fFilename,"UPDATE");
 
   if (OC())
@@ -3439,755 +4243,779 @@ Bool_t AliAnalysisMuMu::Upgrade()
 }
 
 //_____________________________________________________________________________
-TH2* AliAnalysisMuMu::ComputeSPDCorrection(const char* type, const char* eventSel, const char* triggerSel, Bool_t bkgReject)
+void AliAnalysisMuMu::PrintDistribution(const char* binType, const char* what, const char* sResName, const char* ColSys, Bool_t divideByBinWidth, Bool_t AccEffCorr)
 {
-  TString stype(type);
-  TString evtype(eventSel);
-  TString trigtype(triggerSel);
+    /// Compute what distribution vs binType. Delegate procedure to AliAnalysisSpectra object. It can be compute for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
+    ///
+    /// Parameters:
+    ///   -binType    : INTEGRATED, PT, Y (for now)
+    ///   -what       : The quantity (NofJPsi by default, but could be something else...)
+    ///   -AccEffCorr : Just a tag to select right histograms.
+    ///   -sResName   : subresult name to get the yield from. By default is "" (mean of all subresults)
 
-  TH2* hNch = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NchVsZVertexVsEta",evtype.Data(),
-                                                 trigtype.Data()))); // Input Nch // //"/INPUT/QASPDZPSALL/NchVSEtaVSZVertMC"
-  if ( !hNch )
+    if (!OC() || !CC())
         {
-    AliError("No Nch histo found");
-    return 0x0;
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
         }
-  TH2* hNtr = static_cast<TH2*>(OC()->Histo(Form("/%s/%s/V0A/TrackletsVsZVertexVsEta",evtype.Data(),
-                                                trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
-  if ( !hNtr )
+    else
         {
-    AliError("No tracklets histo found");
-    return 0x0;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       PrintDistribution                          " << endl;
+        cout <<      " ================================================================ " << endl;
         }
 
-  TH2* hNtrBkg = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NBkgTrackletsVsZVertexVsEta",evtype.Data(),
-                                                 trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
-  if ( !hNtrBkg )
-  {
-    AliError("No background tracklets histo found");
-    return 0x0;
-  }
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
 
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
 
-  TH2D* hSPDCorr = static_cast<TH2D*>(hNtr->Clone("SPDCorr"));
-  TString title("");\
-  if ( stype.Contains("oneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction");
-  else if ( stype.Contains("AccEffOnly")) hSPDCorr->SetTitle("SPD AccxEff correction");
-  else if ( stype.Contains("statOneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction stat. unc.");
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* swhat;
+    TObjString* sbinType;
+    TObjString* scentrality;
 
-  for (Int_t i = 1 ; i < hNch->GetNbinsX() ; i++)
-  {
-    for (Int_t j = 1 ; j < hNch->GetNbinsY() ; j++)
-    {
-      Int_t n = hNch->GetBin(i,j);
-      Double_t nch = hNch->GetBinContent(n);
-      Double_t ntr = hNtr->GetBinContent(n);
-      Double_t nBkgtr(0.);
-      if ( bkgReject ) nBkgtr = hNtrBkg->GetBinContent(n);
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+    const TString syear(ColSys);
 
-      Double_t corr(0.),corrErr(0.);
-      if ( nch != 0. )
-      {
-        corr = (ntr - nBkgtr)/nch;
-        corrErr = TMath::Max( 1./nch,TMath::Sqrt( corr*(1.-corr)/nch ) );
-      }
+    // Pointers
+    TH1* h= 0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
 
-      if ( stype.Contains("oneOverAccEff"))
+    //Loop on what type
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
         {
-        if ( corr > 0. )
+        AliDebug(1,Form("what %s",swhat->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
             {
-          hSPDCorr->SetBinContent(n,1./corr);
-          hSPDCorr->SetBinError(n,corrErr/TMath::Power(corr,2.));
-        }
-        else
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
                 {
-          hSPDCorr->SetBinContent(n,0.);
-          hSPDCorr->SetBinError(n,1.);
-        }
-        
-      }
-      else if ( stype.Contains("AccEffOnly"))
+                AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
                     {
-        hSPDCorr->SetBinContent(n,corr);
-        hSPDCorr->SetBinError(n,corrErr);
-      }
-      else if ( stype.Contains("statOneOverAccEff"))
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
                         {
-        if ( corr != 0. )
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+
+                        // //canvas
+                        // TCanvas *c1 = new TCanvas;
+                        // c1->Draw();
+                        // gStyle->SetOptStat(0);
+
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
                             {
-          hSPDCorr->SetBinContent(n,(corrErr/TMath::Power(corr,2.)*100)/(1./corr));
-        }
-        else
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),"PSI",sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
                                 {
-          hSPDCorr->SetBinContent(n,-1);
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
                                 }
+                            //________
 
+                            h= spectra->Plot(swhat->String().Data(),sResName,divideByBinWidth);
+                            TCanvas *c = new TCanvas;
+                            c->SetLogy();
+                            h->Draw();
                             }
                         }
                     }
-  
-  return hSPDCorr;
                 }
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeFnorm()
-{
-  /// Compute the CMUL to CINT ratio(s)
-  
-  if (!CC()) return;
-  
-  OC()->Prune("/FNORM");
-  
-  AliAnalysisMuMuFnorm computer(*(CC()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());
-  
-  computer.ComputeFnorm();
-
-  AliMergeableCollection* fnorm = computer.DetachMC();
-  
-  OC()->Attach(fnorm,"/FNORM/");
-  
-  Update();
             }
-
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::ComputeDiffFnormFromHistos(const char* what,const char* quantity,const char* flavour,Bool_t printout)
-{
-  /// OUTDATED METHOD: Compute the CMUL to CINT ratio(s) from the histos stored in the OC(). Now the Counter Collection is used for this (AliAnalysisMuMu::ComputeDiffFnormFromCounters)
-    
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,quantity,flavour));
-    return 0x0;
         }
-  TObjArray* dNchdEtas = binning->CreateBinObjArray();
-  
-  Double_t* binArray = binning->CreateBinArray();
-  
-  TIter next(dNchdEtas);
-  AliAnalysisMuMuBinning::Range* r;
-  
-  Double_t FNorm(0.);
-  Double_t FNormError(0.);
 
-  TH1* hFNorm = new TH1F("hFNorm","'Global' normalization factor vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
-  
-  Int_t bin(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    
-    TH1* hCMSL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMSL7-B-NOPF-MUON/V0A/%s",
-                             Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMSL )
-    {
-      AliError(Form("No event histo in bin %s found for CMSL7-B-NOPF-MUON",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
+    return;
 }
 
-    TH1* hCMSLandOMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMSL7-B-NOPF-MUON&0MUL/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMSLandOMUL )
+void AliAnalysisMuMu::ComputeDimuonRawCount(const Double_t rlow, const Double_t rhigh, const char* binType, const char* binRangeExluded, const char* flavour, Bool_t corrected)
 {
-      AliError(Form("No event histo in bin %s found for CMSL7-B-NOPF-MUON & 0MUL",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
-    }
+    /// Compute the raw count of dimuon pair
+    /// Parameters:
+    ///   - rlow,rhigh  : intervall in bin for the raw count
+    ///   -binType       : integrated,pt,y ...see your AddTaskMuMu
+    ///   -flavour       : Default is BENJ
+    ///   -corrected     : For nomenclature
 
-    TH1* hCINT = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CINT7-B-NOPF-ALLNOTRD/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCINT )
+    if(!OC())
     {
-      AliError(Form("No event histo in bin %s found for CINT7-B-NOPF-ALLNOTRD",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
+        AliError("No mergeable. Consider Upgrade()");
+        return;
     }
-    
-    TH1* hCINTandOMSL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CINT7-B-NOPF-ALLNOTRD&0MSL/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCINTandOMSL )
+    else
     {
-      AliError(Form("No event histo in bin %s found for CINT7-B-NOPF-ALLNOTRD & 0MSL",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputeDimuonRawCount                          " << endl;
+        cout <<      " ================================================================ " << endl;
     }
 
-    FNorm = (hCMSL->GetBinContent(1)/hCMSLandOMUL->GetBinContent(1))*(hCINT->GetBinContent(1)/hCINTandOMSL->GetBinContent(1));
-    FNormError = ErrorPropagationAxBoverCxD(hCMSL->GetBinContent(1),hCINT->GetBinContent(1),hCMSLandOMUL->GetBinContent(1),hCINTandOMSL->GetBinContent(1));
+     // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* binRangeExcludedArray     = TString(binRangeExluded).Tokenize(",");
+    TObjArray* bins;
 
-    if ( printout ) std::cout << r->AsString().Data() << " : " << FNorm << " +- " << FNormError << std::endl;
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
 
-    hFNorm->SetBinContent(++bin,FNorm);
-    hFNorm->SetBinError(bin,FNormError);
-  }
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sbinType;
+    TObjString* scentrality;
 
-  delete binning;
-  delete dNchdEtas;
-  delete[] binArray;
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
 
-  return hFNorm;
-}
+    // Pointers
+    TH1* h= 0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
 
-//_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromInt(const char* triggerCluster, const char* eventSelection, AliMergeableCollection* mc, const char* what,const char* quantity,const char* flavour,Bool_t printout)
-{
-  /// OUTDATED METHOD:Compute the CMUL to CINT ratio(s) form the ratio of "quantity" distributions, in bins. Now the Counter Collection is used for this (AliAnalysisMuMu::ComputeDiffFnormFromGlobal)
 
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
+    // Loop on each envenType (see MuMuConfig)
+    //==============================================================================
+    while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
     {
-    AliError("Unknown trigger cluster");
-    return;
-  }
+        AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+        nextTrigger.Reset();
+        // Loop on each trigger (see MuMuConfig)
+        //==============================================================================
+        while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+        {
+            AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+            nextPairCut.Reset();
+            // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+            //==============================================================================
+            while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+            {
+                AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                nextbinType.Reset();
+                // Loop on each type (pt or y)
+                //==============================================================================
+                while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                {
+                    AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                    nextCentrality.Reset();
 
-  TString seventSelection(eventSelection);
 
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelection.Data()));
+                     AliAnalysisMuMuBinning* binning(0x0);
 
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  if ( !binning )
+                    if ( fBinning && sbinType->String().Length() > 0 )
                     {
-    AliError(Form("%s-%s-%s binning does not exist",what,quantity,flavour));
-    return;
+                        binning = fBinning->Project("psi",sbinType->String().Data(),flavour);
                     }
-  
-  TString path(Form("%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data()));
-  if ( !mc )
+                    else
                     {
-    AliError("Error: No mergeable collection to get Nch histo");
-    delete binning;
-    return;
+                        binning = new AliAnalysisMuMuBinning;
+                        binning->AddBin("psi",sbinType->String().Data());
                     }
-  TH1* hNtr = static_cast<TH1*>(mc->Histo(Form("/%s/Nch",path.Data())));
-  if ( !hNtr )
+
+                    //Check Binning list
+                    TObjArray* bins = binning->CreateBinObjArray("psi");
+                    if (!bins)
                     {
-    AliError(Form("Error: No /%s/Nch histo in mergeable collection",path.Data()));
-    delete binning;
+                        AliError(Form("Did not get any bin for particle psi"));
                         return;
                     }
-  Int_t nTrackletsCorrTot = hNtr->Integral();
+                    // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                        AliDebug(1,Form("----CENTRALITY %s",scentrality->String().Data()));
+                        // The binning pointer, which point at Pt binning, Y binning etc.
+                        AliAnalysisMuMuBinning::Range* sbin;
+                        TIter next(bins);
+                        next.Reset();
 
-  TObjArray* bin = binning->CreateBinObjArray(what,quantity,flavour);
-  Int_t nEntries = bin->GetEntries();
-  Double_t* binArray = binning->CreateBinArray();
-  Double_t FNormTot(0.);
-  Double_t FNormTotError(0.);
+                        // Create ID for the fit which will be used to name results
+                        TString id(Form("/%s/%s/%s/%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data()));
 
-  TH1* hNorm = OC()->Histo(Form("%s/hFNormInt",id.Data()));
+                        // Histo where we put the count
+                        const Double_t * binArrayX = binning->CreateBinArrayX();
+                        Int_t nBinX = binning->GetNBinsX();
 
-  TH1* hFNormTot = new TH1F("hFNormVSdNchdEtaFromInt","Normalization factor vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",nEntries,binArray);
+                        TH1* hraw = new TH1D(Form("hRawCountVS%s_%f-%f",sbinType->String().Data(),rlow,rhigh),Form("raw count of dimuon pairs for %s",id.Data()),nBinX,binArrayX);
+                        hraw->GetYaxis()->SetTitle(Form("raw count of dimuon pairs in [%0.2f;%0.2f] GeV/c",rlow,rhigh));
+                        hraw->GetXaxis()->SetTitle(sbinType->String().Data());
 
-  Double_t FNormGlobal = hNorm->GetBinContent(1);
-  Double_t FNormGlobalError = hNorm->GetBinError(1);
+                        // Loop on each range in bin
+                        //==============================================================================
+                        while ( ( sbin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
+                        {
+                            AliDebug(1,Form("-----Bin range %s",sbin->AsString().Data()));
 
-  if ( printout ) std::cout << "Global FNorm = " << FNormGlobal << " + - " << FNormGlobalError << std::endl;
+                            if(binRangeExcludedArray->FindObject(sbin->AsString().Data())) {
+                               AliDebug(1,Form("-----Bin range is excluded"));
+                               continue;
+                            }
+                            // Create ID for the fit which will be used to name results
+                            TString id(Form("/%s/%s/%s/%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data()));
+                            TString hname = corrected ? Form("MinvUS+%s_AccEffCorr",sbin->AsString().Data()) : Form("MinvUS+%s",sbin->AsString().Data());
 
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
+                            // Pointer to the histo from histo collection
+                            h = OC()->Histo(id.Data(),hname.Data());
+                            if (!h)
                             {
-    Double_t nTrklsCorrBin = hNtr->Integral(r->Xmin(),r->Xmax());
-    Double_t nTrklsCorrBinFrac = nTrklsCorrBin / nTrackletsCorrTot;
-    Double_t nTrklsCorrBinFracError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nTrklsCorrBin) / nTrackletsCorrTot,2.) +
-                                                  TMath::Power(TMath::Sqrt(nTrackletsCorrTot)*nTrklsCorrBin / TMath::Power(nTrackletsCorrTot,2.) ,2.) );
+                                AliError(Form("Could not find histo %s",hname.Data()));
+                                continue;
+                            }
 
-    FNormTot = FNormGlobal*nTrklsCorrBinFrac;
-    FNormTotError = TMath::Sqrt( TMath::Power(FNormGlobalError*nTrklsCorrBinFrac,2.) + TMath::Power(FNormGlobal*nTrklsCorrBinFracError,2.) );
+                            // Get X
+                            Double_t xmin = sbin->Xmin();
+                            Double_t xmax = sbin->Xmax();
+                            Double_t x = xmin + (xmax-xmin)/2;
+                            AliDebug(1,Form("x = %f \n", x));
 
-    hFNormTot->SetBinContent(i,FNormTot);
-    hFNormTot->SetBinError(i,FNormTotError);
-    i++;
+                            //find bin
+                            Int_t binLow   = h->FindBin(rlow);
+                            Int_t binHight = h->FindBin(rhigh);
 
-    if ( printout ) std::cout << "Bin: " << r->AsString().Data() << " ; " << " FNorm = " << FNormTot << " +- " << FNormTotError << std::endl;
+                            if(binLow==0 || binHight ==0)continue;
+                            // Fill
+                            Double_t rawCount =0.;
+                            for (Int_t i = binLow; i < binHight; ++i)
+                            {
+                                rawCount = rawCount + h->GetBinContent(i);
+                                AliDebug(1,Form("rawCount for %s in bin [%d]= %f \n",h->GetTitle(),i,rawCount));
                             }
+                            if(rawCount!=0. )hraw->Fill(x,rawCount);
 
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
+                        }
+                        TH1* o = OC()->Histo(id.Data(),hraw->GetName());
 
                         if (o)
                         {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
+                            AliWarning(Form("Replacing %s/%s",id.Data(),hraw->GetName()));
+                            OC()->Remove(Form("%s/%s",id.Data(),hraw->GetName()));
                         }
 
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
+                        //Adopt
+                        Bool_t adoptOK = OC()->Adopt(Form("%s",id.Data()),hraw);
 
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
+                        if ( adoptOK ) std::cout << "+++raw histo " << hraw->GetName() << " adopted" << std::endl;
+                        else AliError(Form("Could not adopt Yield histo %s",hraw->GetName()));
+                        new TCanvas;
+                        hraw->DrawCopy("e0");
 
+                    }
                     delete binning;
-  delete bin;
-  delete[] binArray;
+
+                }
+            }
+        }
     }
 
-//_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromCounters(const char* filePileUpCorr, const char* what,const char* quantity, const char* flavour, const char* triggerCluster, const char* eventSelectionFnorm, const char* eventSelectionYield,Bool_t printout)
+    return;
+}
+
+void AliAnalysisMuMu::ComputePPCrossSection(const char* binType, const char* particle, const char* what, Bool_t AccEffCorr)
 {
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), in bins.
-  ///
-  /// Important considerations:
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection to compute Fnorm and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly (Usually the event selection should be the same for the Fnorm and the analysis but the option to use 2 different ev. sel. is included). (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
+    /// Compute the PP Cross section
     /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
+    ///   -particle   : default is PSI
+    ///   -particle   : default is CorrNofJPsi
+    ///   -binType    : integrated,pt,y ...see your AddTaskMuMu
+    ///   -sResName   : For a particular results
+    ///   -flavour    : Default is BENJ
+    ///   -AccEffCorr : For nomenclature
 
-
-  //_______ Definitions for the triggers used to extract the counts from the counter collection:
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
+    if(!OC())
     {
-    AliError("Unknown collision type");
+        AliError("No mergeable. Consider Upgrade()");
         return;
     }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
     else
     {
-    AliError("Unknown trigger type");
-    return;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputePPCrossSection                          " << endl;
+        cout <<      " ================================================================ " << endl;
     }
 
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  //_______
+     // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
 
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
 
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sbinType;
+    TObjString* scentrality;
 
-    while ( in.getline(line,1024,'\n'))
-    {
-      TString lrun(line);
-      TString lvalue(line);
+    // Pointers
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphErr=0x0;
 
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
+    TList* list=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
 
-      lvalue.Remove(0,lvalue.First("=")+1);
 
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
+    // Loop on each envenType (see MuMuConfig)
+    //==============================================================================
+    while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+    {
+        AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+        nextTrigger.Reset();
+        // Loop on each trigger (see MuMuConfig)
+        //==============================================================================
+        while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+        {
+            AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+            nextPairCut.Reset();
+            // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+            //==============================================================================
+            while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+            {
+                AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                nextbinType.Reset();
+                // Loop on each type (pt or y)
+                //==============================================================================
+                while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                {
+                    AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                    nextCentrality.Reset();
 
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
-    }
-    corrPU = kTRUE;
-  }
-  //________
 
+                    // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                        AliDebug(1,Form("----CENTRALITY %s",scentrality->String().Data()));
+                        // The binning pointer, which point at Pt binning, Y binning etc.
 
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sQuantity(quantity);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
-  Double_t NofRuns = runs->GetEntries();
 
-  TIter nextRun(runs);
-  TObjString* s;
+                        //________Get spectra
+                        TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),particle,sbinType->String().Data());
+                        if (AccEffCorr)spectraPath+="-AccEffCorr";
 
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
+                        AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                        if(!spectra){
+                          AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
                           return;
                         }
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Double_t* binArray = binning->CreateBinArray();
-  Int_t nEntries = bin->GetEntries();
+                        //________
 
-  TH1* h;
-  TH1* hNofEqMB = new TH1F(Form("hNofEqMBVS%s",sQuantity.Data()),Form("Equivalent MB events per CMUL vs %s",sQuantity.Data()),
-                           nEntries,binArray);
-  TH1* hFNormTot = new TH1F(Form("hFNormVS%s",sQuantity.Data()),Form("Normalization factor vs %s;%s;FNorm",sQuantity.Data(),
-                                                                     sQuantity.Data()),nEntries,binArray);
+                        // //________Get Trigger sum
+                        // Int_t NofMUL = TMath::Nint(CC()->GetSum(Form("trigger:%s/event:%s/centrality:%s",striggerDimuon->String().Data(),seventType->String().Data(),scentrality->String().Data())));
+                        // //________
                         
-  Double_t* FNormTot = new Double_t[nEntries];
-  Double_t* FNormTotError = new Double_t[nEntries];
 
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data()));
+                        AliAnalysisMuMuSpectraCapsulePP * capsule = new AliAnalysisMuMuSpectraCapsulePP(spectra,spectraPath);
+                        if(!capsule) continue;
+                        AliDebug(1,Form("Spectra = %p",capsule));
+                        // capsule->PrintConst();
 
-  TList* lRun2Reject = new TList();
-  lRun2Reject->SetOwner(kTRUE);
+                        // Get Graph with RAA results
+                        list = capsule->ComputePPCrossSection(what);
 
-  Int_t i(0); // Bin number
-  TObjArray* aCluster = striggerCluster.Tokenize("-");
-  TIter nextCluster(aCluster);
-  TObjString* striggerClusterS;
+                        AliDebug(1,Form("list = %p",list));
+                        if(!list) continue;
                         
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    FNormTot[i] = 0;
-    FNormTotError[i] = 0;
-    if ( printout )
-    {
-      std::cout << "______________________________" << std::endl;
-      std::cout << "Bin: " << r->AsString().Data() << std::endl;
-    }
 
-    hFNormTot->GetXaxis()->SetBinLabel(i+1,r->AsString().Data());
-    hNofEqMB->GetXaxis()->SetBinLabel(i+1,r->AsString().Data());
+                        graph = static_cast<TGraphErrors*>(list->At(0)->Clone());
+                        graphErr = static_cast<TGraphErrors*>(list->At(1)->Clone());
 
-    h = new TH1F(Form("hFNormVSrun_%s",r->AsString().Data()),Form("Normalization factor vs run for %s ;run;FNorm",r->AsString().Data()),NofRuns,1,NofRuns);
-    //Set the run labels
+                        graphErr->SetFillColor(2);
+                        graphErr->SetFillStyle(3001);
+                        graphErr->SetTitle(Form("J/psi cross section"));
+                        if(sbinType->String().Contains("PT")) graphErr->GetYaxis()->SetTitle(Form("d^{2}#sigma/dp_{T}(#muBxGeV^{-1}xc)"));
+                        if(sbinType->String().Contains("Y")) graphErr->GetYaxis()->SetTitle(Form("d^{2}#sigma/dY(#muB)"));
+                        graphErr->GetXaxis()->SetTitle(Form("%s",sbinType->String().Data()));
+                        graphErr->SetMarkerSize(1.7);
 
-    Double_t nCMULBin = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                          seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data())); //Nof CMUL7/8 events in Bin summed over runs
+                        TF1* fit=0x0;
+                        TFitResultPtr Fitpoint=0x0;
 
-    Int_t j(1); //Run label index
-    nextRun.Reset();
-    while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
-    {
-      Double_t nCMSL(0.),nCMSLandOMUL(0.);
-      nextCluster.Reset();
-      while ( (striggerClusterS = static_cast<TObjString*>(nextCluster())) && nCMSL == 0. )
-      {
-        nCMSL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s/centrality:V0A/run:%s/bin:%s",
-                                  seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),
-                                  s->GetName(),r->AsString().Data()));
+                        if(sbinType->String().Contains("PT")){
+                            fit = new TF1("fit","[0]*x*(1/pow((1+pow(x/[1], [2])) ,[3]))",0,12);
+                            fit->SetParameters(2424.41, 4.74409,1.70488, 4.42257);
+                        }
 
-        nCMSLandOMUL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s&0MUL/centrality:V0A/run:%s/bin:%s",
-                                         seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),
-                                         s->GetName(),r->AsString().Data()));
+                        if(sbinType->String().Contains("Y")){
+                            fit= new TF1("fit","[0] * TMath::Exp(-0.5*TMath::Power((x-[1])/[2],2.))", -10, 2.5);
+                            fit->SetParameters(2.8,0.00,2.9271);
+                            fit->FixParameter(1,0.00);
                         }
-      Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s/bin:%s",
-                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
+                        new TCanvas;
+                        if(sbinType->String().Contains("PT")) gPad->SetLogy();
 
-      Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/run:%s/bin:%s",
-                                         seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
+                        TLegend * leg = new TLegend(0.4,0.7,0.70,0.9);
+                        leg->SetHeader(Form("ALICE, p-p #sqrt{s_{NN}}=5.02 TeV, L_{int}=111.31 #mub^{-1})"));
+                        if(sbinType->String().Contains("PT")) leg->AddEntry(graph,"Inclusive J/#psi cross-section 2.5 < y < 4","pe");
+                        if(sbinType->String().Contains("Y")) leg->AddEntry(graph,"Inclusive J/#psi cross-section 0 < pT < 8","pe");
+                        leg->AddEntry(graphErr,"systematic uncertainty ","f");
+                        leg->SetTextSize(0.03);
 
-      Double_t nCINTandOMSL = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD&0MSL/centrality:V0A/run:%s/bin:%s",
-                                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
+                        graphErr->DrawClone("A2P[]");
+
+                        if(fit) Fitpoint = graph->Fit("fit","SR");
+                        if(sbinType->String().Contains("PT") && static_cast<int>(Fitpoint)==0) printf("cross section = %f +/- %f \n",fit->Integral(0.,8.),fit->IntegralError(0.,8.));
+                        if(sbinType->String().Contains("Y")  && static_cast<int>(Fitpoint)==0)  printf("cross section = %f +/- %f \n",fit->Integral(-4.,-2.5),fit->IntegralError(-4.,-2.5));
+
+                        graph->DrawClone("Psame");
+                        leg->DrawClone("same");
 
-      Double_t FNorm(0.);
-      Double_t FNormError(0.);
-      Double_t FNormError2(0.);
-      Double_t pUfactor = 1.;
-      if ( nCMSLandOMUL != 0. && nCINTandOMSL !=0. && nCMSL != 0. && nCINT !=0. )
-      {
-        if (corrPU)
-        {
-          TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-          if ( p ) pUfactor = p->GetVal();
-          else
-          {
-            AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
                     }
                 }
-        
-        FNorm = (nCMSL*nCINT)*pUfactor/(nCMSLandOMUL*nCINTandOMSL);
-        FNormError = ErrorPropagationAxBoverCxD(nCMSL,nCINT,nCMSLandOMUL,nCINTandOMSL)*pUfactor;
-        FNormError2 = AliAnalysisMuMuResult::ErrorABCD(nCMSL, TMath::Sqrt(nCMSL), nCINT, TMath::Sqrt(nCINT), nCMSLandOMUL,
-                                                       TMath::Sqrt(nCMSLandOMUL), nCINTandOMSL, TMath::Sqrt(nCINTandOMSL));
             }
-      else
-      {
-        if ( nCINT == 0 ) std::cout << " Warning: Run " << s->GetName() << " has no MB trigger in this bin" << std::endl;
-        
-        lRun2Reject->Add(new TObjString(s->GetName()));
-        if ( printout ) std::cout << "Run " << s->GetName() << " not used for FNorm cause lack of stats" << std::endl;
-        continue;
         }
-      FNormTot[i] += FNorm*nCMUL; // This is the sum of equivalent Nof MB per CMUL run by run. NOTE: This sum is NOT always the total equivalent Nof MB per CMUL because in pp 2012 if just one cluster is used at a time this sum is not the sum for all runs
-      FNormTotError[i] += TMath::Power(nCMUL*FNormError,2.) + TMath::Power(FNorm*TMath::Sqrt(nCMUL),2.);
+    }
 
-      if ( printout ) std::cout << "Run " << s->GetName() << " FNorm = " << FNorm << " +- " << FNormError << " (" << FNormError2 << ")" << " ; PUFactor =" << pUfactor << " ; " << "Nof CMUL = " << nCMUL << std::endl;
+    return;
+}
 
-      h->GetXaxis()->SetBinLabel(j,s->GetName());
-      h->SetBinContent(j,FNorm);
-      h->SetBinError(j++,FNormError);
 
+//_____________________________________________________________________________
+TH2* AliAnalysisMuMu::ComputeSPDCorrection(const char* type, const char* eventSel, const char* triggerSel, Bool_t bkgReject)
+{
+    //FIX ME : make it general
+    //
+    //
+    TString stype(type);
+    TString evtype(eventSel);
+    TString trigtype(triggerSel);
+    // >Add centrality and title in the path<
+    TH2* hNch = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NchVsZVertexVsEta",evtype.Data(),
+                                                   trigtype.Data()))); // Input Nch // //"/INPUT/QASPDZPSALL/NchVSEtaVSZVertMC"
+    if ( !hNch )
+        {
+        AliError("No Nch histo found");
+        return 0x0;
         }
-    
-    TIter nextRejectRun(lRun2Reject);
-    TObjString* run2Rej;
-    Double_t nCMULBinRej(0.);
-    while ( (run2Rej = static_cast<TObjString*>(nextRejectRun())) )
+    // >Add centrality and title in the path<
+    TH2* hNtr = static_cast<TH2*>(OC()->Histo(Form("/%s/%s/V0A/TrackletsVsZVertexVsEta",evtype.Data(),
+                                                   trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
+    if ( !hNtr )
         {
-      nCMULBinRej += CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data(),
-                                       run2Rej->GetName())); //Sum of CMUL7 events from rejected runs
+        AliError("No tracklets histo found");
+        return 0x0;
+        }
+    // >Add centrality and title in the path<
+    TH2* hNtrBkg = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NBkgTrackletsVsZVertexVsEta",evtype.Data(),
+                                                      trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
+    if ( !hNtrBkg )
+        {
+        AliError("No background tracklets histo found");
+        return 0x0;
         }
 
-    nCMULBin = nCMULBin - nCMULBinRej;
-    lRun2Reject->Clear();
-    
-    FNormTotError[i] =  TMath::Sqrt(TMath::Power(TMath::Sqrt(FNormTotError[i])/nCMULBin,2.) + TMath::Power(FNormTot[i]*TMath::Sqrt(nCMULBin)/TMath::Power(nCMULBin,2.),2.));
-    FNormTot[i] = FNormTot[i]/nCMULBin;
-    
-    std::cout << "Mean FNorm in Bin = " << FNormTot[i]  << " +- " << FNormTotError[i] <<std::endl;
-    
-    hFNormTot->SetBinContent(i+1,FNormTot[i]);
-    hFNormTot->SetBinError(i+1,FNormTotError[i]);
-    
-    //____
-    Double_t nCMULBinYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                 seventSelectionYield.Data(),triggerType.Data(),colType.Data(),r->AsString().Data())); //Nof CMUL7/8 events in Bin summed over runs (for yield event selection)
-    
-    Double_t nofEqMB = FNormTot[i]*nCMULBinYield;
-    Double_t nofEqMBError = TMath::Sqrt( TMath::Power(FNormTotError[i]*nCMULBinYield,2.) + TMath::Power(FNormTot[i]*TMath::Sqrt(nCMULBinYield),2.) );
-    
-    std::cout << "EqMB in Bin  = " << nofEqMB << " +- " << nofEqMBError << " ; nCMUL (used for the yield) = " << nCMULBinYield << std::endl;
 
-    hNofEqMB->SetBinContent(i+1,nofEqMB);
-    hNofEqMB->SetBinError(i+1,nofEqMBError);
-    //____
+    TH2D* hSPDCorr = static_cast<TH2D*>(hNtr->Clone("SPDCorr"));
+    TString title("");\
+    if ( stype.Contains("oneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction");
+    else if ( stype.Contains("AccEffOnly")) hSPDCorr->SetTitle("SPD AccxEff correction");
+    else if ( stype.Contains("statOneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction stat. unc.");
 
-    TH1* o = fMergeableCollection->Histo(id.Data(),h->GetName());
+    for (Int_t i = 1 ; i < hNch->GetNbinsX() ; i++)
+        {
+        for (Int_t j = 1 ; j < hNch->GetNbinsY() ; j++)
+            {
+            Int_t n = hNch->GetBin(i,j);
+            Double_t nch = hNch->GetBinContent(n);
+            Double_t ntr = hNtr->GetBinContent(n);
+            Double_t nBkgtr(0.);
+            if ( bkgReject ) nBkgtr = hNtrBkg->GetBinContent(n);
 
-    if (o)
+            Double_t corr(0.),corrErr(0.);
+            if ( nch != 0. )
                 {
-      AliWarning(Form("Replacing %s/%s",id.Data(),h->GetName()));
-      fMergeableCollection->Remove(Form("%s/%s",id.Data(),h->GetName()));
+                corr = (ntr - nBkgtr)/nch;
+                corrErr = TMath::Max( 1./nch,TMath::Sqrt( corr*(1.-corr)/nch ) );
                 }
 
-    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),h);
-    
-    if ( adoptOK ) std::cout << "+++FNorm histo " << h->GetName() << " adopted" << std::endl;
-    else AliError(Form("Could not adopt FNorm histo %s",h->GetName()));
-    
-    i++;
-    lRun2Reject->Clear();
+            if ( stype.Contains("oneOverAccEff"))
+                {
+                if ( corr > 0. )
+                    {
+                    hSPDCorr->SetBinContent(n,1./corr);
+                    hSPDCorr->SetBinError(n,corrErr/TMath::Power(corr,2.));
                     }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
+                else
                     {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
+                    hSPDCorr->SetBinContent(n,0.);
+                    hSPDCorr->SetBinError(n,1.);
                     }
 
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  
-  
-  o = fMergeableCollection->Histo(id.Data(),hNofEqMB->GetName());
-  
-  if (o)
+                }
+            else if ( stype.Contains("AccEffOnly"))
+                {
+                hSPDCorr->SetBinContent(n,corr);
+                hSPDCorr->SetBinError(n,corrErr);
+                }
+            else if ( stype.Contains("statOneOverAccEff"))
+                {
+                if ( corr != 0. )
                     {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNofEqMB->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNofEqMB->GetName()));
+                    hSPDCorr->SetBinContent(n,(corrErr/TMath::Power(corr,2.)*100)/(1./corr));
+                    }
+                else
+                    {
+                    hSPDCorr->SetBinContent(n,-1);
                     }
 
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNofEqMB);
+                }
+            }
+        }
 
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNofEqMB->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNofEqMB->GetName()));
+    return hSPDCorr;
+}
 
-  delete binning;
-  delete runs;
-  delete aCluster;
-  delete bin;
-  delete[] binArray;
-  delete[] FNormTot;
-  delete[] FNormTotError;
-  delete lRun2Reject;
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnorm()
+{
+    /// Compute the CMUL to CINT ratio(s)
 
-  return;
+    if (!CC()) return;
 
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM");
+    //Create the object
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());
+    //Compute Fnorm
+    computer.ComputeFnorm();
+    //Let go the ownership
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/");
+    //Update
+    Update();
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromGlobal(const char* what, const char* quantity, const char* flavour,const char* triggerCluster,
-                                                 const char* eventSelectionFnorm, const char* eventSelectionYield,  Bool_t printout)
+void AliAnalysisMuMu::ComputeNumberOfEvent()
 {
-  /// Compute the CMUL to CINT ratio(s) from the itegrated FNorm, in bins.
-  /// The FNorm bin by bin is computed as follows:
-  ///   FNorm^{i} = FNorm*( (N_{MB}^{i}/N_{MB}) / (N_{CMUL}^{i}/N_{CMUL}) )
-  ///
-  /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection)(because the integrated Fnorm has to be computed in PSALL).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00" (Used for charged particle multiplicity analysis).
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
+    /// Compute the CMUL to CINT ratio(s)
 
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
+    if (!OC() || !CC()|| !Config())
     {
-    AliError("Unknown collision type");
+        AliError("No mergeable/counter collection. Consider Upgrade()");
         return ;
     }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
     else
     {
-    AliError("Unknown trigger type");
-    return;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeNumberOfEvent                 " << endl;
+        cout <<      " ================================================================ " << endl;
     }
 
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
+    const AliAnalysisMuMuFnorm::ETriggerType triggerTypes[] = { AliAnalysisMuMuFnorm::kMB, AliAnalysisMuMuFnorm::kMUL, AliAnalysisMuMuFnorm::kMSL, AliAnalysisMuMuFnorm::kMSH };
+    const Bool_t trueFalse[] = { kTRUE, kFALSE };
+
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Nevent");
+
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());// here trigger type doesn't count
+
+    for ( Int_t i = 0; i < 4; ++i )
     {
-    AliError("Unknown trigger cluster");
-    return;
+        for ( Int_t pileup = 0; pileup < 2; ++pileup )
+        {
+          for ( Int_t ps = 0; ps < 2; ++ps )
+          {
+            computer.ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+          }
+        }
     }
 
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sQuantity(quantity);
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data()));
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Nevent");
+    //Update
+    Update();
+}
 
-  TH1* hFnormGlobalInt = OC()->Histo(id.Data(),"hFNormInt");
-  if( !hFnormGlobalInt)
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnormWeightedMeanGraphs(AliAnalysisMuMuFnorm::ETriggerType refTrigger,const char* patternOrList, const char* graphName )
 {
-    AliError("hFNormInt not found");
-    return;
-  }
-  Double_t FNormGlobal = hFnormGlobalInt->GetBinContent(1);
-  Double_t FNormGlobalError = hFnormGlobalInt->GetBinError(1);
+    /// Compute the FNorm Weighted Mean Graph
+    /// Parameters:
+    ///   - refTrigger    : kMUL, kMB ...
+    ///   - patternOrList : name of the graphs included in th emean proceedur. Two mean graphs are separated by ":" and graphics used to compute a mean graphs are
+    ///                     separated by ',' . For example: FnormOffline2PUPS,FnormOffline1PUPS:FnormOffline2PUPS,FnormOffline1PUPS,FnormScalers1PUPS will compute
+    ///                     one mean graph with  FnormOffline2PUPS - FnormOffline1PUPS, and one mean graph with FnormOffline2PUPS - FnormOffline1PUPS - FnormScalers1PUPS.
+    ///   -  graphName    : name of the output mean graph. Selected by default otherwise
 
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
+    if (!OC() || !CC()|| !Config())
     {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
+        AliError("No mergeable/counter collection. Consider Upgrade()");
         return ;
     }
-  
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Double_t* binArray = binning->CreateBinArray();
-  Int_t nEntries = bin->GetEntries();
-
-  TH1* hNMBVSBin = new TH1F(Form("hNofEqMBVS%sFromGlobal",sQuantity.Data()),Form("Equivalent MB events per CMUL vs %s",sQuantity.Data())
-                            ,nEntries,binArray);
-  TH1* hFNormVSBin = new TH1F(Form("hFNormVS%sFromGlobal",sQuantity.Data()),Form("Normalization factor vs %s;%s;FNorm",sQuantity.Data(),sQuantity.Data()),
-                              nEntries,binArray);
-  
-  Double_t nCMULTot = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                                        seventSelectionFNorm.Data(),triggerType.Data(),colType.Data()));
-  
-  Double_t nCINTTot = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A",
-                                     seventSelectionFNorm.Data(),triggerType.Data(),colType.Data()));
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
+    else
     {
-    Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeFnormWeightedMeanGraphs                 " << endl;
+        cout <<      " ================================================================ " << endl;
+    }
 
-    Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/bin:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/WeightedMeanGraphs");
 
-    Double_t f = nCMUL/nCMULTot;
-    Double_t fError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nCMUL)/nCMULTot,2.) + TMath::Power(nCMUL*TMath::Sqrt(nCMULTot)/TMath::Power(nCMULTot,2.),2.) );
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
 
-    Double_t g = nCINT/nCINTTot;
-    Double_t gError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nCINT)/nCINTTot,2.) + TMath::Power(nCINT*TMath::Sqrt(nCINTTot)/TMath::Power(nCINTTot,2.),2.) );
+    TString spattern(patternOrList);
+    TObjArray* slist(0x0);
+    slist = spattern.Tokenize(":");
 
-    Double_t value = FNormGlobal*(g/f);
-    Double_t error = TMath::Sqrt( TMath::Power(FNormGlobalError*(g/f),2.) + TMath::Power(FNormGlobal*(gError/f),2.) + TMath::Power(FNormGlobal*g*fError/TMath::Power(f,2.),2.) );
+    TIter next(slist);
+    TObjString* str(0x0);
 
-    hFNormVSBin->SetBinContent(i,value);
-    hFNormVSBin->SetBinError(i,error);
-    hFNormVSBin->GetXaxis()->SetBinLabel(i,r->AsString().Data());
 
-    if (printout)
+
+    while ( ( str = static_cast<TObjString*>(next()) ) )
     {
-      std::cout << "Bin " << r->AsString().Data() << " : " << std::endl;
-      std::cout << " FNorm = " << value << " +- " << error << " ; nCMUL = " << nCMUL << std::endl;
+        computer.WeightedMeanGraphs(str->String().Data(),graphName,OC());
     }
 
-    Double_t nCMULYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                       seventSelectionYield.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
 
-    Double_t nMB = value*nCMULYield;
-    Double_t nMBerror = nMB*TMath::Sqrt( TMath::Power(error/value,2.) + TMath::Power(TMath::Sqrt(nCMULYield)/nCMULYield,2.) );
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/WeightedMeanGraphs");
+    //Update
+    Update();
+}
 
-    if (printout) std::cout << " NEqMB = " << nMB << " +- " << nMBerror << " ; nCMUL (for yield) = " << nCMULYield << std::endl;
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnormScalers(AliAnalysisMuMuFnorm::ETriggerType refTrigger, Bool_t PileUpCorr)
+{
+  /// Compute the MB to REF ratio using the scalers method (from OCDB)
+  ///
+  /// i.e. Fnorm = L0B(MB) x PS(MB) x Fpile-up / ( L0B(REF) x PS(REF) )
+  ///
+  /// where MB is the minbias trigger
+  /// REF is the fReferenceTrigger
+  /// and PS is the fraction of events selected by the physics selection
+  ///
+  /// The correction factor (the two PS and one Fpile-up) are
+  /// taken from graphs computed in other methods
+  ///
 
-    hNMBVSBin->SetBinContent(i,nMB);
-    hNMBVSBin->SetBinError(i,nMBerror);
-    hNMBVSBin->GetXaxis()->SetBinLabel(i,r->AsString().Data());
 
-    i++;
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeFnormScalers                 " << endl;
+        cout <<      " ================================================================ " << endl;
     }
 
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormVSBin->GetName());
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Scaler");
 
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormVSBin->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormVSBin->GetName()));
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
+
+    computer.ComputeFnormScalers(kFALSE,0);
+    if(PileUpCorr){
+        computer.ComputeFnormScalers(kTRUE,0);
+        computer.ComputeFnormScalers(kTRUE,1);
     }
 
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormVSBin);
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Scaler");
+    //Update
+    Update();
+}
 
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormVSBin->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormVSBin->GetName()));
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeIntFnormFromCounters(AliAnalysisMuMuFnorm::ETriggerType refTrigger, Bool_t PileUpCorr)
+{
+ /// Compute the CMUL to CINT ratio(s) in 1 or 2 steps (Offline method) from the CC(), in bins.
+ ///
+ /// Important considerations:
+ ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
+ ///   FIX ME : quantity not define in CC() for "pt" and "y".
 
-  o = fMergeableCollection->Histo(id.Data(),hNMBVSBin->GetName());
 
-  if (o)
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
     {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNMBVSBin->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNMBVSBin->GetName()));
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeIntFnormFromCounters                 " << endl;
+        cout <<      " ================================================================ " << endl;
     }
 
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNMBVSBin);
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Offline");
+
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
 
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNMBVSBin->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNMBVSBin->GetName()));
+    computer.ComputeFnormOffline(1,kFALSE,0); // CINT/CINT&0MUL
+    computer.ComputeFnormOffline(1,kFALSE,1); // CINT/CINT&0MUL + Event selection corrected
+    if(PileUpCorr) computer.ComputeFnormOffline(1,kTRUE,1); // CINT/CINT&0MUL + Event selection corrected + pileup correction
 
+    computer.ComputeFnormOffline(2,kFALSE,0); // CMSL/CMSL&0MUL x CINT/CINT&0MSL
+    computer.ComputeFnormOffline(2,kFALSE,1); // CMSL/CMSL&0MUL x CINT/CINT&0MSL + Event selection corrected
+    if(PileUpCorr) computer.ComputeFnormOffline(2,kTRUE,1); // CMSL/CMSL&0MUL x CINT/CINT&0MSL+ Event selection corrected + pileup correction
+
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Offline/");
+    //Update
+    Update();
 
 }
 
@@ -4362,280 +5190,21 @@ void AliAnalysisMuMu::ComputeMeanFnorm(const char* triggerCluster, const char* e
         fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFnormMean->GetName()));
         }
 
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hFnormMean);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFnormMean->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFnormMean->GetName()));
-
-
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeIntFnormFromCounters(const char* filePileUpCorr, const char* triggerCluster, const char* eventSelectionFnorm, const char* eventSelectionYield, Bool_t printout)
-{
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), integrated.
-  ///
-  /// Important considerations:
-  ///   - If the analysed file has a binning, we must be sure that all events are included in the bins to get the correct integrated Fnorm.
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00, but by default is also PSALL (it can be different in case the aditional event cuts do not affect the J/psi yield, like for example a cut on |Z_vtx| < x cm)) to work correctly. (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
-  /// Parameters:
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFNorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
-
-
-  //_______ Definitions for the triggers used to extract the counts from the counter collection:
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data()); // Let the method know if the collision is beam-beam of satellite.
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data()); // Let the method know the MB trigger type (V0 or T0).
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-
-  TString striggerCluster(triggerCluster); // Let the method know in which cluster the CMUL trigger is included.
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  //________
-
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
-  Double_t NofRuns = runs->GetEntries();
-  
-
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
-    
-    while ( in.getline(line,1024,'\n'))
-    {
-      TString lrun(line);
-      TString lvalue(line);
-      
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
-      
-      lvalue.Remove(0,lvalue.First("=")+1);
-      
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
-      
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
-    }
-    corrPU = kTRUE;
-  }
-  //________
-
-  
-  TIter nextRun(runs);
-  TObjString* s;
-  
-  TH1* h;
-  
-  Double_t FNormTot(0.);
-  Double_t FNormTotError(0.);
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data())); // Path to save the Fnorm and EqNofMB histos in the mergeable collection
-  
-  h = new TH1F("hFNormIntVSrun","Integrated Normalization factor vs run;run;FNorm",NofRuns,1.,NofRuns);
-  
-  Double_t nCMULTot = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                                        seventSelectionFNorm.Data(),triggerType.Data(),colType.Data())); //Total Nof CMUL7 events in the event selection for the Fnorm
-  
-  TObjArray* aCluster = striggerCluster.Tokenize("-");
-  TIter nextCluster(aCluster);
-  TObjString* striggerClusterS;
-  
-  TList* lRun2Reject = new TList();
-  lRun2Reject->SetOwner(kTRUE);
-  
-  nextRun.Reset();
-  Int_t i(0);//Run label index
-  std::cout << std::endl;
-  std::cout << std::endl;
-  std::cout << std::endl;
-  std::cout << "Computing FNorm" << std::endl;
-  while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
-  {
-    Double_t nCMSL(0.),nCMSLandOMUL(0.);
-    nextCluster.Reset();
-    while ( (striggerClusterS = static_cast<TObjString*>(nextCluster())) && nCMSL == 0. ) // Loop on clusters (in case the single muon trigger is in different clusters depending on the run). We need to explicitly ask for using more than one cluster by setting "triggercluster" parameter
-    {
-      nCMSL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s/centrality:V0A/run:%s",
-                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),s->GetName()));
-      
-      nCMSLandOMUL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s&0MUL/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),s->GetName()));
-    }
-    
-    Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
-    
-    Double_t nCINTandOMSL = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD&0MSL/centrality:V0A/run:%s",
-                                              seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
-    
-    Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
-    
-    Double_t FNorm(0.),FNormError(0.);
-    Double_t pUfactor = 1.;
-    if ( nCMSLandOMUL != 0. && nCINTandOMSL !=0. && nCMSL != 0. && nCINT !=0. )
-    {
-      if (corrPU) // Pile up correction
-      {
-        TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-        if ( p ) pUfactor = p->GetVal();
-        else
-        {
-          AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
-        }
-      }
-      FNorm = (nCMSL*nCINT)*pUfactor/(nCMSLandOMUL*nCINTandOMSL); //Fnorm computation
-      FNormError = ErrorPropagationAxBoverCxD(nCMSL,nCINT,nCMSLandOMUL,nCINTandOMSL)*pUfactor;
-    }
-    else // If a run has no enough stats to compute FNorm it will be skipped to compute the run average
-    {
-      if ( nCINT == 0 ) std::cout << " Warning: Bad run " << s->GetName() << " has no MB trigger in this bin. Remove from analysis" << std::endl;
-      
-      lRun2Reject->Add(new TObjString(s->GetName()));
-      if ( printout ) std::cout << "Run " << s->GetName() << " not used for FNorm cause lack of stats" << std::endl;
-      continue;
-    }
-    
-    FNormTot += FNorm*nCMUL; // This is the sum of equivalent Nof MB per CMUL run by run (for the ev. selection used for the FNorm, not the yield one). NOTE: This sum is NOT always the total equivalent Nof MB per CMUL because in pp 2012 if just one cluster is set as input parameter "triggercluster", this sum is not the sum for all runs
-    FNormTotError += TMath::Power(nCMUL*FNormError,2.) + TMath::Power(FNorm*TMath::Sqrt(nCMUL),2.);
-    
-    if ( printout ) std::cout << "Run " << s->GetName() << " FNorm = " << FNorm << " +- " << FNormError << " ; PUFactor =" << pUfactor << " ; " << "Nof CMUL = " << nCMUL << std::endl;
-    
-    h->GetXaxis()->SetBinLabel(++i,s->GetName());
-    h->SetBinContent(i,FNorm);
-    h->SetBinError(i,FNormError);
-    
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),h->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),h->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),h->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),h);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << h->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",h->GetName()));
-  
-  
-  //______ Computation of the total Nof CMUL used to compute the FNorm
-  TIter nextRejectRun(lRun2Reject);
-  TObjString* run2Rej;
-  Double_t nCMULTotRej(0.);
-  while ( (run2Rej = static_cast<TObjString*>(nextRejectRun())) )
-  {
-    nCMULTotRej += CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s",
-                                     seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),
-                                     run2Rej->GetName())); //Sum of CMUL7 events (for Fnorm event selection) from rejected runs
-  }
-
-  nCMULTot = nCMULTot - nCMULTotRej;
-  //_______
-
-
-  //_______ Integrated Fnorm computation
-  FNormTotError =  TMath::Sqrt(TMath::Power(TMath::Sqrt(FNormTotError)/nCMULTot,2.) + TMath::Power(FNormTot*TMath::Sqrt(nCMULTot)/TMath::Power(nCMULTot,2.),2.));
-  
-  FNormTot = FNormTot/nCMULTot; // nCMULTot is here nCMULTot - nCMULTotRej
-  
-  std::cout << "FNorm = " << FNormTot << " +- " << FNormTotError << std::endl;
-  
-  TH1* hFNormTot = new TH1F("hFNormInt","Global Normalization factor",1,0.,1.);
-  hFNormTot->SetBinContent(1,FNormTot);
-  hFNormTot->SetBinError(1,FNormTotError);
-  
-  o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  //________
-
-  
-  //_______ Integrated Equivalent number of minimum bias events (for the yield computation event selection)
-  TH1* hNEqMB = new TH1F("hNEqMB","Equivalent number of MB events per CMUL",1,0.,1.);
-  
-  Double_t nCMULTotYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                               seventSelectionYield.Data(),triggerType.Data(),colType.Data())); //Total Nof CMUL7 events for the event selection used to compute the yield
-  
-  Double_t nofEqMB = FNormTot*nCMULTotYield;
-  Double_t nofEqMBError = TMath::Sqrt( TMath::Power(FNormTotError*nCMULTotYield,2.) + TMath::Power(FNormTot*TMath::Sqrt(nCMULTotYield),2.) );
-  
-  std::cout << "Nof CMUL tot (used for yield) = " << nCMULTotYield << " ; " << "EqMB = " << nofEqMB << " +- " << TMath::Sqrt(nofEqMBError) << std::endl;
-  
-  hNEqMB->SetBinContent(1,nofEqMB);
-  hNEqMB->SetBinError(1,nofEqMBError);
-  
-  o = fMergeableCollection->Histo(id.Data(),hNEqMB->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNEqMB->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNEqMB->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNEqMB);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNEqMB->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNEqMB->GetName()));
-  //_______
+    adoptOK = fMergeableCollection->Adopt(id.Data(),hFnormMean);
 
-  delete runs;
-  delete lRun2Reject;
-  delete aCluster;
+    if ( adoptOK ) std::cout << "+++FNorm histo " << hFnormMean->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt FNorm histo %s",hFnormMean->GetName()));
 
-  return;
 
 }
 
+
 //_____________________________________________________________________________
 void AliAnalysisMuMu::PlotYiedWSyst(const char* triggerCluster)
 {
+    // Add syst. to yield and plot it
+    //
+    // FIX ME : make me more general
     TString striggerCluster(triggerCluster);
     if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
     else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
@@ -4646,6 +5215,7 @@ void AliAnalysisMuMu::PlotYiedWSyst(const char* triggerCluster)
         return;
         }
 
+
     TString path(Form("%s/%s/%s/%s",
                       Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
                       Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
@@ -4680,311 +5250,206 @@ void AliAnalysisMuMu::PlotYiedWSyst(const char* triggerCluster)
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeJpsiYield( Bool_t relative, const char* fNormType, const char* evSelInt, const char* evSelDiff, const char* triggerCluster, const char* spectra, const char* sResName)
+void AliAnalysisMuMu::ComputeJpsiYield(const char* binType, const char* what, const char* externfile, const char* externfile2, const char* sResName, const char* beamYear, Bool_t AccEffCorr)
 {
-  /// Compute the Jpsi yield integrated and in bins, absolute or relative (Y_bin/Y_int). It can be calculated for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
-  ///
-  /// Important considerations:
-  ///   - No corrections can be applied to the yields or x-axis with this method
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL (fot integrated signal extraction) and the one used in the bin by bin yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly.
+    /// Compute the Jpsi yield, i.e NofJPsi/Fnorm. Delegate procedure to the right capsule object. It can be compute for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
     ///
     /// Parameters:
-  ///   -relative: kTRUE if relative yield (y/y_int) is to be computed. Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
-  ///   -fNormType: Desired FNorm to use: "offline", "global" or "mean"
-  ///   -evSelInt: Event selection to compute integrated NofJpsi
-  ///   -evSelDiff: Event selection to compute diferential NofJpsi
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -spectra: spectra (AliAnalysisMuMuSpectra) to be used to get the differential NofJpsi
+    ///   -binType    : INTEGRATED, PT, Y (for now)
+    ///   -what       : The quantity divided by FNorm (NofJPsi by default, but could be something else...)
+    ///   -externfile : For the capsule
+    ///   -externfile2: For the capsule
+    ///   -AccEffCorr : Just a tag to select right histograms.
     ///   -sResName   : subresult name to get the yield from. By default is "" (mean of all subresults)
 
-  TString sfNormType(fNormType);
-  TString swhat("");
-  TString sres(sResName);
-  TString sspectra(spectra);
-  TString sevSelInt(evSelInt);
-  TString sevSelDiff(evSelDiff);
-
-  if ( sspectra.Contains("DNCHDETA")) swhat = "dnchdeta";   //FIXME::Make it general for any bin quantity (pt,centrality...)
-  else if ( sspectra.Contains("NTRCORR") ) swhat = "ntrcorr";
-  else if ( sspectra.Contains("V0ACORR") ) swhat = "v0acorr";
-  else if ( sspectra.Contains("V0CCORR") ) swhat = "v0ccorr";
-  else if ( sspectra.Contains("V0MCORR") ) swhat = "v0mcorr";
-
-  if ( IsSimulation() )
+    if (!OC() || !CC())
         {
-    AliError("Cannot compute J/Psi yield: Is a simulation file");
+        AliError("No mergeable/counter collection. Consider Upgrade()");
         return ;
         }
-
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
     else
         {
-    AliError("Unknown trigger cluster");
-    return;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputeJpsiYield                           " << endl;
+        cout <<      " ================================================================ " << endl;
         }
 
-  TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
-  TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
-  TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
-  
-  //Path to get/store integrated results from Mergeable Collection
-  TString intPath(Form("%s/%s/%s/%s",
-                       sevSelInt.Data(),
-                       dimuonTriggerClassName.Data(),
-                       centralitySelection.Data(),
-                       pairSelection.Data()));
-  
-  //Path to get/store differential results from Mergeable Collection
-  TString diffPath(Form("%s/%s/%s/%s",
-                        sevSelDiff.Data(),
-                        dimuonTriggerClassName.Data(),
-                        centralitySelection.Data(),
-                        pairSelection.Data()));
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
 
 
-  Double_t bR = 0.0593; // BR(JPsi->mu+mu-)
-  Double_t bRerror = 0.0006 ;
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
 
-  if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* swhat;
+    TObjString* sbinType;
+    TObjString* scentrality;
 
-  //_________Integrated yield
-  AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),"PSI-INTEGRATED-AccEffCorr"))); //FIXME::Make it general
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+    const TString syear(beamYear);
 
-  if ( !sInt )
-  {
-    AliError(Form("No spectra %s found in %s","PSI-INTEGRATED-AccEffCorr",intPath.Data()));
-    return;
-  }
 
-  AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
-  b->AddBin("psi","INTEGRATED");
 
-  AliAnalysisMuMuBinning::Range* bin = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
+    // Pointers
+    TH1* h= 0x0;
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphCent=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
 
-  AliAnalysisMuMuResult* result = sInt->GetResultForBin(*bin);
-  if ( !result )
+    //Loop on what type
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
         {
-    AliError(Form("No result for bin %s found in %s",bin->AsString().Data(),"PSI-INTEGRATED-AccEffCorr"));
-    return;
-  }
-
-  Double_t NofJPsiTot = result->GetValue("NofJPsi",sres.Data());
-  Double_t NofJPsiTotError = result->GetErrorStat("NofJPsi",sres.Data());
-
-  TH1* hMBTot = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data()));
-  if ( !hMBTot )
+        AliDebug(1,Form("what %s",swhat->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
             {
-    AliError(Form("No eq Nof MB events found in %s",Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data())));
-    return;
-  }
-
-  Double_t nEqMBTot = hMBTot->GetBinContent(1);
-  Double_t nEqMBTotError = hMBTot->GetBinError(1);
-
-  Double_t yieldInt = NofJPsiTot/(nEqMBTot*bR);
-  Double_t yieldIntError = yieldInt*TMath::Sqrt(TMath::Power(NofJPsiTotError/NofJPsiTot,2.) +
-                                       TMath::Power(nEqMBTotError/nEqMBTot,2.) +
-                                       TMath::Power(bRerror/bR,2.));
-
-  std::cout << "Integrated yield = " << yieldInt << " +- " << yieldIntError << std::endl;
-
-  TH1* hYint = new TH1F("hJPsiYieldInt","Integrated J/#psi yield",1,0.,1.);
-  hYint->SetBinContent(1,yieldInt);
-  hYint->SetBinError(1,yieldIntError);
-
-  TH1* o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),intPath.Data()),hYint->GetName());
-
-  if (o)
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
                 {
-    AliWarning(Form("Replacing /RESULTS-%s/%s/%s",striggerCluster.Data(),intPath.Data(),hYint->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),intPath.Data(),hYint->GetName()));
-  }
-
-  Bool_t adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),intPath.Data()),hYint);
-
-  if ( adoptOK ) std::cout << "+++Yield histo " << hYint->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hYint->GetName()));
-
-  std::cout << std::endl;
-
-  delete b;
-  //_________
-
+                AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
 
+                        //canvas
+                        TCanvas *c1 = new TCanvas;
+                        c1->Draw();
+                        gStyle->SetOptStat(0);
 
-  //_____Differential yield
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),sspectra.Data())));
-  if ( !s )
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
                             {
-    AliError(Form("No spectra %s found in %s",sspectra.Data(),diffPath.Data()));
-    return;
-  }
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
 
-  std::cout << "Number of J/Psi:" << std::endl;
-  TH1* hry = s->Plot("NofJPsi",sres.Data(),kFALSE); //Number of Jpsi
+                            //________Get Fnorm Histo
+                            TString id(Form("/FNORM-%s/%s/%s/%s",striggerDimuon->String().Data(),seventType->String().Data(),scentrality->String().Data(),syear.Data())); // Path to save the Fnorm and EqNofMB histos in the mergeable collection
 
-  std::cout << "" << std::endl;
+                            TString idHisto="";
+                            if (!sbinType->String().Contains("INTEGRATED")) idHisto= Form("hNofEqMBVS%s",sbinType->String().Data());
+                            else if (sbinType->String().Contains("INTEGRATED")) idHisto= Form("hFNormInt_%s",striggerMB.Data());
 
-  //  std::cout << "Equivalent number of MB events:" << std::endl;
-  TH1* hMB(0x0);
-  if ( sfNormType.Contains("offline") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
+                            h = OC()->Histo(Form("%s/%s",id.Data(),idHisto.Data()));
+                            if (!h)
                                 {
-      AliError(Form("Histo hNofEqMBVS%s not found",swhat.Data()));
+                                AliError(Form("Could not find histo in %s/%s",id.Data(),idHisto.Data()));
                                 return;
                                 }
+                            //________
 
-    std::cout << " Using Fnorm from offline method " << std::endl;
-  }
-  else if ( sfNormType.Contains("global") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),"PSI",sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
                                 {
-      AliError(Form("Histo hNofEqMBVS%sFromGlobal not found",swhat.Data()));
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
                                 return;
                                 }
+                            //________
 
-    std::cout << " Using Fnorm from global method " << std::endl;
-  }
-  else if ( sfNormType.Contains("mean") )
+                            //________Select methods
+                            if(syear.Contains("PbPb"))
                                 {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromMean",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
-    {
-      AliError(Form("Histo hNofEqMBVS%sFromMean not found",swhat.Data()));
-      return;
-    }
 
-    std::cout << " Using mean Fnorm " << std::endl;
-  }
-  else
-  {
-    AliError("Dont know what Fnorm use");
-    return;
-  }
 
-  std::cout << std::endl;
+                                    AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,externfile,externfile2);
+                                    AliDebug(1,Form("Spectra = %p",capsule));
 
-  TH1* hy;
-  const TArrayD* binArray = hry->GetXaxis()->GetXbins();
-  Int_t size = binArray->GetSize();
-  const Double_t* axis = binArray->GetArray();
+                                    // Get Graph with Yield results
+                                    graph = capsule->ComputeYield(swhat->String().Data(),h,sResName);
 
-  if (sres.IsNull()) sres += "mean"; // To indicate that the result is computed from the mean yield of all the subresults
+                                    TLegend * leg = new TLegend(0.4,0.7,0.90,0.9);
+                                    leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=2.76 TeV, L_{int}=70 #mub^{-1}, %s",scentrality->String().Data()));
+                                    leg->AddEntry(graph,"Inclusive J/#psi Yield","pe");
+                                    graph->Draw("ap");
+                                    leg->Draw();
 
-  if ( relative )
-  {
-    hy = new TH1D(Form("hJPsiYieldVS%sRelative",swhat.Data()),Form("Relative J/#psi yield vs %s (%s);%s;Y^{J/#psi}/Y^{J/#psi}_{int}",swhat.Data(),sres.Data(),swhat.Data()),size-1,axis);
+                                    delete capsule;
                                 }
-  else
+                            else if(syear.Contains("pPb") || syear.Contains("Pbp"))
                                 {
-    hy = new TH1D(Form("hJPsiYieldVS%s",swhat.Data()),Form("J/#psi yield vs %s (%s);%s;Y^{J/#psi}",swhat.Data(),sres.Data(),swhat.Data())
-                  ,size-1,axis);
-  }
-
-  delete axis;
+                                AliAnalysisMuMuSpectraCapsulePbP * capsule = new AliAnalysisMuMuSpectraCapsulePbP(spectra,spectraPath,externfile,externfile2);
+                                AliDebug(1,Form("Spectra = %p",capsule));
 
-  // AccxEff(from rel diff or paper)  // Signal extraction
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.01,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.022,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.009,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.016 ,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.033,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.003,0.001,0.002,0.003,0.002,0.004,0.011,0.012,0.071};
-  //  Double_t systPU[9] = {0.00,0.01,0.012,0.014,0.014,0.019,0.020,0.021,0.040}; //_______pPb
-  // AccxEff(from paper)
-  //  Double_t systNofJpsiTot = 0.015;
-
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.028,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.016,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.024,2.) + TMath::Power(0.005 ,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.016,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.005,0.004,0.004,0.004,0.003,0.002,0.002,0.04,0.04};
-  //  Double_t systPU[9] = {0.00,0.007,0.015,0.011,0.014,0.018,0.014,0.011,0.020}; //______Pbp
-  //  Double_t systNofJpsiTot = 0.015;
-
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.034,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.042,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.063,2.) + TMath::Power(0.014,2.) ),TMath::Sqrt( TMath::Power(0.094,2.) + TMath::Power(0.009,2.) ),TMath::Sqrt( TMath::Power(0.00,2.) + TMath::Power(0.00 ,2.) ),TMath::Sqrt( TMath::Power(0.00,2.) + TMath::Power(0.00,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.004,0.019,0.002,0.012,0.048,0.063,0.082,0.000,0.000};
-  //  Double_t systPU[9] = {0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00}; //______pp |eta|<0.5
-  //  Double_t systNofJpsiTot = 0.017;
-
-//  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.037,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.021,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.022,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.019,2.) + TMath::Power(0.001,2.) ),TMath::Sqrt( TMath::Power(0.036,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.042,2.) + TMath::Power(0.001,2.) ),TMath::Sqrt( TMath::Power(0.039,2.) + TMath::Power(0.012 ,2.) ),TMath::Sqrt( TMath::Power(0.000,2.) + TMath::Power(0.000,2.) )}; //FIXME: find a way to give this as input
-//  Double_t systFNorm[9] = {0.026,0.002,0.015,0.019,0.012,0.030,0.015,0.119,0.000};
-//  Double_t systPU[9] = {0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00}; //______pp |eta|<1
-//  Double_t systNofJpsiTot = 0.017;
-  
-  Double_t systRNofJpsi[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  Double_t systFNormInt[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  Double_t systFNormBin[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  
-  TString* nameMB = new TString();
-  TString* nameY = new TString();
-  Int_t deltai(0);
-  for ( Int_t i = 1 ; i <= hy->GetNbinsX() ; i++ )
-  {
-    Int_t iMB = i + deltai;
-    nameMB->Replace(0,nameMB->Sizeof(),hMB->GetXaxis()->GetBinLabel(iMB));
-    nameY->Replace(0,nameY->Sizeof(),hry->GetXaxis()->GetBinLabel(i));
+                                // Get Graph with Yield results
+                                graph = capsule->ComputeYield(swhat->String().Data(),h,sResName);
 
-    // If the spectra had some results wich could not be fitted the corresponding bins are not in hry, producing a missmatchig between the bins in hMB and hry (Because hMB contains all the bins, even if for one bin the Fnorm could not be calculated). So we skip the hMB bin until matches with the hry one:
+                                TLegend * leg = new TLegend(0.4,0.7,0.90,0.9);
+                                leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=2.76 TeV, L_{int}=70 #mub^{-1}, %s",scentrality->String().Data()));
+                                leg->AddEntry(graph,"Inclusive J/#psi Yield","pe");
+                                graph->Draw("ap");
+                                leg->Draw();
 
-    while ( nameMB->CompareTo(*nameY) )
-    {
-      deltai++;
-      iMB++;
-      nameMB->Replace(0,nameMB->Sizeof(),hMB->GetXaxis()->GetBinLabel(iMB));
+                                delete capsule;
                                 }
-
-    std::cout << " Computing yield in bin(" << iMB << "): " << nameMB->Data() << " with yield from bin (" << i << "): " << nameY->Data() << std::endl; //Just to check that the bin matching is ok
-
-
-    Double_t yield = hry->GetBinContent(i)/(hMB->GetBinContent(iMB)*bR);
-    Double_t yieldError = yield*TMath::Sqrt(TMath::Power(hry->GetBinError(i)/hry->GetBinContent(i),2.) +
-                                            TMath::Power(hMB->GetBinError(iMB)/hMB->GetBinContent(iMB),2.) +
-                                            TMath::Power(bRerror/bR,2.));
-
-    std::cout << "Yield = " << yield << " +- " << yieldError << " (stat) " << std::endl;
-    std::cout << std::endl;
-    
-    if ( relative )
+                            else if(syear.Contains("pp"))
                                 {
-      yieldError = (yield/yieldInt)*TMath::Sqrt(TMath::Power(yieldError/yield,2.) + TMath::Power(yieldIntError/yieldInt,2.));
-      yield /= yieldInt;
-      
-      Double_t syst = yield*TMath::Sqrt( TMath::Power(systRNofJpsi[i-1],2.) + TMath::Power(systFNormInt[i-1],2.) +
-                                             TMath::Power(systFNormBin[iMB-1],2.) );
-      
-      std::cout << "Relative yield = " << yield << " +- " << yieldError << " (stat) " << " +- " << syst << " (sys) "  << std::endl;
-      std::cout << std::endl;
-
+                                AliError("No method implemented for this beam yet, but you're welcome to do it !");
+                                return;
                                 }
 
-    hy->SetBinContent(i,yield);
-    hy->SetBinError(i,yieldError);
-  }
+                            //________ Update resultes in Mergeable collection
+                            TString id2(Form("/JpsiYield-%s/%s/%s/%s/%s",striggerDimuon->String().Data(),seventType->String().Data(),spairCut->String().Data(),sbinType->String().Data(),swhat->String().Data()));
 
-  delete nameMB;
-  delete nameY;
+                            TObject* o = 0x0;
 
-  o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy->GetName());
+                            if (graph)// first graph
+                                {
+                                o = fMergeableCollection->GetObject(Form("%s/%s",id2.Data(),graph->GetName()));
 
                                 if (o)
                                     {
-    AliWarning(Form("Replacing %s/%s","/RESULTS-%s/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/V0A",hy->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),diffPath.Data(),hy->GetName()));
+                                    AliWarning(Form("Replacing %s/%s",id2.Data(),graph->GetName()));
+                                    fMergeableCollection->Remove(Form("%s/%s",id2.Data(),graph->GetName()));
                                     }
 
-  adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy);
-
-  if ( adoptOK ) std::cout << "+++Yield histo " << hy->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hy->GetName()));
+                                Bool_t adoptOK = fMergeableCollection->Adopt(id2.Data(),graph);
 
+                                if ( adoptOK ) std::cout << "+++JpsiYield graph " << graph->GetName() << " adopted" << std::endl;
+                                else AliError(Form("Could not adopt JpsiYield grap %s",graph->GetName()));
+                                }
+                            //________
 
 
-//  delete hry;
 
+                            }
+                        }
+                    }
+                }
+            }
+        }
 
     return;
 }
@@ -5013,25 +5478,21 @@ void AliAnalysisMuMu::ComputeJpsiMPt(Bool_t relative, const char* evSelInt, cons
         AliError("Cannot compute J/Psi <pT>: Is a simulation file");
         return;
         }
-  
     TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
     TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
     TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
 
-  //Path to get/store integrated results from Mergeable Collection
     TString intPath(Form("%s/%s/%s/%s",
                          sevSelInt.Data(),
                          dimuonTriggerClassName.Data(),
                          centralitySelection.Data(),
-                       pairSelection.Data()));
+                         pairSelection.Data())); //Path to store integrated result in Mergeable Collection
 
-  //Path to get/store differential results from Mergeable Collection
     TString diffPath(Form("%s/%s/%s/%s",
                           sevSelDiff.Data(),
                           dimuonTriggerClassName.Data(),
                           centralitySelection.Data(),
-                        pairSelection.Data()));
-  
+                          pairSelection.Data())); //Path to store differential result in Mergeable Collection
 
     if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
 
@@ -5103,16 +5564,32 @@ void AliAnalysisMuMu::ComputeJpsiMPt(Bool_t relative, const char* evSelInt, cons
     TH1* hmPt;
     if ( relative )
         {
+        //    TString path2(Form("/%s/%s/%s",
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kEventSelectionList,kFALSE)).Data(),
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kMinbiasTriggerList,kFALSE)).Data(),
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kCentralitySelectionList,kFALSE)).Data()));
+        //
+        //    TH1* hdNch = OC()->Histo(path2.Data(),swhat.Data());
+
+
 
         hmPt = new TH1D(Form("hJPsiMeanPtVS%sRelative",swhat.Data()),Form("Relative J/#psi mean p_{T} vs %s;%s;<p_{T}^{J/#psi}>/<p_{T}^{J/#psi}_{int}>",swhat.Data(),swhat.Data())
                         ,size-1,axis);
 
+        //
+        //    ptInt = result->GetValue("MeanPtJPsi",sres.Data());
+        //    ptIntError = result->GetErrorStat("MeanPtJPsi",sres.Data());
+
         }
     else
         {
         hmPt = new TH1D(Form("hJPsiMeanPtVS%s",swhat.Data()),Form("J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}",swhat.Data(),swhat.Data())
                         ,size-1,axis);
 
+        //    hmPt = static_cast<TH1D*>(hrmPt->Clone("hJPsiMeanPtVSdNchdEta"));
+        //    hmPt->SetTitle("J/#psi mean p_{T} vs dN_{ch}/d#eta");
+        //    hmPt->GetXaxis()->SetTitle("dN_{ch}/d#eta");
+        //    hmPt->GetYaxis()->SetTitle("<p_{T}^{J/#psi}>");
         }
 
     delete axis;
@@ -5339,52 +5816,55 @@ Double_t AliAnalysisMuMu::ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Doubl
     return TMath::Sqrt(error2);
 }
 
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::ComputeEquNofMB(const char* what,const char* quantity,const char* flavour,Bool_t printout)
-{
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  TObjArray* dNchdEtas = binning->CreateBinObjArray();
-  
-  Double_t* binArray = binning->CreateBinArray();
-  
-  TIter next(dNchdEtas);
-  AliAnalysisMuMuBinning::Range* r;
-  
-  TH1* hFNorm = ComputeDiffFnormFromHistos(what,quantity,flavour,kFALSE);
-  
-  TH1* hNMB = new TH1F("hNofEqMB","Equivalent number of MB triggers vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
-  
-  Int_t bin(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    
-    TH1* hCMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMUL7-B-NOPF-MUON/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMUL )
-    {
-      AliError(Form("No event histo in bin %s found for CMUL7-B-NOPF-MUON",r->AsString().Data()));
-      return 0x0;
-    }
-    
-    Double_t NMB = hCMUL->GetBinContent(1)*hFNorm->GetBinContent(++bin);
-    Double_t NMBError = TMath::Sqrt(TMath::Power(hCMUL->GetBinContent(1)*hFNorm->GetBinError(bin),2.) + TMath::Power(TMath::Sqrt(hCMUL->GetBinContent(1))*hFNorm->GetBinContent(bin),2));
-    
-    if ( printout ) std::cout << r->AsString().Data() << " : " << NMB << " +- " << NMBError << std::endl;
-    
-    hNMB->SetBinContent(bin,NMB);
-    hNMB->SetBinError(bin,NMBError);
-  }
-  
-  delete dNchdEtas;
-  delete[] binArray;
-  
-  return hNMB;
-}
+// //_____________________________________________________________________________
+// TH1* AliAnalysisMuMu::ComputeEquNofMB(const char* what,const char* quantity,const char* flavour,Bool_t printout)
+// {
+//   //Compute Equivalent Numbre of MB bin by bin
+//
+//   // Get binning
+//   AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
+//
+//   // Copy binning array
+//   TObjArray* dNchdEtas = binning->CreateBinObjArray();
+//   Double_t* binArray = binning->CreateBinArray();
+//
+//   TIter next(dNchdEtas);
+//   AliAnalysisMuMuBinning::Range* r;
+//
+//   TH1* hFNorm = ComputeDiffFnormFromHistos(what,quantity,flavour,kFALSE);
+//
+//   TH1* hNMB = new TH1F("hNofEqMB","Equivalent number of MB triggers vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
+//
+//   Int_t bin(0);
+//   while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+//   {
+//
+//     TH1* hCMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMUL7-B-NOPF-MUON/V0A/%s",
+//                                   Form("EventsIn%s",r->AsString().Data())));
+//     if ( !hCMUL )
+//     {
+//       AliError(Form("No event histo in bin %s found for CMUL7-B-NOPF-MUON",r->AsString().Data()));
+//       return 0x0;
+//     }
+//
+//     Double_t NMB = hCMUL->GetBinContent(1)*hFNorm->GetBinContent(++bin);
+//     Double_t NMBError = TMath::Sqrt(TMath::Power(hCMUL->GetBinContent(1)*hFNorm->GetBinError(bin),2.) + TMath::Power(TMath::Sqrt(hCMUL->GetBinContent(1))*hFNorm->GetBinContent(bin),2));
+//
+//     if ( printout ) std::cout << r->AsString().Data() << " : " << NMB << " +- " << NMBError << std::endl;
+//
+//     hNMB->SetBinContent(bin,NMB);
+//     hNMB->SetBinError(bin,NMBError);
+//   }
+//
+//   delete dNchdEtas;
+//   delete[] binArray;
+//
+//   return hNMB;
+// }
 
 
 //_____________________________________________________________________________
-AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const char* flavour)
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const char* flavour,const char* accEffSubResultName)
 {
     /// Correct one spectra
 
@@ -5394,10 +5874,8 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const
         return 0x0;
         }
 
-  const char* accEffSubResultName="PSICOUNT:1";
-  
     AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
-  AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
+    AliAnalysisMuMuSpectra* simSpectra = SIM()->GetMCSpectra(type,"ALL" ,"ANY","PP","pALLPAIRYPAIRPTIN0.0-12.0RABSMATCHLOWETAPDCA", flavour);
 
     if ( !realSpectra )
         {
@@ -5411,7 +5889,7 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const
         return 0x0;
         }
 
-  realSpectra->Correct(*simSpectra,"Jpsi",accEffSubResultName);
+    realSpectra->Correct(*simSpectra,"JPsi",accEffSubResultName);
 
     Update();
 
@@ -5419,16 +5897,18 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const
 }
 
 //_____________________________________________________________________________
-AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const char* flavour)
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const char* flavour,const char* accEffSubResultName)
 {
+    // Compute yield from simulation file
+    //
+    // FIX ME: make it general
+
     if (!SIM())
         {
         AliError("Cannot compute corrected yield without associated MC file !");
         return 0x0;
         }
 
-  const char* accEffSubResultName="PSICOUNT:1";
-  
     AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
 
     if ( !realSpectra )
@@ -5437,16 +5917,16 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const ch
         return 0x0;
         }
 
-  if (!realSpectra->HasValue("CoffNofJpsi"))
+    if (!realSpectra->HasValue("CoffNofJPsi"))
         {
-    if (!CorrectSpectra(type,flavour))
+        if (!CorrectSpectra(type,flavour,accEffSubResultName))
             {
             AliError("Could not get corrected spectra");
             return 0x0;
             }
         }
 
-  AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
+    AliAnalysisMuMuSpectra* simSpectra = SIM()->GetMCSpectra(type,"ALL" ,"ANY","PP","pALLPAIRYPAIRPTIN0.0-12.0RABSMATCHLOWETAPDCA", flavour);
 
     if ( !simSpectra)
         {
@@ -5454,9 +5934,9 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const ch
         return 0x0;
         }
 
-  Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
-  Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
-  Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
+    // Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
+    // Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
+    // Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
 
     AliAnalysisMuMuBinning* binning = realSpectra->Binning();
     TObjArray* bins = binning->CreateBinObjArray();
@@ -5473,23 +5953,23 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const ch
 
         AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
 
-    Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
-    Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                                                nofCINT7,TMath::Sqrt(nofCINT7),
-                                                                nofCMUL7,TMath::Sqrt(nofCMUL7));
+        // Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
+        // Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+        //                                                             nofCINT7,TMath::Sqrt(nofCINT7),
+        //                                                             nofCMUL7,TMath::Sqrt(nofCMUL7));
 
-    r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                                                                                nofCINT7,TMath::Sqrt(nofCINT7)));
+        // r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+        //                                                                                               nofCINT7,TMath::Sqrt(nofCINT7)));
 
-    Double_t yield =  r->GetValue("CorrNofJpsi") * mbeq;
+        // Double_t yield =  r->GetValue("CorrNofJPsi") * mbeq;
 
-    Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJpsi"), r->GetErrorStat("CorrNofJpsi"),
-                                                                 mbeq,mbeqError);
+        // Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJPsi"), r->GetErrorStat("CorrNofJPsi"),
+        //                                                              mbeq,mbeqError);
 
-    r->Set("YJpsi",yield,yieldError);
+        // r->Set("YJpsi",yield,yieldError);
 
-    r->Set("NofInputJpsi",rsim->GetValue("NofInputJpsi",accEffSubResultName),rsim->GetErrorStat("NofInputJpsi",accEffSubResultName));
-    r->Set("AccEffJpsi",rsim->GetValue("AccEffJpsi",accEffSubResultName),rsim->GetErrorStat("AccEffJpsi",accEffSubResultName));
+        r->Set("NofInputJPsi",rsim->GetValue("NofInputJPsi",accEffSubResultName),rsim->GetErrorStat("NofInputJPsi",accEffSubResultName));
+        r->Set("AccEffJPsi",rsim->GetValue("AccEffJPsi",accEffSubResultName),rsim->GetErrorStat("AccEffJPsi",accEffSubResultName));
 
         ++i;
         }
@@ -5596,10 +6076,15 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* dire
     Double_t brsigmapp = ydist.Integral(ylownorm,yhighnorm);
     Double_t brsigmappError = 0.0; // FIXME
 
-    AliInfoClass(Form("y range : LAB %f ; %f CMS %f ; %f -> ynorm : %f ; %f -> BR x sigmapp = %f",
-                      ylowlab,yhighlab,ylowcms,yhighcms,ylownorm,yhighnorm,brsigmapp));
+    AliAnalysisMuMuSpectra* realSpectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/PSALL/CMUL7-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
+    AliAnalysisMuMuSpectra* simSpectra = static_cast<AliAnalysisMuMuSpectra*>(SIM()->OC()->GetObject(Form("/ALL/CMULLO-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
+
+    if ( !realSpectra )
+        {
+        AliErrorClass("could not get real spectra");
+        return 0x0;
+        }
 
-    r = static_cast<AliAnalysisMuMuJpsiResult*>(corrSpectra->BinContentArray()->At(i)->Clone());
 
     AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
 
@@ -5710,5 +6195,3 @@ void AliAnalysisMuMu::GetFileNameAndDirectory(const char* filename)
     fDirectory = fDirectory(colon+1,strlen(filename)-colon);
   }
 }
-
-
diff --git a/PWG/muondep/AliAnalysisMuMu.h b/PWG/muondep/AliAnalysisMuMu.h
index 7e85570..2f3d5d5 100644
--- a/PWG/muondep/AliAnalysisMuMu.h
+++ b/PWG/muondep/AliAnalysisMuMu.h
@@ -7,12 +7,13 @@
 // $Id$
 
 ///
-/// AliAnalysisMuMu : helper class to digest/plot/massage results from
+/// AliAnalysisMuMu : Facade class of all subclass called to digest/plot/massage results from
 /// AliAnalysisTaskMuMu
 ///
 /// author : Laurent Aphecetche (Subatech) and Javier Martin Blanco
 
 #include "AliAnalysisMuMuBinning.h"
+#include "AliAnalysisMuMuFnorm.h"
 #include "TNamed.h"
 #include <map>
 #include <set>
@@ -43,7 +44,7 @@ public:
 
     AliAnalysisMuMu(const char* filename, AliAnalysisMuMuConfig& config);
 
-  AliAnalysisMuMu(const char* filename,
+    AliAnalysisMuMu(const char* filename="",
                     const char* associatedSimFileName="",
                     const char* associatedSimFileName2="",
                     const char* configurationFile="");
@@ -70,20 +71,45 @@ public:
                                         const char* spectraType="minv",
                                         Bool_t corrected=kFALSE);
 
-  AliAnalysisMuMuSpectra* CorrectSpectra(const char* type, const char* flavour="");
+    AliAnalysisMuMuSpectra* CorrectSpectra(const char* type, const char* flavour="",const char* accEffSubResultName="");
+
+    void PrintDistribution(
+                           const char              * binType="Y",
+                           const char              * what="NofJPsi",
+                           const char              * sResName="",
+                           const char              * ColSys="PbPb",
+                           Bool_t divideByBinWidth =kTRUE,
+                           Bool_t AccEffCorr       =kFALSE);
+
+    void PrintFitParam(const char* particle ="PSI",
+                                     const char* param = "mJPsi",
+                                     const char* binType="PT",
+                                     const char* subresult="CB2VWG_2.4_4.5_SP1.2",
+                                     const char* printDirectoryPath="",
+                                     Bool_t AccEffCorr =kFALSE
+                                     )const;
+
+    void ComputeDimuonRawCount(
+                            const Double_t rlow   = 2.8,
+                            const Double_t rhight = 3.4,
+                            const char            * binType="pt",
+                            const char            * binRangeExluded="PT_BENJ_00.00_00.30,PT_BENJ_01.00_08.00,PT_BENJ_00.30_01.00",
+                            const char            * flavour="BENJ",
+                            Bool_t corrected      =kFALSE );
+
+    void ComputePPCrossSection(
+    const char        * binType="PT",
+    const char        * particle ="PSI",
+    const char        * what ="CorrNofJPsi",
+    Bool_t AccEffCorr =kFALSE);
 
     TH2* ComputeSPDCorrection(const char* type="oneOverAccEff", const char* eventSel="PSALL", const char* triggerSel="ANY", Bool_t bkgReject=kTRUE);
 
     void ComputeFnorm();
 
-  TH1* ComputeDiffFnormFromHistos(const char* what="psi",const char* quantity="ntrcorr",const char* flavour="JAVI",Bool_t printout=kFALSE);
-  
-  void ComputeDiffFnormFromInt(const char* triggerCluster="MUON", const char* eventSelection="PSALL", AliMergeableCollection* mc=0x0, const char* what="psi",const char* quantity="ntrcorr",const char* flavour="JAVI",Bool_t printout=kTRUE);
+    void ComputeNumberOfEvent();
 
-  void ComputeDiffFnormFromCounters(const char* filePileUpCorr="", const char* what="psi", const char* quantity="ntrcorr",
-                                    const char* flavour="D2H",const char* triggerCluster="MUON",
-                                    const char* eventSelectionFNorm="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                                    const char* eventSelectionYield="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00", Bool_t printout=kTRUE);
+    void ComputeDiffFnormFromCounters(const char* filePileUpCorr="", const char* what ="psi",const char* quantity="pt", const char* flavour="BENJ", Bool_t printout=kTRUE);
 
     void ComputeDiffFnormFromGlobal(const char* what="psi",const char* quantity="ntrcorr",const char* flavour="D2H",const char* triggerCluster="MUON",
                                     const char* eventSelectionFnorm="PSALL",
@@ -92,8 +118,11 @@ public:
     void ComputeMeanFnorm(const char* triggerCluster="MUON", const char* eventSelection="PSALL", const char* what="psi",const char* quantity="ntrcorr",
                           const char* flavour="D2H");
 
-  void ComputeIntFnormFromCounters(const char* filePileUpCorr="", const char* triggerCluster="MUON", const char* eventSelectionFNorm="PSALL",
-                                   const char* eventSelectionYield="PSALL", Bool_t printout=kTRUE);
+    void ComputeFnormWeightedMeanGraphs(AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, const char* patternOrList= "", const char* graphName= "");
+
+    void ComputeFnormScalers(AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, Bool_t PileUpCorr =kFALSE);
+
+    void ComputeIntFnormFromCounters(AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, Bool_t PileUpCorr =kFALSE);
 
     void PlotYiedWSyst(const char* triggerCluster="MUON");
 
@@ -102,9 +131,14 @@ public:
                                               const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
                                               const char* triggerCluster="MUON");
 
-  void ComputeJpsiYield( Bool_t relative=kTRUE, const char* fNormType="mean", const char* evSelInt="PSALL",
-                        const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                        const char* triggerCluster="MUON", const char* whatever="PSI-NTRCORR-AccEffCorr", const char* sResName="");
+    void ComputeJpsiYield(
+                          const char        * binType="INTEGRATED",
+                          const char        * what="NofJPsi",
+                          const char        * externfile1="externFile_PT.txt",
+                          const char        * externfile2="externFile_CENT.txt",
+                          const char        * sResName="",
+                          const char        * beamYear="",
+                          Bool_t AccEffCorr =kFALSE);
 
     void ComputeJpsiMPt(Bool_t relative=kTRUE, const char* evSelInt="PSALL", const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00"
                         ,const char* spectra="PSI-NTRCORR-AccEffCorr-MeanPtVsMinvUS",const char* sResName="");
@@ -118,12 +152,35 @@ public:
 
     void TwikiOutputFnorm(const char* series="FnormOffline2PUPS,FnormScalersPUPS,FnormBest2,RelDifFnormScalersPUPSvsFnormOffline2PUPS,FnormScalersPUVDM,RelDifFnormScalersPUPSvsFnormScalersPUVDM") const;
 
-  AliAnalysisMuMuSpectra* ComputeYield(const char* type, const char* flavour="");
+    AliAnalysisMuMuSpectra* ComputeYield(const char* type, const char* flavour="",const char* accEffSubResultName="PSICB2");
 
     void CleanAllSpectra();
 
+    void CleanFNorm();
+
     ///------
 
+    void RAAasGraphic(
+                      const char                                           * particle="PSI",
+                      const char                                           * binType="PT",
+                      const char                                           * externfile1="externFile_PT.txt",
+                      const char                                           * externfile2="externFile_CENT.txt",
+                      const char                                           * RefCent ="V0M_00.00_90.00",
+                      Bool_t AccEffCorr                                    =kFALSE)const;
+
+    void DrawFitResults(
+                        const char                                           * particle="PSI",
+                        const char                                           * binType="INTEGRATED",
+                        const char                                           * printDirectoryPath="histo",
+                        Bool_t Print                                         =kFALSE,
+                        Bool_t AccEffCorr                                    =kFALSE)const;
+
+    void PrintNofParticle(
+                          const char                                           * particle="PSI",
+                          const char                                           * what="NofJPsi",
+                          const char                                           * binType="PT",
+                          Bool_t AccEffCorr                                    =kFALSE) const;
+
     //  static AliAnalysisMuMuSpectra* ComputeYield(const char* realFile="ds.list.saf.root",
     //                                              const char* simFile="ds.sim.list.saf.root",
     //                                              const  char* type="PSI-Y VS PT");
@@ -153,13 +210,17 @@ public:
     static TString ExpandPathName(const char* file);
 
     
-  Bool_t GetCollections(const char* rootfile, const char* subdir,
+    
+    Bool_t GetCollections(const char* rootfile, 
+                          const char* subdir,
                           AliMergeableCollection*& oc,
                           AliCounterCollection*& cc,
                           AliAnalysisMuMuBinning*& bin,
                           std::set<int>& runnumbers);
 
     AliAnalysisMuMuSpectra* GetSpectra(const char* what, const char* flavour="") const;
+    AliAnalysisMuMuSpectra* GetMCSpectra(const char* what ,const char* EventSelection ="ALL" ,  const char* DimuonTrigger="ANY", 
+  const char* Centrality="V0A", const char* PairSelectionKey="pALLPAIRYPAIRPTIN0.0-12.0RABSMATCHLOWETAPDCA", const char* flavour="BENJ") const;
 
     TH1* PlotAccEfficiency(const char* whatever="PSI-INTEGRATED");
 
@@ -212,7 +273,7 @@ public:
 
     void Update();
 
-  AliAnalysisMuMuConfig* Config();
+    // AliAnalysisMuMuConfig* Config();
 
     AliAnalysisMuMuConfig* Config() const { return fConfig; }
 
@@ -230,9 +291,12 @@ private:
 
     TFile* ReOpen(const char* filename, const char* mode) const;
 
+    TString First(const TString& list) const;
+
     void GetParametersFromMC(TString& fitType, const char* pathCentrPairCut, const char* spectraName, AliAnalysisMuMuBinning::Range* bin) const;
     void GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const;
 
+    
     void GetCollectionsFromAnySubdir(TDirectory& dir,
                                      AliMergeableCollection*& oc,
                                      AliCounterCollection*& cc,
@@ -265,7 +329,7 @@ private:
 
     AliAnalysisMuMuConfig* fConfig; // configuration
 
-  ClassDef(AliAnalysisMuMu,13) // class to analysis results from AliAnalysisTaskMuMuXXX tasks
+    ClassDef(AliAnalysisMuMu,12) // class to analysis results from AliAnalysisTaskMuMuXXX tasks
 };
 
 #endif
diff --git a/PWG/muondep/AliAnalysisMuMuConfig.h b/PWG/muondep/AliAnalysisMuMuConfig.h
index cc4da2b..d5512ab 100644
--- a/PWG/muondep/AliAnalysisMuMuConfig.h
+++ b/PWG/muondep/AliAnalysisMuMuConfig.h
@@ -130,6 +130,8 @@ public:
   
   TObjArray* GetListElements(const char* type, Bool_t simulation) const;
 
+  void DefineDefaultsFromFile(const char* configfile);
+
 private:
   
   enum EDataType { kSim = 1<<0, kReal = 1<<1 };
diff --git a/PWG/muondep/AliAnalysisMuMuFnorm.cxx b/PWG/muondep/AliAnalysisMuMuFnorm.cxx
index 59f44d8..45389f7 100644
--- a/PWG/muondep/AliAnalysisMuMuFnorm.cxx
+++ b/PWG/muondep/AliAnalysisMuMuFnorm.cxx
@@ -35,11 +35,13 @@
 #include "AliCounterCollection.h"
 #include "AliLog.h"
 #include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuConfig.h"
 #include "Riostream.h"
 #include "TAxis.h"
 #include "TCanvas.h"
 #include "TGraphErrors.h"
 #include "TH1F.h"
+#include "TH1.h"
 #include "TList.h"
 #include "TMap.h"
 #include "TMath.h"
@@ -53,12 +55,13 @@
 ClassImp(AliAnalysisMuMuFnorm)
 
 //_____________________________________________________________________________
-AliAnalysisMuMuFnorm::AliAnalysisMuMuFnorm(AliCounterCollection& cc,
+AliAnalysisMuMuFnorm::AliAnalysisMuMuFnorm(AliCounterCollection& cc,AliAnalysisMuMuConfig& cf,
                                            AliAnalysisMuMuFnorm::ETriggerType refTriggerType,
                                            const char* ocdbpath,
                                            Bool_t compactGraphs) :
 TObject(),
 fCounterCollection(cc),
+fConfig(cf),
 fMergeableCollection(0x0),
 fIsOwner(kTRUE),
 fOCDBPath(ocdbpath),
@@ -67,8 +70,6 @@ fIsCompactGraphs(compactGraphs),
 fReferenceTriggerType(refTriggerType)
 {
   // ctor
-  
-  
 }
 
 //_____________________________________________________________________________
@@ -95,73 +96,72 @@ void AliAnalysisMuMuFnorm::ComputeFnorm()
   ///   - scaler values corrected for pile-up
   ///   - scaler values corrected for pile-up and physics selection
 
-  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
-  const Bool_t trueFalse[] = { kTRUE, kFALSE };
-  
-  for ( Int_t i = 0; i < 4; ++i )
-  {
-    for ( Int_t pileup = 0; pileup < 2; ++pileup )
-    {
-      for ( Int_t ps = 0; ps < 2; ++ps )
-      {
-        ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
-      }
-    }
-  }
-
-  ComputeFnormOffline(1,kFALSE,0);
-  ComputeFnormOffline(1,kFALSE,1);
-  ComputeFnormOffline(1,kTRUE,1);
+//   const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+//   const Bool_t trueFalse[] = { kTRUE, kFALSE };
+//   // Call ComputeNofEvent for every combination possible
+//   for ( Int_t i = 0; i < 4; ++i )
+//   {
+//     for ( Int_t pileup = 0; pileup < 2; ++pileup )
+//     {
+//       for ( Int_t ps = 0; ps < 2; ++ps )
+//       {
+//         ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+//       }
+//     }
+//   }
+//   ComputeFnormOffline(1,kFALSE,0);
+//   ComputeFnormOffline(1,kFALSE,1);
+//   ComputeFnormOffline(1,kTRUE,1);
   
-  ComputeFnormOffline(2,kFALSE,0);
-  ComputeFnormOffline(2,kFALSE,1);
-  ComputeFnormOffline(2,kTRUE,1);
+//   ComputeFnormOffline(2,kFALSE,0);
+//   ComputeFnormOffline(2,kFALSE,1);
+//   ComputeFnormOffline(2,kTRUE,1);
 
-//  ComputeFnormOffline(2,kFALSE,2);
-//  ComputeFnormOffline(2,kTRUE,2);
+// //  ComputeFnormOffline(2,kFALSE,2);
+// //  ComputeFnormOffline(2,kTRUE,2);
 
-  ComputeFnormScalers(kFALSE,0);
-  ComputeFnormScalers(kTRUE,0);
-  ComputeFnormScalers(kTRUE,1);
-//  ComputeFnormScalers(kTRUE,2);
+//   ComputeFnormScalers(kFALSE,0);
+//   ComputeFnormScalers(kTRUE,0);
+//   ComputeFnormScalers(kTRUE,1);
+// //  ComputeFnormScalers(kTRUE,2);
 
-  WeightedMeanGraphs("Offline");
-  WeightedMeanGraphs("Scalers");
-  WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
+//   WeightedMeanGraphs("Offline");
+//   WeightedMeanGraphs("Scalers");
+//   WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
   
-  WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
+//   WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
   
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
 
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
   
-  ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
+//   ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
 
-//  for ( Int_t i = 0; i < 4; ++i )
-///  {
-    TString triggerEvents;
+// //  for ( Int_t i = 0; i < 4; ++i )
+// ///  {
+//     TString triggerEvents;
     
-//  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
-  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
+// //  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
+//   triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
   
-  MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
+//   MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
   
-    MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
-  MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
-//  }
+//     MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
+//   MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
+// //  }
 
-//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
-//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
+// //  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
+// //  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
 
-  ComputeResultsFromGraphs();
+//   ComputeResultsFromGraphs();
   
-  AliAnalysisMuMuResult* result = GetResult("Fnorm");
-  if (result)
-  {
-    result->Exclude("*");
-    result->Include("FnormBest2");
-  }
+//   AliAnalysisMuMuResult* result = GetResult("Fnorm");
+//   if (result)
+//   {
+//     result->Exclude("*");
+//     result->Include("FnormBest2");
+//   }
 }
 
 //_____________________________________________________________________________
@@ -179,7 +179,7 @@ void AliAnalysisMuMuFnorm::ComputeCorrectionFactors(Int_t eventSelectionCorrecte
     return;
   }
   
-  AliDebug(2,"");
+  AliDebug(2,"");// ??
   
   std::vector<double> vx;
   std::vector<double> vxerr;
@@ -193,7 +193,7 @@ void AliAnalysisMuMuFnorm::ComputeCorrectionFactors(Int_t eventSelectionCorrecte
   
   for ( Int_t i = 0; i < 4; ++i )
   {
-    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);
+    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);// Problem from here
     ComputePileUpGraph(triggerTypes[i],eventSelectionCorrected);
   }
   
@@ -259,6 +259,7 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
   TString name("FnormOffline");
   TString title("Computed using offline information");
   TString refInput = Form("0%s",GetTriggerTypeName(fReferenceTriggerType).Data());
+  printf("refInput = %s\n",refInput.Data() );
   
   if (nstep==1)
   {
@@ -309,6 +310,7 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     TString mbTrigger = GetTriggerClassName(kMB,runNumber);
     TString muonTrigger = GetTriggerClassName(kMSL,runNumber);
 //    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
+    printf("mb trigger : %s\n", mbTrigger.Data() );
 
     if (!mbTrigger.Length())
     {
@@ -331,7 +333,7 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     Double_t nofMBw0REF = GetSum(Form("%s&%s",mbTrigger.Data(),refInput.Data()),runNumber,eventSelectionCorrected);
     Double_t nofMBw0MSL = GetSum(Form("%s&0MSL",mbTrigger.Data()),runNumber,eventSelectionCorrected);
     
-    if ( !nofMBw0REF ) continue;
+    // if ( !nofMBw0REF && nstep == 1) continue;
     if ( !nofMBw0MSL && nstep == 2 ) continue;
     
     Double_t purityMB(1.0);
@@ -341,7 +343,9 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     {
       ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
       
-      TGraphErrors* gps = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      TGraphErrors* gps= 0x0;
+      gps = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      if (!gps)printf("Could not found Correction%s%s \n",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data());
 
       GetValueAndErrorFromGraph(gps,runNumber,purityMB,purityMBerror);
     }
@@ -369,12 +373,12 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     {
       value = (nofMB/nofMSLw0REF)*(nofMSL/nofMBw0MSL);
       
-      if ( runNumber == 196310 )
-      {
+      // if ( runNumber == 196310 )
+      // {
         AliDebug(1,Form("RUN %09d %d-%d-%d value=%e nofMB %e nofMSLw%s %e nofMSL %e nofMBw0MSL %e",
                         runNumber,nstep,pileUpCorrected,eventSelectionCorrected,
                         value,nofMB,refInput.Data(),nofMSLw0REF,nofMSL,nofMBw0MSL));
-      }
+      // }
       
       error = value*AliAnalysisMuMuResult::ErrorABCD(nofMB,TMath::Sqrt(nofMB),
                                                           nofMSLw0REF,TMath::Sqrt(nofMSLw0REF),
@@ -391,7 +395,6 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     }
   }
   
-    
   CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
 }
 
@@ -412,6 +415,9 @@ void AliAnalysisMuMuFnorm::ComputeFnormScalers(Bool_t pileUpCorrected,
   /// taken from graphs computed in other methods
   ///
   
+  TString centrality(fConfig.First(fConfig.CentralitySelectionKey()));
+
+
   TString name("FnormScalers");
   TString title("Computed using OCDB scalers");
   
@@ -468,14 +474,14 @@ void AliAnalysisMuMuFnorm::ComputeFnormScalers(Bool_t pileUpCorrected,
     
     if (eventSelectionCorrected>0)
     {
-      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
-      ComputeEventSelectionGraph(fReferenceTriggerType,eventSelectionCorrected);
+      ComputePurityFactorForScalerGraph(kMB,eventSelectionCorrected,&centrality);
+      ComputePurityFactorForScalerGraph(fReferenceTriggerType,eventSelectionCorrected,&centrality);
       
-      TGraphErrors* gpsMB  = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
-      TGraphErrors* gpsREF = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data()));
+      TGraphErrors* gpsfactorMB  = GetGraph(Form("PurityFactorForScaler%s%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(kMB).Data(),centrality.Data()));
+      TGraphErrors* gpsfactorREF  = GetGraph(Form("PurityFactorForScaler%s%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(fReferenceTriggerType).Data(),centrality.Data()));
 
-      GetValueAndErrorFromGraph(gpsMB,runNumber,purityMB,purityMBerror);
-      GetValueAndErrorFromGraph(gpsREF,runNumber,purityREF,purityREFerror);
+      GetValueAndErrorFromGraph(gpsfactorMB,runNumber,purityMB,purityMBerror);
+      GetValueAndErrorFromGraph(gpsfactorREF,runNumber,purityREF,purityREFerror);
     }
     
     if (purityMB<=0.0)
@@ -498,6 +504,8 @@ void AliAnalysisMuMuFnorm::ComputeFnormScalers(Bool_t pileUpCorrected,
     
     if (pileUpCorrected)
     { 
+      ComputePileUpGraph(kMB,eventSelectionCorrected);
+      
       TGraphErrors* gpu = GetGraph((Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data())));
       
       GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
@@ -715,7 +723,7 @@ void AliAnalysisMuMuFnorm::ComputeEventSelectionGraph(ETriggerType tt, Int_t eve
   
   const std::set<int>& runs = RunNumbers();
   
-  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+  // AliAnalysisTriggerScalers ts(runs,OCDBPath().Data()); // à quoi ça sert ??
   
   for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
   {
@@ -745,6 +753,60 @@ void AliAnalysisMuMuFnorm::ComputeEventSelectionGraph(ETriggerType tt, Int_t eve
   CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
 }
 
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnorm::ComputePurityFactorForScalerGraph(ETriggerType tt, Int_t eventSelectionCorrected, TString* centrality)
+{
+  /// Compute the per-run graph of the scaler purity factor purity
+  /// for the given trigger
+  /// This factor is computed offline as FScal_purity = NTRIGG(PS,0-90%)/NTRIGG(All,All); Offline
+  
+  TString graphName(Form("PurityFactorForScaler%s%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(tt).Data(),centrality->Data()));
+  
+  if (GetGraph(graphName))
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  const std::set<int>& runs = RunNumbers();
+  
+  // AliAnalysisTriggerScalers ts(runs,OCDBPath().Data()); // à quoi ça sert ??
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    Double_t purityfactor, purityfactorError;
+    
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+    
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+
+    GetPurityFactor(triggerClassName.Data(),runNumber,purityfactor,purityfactorError,eventSelectionCorrected,centrality);
+    
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(purityfactor);
+    vyerr.push_back(purityfactorError);
+  }
+  
+  TString title(Form("Fraction of %s events accepted for %s by all events for trigger %s",
+    GetEventSelectionName(eventSelectionCorrected).Data(),centrality->Data(),GetTriggerTypeName(tt).Data()));
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuFnorm::ComputeResultsFromGraphs()
@@ -819,7 +881,7 @@ void AliAnalysisMuMuFnorm::ComputeNofEvents(ETriggerType triggerType,
   TString graphName(Form("NofEvent%s%s%s",GetTriggerTypeName(triggerType).Data(),
                          pileUpCorrected ? "PU" : "",
                          GetEventSelectionName(eventSelectionCorrected).Data()));
-  
+  // Check if Compute has already been done
   if ( GetGraph(graphName) )
   {
     // compute it only once
@@ -1083,18 +1145,16 @@ TGraphErrors* AliAnalysisMuMuFnorm::CreateAndAddGraph(const TString& name,
                                                       const std::vector<double>& vy,
                                                       const std::vector<double>& vyerr) const
 {
-  /// Creates a graph and adds it to our mergeable collection
+  /// Creates a graph and an histo and adds it to our mergeable collection
   
   TGraphErrors* g = new TGraphErrors(vx.size(),&vx[0],&vy[0],&vxerr[0],&vyerr[0]);
   g->SetName(name.Data());
   g->SetTitle(title.Data());
-  
   if  (fIsCompactGraphs)
   {
     AliAnalysisMuMuGraphUtil::Compact(*g);
   }
 
-  g->GetXaxis()->SetNoExponent();
 //  g->GetXaxis()->SetTitle("Run number");
 
   TPaveText* text = new TPaveText(0.70,0.70,0.89,0.89,"NDC");
@@ -1104,7 +1164,11 @@ TGraphErrors* AliAnalysisMuMuFnorm::CreateAndAddGraph(const TString& name,
   text->AddText(Form("RMS  %e",g->GetRMS(2)));
   g->GetListOfFunctions()->Add(text);
 
+
+  
   MC()->Adopt("/GRAPHS/",g);
+  TH1* h = GetGraphAsHisto(name);
+  MC()->Adopt("/GRAPHS/",h);
   return g;
 }
 
@@ -1219,6 +1283,58 @@ TGraphErrors* AliAnalysisMuMuFnorm::GetGraph(const char* name) const
 }
 
 //_____________________________________________________________________________
+TH1* AliAnalysisMuMuFnorm::GetGraphAsHisto(const char* name) const
+{
+  // shortcut method to give access to one graph and return it as an histo
+
+  TObject* o = MC()->GetObject(Form("/GRAPHS/%s",name));
+
+  if (!o) return 0x0;
+  if ( o->IsA() != TGraphErrors::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+
+  const std::set<int>& runs = RunNumbers();
+
+  TGraphErrors *g = static_cast<TGraphErrors*>(o->Clone());
+  TH1F * h =new TH1F(Form("%s_AsHisto",g->GetName()),Form("%s_AsHisto",g->GetName()),1,0.,1.);
+
+  Double_t y = 0.;
+  Double_t dy = 0.;
+
+  //Fill
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    GetValueAndErrorFromGraph(g,runNumber,y,dy);
+    if(y==0.)
+    {
+      printf("Error : no values for run %d\n",runNumber );
+      continue;
+    }
+
+    Int_t bin = h->Fill(TString::Format("%d",runNumber).Data(),y);
+    h->SetBinError(bin,dy);
+  }
+
+  // Set range
+  int j=0;
+  for (int i = 1; i < h->GetEntries()+1; i++)
+  {
+    if(TString(h->GetXaxis()->GetBinLabel(i)).IsNull()) continue;
+    j++;
+  }
+  if(j == runs.size()) h->GetXaxis()->SetRange(1,j);
+
+  delete g;
+  return h;
+
+}
+
+//_____________________________________________________________________________
 void AliAnalysisMuMuFnorm::GetPurity(const char* triggerClassName, Int_t runNumber,
                                      Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const
 {
@@ -1239,7 +1355,7 @@ void AliAnalysisMuMuFnorm::GetPurity(const char* triggerClassName, Int_t runNumb
   
   if ( eventSelectionCorrected == 1 )
   {
-    ename = "PSALL";
+    ename = fConfig.First(fConfig.EventSelectionKey(),kFALSE).Data();
   }
   else if ( eventSelectionCorrected == 2 )
   {
@@ -1258,7 +1374,54 @@ void AliAnalysisMuMuFnorm::GetPurity(const char* triggerClassName, Int_t runNumb
   
   value = nps/nall;
   
-  error = AliAnalysisMuMuResult::ErrorAB(nall,TMath::Sqrt(nall),nps,TMath::Sqrt(nps));
+  error = value*AliAnalysisMuMuResult::ErrorAB(nall,TMath::Sqrt(nall),nps,TMath::Sqrt(nps));
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnorm::GetPurityFactor(const char* triggerClassName, Int_t runNumber,
+                                     Double_t& value, Double_t& error, Int_t eventSelectionCorrected, TString * centrality) const
+{
+  /// Get the physics selection accept fraction for a given trigger
+  
+  value=error=0.0;
+
+  TString runCondition;
+  
+  if (runNumber>0)
+  {
+    runCondition.Form("/run:%d",runNumber);
+  }
+
+  TObjArray * centralityArray = centrality->Tokenize("_");
+  TObjString * centralityType = static_cast<TObjString*>(centralityArray->At(0));
+  
+  TString ename;
+  if ( eventSelectionCorrected == 1 )ename = Form("%s",fConfig.First(fConfig.EventSelectionKey(),kFALSE).Data());
+  else if ( eventSelectionCorrected == 2 )ename = "OFFLINE1";
+  else {
+    value = 1.0;
+    return;
+  }
+
+  Double_t b1 = fCounterCollection.GetSum(Form("trigger:%s/event:%s%s/centrality:%s",
+                                                triggerClassName,ename.Data(),runCondition.Data(),centrality->Data()));
+  Double_t b1sq = b1*b1;
+  Double_t e1sq = b1;
+  
+  Double_t b2 = fCounterCollection.GetSum(Form("trigger:%s/event:ALL%s/centrality:%s",triggerClassName,runCondition.Data(),centralityType->String().Data()));
+  Double_t b2sq = b2*b2;
+  Double_t e2sq = b2;
+  
+  if ( b2 <= 0.0 ) return;
+  
+  value = b1/b2;
+  
+  //fully correlated bayasian
+  if (b1 != b2) {
+  error = TMath::Sqrt( TMath::Abs( ( (1. - 2.* b1 / b2) * e1sq  + b1sq * e2sq / b2sq ) / b2sq ) );
+  } 
+  else error = 0;
+
 }
 
 //_____________________________________________________________________________
@@ -1375,7 +1538,7 @@ Double_t AliAnalysisMuMuFnorm::GetSum(const char* triggerClassName,
   
   if (eventSelectionCorrected==1)
   {
-    condition += "/event:PSALL";
+    condition += Form("/event:%s",fConfig.First(fConfig.EventSelectionKey(),kFALSE).Data());
   }
   else if ( eventSelectionCorrected == 2 )
   {
@@ -1386,8 +1549,12 @@ Double_t AliAnalysisMuMuFnorm::GetSum(const char* triggerClassName,
     condition += "/event:ALL";
   }
 
+  condition += Form("/centrality:%s",fConfig.First(fConfig.CentralitySelectionKey(),kFALSE).Data());
+  
   Double_t n = fCounterCollection.GetSum(condition.Data());
 
+  printf("Sum of %s for %s = %f \n",triggerClassName,condition.Data(),n );
+  
   if (n<=0)
   {
     AliError(Form("Got no count for %s for run %d (physicsSelected:%d)",triggerClassName,runNumber,eventSelectionCorrected));
@@ -1488,13 +1655,21 @@ TString AliAnalysisMuMuFnorm::MBTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
-  {
-    return "CINT7-B-NOPF-ALLNOTRD";
-  }
-  return "";
+  // if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CINT7-B-NOPF-ALLNOTRD";
+  // }
+  // else if ( TriggerClassnameTest("CPBI2_B1-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CPBI2_B1-B-NOPF-ALLNOTRD";
+  // }
+  // return "";
+
+  TString triggerType(fConfig.First(fConfig.MinbiasTriggerKey(),kFALSE).Data());
+  return triggerType.Data();
 }
 
+
 //_____________________________________________________________________________
 TString AliAnalysisMuMuFnorm::MSHTriggerClassName(Int_t runNumber) const
 {
@@ -1516,18 +1691,22 @@ TString AliAnalysisMuMuFnorm::MSLTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
-  {
-      return "CMSL7-B-NOPF-MUON";
-  }
+ //  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
+ //  {
+ //      return "CMSL7-B-NOPF-MUON";
+ //  }
  // else
-//    if ( TriggerClassnameTest("CMSL7-B-NOPF-ALLNOTRD",runNumber) )
+ //   if ( TriggerClassnameTest("CPBI1MSL-B-NOPF-MUON",runNumber) )
  // {
-//    return "CMSL7-B-NOPF-ALLNOTRD";
+ //   return "CPBI1MSL-B-NOPF-MUON";
  // }
-  return "";
+ //  return "";
+
+ TString triggerType(fConfig.First(fConfig.MuonTriggerKey(),kFALSE).Data());
+  return triggerType.Data();
 }
 
+
 //_____________________________________________________________________________
 void AliAnalysisMuMuFnorm::MultiplyGraphs(const char* g1name, const char* g2name, const char* name)
 {
@@ -1596,15 +1775,23 @@ TString AliAnalysisMuMuFnorm::MULTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
-  {
-    return "CMUL7-B-NOPF-ALLNOTRD";
-  }
-  else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
-  {
-    return "CMUL7-B-NOPF-MUON";
-  }
-  return "";
+  // if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CMUL7-B-NOPF-ALLNOTRD";
+  // }
+  // else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
+  // {
+  //   return "CMUL7-B-NOPF-MUON";
+  // }
+  // else if ( TriggerClassnameTest("CPBI1MUL-B-NOPF-MUON",runNumber) )
+  // {
+  //   return "CPBI1MUL-B-NOPF-MUON";
+  // }
+  // return "";
+  
+  TString triggerType(fConfig.First(fConfig.DimuonTriggerKey(),kFALSE).Data());
+    return triggerType.Data();
+
 
 }
 
@@ -1725,7 +1912,7 @@ Bool_t AliAnalysisMuMuFnorm::TriggerClassnameTest(const char* triggerClassName,
 
 //_____________________________________________________________________________
 void
-AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char* graphName)
+AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char* graphName, AliMergeableCollection* oc)
 {
   /// Sum the graphs which name matches pattern
   /// Sum is made using a weighted mean (each element is weighted by the inverse
@@ -1741,27 +1928,42 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     spattern = "";
   }
 
-  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+  TList* objectList = 0x0;
+  if(oc) {
+    printf("Adding %s to the list...\n", "/FNORM/Offline/GRAPHS/");
+    objectList = oc->CreateListOfObjectNames("/FNORM/Offline/GRAPHS/");
+    printf("Adding %s to the list...\n", "/FNORM/Scaler/GRAPHS/");
+    objectList->Add(static_cast<TObject*>(oc->CreateListOfObjectNames("/FNORM/Scaler/GRAPHS/")));
+  }
+  else return;
+
+  if (!objectList){
+    printf("Cannot add list\n");
+    return;
+  }
+
   TIter next(objectList);
   TObjString* str(0x0);
   TObjArray selected;
   selected.SetOwner(kFALSE);
 
+  printf("Selecting graphs ...\n");
   while ( ( str = static_cast<TObjString*>(next()) ) )
   {
-    TGraphErrors* g = GetGraph(str->String());
-    
+    TGraphErrors* g = static_cast<TGraphErrors*>(oc->GetObject(Form("/FNORM/Offline/GRAPHS/%s",str->String().Data())));
+    if (!g) g = static_cast<TGraphErrors*>(oc->GetObject(Form("/FNORM/Scaler/GRAPHS/%s",str->String().Data())));
     if (!g) continue;
 
     TString name(g->GetName());
 
     if ( spattern.Length() >0 && !name.Contains(spattern.Data()) ) continue;
+    AliDebug(2,Form("name : %s !\n",name.Data() ));
 
     if ( slist && !slist->FindObject(name)) continue;
 
     AliDebug(2,Form("Selected for sum : %s",name.Data()));
     
-    selected.Add(g);
+    selected.Add(g->Clone());
   }
   
   delete slist;
@@ -1775,6 +1977,9 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
   std::vector<double> vyerr;
   
   Int_t npts = static_cast<TGraphErrors*>(selected.First())->GetN();
+  if(npts==0 || npts==1) return;
+  
+  printf("Computing mean ...\n");
 
   for ( Int_t ipoint = 0; ipoint < npts; ++ipoint )
   {
@@ -1782,6 +1987,7 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     Double_t sum(0.0);
     Double_t sume2(0.0);
 
+    // Loop on graphs
     for ( Int_t igraph = 0; igraph <= selected.GetLast(); ++igraph )
     {
       TGraphErrors* g = static_cast<TGraphErrors*>(selected.At(igraph));
@@ -1801,7 +2007,6 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
       {
         runNumber = g->GetX()[ipoint];
       }
-      
       if ( igraph == 0 )
       {
         xref = g->GetX()[ipoint];
@@ -1835,6 +2040,7 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     }
   }
   
+  printf("Changing titles ...\n");
   Int_t n = selected.GetEntries();
   
   TString name(graphName);
@@ -1847,7 +2053,9 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     title = TString::Format("WeightMeanFnorm%s from %d individual graphs",patternOrList,n);
   }
   
+  printf("Creating graph ...\n");
   CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+
 }
 
 
diff --git a/PWG/muondep/AliAnalysisMuMuFnorm.h b/PWG/muondep/AliAnalysisMuMuFnorm.h
index d132c0b..060509f 100644
--- a/PWG/muondep/AliAnalysisMuMuFnorm.h
+++ b/PWG/muondep/AliAnalysisMuMuFnorm.h
@@ -18,9 +18,11 @@
 class TObjArray;
 class TGraphErrors;
 class TGraph;
+class TH1;
 class AliAnalysisMuMuResult;
 class AliCounterCollection;
 class AliMergeableCollection;
+class AliAnalysisMuMuConfig;
 
 class AliAnalysisMuMuFnorm : public TObject
 {
@@ -35,7 +37,7 @@ public:
     kMSH=4
   };
   
-  AliAnalysisMuMuFnorm(AliCounterCollection& cc,
+  AliAnalysisMuMuFnorm(AliCounterCollection& cc, AliAnalysisMuMuConfig& cf,
                        AliAnalysisMuMuFnorm::ETriggerType triggerType=AliAnalysisMuMuFnorm::kMUL,
                        const char* ocdbpath="raw://",
                        Bool_t compactGraphs=kFALSE);
@@ -59,6 +61,8 @@ public:
   
   void ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected);
   
+  void ComputePurityFactorForScalerGraph(ETriggerType tt, Int_t eventSelectionCorrected, TString* centrality);
+
   void ComputeResultsFromGraphs();
 
   void ComputeTriggerFractions(ETriggerType triggerType, Bool_t physicsSelectionCorrected);
@@ -77,8 +81,12 @@ public:
   
   TGraphErrors* GetGraph(const char* name) const;
 
+  TH1* GetGraphAsHisto(const char* name) const;
+  
   void GetPurity(const char* triggerClassName, Int_t runNumber, Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const;
   
+  void GetPurityFactor(const char* triggerClassName, Int_t runNumber,Double_t& value, Double_t& error, Int_t eventSelectionCorrected, TString * centrality) const;
+
   void GetValueAndErrorFromGraph(TGraphErrors* graph,
                                  Int_t runNumber,
                                  Double_t& value,
@@ -105,7 +113,7 @@ public:
 
   Bool_t TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const;
 
-  void WeightedMeanGraphs(const char* pattern, const char* name="");
+  void WeightedMeanGraphs(const char* pattern="", const char* name="", AliMergeableCollection* mc =0x0);
   
 private:
   
@@ -135,6 +143,7 @@ private:
 private:
   
   /*const*/ AliCounterCollection& fCounterCollection; // collection of trigger counters (not owner)
+  /*const*/ AliAnalysisMuMuConfig& fConfig; // collection of trigger counters (not owner)
   mutable AliMergeableCollection* fMergeableCollection; // collection of results, histograms, graphs (ownership is in fIsOwner)
   Bool_t fIsOwner; // whether we are the owner of the mergeable collection
   TString fOCDBPath; // OCDB to be used (raw:// by default)
diff --git a/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx b/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
new file mode 100644
index 0000000..2d33032
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
@@ -0,0 +1,1857 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// AliAnalysisMuMuFnormBeta : class to encapsulate computation(s)
+/// of the normalisation factor used to get the equivalent
+/// number of MB events from the number of REF triggers
+///
+/// The computed objects are stored within a AliMergeableCollection
+/// with 3 subdirectories, dependinf on their type
+///
+/// /GRAPHS/
+/// /RESULTS/
+/// /HISTOS/
+///
+/// author: Laurent Aphecetche (Subatech) and Benjamin Audurier
+
+#include "AliAnalysisMuMuFnormBeta.h"
+
+#include "AliAnalysisMuMuGraphUtil.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisTriggerScalers.h"
+#include "AliCounterCollection.h"
+#include "AliLog.h"
+#include "AliMergeableCollection.h"
+#include "Riostream.h"
+#include "TAxis.h"
+#include "TCanvas.h"
+#include "TGraphErrors.h"
+#include "TH1F.h"
+#include "TList.h"
+#include "TMap.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "TObjString.h"
+#include "TPaveText.h"
+#include "TStyle.h"
+#include <cassert>
+#include <numeric>
+
+ClassImp(AliAnalysisMuMuFnormBeta)
+
+//_____________________________________________________________________________
+AliAnalysisMuMuFnormBeta::AliAnalysisMuMuFnormBeta(AliCounterCollection& cc,
+                                           AliAnalysisMuMuFnormBeta::ETriggerType refTriggerType,
+                                           const char* ocdbpath,
+                                           Bool_t compactGraphs) :
+TObject(),
+fCounterCollection(cc),
+fMergeableCollection(0x0),
+fIsOwner(kTRUE),
+fOCDBPath(ocdbpath),
+fResult(0x0),
+fIsCompactGraphs(compactGraphs),
+fReferenceTriggerType(refTriggerType)
+{
+  // ctor
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuFnormBeta::~AliAnalysisMuMuFnormBeta()
+{
+  // dtor
+  if ( fIsOwner )
+  {
+    delete fMergeableCollection;
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnorm()
+{
+  /// Compute the REF to CINT ratio(s)
+  ///
+  /// Using offline method
+  ///   - in one go CINT/REF
+  ///   - in two steps CINT/CMSL and CMSL/REF
+  ///
+  /// Using scaler method
+  ///   - bare scaler values
+  ///   - scaler values corrected for pile-up
+  ///   - scaler values corrected for pile-up and physics selection
+
+  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+  const Bool_t trueFalse[] = { kTRUE, kFALSE };
+  // Call ComputeNofEvent for every combination possible
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    for ( Int_t pileup = 0; pileup < 2; ++pileup )
+    {
+      for ( Int_t ps = 0; ps < 2; ++ps )
+      {
+        ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+      }
+    }
+  }
+ cout << "Here ! "<< endl;
+  ComputeFnormOffline(1,kFALSE,0);
+  ComputeFnormOffline(1,kFALSE,1);
+  ComputeFnormOffline(1,kTRUE,1);
+
+  ComputeFnormOffline(2,kFALSE,0);
+  ComputeFnormOffline(2,kFALSE,1);
+  ComputeFnormOffline(2,kTRUE,1);
+
+//  ComputeFnormOffline(2,kFALSE,2);
+//  ComputeFnormOffline(2,kTRUE,2);
+
+  ComputeFnormScalers(kFALSE,0);
+  ComputeFnormScalers(kTRUE,0);
+  ComputeFnormScalers(kTRUE,1);
+//  ComputeFnormScalers(kTRUE,2);
+
+  WeightedMeanGraphs("Offline");
+  WeightedMeanGraphs("Scalers");
+  WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
+
+  WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
+
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
+
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
+
+  ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
+
+//  for ( Int_t i = 0; i < 4; ++i )
+///  {
+    TString triggerEvents;
+
+//  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
+  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
+
+  MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
+
+    MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
+  MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
+//  }
+
+//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
+//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
+
+  ComputeResultsFromGraphs();
+
+  AliAnalysisMuMuResult* result = GetResult("Fnorm");
+  if (result)
+  {
+    result->Exclude("*");
+    result->Include("FnormBest2");
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeCorrectionFactors(Int_t eventSelectionCorrected)
+{
+  /// Compute individual graphs for the correction factors (PS_REF, PS_CINT,
+  /// F_pile-up,PS_CINT/PS_REF) used in the computation of (some) Fnorm factors
+  ///
+
+  TString graphName(Form("CorrectionGlobal%s",GetEventSelectionName(eventSelectionCorrected).Data()));;
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we compute it only once
+    return;
+  }
+
+  AliDebug(2,"");// ??
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  std::vector<double> vyGlobal;
+  std::vector<double> vyGlobalErr;
+
+  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);// Problem from here
+    ComputePileUpGraph(triggerTypes[i],eventSelectionCorrected);
+  }
+
+  TGraphErrors* gPSCINT = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(AliAnalysisMuMuFnormBeta::kMB).Data()));
+
+  TGraphErrors* gPSREF = GetGraph(Form("Correction%s%s", GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(fReferenceTriggerType).Data()));
+
+  TGraphErrors* gPU = GetGraph(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(AliAnalysisMuMuFnormBeta::kMB).Data()));
+
+  if ( !gPSCINT || !gPSREF || !gPU )
+  {
+    AliError("Did not get the relevant graphs. Cannot work");
+    return;
+  }
+
+  for ( Int_t i = 0; i < gPSCINT->GetN(); ++i )
+  {
+    Double_t x,y,yerr,yGlobal,yGlobalErr;
+
+    gPSCINT->GetPoint(i,x,y);
+
+    if ( fIsCompactGraphs )
+    {
+      x = TString(gPSCINT->GetXaxis()->GetBinLabel(i)).Atoi();
+    }
+
+    yGlobal = gPSCINT->GetY()[i] * gPU->GetY()[i] / gPSREF->GetY()[i];
+
+    yGlobalErr = yGlobal*AliAnalysisMuMuResult::ErrorABC(gPSCINT->GetY()[i],gPSCINT->GetEY()[i],
+                                                         gPSREF->GetY()[i],gPSREF->GetEY()[i],
+                                                         gPU->GetY()[i],gPU->GetEY()[i]);
+
+    y = gPSCINT->GetY()[i] / gPSREF->GetY()[i];
+    yerr = y * AliAnalysisMuMuResult::ErrorAB(gPSCINT->GetY()[i],gPSCINT->GetEY()[i],
+                                              gPSREF->GetY()[i],gPSREF->GetEY()[i]);
+
+    vx.push_back(x);
+    vxerr.push_back(gPSCINT->GetEX()[i]);
+
+    vyGlobal.push_back(yGlobal);
+    vyGlobalErr.push_back(yGlobalErr);
+
+    vy.push_back(y);
+    vyerr.push_back(yerr);
+  }
+
+  TString name(Form("Correction%sRatio",GetEventSelectionName(eventSelectionCorrected).Data()));
+  TString title(Form("%s_MB/%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data(),
+                     GetEventSelectionName(eventSelectionCorrected).Data()));
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+
+  title = TString::Format("%s_MB x Fpile-up / %s_%s ",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data(),GetEventSelectionName(eventSelectionCorrected).Data());
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vyGlobal,vyGlobalErr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrected, Int_t eventSelectionCorrected)
+{
+  /// Compute MB to REF ratio using offline method, either in 1 or 2 steps
+
+  TString name("FnormOffline");
+  TString title("Computed using offline information");
+  TString refInput = Form("0%s",GetTriggerTypeName(fReferenceTriggerType).Data());
+
+  if (nstep==1)
+  {
+    name += "1";
+    title += Form(" in one step (CINT/CINT&%s)",refInput.Data());
+  }
+  else
+  {
+    name += "2";
+    title += Form(" in two steps (CMSL/CMSL&%s x CINT/CINT&0MSL)",refInput.Data());
+  }
+
+  if (pileUpCorrected)
+  {
+    name += "PU";
+    title += " with pile-up correction";
+  }
+  if (eventSelectionCorrected==1)
+  {
+    name += "PS";
+    title += " with (ps) purity corrections";
+  }
+  else if ( eventSelectionCorrected==2 )
+  {
+    name += "TS";
+    title += " with (ts) purity corrections";
+  }
+
+  if ( GetGraph(name) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,name);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString mbTrigger = GetTriggerClassName(kMB,runNumber);
+    TString muonTrigger = GetTriggerClassName(kMUL,runNumber);
+//    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
+
+    if (!mbTrigger.Length())
+    {
+      AliError(Form("Cannot get MB trigger for run %d",runNumber));
+      continue;
+    }
+
+    Double_t nofMB = GetSum(mbTrigger.Data(),runNumber,eventSelectionCorrected);
+    Double_t nofMSL(0.0);
+    Double_t nofMSLw0REF(0.0);
+
+    if ( nstep==2 )
+    {
+      nofMSL = GetSum(muonTrigger.Data(),runNumber,eventSelectionCorrected);
+      TString counterName = muonTrigger;
+      if ( fReferenceTriggerType != kMSL ) counterName += Form("&%s",refInput.Data());
+      nofMSLw0REF = GetSum(counterName,runNumber,eventSelectionCorrected);
+    }
+
+    Double_t nofMBw0REF = GetSum(Form("%s&%s",mbTrigger.Data(),refInput.Data()),runNumber,eventSelectionCorrected);
+    Double_t nofMBw0MSL = GetSum(Form("%s&0MSL",mbTrigger.Data()),runNumber,eventSelectionCorrected);
+
+    if ( !nofMBw0REF ) continue;
+    if ( !nofMBw0MSL && nstep == 2 ) continue;
+
+    Double_t purityMB(1.0);
+    Double_t purityMBerror(0.0);
+
+    if ( eventSelectionCorrected > 0 )
+    {
+      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
+
+      TGraphErrors* gps = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+
+      GetValueAndErrorFromGraph(gps,runNumber,purityMB,purityMBerror);
+    }
+
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+
+    if (pileUpCorrected)
+    {
+      ComputePileUpGraph(kMB,eventSelectionCorrected);
+
+      TGraphErrors* gpu = GetGraph(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+
+      GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
+
+      nofMB *= pileUpFactor;
+    }
+
+    double value = nofMBw0REF > 0.0 ? nofMB/nofMBw0REF : 0.0;
+    double error = value*AliAnalysisMuMuResult::ErrorABC(nofMB,TMath::Sqrt(nofMB),
+                                                              nofMBw0REF,TMath::Sqrt(nofMBw0REF),
+                                                              pileUpFactor,pileUpFactorError);
+
+    if ( nstep == 2 )
+    {
+      value = (nofMB/nofMSLw0REF)*(nofMSL/nofMBw0MSL);
+
+      if ( runNumber == 196310 )
+      {
+        AliDebug(1,Form("RUN %09d %d-%d-%d value=%e nofMB %e nofMSLw%s %e nofMSL %e nofMBw0MSL %e",
+                        runNumber,nstep,pileUpCorrected,eventSelectionCorrected,
+                        value,nofMB,refInput.Data(),nofMSLw0REF,nofMSL,nofMBw0MSL));
+      }
+
+      error = value*AliAnalysisMuMuResult::ErrorABCD(nofMB,TMath::Sqrt(nofMB),
+                                                          nofMSLw0REF,TMath::Sqrt(nofMSLw0REF),
+                                                          nofMSL,TMath::Sqrt(nofMSL),
+                                                          nofMBw0MSL,TMath::Sqrt(nofMBw0MSL));
+    }
+
+    if ( value > 0.0 )
+    {
+      vx.push_back(1.0*runNumber);
+      vxerr.push_back(0.5);
+      vy.push_back(value);
+      vyerr.push_back(error);
+    }
+  }
+
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnormScalers(Bool_t pileUpCorrected,
+                                               Int_t eventSelectionCorrected)
+{
+  /// Compute the MB to REF ratio using the scalers method (from OCDB)
+  ///
+  /// i.e. Fnorm = L0B(MB) x PS(MB) x Fpile-up / ( L0B(REF) x PS(REF) )
+  ///
+  /// where MB is the minbias trigger
+  /// REF is the fReferenceTrigger
+  /// and PS is the fraction of events selected by the physics selection
+  ///
+  /// The correction factor (the two PS and one Fpile-up) are
+  /// taken from graphs computed in other methods
+  ///
+
+  TString name("FnormScalers");
+  TString title("Computed using OCDB scalers");
+
+  if (pileUpCorrected)
+  {
+    name += "PU";
+    title += " with pile-up correction";
+  }
+  if (eventSelectionCorrected==1)
+  {
+    name += "PS";
+    title += " with (ps) purity corrections";
+  }
+  if (eventSelectionCorrected==2)
+  {
+    name += "TS";
+    title += " with (ts) purity corrections";
+  }
+
+  if ( GetGraph(name) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,name);
+
+  // insure we have all the graphs we need to work
+  ComputeTriggerL0B(kMB);
+  ComputeTriggerL0B(fReferenceTriggerType);
+
+  const std::set<int>& runs = RunNumbers();
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  Double_t purityREF(1.0);
+  Double_t purityMB(1.0);
+  Double_t purityREFerror(00);
+  Double_t purityMBerror(0.0);
+
+  // compute the per run values
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString mbTrigger = GetTriggerClassName(kMB,runNumber);
+//    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
+
+    purityMB=purityREF=1.0;
+    purityMBerror=purityREFerror=0.0;
+
+    if (eventSelectionCorrected>0)
+    {
+      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
+      ComputeEventSelectionGraph(fReferenceTriggerType,eventSelectionCorrected);
+
+      TGraphErrors* gpsMB  = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      TGraphErrors* gpsREF = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data()));
+
+      GetValueAndErrorFromGraph(gpsMB,runNumber,purityMB,purityMBerror);
+      GetValueAndErrorFromGraph(gpsREF,runNumber,purityREF,purityREFerror);
+    }
+
+    if (purityMB<=0.0)
+    {
+      AliError(Form("Got purity=%e for MB for run %9d",purityMB,runNumber));
+      continue;
+    }
+
+    TGraphErrors* gl0bMB = GetGraph(Form("L0B%s",GetTriggerTypeName(kMB).Data()));
+    TGraphErrors* gl0bREF = GetGraph(Form("L0B%s",GetTriggerTypeName(fReferenceTriggerType).Data()));
+
+    Double_t L0bMB,L0bMBError;
+    Double_t L0bREF,L0bREFError;
+
+    GetValueAndErrorFromGraph(gl0bMB,runNumber,L0bMB,L0bMBError);
+    GetValueAndErrorFromGraph(gl0bREF,runNumber,L0bREF,L0bREFError);
+
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+
+    if (pileUpCorrected)
+    {
+      TGraphErrors* gpu = GetGraph((Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data())));
+
+      GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
+    }
+
+    Double_t value;
+    Double_t error;
+
+    ScalerFnorm(value,error,
+                L0bREF,purityREF,purityREFerror,
+                L0bMB,purityMB,purityMBerror,
+                pileUpFactor,pileUpFactorError);
+
+    if ( value > 0.0 )
+    {
+      vx.push_back(1.0*runNumber);
+      vxerr.push_back(0.5);
+      vy.push_back(value);
+      vyerr.push_back(error);
+    }
+  }
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeGraphRelDif(const char* a, const char* b) const
+{
+  // compute dispersion of b versus a
+  //
+  // computed differences graphs are put into the GRAPHS/ directory
+  // computed differences results are put into the HISTOS/ directory
+
+  TString name(Form("RelDif%svs%s",b,a));
+
+  if ( GetGraph(name) )
+  {
+    // insure we compute it only once
+    return;
+  }
+
+  AliDebug(2,name);
+
+  TGraphErrors* ga = static_cast<TGraphErrors*>(MC()->GetObject(Form("/GRAPHS/%s",a)));
+  TGraphErrors* gb = static_cast<TGraphErrors*>(MC()->GetObject(Form("/GRAPHS/%s",b)));
+
+  if (!ga)
+  {
+    AliError(Form("Cannot get graph for %s",a));
+    return;
+  }
+
+  if (!gb)
+  {
+    AliError(Form("Cannot get graph for %s",b));
+    return;
+  }
+
+  if ( ga->GetN() != gb->GetN() )
+  {
+    AliError(Form("Cannot work with different number of points in the graphs : %d vs %d",
+                  ga->GetN(),gb->GetN()));
+    return;
+  }
+
+  TString title(Form("%s-%s (RelDif,%%)",b,a));
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  for ( Int_t i = 0; i < ga->GetN(); ++i )
+  {
+    Double_t xa,xb,ya,yb;
+
+    ga->GetPoint(i,xa,ya);
+    gb->GetPoint(i,xb,yb);
+
+    if ( xa != xb )
+    {
+      AliError(Form("Incompatible graphs : got xa=%e and xb=%e",xa,xb));
+      return;
+    }
+
+    Double_t newvalue = 0.0;
+
+    if ( TMath::Abs(xa) > 1E-12 )
+    {
+      newvalue = 100.0*( yb - ya ) / ya;
+    }
+
+    Double_t yerr = newvalue*AliAnalysisMuMuResult::ErrorAB(ya,ga->GetEY()[i],
+                                                            yb,gb->GetEY()[i]);
+
+    if ( fIsCompactGraphs )
+    {
+      xa = TString(ga->GetXaxis()->GetBinLabel(i+1)).Atoi()*1.0;
+    }
+
+    vx.push_back(xa);
+    vxerr.push_back(0.5);
+    vy.push_back(newvalue);
+    vyerr.push_back(yerr);
+
+  }
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+
+  // FIXME : fill here an histogram from the graph to get the
+  // weight of 1/e2 ?
+  //  h->Fill(newvalue,1.0/(yerr*yerr));
+  //  MC()->Adopt("/HISTOS/",h);
+
+  //  AliAnalysisMuMuResult* r = GetRunIntegratedResult(*g,"FnormDispersion");
+  //  if (r)
+  //  {
+  //    if (!dispersion)
+  //    {
+  //      dispersion = new AliAnalysisMuMuResult("FnormDispersion");
+  //    }
+  //    dispersion->AdoptSubResult(r);
+  //    if ( !TString(g->GetName()).BeginsWith("Fnorm") )
+  //    {
+  //      dispersion->Exclude(r->Alias());
+  //    }
+  //  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputePileUpGraph(ETriggerType tt, Int_t eventSelectionCorrected)
+{
+  /// Compute the per-run graph of pile-up factor
+
+  TString graphName(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(tt).Data()));
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+    Double_t purity(1.0);
+    Double_t purityError(0.0);
+
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+
+    if (eventSelectionCorrected)
+    {
+      GetPurity(triggerClassName.Data(),runNumber,purity,purityError,eventSelectionCorrected);
+    }
+    ts.GetPileUpFactor(runNumber,triggerClassName.Data(),purity,pileUpFactor,pileUpFactorError);
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(pileUpFactor);
+    vyerr.push_back(pileUpFactorError);
+  }
+
+  TString title(Form("Pile-up correction factor for trigger %s",GetTriggerTypeName(tt).Data()));
+
+  if (eventSelectionCorrected)
+  {
+    title += "( L0BRate corrected by event selection";
+    title += GetEventSelectionName(eventSelectionCorrected);
+    title += " accept fraction)";
+  }
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected)
+{
+  /// Compute the per-run graph of physics selection accept fraction
+  /// for the given trigger
+
+  TString graphName(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(tt).Data()));
+
+  if (GetGraph(graphName))
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    Double_t purity, purityError;
+
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+
+    GetPurity(triggerClassName.Data(),runNumber,purity,purityError,eventSelectionCorrected);
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(purity);
+    vyerr.push_back(purityError);
+  }
+
+  TString title(Form("Fraction of events accepted by the event selection %s for trigger %s",GetTriggerTypeName(tt).Data(),
+                     GetEventSelectionName(eventSelectionCorrected).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeResultsFromGraphs()
+{
+  // Compute one single value for each graph, by weighting by the fraction
+  // of events in each run
+  // do this for certain groups of graphs
+
+  TObjArray groups;
+  groups.SetOwner(kTRUE);
+
+  groups.Add(new TObjString("Fnorm"));
+  groups.Add(new TObjString("NMBeq"));
+  groups.Add(new TObjString("Correction"));
+  groups.Add(new TObjString("RelDif"));
+
+  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+
+  TIter nextGroup(&groups);
+  TObjString* grp;
+
+  TIter next(objectList);
+  TObjString* str(0x0);
+
+  while ( ( grp = static_cast<TObjString*>(nextGroup()) ) )
+  {
+    TString oname(Form("/RESULTS/%s",grp->String().Data()));
+
+    if ( MC()->GetObject(oname) )
+    {
+      // delete if we have it already so we can replace it
+      MC()->Remove(oname);
+    }
+
+    AliAnalysisMuMuResult* result = new AliAnalysisMuMuResult(grp->String());
+
+    MC()->Adopt("/RESULTS/",result);
+
+    next.Reset();
+
+    while ( ( str = static_cast<TObjString*>(next()) ) )
+    {
+      if ( ! ( str->String().BeginsWith(grp->String() ) ) ) continue;
+
+      TGraphErrors* g = GetGraph(str->String());
+
+      if (!g) continue;
+
+      AliAnalysisMuMuResult* sub = GetRunIntegratedResult(*g);
+
+      if ( !sub )
+      {
+        AliError(Form("Could not get result for graph %s",g->GetName()));
+      }
+      if ( sub )
+      {
+        result->AdoptSubResult(sub);
+      }
+    }
+  }
+
+  delete objectList;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeNofEvents(ETriggerType triggerType,
+                                            Bool_t pileUpCorrected,
+                                            Int_t eventSelectionCorrected)
+{
+  /// Compute trigger fractions
+
+  TString graphName(Form("NofEvent%s%s%s",GetTriggerTypeName(triggerType).Data(),
+                         pileUpCorrected ? "PU" : "",
+                         GetEventSelectionName(eventSelectionCorrected).Data()));
+  // Check if Compute has already been done
+  if ( GetGraph(graphName) )
+  {
+    // compute it only once
+    return;
+  }
+
+  ComputeCorrectionFactors(eventSelectionCorrected);
+
+  TString gpsname(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(triggerType).Data()));
+  TString gpuname(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(triggerType).Data()));
+
+  TGraphErrors* gPS = GetGraph(gpsname);
+
+  if (!gPS)
+  {
+    AliError(Form("Could not find %s",gpsname.Data()));
+    return;
+  }
+
+  TGraphErrors* gPU = GetGraph(gpuname);
+
+  if (!gPU)
+  {
+    AliError(Form("Could not find %s",gpuname.Data()));
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  Int_t i(0);
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    if ( triggerClassName.Length() )
+    {
+      Double_t n = GetSum(triggerClassName,runNumber,0);
+
+      vx.push_back(runNumber);
+      vxerr.push_back(0.5);
+
+      assert(runNumber==TMath::Nint(gPU->GetX()[i]));
+
+      Double_t y(n);
+      Double_t y1(1.0);
+      Double_t y2(1.0);
+      Double_t e1(0);
+      Double_t e2(0);
+
+      if ( pileUpCorrected )
+      {
+        y1 = gPU->GetY()[i];
+        e1 = gPU->GetEY()[i];
+      }
+
+      if ( eventSelectionCorrected > 0 )
+      {
+        y2 = gPS->GetY()[i];
+        e2 = gPS->GetEY()[i];
+      }
+
+      y *= y1*y2;
+
+      AliDebug(2,Form("RUN %09d n %e y1 %e y2 %e y% e",runNumber,n,y1,y2,y));
+
+      Double_t yerr = y*AliAnalysisMuMuResult::ErrorABC( n, TMath::Sqrt(n),
+                                                        y1, e1,
+                                                        y2, e2);
+
+      vy.push_back(y);
+      vyerr.push_back(yerr);
+
+      ++i;
+    }
+  }
+
+  TString title(Form("Number of event of trigger %s",GetTriggerTypeName(triggerType).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeTriggerFractions(ETriggerType triggerType,
+                                                   Bool_t physicsSelectionCorrected)
+{
+  /// Compute trigger fractions
+
+  TString graphName(Form("Fractions%s%s",GetTriggerTypeName(triggerType).Data(),physicsSelectionCorrected ? "PS" : ""));
+
+  if ( GetGraph(graphName) )
+  {
+    // compute it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  Double_t n(0.0);
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    if ( triggerClassName.Length() )
+    {
+      n += GetSum(triggerClassName,runNumber,physicsSelectionCorrected);
+    }
+  }
+
+  if ( n <= 0.0 )
+  {
+    AliWarning(Form("Got zero trigger for %s",GetTriggerTypeName(triggerType).Data()));
+    return;
+  }
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    Double_t y = GetSum(triggerClassName,runNumber,physicsSelectionCorrected);
+    vy.push_back(y/n);
+    vyerr.push_back( (y/n) * AliAnalysisMuMuResult::ErrorAB( y,TMath::Sqrt(y),
+                                                        n, TMath::Sqrt(n)));
+  }
+
+
+  TString title(Form("Fraction of event of trigger %s",GetTriggerTypeName(triggerType).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeTriggerL0B(ETriggerType triggerType)
+{
+  /// Compute trigger L0B
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  TString graphName(Form("L0B%s",GetTriggerTypeName(triggerType).Data()));
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  const std::set<int>& runs = RunNumbers();
+
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L0B",triggerClassName);
+    if (!item) continue;
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+
+    Double_t y = item->Value();
+
+    vy.push_back(y);
+
+    vyerr.push_back( TMath::Sqrt(y) );
+  }
+
+  TString title(Form("L0B of trigger %s",GetTriggerTypeName(triggerType).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+////_____________________________________________________________________________
+//void AliAnalysisMuMuFnormBeta::ComputeTSGraph(ETriggerType tt)
+//{
+//  /// Compute the per-run graph of physics selection accept fraction x track
+//  /// accept fraction for the given trigger
+//
+//  TString graphName(Form("CorrectionTS%s",GetTriggerTypeName(tt).Data()));
+//
+//  if (GetGraph(graphName))
+//  {
+//    // insure we're computing it only once
+//    return;
+//  }
+//
+//  AliDebug(1,graphName);
+//
+//  std::vector<double> vx;
+//  std::vector<double> vxerr;
+//  std::vector<double> vy;
+//  std::vector<double> vyerr;
+//
+//  const std::set<int>& runs = RunNumbers();
+//
+//  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+//
+//  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+//  {
+//    Int_t runNumber = *it;
+//
+//    Double_t purity, purityError;
+//
+//    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+//
+//    if ( triggerClassName.Length()==0 )
+//    {
+//      AliError(Form("Unknown trigger type %d",tt));
+//      return;
+//    }
+//
+//    GetPurity(triggerClassName.Data(),runNumber,purity,purityError,"OFFLINE1");
+//
+//    vx.push_back(runNumber);
+//    vxerr.push_back(0.5);
+//    vy.push_back(purity);
+//    vyerr.push_back(purityError);
+//  }
+//
+//  TString title(Form("Fraction of events accepted by the physics selection x track selection for trigger %s",GetTriggerTypeName(tt).Data()));
+//
+//  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+//}
+//
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuFnormBeta::CreateAndAddGraph(const TString& name,
+                                                      const TString& title,
+                                                      const std::vector<double>& vx,
+                                                      const std::vector<double>& vxerr,
+                                                      const std::vector<double>& vy,
+                                                      const std::vector<double>& vyerr) const
+{
+  /// Creates a graph and adds it to our mergeable collection
+
+  TGraphErrors* g = new TGraphErrors(vx.size(),&vx[0],&vy[0],&vxerr[0],&vyerr[0]);
+  g->SetName(name.Data());
+  g->SetTitle(title.Data());
+
+  if  (fIsCompactGraphs)
+  {
+    AliAnalysisMuMuGraphUtil::Compact(*g);
+  }
+
+  g->GetXaxis()->SetNoExponent();
+//  g->GetXaxis()->SetTitle("Run number");
+
+  TPaveText* text = new TPaveText(0.70,0.70,0.89,0.89,"NDC");
+  text->SetBorderSize(0);
+  text->SetFillColor(0);
+  text->AddText(Form("Mean %e",g->GetMean(2)));
+  text->AddText(Form("RMS  %e",g->GetRMS(2)));
+  g->GetListOfFunctions()->Add(text);
+
+  MC()->Adopt("/GRAPHS/",g);
+  return g;
+}
+
+//_____________________________________________________________________________
+AliMergeableCollection* AliAnalysisMuMuFnormBeta::DetachMC()
+{
+  // let go the ownership of our mergeable collection
+  fIsOwner = kFALSE;
+  return fMergeableCollection;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::DrawWith2Scales(const char* graphName1, const char* graphName2)
+{
+  TGraphErrors* g1 = static_cast<TGraphErrors*>(GetGraph(graphName1)->Clone());
+  TGraphErrors* g2 = static_cast<TGraphErrors*>(GetGraph(graphName2)->Clone());
+
+  if ( g1 && g2 )
+  {
+    gStyle->SetOptTitle(0);
+
+    AliAnalysisMuMuGraphUtil gu;
+
+    TCanvas* c = gu.DrawWith2Scales(*g1,*g2);
+    c->Draw();
+
+    for ( Int_t i = 0; i < 2; ++i )
+    {
+      c->cd(i);
+      gPad->SetLeftMargin(0.15);
+      gPad->SetRightMargin(0.15);
+    }
+
+    c->Update();
+
+    //    TGraphErrors* g = new TGraphErrors(g1->GetN());
+    //
+    //    Double_t check(0.0);
+    //
+    //    for ( Int_t i = 0; i < g->GetN(); ++i )
+    //    {
+    //      Double_t y = g1->GetY()[i]*g2->GetY()[i];
+    //
+    //      check += g2->GetY()[i];
+    //
+    //      g->SetPoint(i,g2->GetX()[i],y);
+    //      g->SetPointError(i,g2->GetEX()[i],
+    //                       y*AliAnalysisMuMuResult::ErrorAB(g1->GetY()[i],g1->GetEY()[i],
+    //                                                        g2->GetY()[i],g2->GetEY()[i]));
+    //    }
+    //
+    //    new TCanvas;
+    //
+    //    g->Draw("ap");
+    //
+    //    AliInfo(Form("check: %e g mean %e rms %e",check,g->GetMean(2),g->GetRMS(2)));
+
+    /*
+
+    // g1 vs g2
+
+    TGraphErrors* g = new TGraphErrors(g1->GetN());
+
+    for ( Int_t i = 0; i < g->GetN(); ++i )
+    {
+      g->SetPoint(i,g2->GetY()[i],g1->GetY()[i]);
+      g->SetPointError(i,g2->GetEY()[i],g1->GetEY()[i]);
+    }
+
+    new TCanvas;
+
+    g->Draw("ap");
+
+    AliInfo(Form("g mean %e rms %e",g->GetMean(2),g->GetRMS(2)));
+
+     */
+
+  }
+
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetEventSelectionName(Int_t eventSelectionCorrected) const
+{
+  if ( eventSelectionCorrected == 1 )
+  {
+    return "PS";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    return "TS";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuFnormBeta::GetGraph(const char* name) const
+{
+  // shortcut method to give access to one graph
+
+  TObject* o = MC()->GetObject(Form("/GRAPHS/%s",name));
+
+  if (!o) return 0x0;
+
+  if ( o->IsA() != TGraphErrors::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+
+  return static_cast<TGraphErrors*>(o);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::GetPurity(const char* triggerClassName, Int_t runNumber,
+                                     Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const
+{
+  /// Get the physics selection accept fraction for a given trigger
+
+  value=error=0.0;
+
+  TString runCondition;
+
+  if (runNumber>0)
+  {
+    runCondition.Form("/run:%d",runNumber);
+  }
+
+  Double_t nall = fCounterCollection.GetSum(Form("trigger:%s/event:ALL%s",triggerClassName,runCondition.Data()));
+
+  TString ename;
+
+  if ( eventSelectionCorrected == 1 )
+  {
+    ename = "PSALL";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    ename = "OFFLINE1";
+  }
+  else
+  {
+    value = 1.0;
+    return;
+
+  }
+  Double_t nps = fCounterCollection.GetSum(Form("trigger:%s/event:%s%s",
+                                                triggerClassName,ename.Data(),runCondition.Data()));
+
+  if ( nall <= 0.0 ) return;
+
+  value = nps/nall;
+
+  error = AliAnalysisMuMuResult::ErrorAB(nall,TMath::Sqrt(nall),nps,TMath::Sqrt(nps));
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuResult* AliAnalysisMuMuFnormBeta::GetResult(const char* name) const
+{
+  // shortcut method to give access to one result
+
+  TObject* o = MC()->GetObject(Form("/RESULTS/%s",name));
+
+  if (!o) return 0x0;
+
+  if ( o->IsA() != AliAnalysisMuMuResult::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+
+  return static_cast<AliAnalysisMuMuResult*>(o);
+}
+
+//______________________________________________________________________________
+AliAnalysisMuMuResult* AliAnalysisMuMuFnormBeta::GetRunIntegratedResult(const TGraphErrors& g, const char* basename)
+{
+  /// get one value +- error for this graph (weighting the run-by-run values
+  /// by the fraction of the number of triggers in that run)
+  /// also the rms is computed.
+
+  Bool_t physicsSelectionCorrected(kFALSE);
+
+  if ( TString(g.GetName()).Contains("PS") )
+  {
+    physicsSelectionCorrected=kTRUE;
+  }
+
+  ComputeTriggerFractions(fReferenceTriggerType,physicsSelectionCorrected);
+
+  TString fname(Form("Fractions%s%s",GetTriggerTypeName(fReferenceTriggerType).Data(),physicsSelectionCorrected ? "PS" : ""));
+
+  TGraphErrors* gTriggerFractions = GetGraph(fname);
+
+  StdoutToAliDebug(2,std::cout << g.GetName() << std::endl; g.Print(););
+
+  if (!gTriggerFractions)
+  {
+    AliError(Form("Did not find graph for %s",fname.Data()));
+    return 0x0;
+  }
+
+  Double_t mean = g.GetY()[0];
+  Int_t n = g.GetN();
+
+  Double_t errorOnMean = g.GetEY()[0];
+  Double_t rms = 0.0;
+
+  if ( n > 1 )
+  {
+    mean = errorOnMean = 0.0;
+    Double_t d(0.0);
+    Double_t v1(0.0);
+    Double_t v2(0.0);
+
+    for ( Int_t i = 0; i < n; ++i )
+    {
+      Double_t y = g.GetY()[i];
+
+      Double_t weight = gTriggerFractions->GetY()[i]; // sum of weight should be 1.0
+
+      AliDebug(2,Form("%s i %3d y %e weight %e",g.GetName(),i,y,weight));
+
+      mean += y * weight;
+
+      v1 += weight;
+      v2 += weight*weight;
+    }
+
+    mean /= v1;
+
+    for ( Int_t i = 0; i < n; ++i )
+    {
+      Double_t weight = gTriggerFractions->GetY()[i]; // sum of weight should be 1.0
+      Double_t y = g.GetY()[i];
+
+      d += (y-mean)*(y-mean)*weight;
+    }
+
+    AliDebug(2,Form("v1=%e v2=%e d=%e",v1,v2,d));
+
+    if ( v1 <= 0) return 0x0;
+
+    errorOnMean = TMath::Sqrt((1.0/v1)*(1.0/(n-1))*d);
+
+    rms = TMath::Sqrt( (v1/(v1*v1-v2))*d );
+  }
+
+  AliAnalysisMuMuResult* result = new AliAnalysisMuMuResult(g.GetName(),g.GetTitle());
+
+  result->Set(basename,mean,errorOnMean,rms);
+
+  if ( TString(g.GetName()) == "FnormScalersPUPS" )
+  {
+    AliDebug(1,Form("mean %e errorOnMean %e rms %e",mean,errorOnMean,rms));
+    StdoutToAliDebug(1,result->Print("full"));
+  }
+
+  return result;
+}
+
+//_____________________________________________________________________________
+Double_t AliAnalysisMuMuFnormBeta::GetSum(const char* triggerClassName,
+                                      Int_t runNumber,
+                                      Int_t eventSelectionCorrected) const
+{
+  TString condition(Form("trigger:%s/run:%d",triggerClassName,runNumber));
+
+  if (eventSelectionCorrected==1)
+  {
+    condition += "/event:PSALL";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    condition += "/event:OFFLINE1";
+  }
+  else
+  {
+    condition += "/event:ALL";
+  }
+
+  Double_t n = fCounterCollection.GetSum(condition.Data());
+
+  if (n<=0)
+  {
+    AliError(Form("Got no count for %s for run %d (physicsSelected:%d)",triggerClassName,runNumber,eventSelectionCorrected));
+    return 0;
+  }
+
+  return n;
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetTriggerClassName(ETriggerType tt, Int_t runNumber) const
+{
+  // get the triggerclass to for a given trigger type and run number
+
+  if ( tt == kMB )
+  {
+    return MBTriggerClassName(runNumber);
+  }
+  else if ( tt == kMUL )
+  {
+    return MULTriggerClassName(runNumber);
+  }
+  else if ( tt == kMSL)
+  {
+    return MSLTriggerClassName(runNumber);
+  }
+  else if ( tt == kMSH)
+  {
+    return MSHTriggerClassName(runNumber);
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetTriggerTypeName(ETriggerType tt) const
+{
+  // get the name of the trigger type
+  if ( tt == kMB )
+  {
+    return "MB";
+  }
+  else if ( tt == kMUL )
+  {
+    return "MUL";
+  }
+  else if ( tt == kMSL)
+  {
+    return "MSL";
+  }
+  else if ( tt == kMSH)
+  {
+    return "MSH";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::GetValueAndErrorFromGraph(TGraphErrors* graph,
+                                                     Int_t runNumber,
+                                                     Double_t& value,
+                                                     Double_t& error) const
+{
+  /// get (value,error) corresponding to run=runNumber.
+  /// Works both for compact and non-compact graphs
+
+  value = TMath::Limits<Double_t>::Max();
+  error = 0.0;
+
+  if (!graph) return;
+
+  TAxis* axis = graph->GetXaxis();
+
+  for ( Int_t i = 0; i < graph->GetN(); ++i )
+  {
+    Int_t rbin = TMath::Nint(graph->GetX()[i]);
+    Int_t rlabel = TString(axis->GetBinLabel(i+1)).Atoi();
+    if ( rbin == runNumber || rlabel == runNumber )
+    {
+      value = graph->GetY()[i];
+      error = graph->GetEY()[i];
+    }
+  }
+}
+
+//_____________________________________________________________________________
+AliMergeableCollection* AliAnalysisMuMuFnormBeta::MC() const
+{
+  // get our mergeable collection
+  if (!fMergeableCollection)
+  {
+    fMergeableCollection = new AliMergeableCollection("Fnorm",Form("MB to %s trigger normalization results",GetTriggerTypeName(fReferenceTriggerType).Data()));
+  }
+  return fMergeableCollection;
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MBTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CINT7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CPBI2_B1-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CPBI2_B1-B-NOPF-ALLNOTRD";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MSHTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CMSH7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CMSH7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CMSH7-B-NOPF-MUON",runNumber) )
+  {
+    return "CMSH7-B-NOPF-MUON";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MSLTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
+  {
+      return "CMSL7-B-NOPF-MUON";
+  }
+ else
+   if ( TriggerClassnameTest("CPBI1MSL-B-NOPF-MUON",runNumber) )
+ {
+   return "CPBI1MSL-B-NOPF-MUON";
+ }
+  return "";
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::MultiplyGraphs(const char* g1name, const char* g2name, const char* name)
+{
+  /// Make a new graph = g1*g2
+  std::vector<double> vx;
+  std::vector<double> vy;
+  std::vector<double> vxerr;
+  std::vector<double> vyerr;
+
+  TGraphErrors* g1 = GetGraph(g1name);
+  TGraphErrors* g2 = GetGraph(g2name);
+
+  if (!g1)
+  {
+    AliError(Form("Could not get graph %s",g1name));
+    return;
+  }
+
+  if (!g2)
+  {
+    AliError(Form("Could not get graph %s",g2name));
+    return;
+  }
+
+  if ( g1->GetN() != g2->GetN() )
+  {
+    AliError(Form("Could not multiply incompatible graphs %d pts vs %d pts",g1->GetN(),g2->GetN()));
+    return;
+  }
+
+  for ( Int_t i = 0; i < g1->GetN(); ++i )
+  {
+    if ( g1->GetX()[i] != g2->GetX()[i] )
+    {
+      AliError(Form("Incompatible bin %d : %e vs %e",i,g1->GetX()[i],g2->GetX()[i]));
+      return;
+    }
+
+    vx.push_back(g1->GetX()[i]);
+    vxerr.push_back(g1->GetEX()[i]);
+
+    Double_t y = g1->GetY()[i]*g2->GetY()[i];
+    Double_t yerr = y*AliAnalysisMuMuResult::ErrorAB( g1->GetY()[i], g1->GetEY()[i],
+                                                     g2->GetY()[i], g2->GetEY()[i]);
+
+    vy.push_back(y);
+    vyerr.push_back(yerr);
+  }
+
+  TString gname(name);
+
+  if ( gname.Length() == 0 )
+  {
+    gname = g1->GetName();
+    gname += "x";
+    gname += g2->GetName();
+  }
+
+  TString title(Form("Product of %s by %s",g1->GetName(),g2->GetName()));
+
+  CreateAndAddGraph(gname,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MULTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CMUL7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
+  {
+    return "CMUL7-B-NOPF-MUON";
+  }
+  else if ( TriggerClassnameTest("CPBI1MUL-B-NOPF-MUON",runNumber) )
+  {
+    return "CPBI1MUL-B-NOPF-MUON";
+  }
+  return "";
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::Print(Option_t* opt) const
+{
+  if ( fMergeableCollection )
+  {
+    fMergeableCollection->Print(opt);
+  }
+}
+
+//_____________________________________________________________________________
+std::set<int> AliAnalysisMuMuFnormBeta::RunNumbers() const
+{
+  // Extract the run numbers from our counter collection
+
+  std::set<int> runset;
+
+  TString sruns = fCounterCollection.GetKeyWords("run");
+  TObjArray* runs = sruns.Tokenize(",");
+
+  TIter next(runs);
+  TObjString* s;
+
+  while ( ( s = static_cast<TObjString*>(next())) )
+  {
+    runset.insert(s->String().Atoi());
+  }
+  delete runs;
+
+  return runset;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ScalerFnorm(Double_t& value, Double_t& error,
+                                       Double_t L0bREF, Double_t purityREF, Double_t purityREFerror,
+                                       Double_t L0bMB, Double_t purityMB, Double_t purityMBerror,
+                                       Double_t pileUpFactor, Double_t pileUpFactorError)
+{
+  /// Compute the MB to REF ratio and its associated error
+
+  value = error = 0.0;
+
+  value = L0bREF*purityREF;
+
+  if (!value) return;
+
+  value = L0bMB*purityMB*pileUpFactor/value;
+
+  error = value*AliAnalysisMuMuResult::ErrorABCDE(L0bREF,TMath::Sqrt(L0bREF),
+                                                  purityREF,purityREFerror,
+                                                  L0bMB,TMath::Sqrt(L0bMB),
+                                                  purityMB,purityMBerror,
+                                                  pileUpFactor,pileUpFactorError);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ShowFnorm(const TObjArray& a) const
+{
+  /// Print and plot Fnorm values
+  TIter next(&a);
+  TGraphErrors* g;
+
+  while ( ( g = static_cast<TGraphErrors*>(next()) ) )
+  {
+    g->SetTitle(Form("Fnorm %s",g->GetTitle()));
+
+    new TCanvas(Form("c%s",g->GetName()));
+
+    if (fIsCompactGraphs)
+    {
+      AliAnalysisMuMuGraphUtil::Compact(*g);
+    }
+    else
+    {
+      g->GetXaxis()->SetNoExponent();
+    }
+    g->Draw("lpa");
+
+    Double_t y(0.0);
+    Double_t yerr(0.0);
+
+    for ( Int_t i = 0; i < g->GetN(); ++i )
+    {
+      y += g->GetY()[i];
+      Double_t e = ( y != 0.0  ? g->GetEY()[i]/y : 0.0);
+
+      yerr += e*e;
+    }
+
+    y /= (g->GetN());
+    yerr = TMath::Sqrt(yerr)*y;
+
+    AliInfo(Form("%30s graph %e +- %e (%5.2f %%) RMS %e",g->GetName(),
+                 y,yerr,yerr*100/y,g->GetRMS(2)));
+
+  }
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuFnormBeta::TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const
+{
+  /// Check if we have counts for that trigger,run combination
+
+  TString runs = fCounterCollection.GetKeyWords("run");
+
+  if ( !runs.Contains(Form("%d",runNumber)) ) return kFALSE;
+
+  TString triggers = fCounterCollection.GetKeyWords("trigger");
+
+  if (!triggers.Contains(triggerClassName)) return kFALSE;
+
+  Double_t n = fCounterCollection.GetSum(Form("trigger:%s/run:%d",triggerClassName,runNumber));
+
+  return ( n > 0.0 );
+}
+
+//_____________________________________________________________________________
+void
+AliAnalysisMuMuFnormBeta::WeightedMeanGraphs(const char* patternOrList, const char* graphName)
+{
+  /// Sum the graphs which name matches pattern
+  /// Sum is made using a weighted mean (each element is weighted by the inverse
+  /// of its error squared)
+
+  TString spattern(patternOrList);
+  TObjArray* slist(0x0);
+
+  if ( spattern.CountChar(',') )
+  {
+    // it's not a pattern but a list...
+    slist = spattern.Tokenize(",");
+    spattern = "";
+  }
+
+  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+  TIter next(objectList);
+  TObjString* str(0x0);
+  TObjArray selected;
+  selected.SetOwner(kFALSE);
+
+  while ( ( str = static_cast<TObjString*>(next()) ) )
+  {
+    TGraphErrors* g = GetGraph(str->String());
+
+    if (!g) continue;
+
+    TString name(g->GetName());
+
+    if ( spattern.Length() >0 && !name.Contains(spattern.Data()) ) continue;
+
+    if ( slist && !slist->FindObject(name)) continue;
+
+    AliDebug(2,Form("Selected for sum : %s",name.Data()));
+
+    selected.Add(g);
+  }
+
+  delete slist;
+  delete objectList;
+
+  if (selected.GetLast()<0) return;
+
+  std::vector<double> vx;
+  std::vector<double> vy;
+  std::vector<double> vxerr;
+  std::vector<double> vyerr;
+
+  Int_t npts = static_cast<TGraphErrors*>(selected.First())->GetN();
+
+  for ( Int_t ipoint = 0; ipoint < npts; ++ipoint )
+  {
+    Double_t x(0.0),xref(0.0),xerr(0.0);
+    Double_t sum(0.0);
+    Double_t sume2(0.0);
+
+    for ( Int_t igraph = 0; igraph <= selected.GetLast(); ++igraph )
+    {
+      TGraphErrors* g = static_cast<TGraphErrors*>(selected.At(igraph));
+
+      if ( g->GetN() != npts )
+      {
+        AliError(Form("Graph %s does not have the expected %d points",g->GetName(),npts));
+        continue;
+      }
+      Double_t runNumber;
+
+      if ( fIsCompactGraphs )
+      {
+        runNumber = TString(g->GetXaxis()->GetBinLabel(ipoint+1)).Atoi()*1.0;
+      }
+      else
+      {
+        runNumber = g->GetX()[ipoint];
+      }
+
+      if ( igraph == 0 )
+      {
+        xref = g->GetX()[ipoint];
+        x = runNumber;
+        xerr = g->GetEX()[ipoint];
+      }
+      else
+      {
+        if ( xref != g->GetX()[ipoint] )
+        {
+          AliError(Form("Cannot sum graphs with different axis : get %e and expected %e : %s vs %s",xref,x,selected.At(0)->GetName(),g->GetName()));
+          return;
+        }
+      }
+
+      Double_t e2 = g->GetEY()[ipoint]*g->GetEY()[ipoint];
+
+      if ( e2 != 0.0 )
+      {
+        sum += g->GetY()[ipoint]/e2;
+        sume2 += 1.0/e2;
+      }
+    }
+
+    if (sume2 != 0.0)
+    {
+      vx.push_back(x);
+      vxerr.push_back(xerr);
+      vy.push_back(sum/sume2);
+      vyerr.push_back(TMath::Sqrt(1/sume2));
+    }
+  }
+
+  Int_t n = selected.GetEntries();
+
+  TString name(graphName);
+  TString title(Form("Weighted mean from %d individual graphs",n));
+
+  if ( strlen(graphName) == 0)
+  {
+    name = TString::Format("WeightMeanFnorm%s",patternOrList);
+    name.ReplaceAll(",","_");
+    title = TString::Format("WeightMeanFnorm%s from %d individual graphs",patternOrList,n);
+  }
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
diff --git a/PWG/muondep/AliAnalysisMuMuFnormBeta.h b/PWG/muondep/AliAnalysisMuMuFnormBeta.h
new file mode 100644
index 0000000..1281bba
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuFnormBeta.h
@@ -0,0 +1,148 @@
+#ifndef ALIANALYSISMUMUFNORMBETA_H
+#define ALIANALYSISMUMUFNORMBETA_H
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+#ifndef ROOT_TObject
+#  include "TObject.h"
+#endif
+
+#ifndef ROOT_TString
+#  include "TString.h"
+#endif
+
+#include <set>
+#include <vector>
+
+class TObjArray;
+class TGraphErrors;
+class TGraph;
+class AliAnalysisMuMuResult;
+class AliCounterCollection;
+class AliMergeableCollection;
+
+class AliAnalysisMuMuFnormBeta : public TObject
+{
+
+public:
+
+  enum ETriggerType
+  {
+    kMB=1,
+    kMUL=2,
+    kMSL=3,
+    kMSH=4
+  };
+
+  AliAnalysisMuMuFnormBeta(AliCounterCollection& cc,
+                       AliAnalysisMuMuFnormBeta::ETriggerType triggerType=AliAnalysisMuMuFnormBeta::kMUL,
+                       const char* ocdbpath="raw://",
+                       Bool_t compactGraphs=kFALSE);
+
+  virtual ~AliAnalysisMuMuFnormBeta();
+
+  void ComputeFnorm();
+
+  void ComputeCorrectionFactors(Int_t eventSelectionCorrected);
+
+  void ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+
+  void ComputeFnormScalers(Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+  void ComputeGraphRelDif(const char* a, const char* b) const;
+
+  void ComputeNofEvents(ETriggerType triggerType, Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+  void ComputePileUpGraph(ETriggerType tt, Int_t eventSelectionCorrected=0);
+
+  void ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected);
+
+  void ComputeResultsFromGraphs();
+
+  void ComputeTriggerFractions(ETriggerType triggerType, Bool_t physicsSelectionCorrected);
+
+  void ComputeTriggerL0B(ETriggerType tt);
+
+  //  void ComputeTSGraph(ETriggerType tt); // Commented out in the implementation file
+
+  AliMergeableCollection* DetachMC();
+
+  void DrawWith2Scales(const char* graphName1, const char* graphName2);
+
+  TString GetEventSelectionName(Int_t eventSelectionCorrected) const;
+
+  //  void GetFnorm(Int_t runNumber, const char* eventSelection, Double_t& value, Double_t& error) const; // Not implemented
+
+  TGraphErrors* GetGraph(const char* name) const;
+
+  void GetPurity(const char* triggerClassName, Int_t runNumber, Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const;
+
+  void GetValueAndErrorFromGraph(TGraphErrors* graph,
+                                 Int_t runNumber,
+                                 Double_t& value,
+                                 Double_t& error) const;
+
+  AliAnalysisMuMuResult* GetResult(const char* name) const;
+
+  AliAnalysisMuMuResult* GetRunIntegratedResult(const TGraphErrors& g, const char* basename="Fnorm");
+
+  AliMergeableCollection* MC() const;
+
+  void MultiplyGraphs(const char* g1, const char* g2, const char* name="");
+
+  TString OCDBPath() const { return fOCDBPath; }
+
+  void Print(Option_t* opt="") const;
+
+  void ScalerFnorm(Double_t& value, Double_t& error,
+                   Double_t L0bCMUL7, Double_t purityCMUL7, Double_t purityCMUL7error,
+                   Double_t L0bCINT7, Double_t purityCINT7, Double_t purityCINT7error,
+                   Double_t pileUpFactor, Double_t pileUpFactorError);
+
+  void ShowFnorm(const TObjArray& a) const;
+
+  Bool_t TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const;
+
+  void WeightedMeanGraphs(const char* pattern, const char* name="");
+
+private:
+
+  AliAnalysisMuMuFnormBeta(const AliAnalysisMuMuFnormBeta& rhs); // not implemented on purpose
+  AliAnalysisMuMuFnormBeta& operator=(const AliAnalysisMuMuFnormBeta& rhs); // not implemented on purpose
+
+  TGraphErrors* CreateAndAddGraph(const TString& name,
+                                  const TString& title,
+                                  const std::vector<double>& vx,
+                                  const std::vector<double>& vxerr,
+                                  const std::vector<double>& vy,
+                                  const std::vector<double>& vyerr) const;
+
+  Double_t GetSum(const char* triggerClassName, Int_t runNumber, Int_t eventSelectionCorrected) const;
+
+  TString GetTriggerClassName(ETriggerType tt, Int_t runNumber) const;
+
+  TString GetTriggerTypeName(ETriggerType tt) const;
+
+  std::set<int> RunNumbers() const;
+
+  TString MBTriggerClassName(Int_t runNumber) const;
+  TString MSLTriggerClassName(Int_t runNumber) const;
+  TString MULTriggerClassName(Int_t runNumber) const;
+  TString MSHTriggerClassName(Int_t runNumber) const;
+
+private:
+
+  /*const*/ AliCounterCollection& fCounterCollection; // collection of trigger counters (not owner)
+  mutable AliMergeableCollection* fMergeableCollection; // collection of results, histograms, graphs (ownership is in fIsOwner)
+  Bool_t fIsOwner; // whether we are the owner of the mergeable collection
+  TString fOCDBPath; // OCDB to be used (raw:// by default)
+  mutable AliAnalysisMuMuResult* fResult; // combined result of the various computations
+  Bool_t fIsCompactGraphs; // whether the graph produced should be compact
+  ETriggerType fReferenceTriggerType; // reference trigger to get the weighting factors
+
+  ClassDef(AliAnalysisMuMuFnormBeta,0) // class to compute MB to MUON trigger normalization factor
+};
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx b/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
index 16b1af2..63630a7 100644
--- a/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
+++ b/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
@@ -295,21 +295,21 @@ void AliAnalysisMuMuJpsiResult::AttachFunctionsToHisto(TF1* signal, TF1* bck, TF
   if (signal)
   {
     signal->SetLineColor(1);
-    signal->SetNpx(1000);
+    signal->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(signal);
   }
 
   if ( bck )
   {
     bck->SetLineColor(2);
-    bck->SetNpx(1000);
+    bck->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(bck);
   }
 
   if ( total )
   {
     total->SetLineColor(4);
-    total->SetNpx(1000);
+    total->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(total);
   }
 
@@ -336,21 +336,21 @@ void AliAnalysisMuMuJpsiResult::AttachFunctionsToHisto(TF1* signal1, TF1* signal
   if (signal2)
   {
     signal2->SetLineColor(3);
-    signal2->SetNpx(1000);
+    signal2->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(signal2);
   }
 
   if ( bck )
   {
     bck->SetLineColor(2);
-    bck->SetNpx(1000);
+    bck->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(bck);
   }
 
   if ( total )
   {
     total->SetLineColor(4);
-    total->SetNpx(1000);
+    total->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(total);
   }
 
@@ -466,6 +466,34 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundLin(Double_t *x, Double
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2(Double_t *x, Double_t *par)
+{
+  // Linear function for Bkg 2 params
+
+  if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
+  {
+    TF1::RejectPoint();
+    return 0.;
+  }
+  else TF1::RejectPoint(kFALSE);
+  return (par[0]*x[0] + par[1] )/(par[2]*x[0]*x[0] + par[3]*x[0] + par[4]) ;
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3(Double_t *x, Double_t *par)
+{
+  // Linear function for Bkg 2 params
+
+  if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
+  {
+    TF1::RejectPoint();
+    return 0.;
+  }
+  else TF1::RejectPoint(kFALSE);
+  return (  par[0]*x[0]*x[0] + x[0]*par[1] + par[2]  )/( par[3]*x[0]*x[0]*x[0]+ par[4]*x[0]*x[0] + par[5]*x[0] + par[6]) ;
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2(Double_t *x, Double_t *par)
 {
   // pol2 3 params
@@ -544,11 +572,27 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG(Double_t *x, Double
     TF1::RejectPoint();
     return 0.;
   }
+  else TF1::RejectPoint(kFALSE);
   Double_t sigma = par[2]+par[3]*((x[0]-par[1])/par[1]);
   return par[0]*TMath::Exp(-(x[0]-par[1])*(x[0]-par[1])/(2.*sigma*sigma));
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2(Double_t *x, Double_t *par)
+{
+  // gaussian variable width : 5 params
+
+  if (fRejectFitPoints && x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
+  {
+    TF1::RejectPoint();
+    return 0.;
+  }
+  else TF1::RejectPoint(kFALSE);
+  Double_t sigma = par[2] + par[3]*((x[0]-par[1])/par[1]) + par[4]*((x[0]-par[1])/par[1])*((x[0]-par[1])/par[1]);
+  return par[0]*TMath::Exp(-(x[0]-par[1])*(x[0]-par[1])/(2.*sigma*sigma));
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended(Double_t *x,Double_t *par)
 {
   // Extended Crystal Ball : 7 parameters
@@ -644,6 +688,54 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG(Double_t *x, D
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol1Pol2(Double_t *x, Double_t *par)
+{
+  /// 2 NA60 (new) + pol2 x exp
+  /// width of the second NA60 related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[11] = {
+    par[16],
+    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+    par[7]*SPsiPFactor, // /3.096916*3.68609
+    par[8],
+    par[9],
+    par[10],
+    par[11],
+    par[12],
+    par[13],
+    par[14],
+    par[15],
+  };
+  return FitFunctionBackgroundPol1Pol2(x, par) + FitFunctionNA60New(x, &par[5]) + FitFunctionNA60New(x, par2);
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol2Pol3(Double_t *x, Double_t *par)
+{
+  /// 2 NA60 (new) + pol2 x exp
+  /// width of the second NA60 related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[11] = {
+    par[18],
+    3.68609+(par[8]-3.096916)/3.096916*3.68609,
+    par[9]*SPsiPFactor, // /3.096916*3.68609
+    par[10],
+    par[11],
+    par[12],
+    par[13],
+    par[14],
+    par[15],
+    par[16],
+    par[17],
+  };
+  return FitFunctionBackgroundPol2Pol3(x, par) + FitFunctionNA60New(x, &par[7]) + FitFunctionNA60New(x, par2);
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol2Exp(Double_t *x, Double_t *par)
 {
   /// 2 NA60 (new) + pol2 x exp
@@ -713,6 +805,46 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Lin(Double_t *x, Doubl
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol1Pol2(Double_t *x, Double_t *par)
+{
+  /// 2 extended crystal balls + Pol1
+  /// width of the second CB related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[7] = {
+    par[12],
+    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+    par[7]*SPsiPFactor, // /3.096916*3.68609,
+    par[8],
+    par[9],
+    par[10],
+    par[11]
+  };
+  return FitFunctionBackgroundPol1Pol2(x, par)   + FitFunctionSignalCrystalBallExtended(x, &par[5]) + FitFunctionSignalCrystalBallExtended(x, par2);
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Pol3(Double_t *x, Double_t *par)
+{
+  /// 2 extended crystal balls + Pol1
+  /// width of the second CB related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[7] = {
+    par[14],
+    3.68609+(par[8]-3.096916)/3.096916*3.68609,
+    par[9]*SPsiPFactor, // /3.096916*3.68609,
+    par[10],
+    par[11],
+    par[12],
+    par[13]
+  };
+  return FitFunctionBackgroundPol2Pol3(x, par)   + FitFunctionSignalCrystalBallExtended(x, &par[7]) + FitFunctionSignalCrystalBallExtended(x, par2);
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp(Double_t *x, Double_t *par)
 {
   /// 2 extended crystal balls + pol2 x exp
@@ -809,6 +941,26 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG(Double_t *x, Doubl
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG2(Double_t *x, Double_t *par)
+{
+  /// 2 extended crystal balls + VWG2
+  /// width of the second CB related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[7] = {
+    par[12],
+    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+    par[7]*SPsiPFactor, // /3.096916*3.68609,
+    par[8],
+    par[9],
+    par[10],
+    par[11]
+  };
+  return FitFunctionBackgroundVWG2(x, par) + FitFunctionSignalCrystalBallExtended(x, &par[5]) + FitFunctionSignalCrystalBallExtended(x, par2);
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWGINDEPTAILS(Double_t *x, Double_t *par)
 {
   /// 2 extended crystal balls + pol2 x exp
@@ -1232,14 +1384,14 @@ void AliAnalysisMuMuJpsiResult::FitPSICB2()
     fitTotal->SetParameter(1, 3.1);
     fitTotal->SetParLimits(1, 3.08, 3.2);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else if (particleName.Contains("PsiP"))
   {
     fitTotal->SetParameter(1, 3.7);
     fitTotal->SetParLimits(1, 3.63, 3.72);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else AliError(Form("Could not set initial fit parameters for particle %s: The fit might not converge",particleName.Data()));
 
@@ -1253,7 +1405,7 @@ void AliAnalysisMuMuJpsiResult::FitPSICB2()
 //  fitTotal->FixParameter(5, alphaUp);
 //  fitTotal->FixParameter(6, nUp);
 
-  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERI","");
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERIL","");
 
   // Check parameters...
   if (
@@ -1266,7 +1418,7 @@ void AliAnalysisMuMuJpsiResult::FitPSICB2()
       )
   {
     // try again...
-    fitResult = fHisto->Fit(fitTotal,"SERI","");
+    fitResult = fHisto->Fit(fitTotal,"SERIL","");
   }
 
   TF1* signal = new TF1("signal",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","SignalCB2");
@@ -1312,6 +1464,9 @@ void AliAnalysisMuMuJpsiResult::FitPSICB2()
   Set(Form("Nof%sTailL",particleName.Data()),njpsiTailL,nerrTailL);
   Set(Form("Nof%sTailR",particleName.Data()),njpsiTailR,nerrTailR);
 
+  // new TCanvas;
+  // fHisto->DrawCopy();
+
 }
 
 //_____________________________________________________________________________
@@ -1381,14 +1536,14 @@ void AliAnalysisMuMuJpsiResult::FitPSINA60NEW()
     fitTotal->SetParameter(1, 3.1);
     fitTotal->SetParLimits(1, 3.08, 3.2);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else if (particleName.Contains("PsiP"))
   {
     fitTotal->SetParameter(1, 3.7);
     fitTotal->SetParLimits(1, 3.63, 3.72);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else AliError(Form("Could not set initial fit parameters for particle %s: The fit might not converge",particleName.Data()));
 
@@ -1422,7 +1577,7 @@ void AliAnalysisMuMuJpsiResult::FitPSINA60NEW()
 //  SetParameter(fitTotal,9,alphaLeft,1.,-1.E8,1.E5);
 //  SetParameter(fitTotal,10,alphaRight,1.0,-1.E5,1.E5);
 
-  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERI","");
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERIL","");
 
   // Check parameters...
 //  if (
@@ -1469,6 +1624,310 @@ void AliAnalysisMuMuJpsiResult::FitPSINA60NEW()
   Set(Form("Nof%s",particleName.Data()),njpsi,nerr);
 }
 
+// //_____________________________________________________________________________
+// void AliAnalysisMuMuJpsiResult::FitPSICB2VWG()
+// {
+//     /// Fit using 1 extended crystal ball (signal) + variable width gaussian (background)
+//     //Refresh
+//     fHisto->GetListOfFunctions()->Delete();
+//     //Check if values given in MuMuConfig
+//     Double_t alphaLow = GetValue("alJPsi");
+//     Double_t nLow = GetValue("nlJPsi");
+//     Double_t alphaUp = GetValue("auJPsi");
+//     Double_t nUp = GetValue("nuJPsi");
+//     Double_t fitRangeLow = GetValue(kFitRangeLow);
+//     Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+//     TString msg;
+//     //Output Message
+//     if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+//     if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+//     if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+//     if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+
+//     AliDebug(1,Form("Fit with jpsi VWG %s",msg.Data()));
+
+//     //  std::cout << "Tails parameters: " << msg.Data() << std::endl;
+//     //Create pointer and configure signal+bck fit functions
+//     TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalOneCB2VWG,fitRangeLow,fitRangeHigh,11,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
+
+//     fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
+//     //                        0      1       2       3       4      5      6
+//                           "alJPsi","nlJPsi","auJPsi","nuJPsi");
+//     //                         7        8        9        10
+
+
+//     // Create pointer for bck function
+//     TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+//     const char* fitOption = "SERL"; //We can add NO to avoid plotting
+
+// //#if 0
+// //    bck->SetParameter(0,fHisto->GetMaximum());
+// //    bck->SetParameter(1,3);
+// //    bck->SetParameter(2,10);
+// //    bck->SetParameter(3,10);
+// //
+// //    bck->SetParLimits(1, 0., 100.);
+// //    bck->SetParLimits(2, 0., 100.);
+// //    bck->SetParLimits(3, 0., 100.);
+// //
+// //    SetFitRejectRange(2.7,3.5);
+// //
+// //    fHisto->Fit(bck,fitOption,"");
+// //
+// //    for ( Int_t i = 0; i < 4; ++i )
+// //        {
+// //        Double_t a,b;
+// //        bck->GetParLimits(i,a,b);
+// //        fitTotal->SetParameter(i,bck->GetParameter(i));
+// //        fitTotal->SetParLimits(i,a,b);
+// //        }
+// //#endif
+//     // Create pointer for bck fitting
+//     TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+//     // To set first parameter
+//     Int_t bin = fHisto->FindBin(0.26);
+//     // Setting parameters
+//     bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//     // Reject region ot J/Psi
+//     SetFitRejectRange(2.7,4.0);
+//     // Store fit results in a TFitResult
+//     TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
+//     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+//     // if success a new fit is proceed
+//     if ( static_cast<int>(fitResultInit) )
+//         {
+//         bin = fHisto->FindBin(0.82);
+//         bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//         fitResultInit = fHisto->Fit(bckInit,"SRL");
+//         }
+//     else if ( bckInit->GetParameter(0) < 0 )
+//         {
+//         bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//         }
+//     // ??
+//     SetFitRejectRange();
+//     // Set bck paramaters from precedent fit to fitTotal
+//     for ( Int_t i = 0; i < 4; ++i )
+//         {
+//         fitTotal->SetParameter(i, bckInit->GetParameter(i));
+//         }
+
+//     // Set J/Psi parameters to FitTotal
+//     bin = fHisto->FindBin(3.09);
+//     fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm
+
+//     fitTotal->SetParameter(5, 3.1); // mean
+//     fitTotal->SetParLimits(5, 3.0, 3.2);
+
+//     fitTotal->SetParameter(6, 0.08); // sigma
+//     fitTotal->SetParLimits(6, 0.05, 0.09);
+//     // Set parameters from MuMuConfig if present
+//     if ( IsValidValue(alphaLow) )
+//         {
+//         fitTotal->FixParameter(7, alphaLow);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(7,0.9);
+//         fitTotal->SetParLimits(7,0.1,10.0);
+//         }
+
+//     if ( IsValidValue(nLow) )
+//         {
+//         fitTotal->FixParameter(8, nLow);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(8,5.0);
+//         fitTotal->SetParLimits(8,0.0,10.0);
+//         }
+
+//     if ( IsValidValue(alphaUp) )
+//         {
+//         fitTotal->FixParameter(9, alphaUp);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(9, 2.0);
+//         fitTotal->SetParLimits(9,0.1,10.0);
+//         }
+
+//     if ( IsValidValue(nUp) )
+//         {
+//         fitTotal->FixParameter(10, nUp);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(10,3.0);
+//         fitTotal->SetParLimits(10,0.0,10.0);
+//         }
+
+
+//     SetFitRejectRange();
+
+//     //  std::cout << fitTotal->GetParameter(0) << std::endl; //Just a xcheck
+
+//     TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+//     //  std::cout << fitTotal->GetParameter(0) << " ?= " << fitResult->Parameter(0) << std::endl; //Just a xcheck
+//     // Output message
+//     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+//     //  std::cout << fitTotal->GetParameter(0) << std::endl; //Just a xcheck
+//     // Refit in case of error on kVWG to high
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
+//             {
+//             std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+
+//             fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+//             }
+
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Refit in case of KkVWG to low
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         std::cout << "//-------Refitting again (setting kVWG=kVWG*2)" << std::endl;
+
+//         fitTotal->SetParameter(0, fHisto->GetMaximum()*2.); // kVWG
+
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Idem
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+
+//         fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Set parameters to fit Total and fit with it
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         for ( Int_t i = 0; i < 4; ++i )
+//             {
+//             fitTotal->SetParameter(i, bckInit->GetParameter(i));
+//             }
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+//         if ( static_cast<int>(fitResult) ) std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+//         }
+
+//     delete bckInit;
+//     // Set things ...
+//     Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+//     Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+//     Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+//     Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+//     // Create JPsi function and set parameters
+//     TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+//     signalJPsi->SetParameters(fitTotal->GetParameter(4),
+//                               fitTotal->GetParameter(5),
+//                               fitTotal->GetParameter(6),
+//                               fitTotal->GetParameter(7),
+//                               fitTotal->GetParameter(8),
+//                               fitTotal->GetParameter(9),
+//                               fitTotal->GetParameter(10));
+//     // Set bck parameter
+//     bck->SetParameters(fitTotal->GetParameter(0),
+//                        fitTotal->GetParameter(1),
+//                        fitTotal->GetParameter(2),
+//                        fitTotal->GetParameter(3));
+
+//     // Set value + error for each parameters
+//     Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+//     Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+//     Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+//     Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+//     Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+
+//     Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+//     Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+//     Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+//     Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+
+//     SetFitRejectRange();
+
+//     AttachFunctionsToHisto(signalJPsi,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+//     Double_t cbParameters[7];
+//     Double_t covarianceMatrix[7][7];
+
+//     for ( int ix = 0; ix < 7; ++ix )
+//         {
+//         cbParameters[ix] = fitTotal->GetParameter(ix+4);
+//         }
+
+//     for ( int iy = 0; iy < 7; ++iy )
+//         {
+//         for ( int ix = 0; ix < 7; ++ix )
+//             {
+//             covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+//             }
+//         }
+
+//     Double_t a = fHisto->GetXaxis()->GetXmin();
+//     Double_t b = fHisto->GetXaxis()->GetXmax();
+//     double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+//     double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+//     Set("NofJPsi",njpsi,nerr);
+
+//     double m = GetValue("mJPsi");
+//     double s = GetValue("sJPsi");
+//     double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+//     double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+//     Set("NofJPsi3s",njpsi3s,nerr3s);
+
+//     //Computation of bin significance and signal over background
+
+//     Double_t bkgParameters[4];
+//     Double_t bkgcovarianceMatrix[4][4];
+
+//     for ( int ix = 0; ix < 4; ++ix )
+//         {
+//         bkgParameters[ix] = fitTotal->GetParameter(ix);
+//         }
+
+//     for ( int iy = 0; iy < 4; ++iy )
+//         {
+//         for ( int ix = 0; ix < 4; ++ix )
+//             {
+//             bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+//             }
+//         }
+
+//     double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+//     double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+//     double sOverB3s = njpsi3s / nbck3s;
+//     double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+//     Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+//     double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+//     double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+//                                 TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+//     Set("Significance3s",sig,sigErr);
+
+// }
+
+
+
 //_____________________________________________________________________________
 void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 {
@@ -1476,6 +1935,10 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 
   fHisto->GetListOfFunctions()->Delete();
 
+  const char* fitOption = "SERL"; //We can add NO to avoid plotting
+  const char* fitOptionBg = "SRL"; //We can add NO to avoid plotting
+
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
@@ -1509,8 +1972,6 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
 
-  const char* fitOption = "SER"; //We can add NO to avoid plotting
-
   //___________
 
 #if 0
@@ -1551,21 +2012,21 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 
 
   //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.8,10.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
 
   Int_t bin = fHisto->FindBin(0.26);
 
   bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
 //  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
 
-  SetFitRejectRange(2.7,4.0);
+  SetFitRejectRange(2.6,3.4);
 
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
 
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG",fitOptionBg);
   //___________
 
   SetFitRejectRange();
@@ -1582,10 +2043,10 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
   fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm
 
   fitTotal->SetParameter(5, 3.15); // mean
-  fitTotal->SetParLimits(5, 2.95, 3.25);
+  fitTotal->SetParLimits(5, 2.95, 3.2);
 
   fitTotal->SetParameter(6, 0.08); // sigma
-  fitTotal->SetParLimits(6, 0.05, 0.09);
+  fitTotal->SetParLimits(6, 0.03, 0.2);
 
   if ( IsValidValue(alphaLow) )
   {
@@ -1629,7 +2090,7 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 
   bin = fHisto->FindBin(3.68);
   fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+  fitTotal->SetParLimits(11, 0.,fHisto->GetBinContent(bin));
   //______________
 
 
@@ -1765,26 +2226,23 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWGINDEPTAILS()
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG2()
 {
-  /// Fit using 2 extended crystal balls with independent tails (signal) + variable width gaussian (background)
-  // Was used as a test of the Psi' tails effect, since it was negligible is not used anymore
+  /// Fit using 2 extended crystal balls (signal) + variable width gaussian (background)
 
   fHisto->GetListOfFunctions()->Delete();
 
+  const char* fitOption = "SERL"; //We can add NO to avoid plotting
+  const char* fitOptionBg = "SRL"; //We can add NO to avoid plotting
+
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
   Double_t alphaLow     = GetValue("alJPsi");
   Double_t nLow         = GetValue("nlJPsi");
   Double_t alphaUp      = GetValue("auJPsi");
   Double_t nUp          = GetValue("nuJPsi");
-  
-  Double_t alphaLowP = GetValue("alPsiP");
-  Double_t nLowP = GetValue("nlPsiP");
-  Double_t alphaUpP = GetValue("auPsiP");
-  Double_t nUpP = GetValue("nuPsiP");
-  
   Double_t fitRangeLow  = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
   Double_t paramSPsiP   = GetValue("FSigmaPsiP");
 
   TString msg;
@@ -1793,295 +2251,165 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWGINDEPTAILS()
   if (IsValidValue(nLow)) msg     += TString::Format("nLow=%e ",nLow);
   if (IsValidValue(alphaUp)) msg  += TString::Format("alphaUp=%e ",alphaUp);
   if (IsValidValue(nUp)) msg      += TString::Format("nUp=%e ",nUp);
+  //__________
 
-  if (IsValidValue(alphaLowP)) msg += TString::Format("alphaLowP=%e ",alphaLowP);
-  if (IsValidValue(nLowP)) msg += TString::Format("nLowP=%e ",nLowP);
-  if (IsValidValue(alphaUpP)) msg += TString::Format("alphaUpP=%e ",alphaUpP);
-  if (IsValidValue(nUpP)) msg += TString::Format("nUpP=%e ",nUpP);
 
   AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
 
-  // Add fit with indep tails
 
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWGINDEPTAILS,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWGINDEPTAILS");
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG2,fitRangeLow,fitRangeHigh,13,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG2");
 
-  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
-  //                        0      1       2       3       4      5      6
-                        "alJPsi","nlJPsi","auJPsi","nuJPsi");
-  //                       7        8        9        10
-//  fitTotal->SetParName(11, "kPsiP");
-//  //                            11
-//  fitTotal->SetParName(12, "mPsiP");
-//  //                            12
-//  fitTotal->SetParName(13, "sPsiP");
-//  //                            13
-//  fitTotal->SetParName(14, "alPsiP");
-//  //                            14
-//  fitTotal->SetParName(15, "nlPsiP");
-//  //                            15
-//  fitTotal->SetParName(16, "auPsiP");
-//  //                            16
-//  fitTotal->SetParName(17, "nuPsiP");
-//  //                            17
-  
-  fitTotal->SetParName(11, "kPsiP");
+  fitTotal->SetParNames("kVWG2","mVWG2","s1VWG2","s2VWG2","gVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi");
+//                        0        1       2        3        4      5      6        7       8           9       10
+  fitTotal->SetParName(11, "nuJPsi");
 //                            11
-   fitTotal->SetParName(12, "alPsiP");
+  fitTotal->SetParName(12, "kPsiP");
 //                            12
-  fitTotal->SetParName(13, "nlPsiP");
-  //                            13
-  fitTotal->SetParName(14, "auPsiP");
-  //                            14
-  fitTotal->SetParName(15, "nuPsiP");
-  //                            15
-  
-  
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
-  
-  const char* fitOption = "SERI";
-  
-#if 0
-  bck->SetParameter(0,fHisto->GetMaximum());
-  bck->SetParameter(1,3);
-  bck->SetParameter(2,10);
-  bck->SetParameter(3,10);
 
-  bck->SetParLimits(1, 0., 100.);
-  bck->SetParLimits(2, 0., 100.);
-  bck->SetParLimits(3, 0., 100.);
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG2");
+  //___________
 
-  SetFitRejectRange(2.7,3.5);
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2,1.8,10.,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG2");
 
-  fHisto->Fit(bck,fitOption,"");
+  Int_t bin = fHisto->FindBin(0.26);
 
-  for ( Int_t i = 0; i < 4; ++i )
-  {
-    Double_t a,b;
-    bck->GetParLimits(i,a,b);
-    fitTotal->SetParameter(i,bck->GetParameter(i));
-    fitTotal->SetParLimits(i,a,b);
-  }
-#endif
+  bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
 
-  Int_t bin = fHisto->FindBin(fitRangeLow);
-  fitTotal->SetParameter(0, fHisto->GetBinContent(bin)); // kVWG
-  fitTotal->SetParameter(1, 1.9); // mVWG
+  SetFitRejectRange(2.6,3.4);
 
-  fitTotal->SetParameter(2, 0.5); // sVWG1
-  fitTotal->SetParLimits(2, 0., 100.);
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
 
-  fitTotal->SetParameter(3, 0.3); // sVWG2
-  fitTotal->SetParLimits(3, 0., 100.);
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
-  bin = fHisto->FindBin(3.09);
-  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG2",fitOptionBg);
+  //___________
 
-  fitTotal->SetParameter(5, 3.1); // mean
-  fitTotal->SetParLimits(5, 3.0, 3.2);
+  SetFitRejectRange();
+  //____________
   
-  fitTotal->SetParameter(6, 0.08); // sigma
-  fitTotal->SetParLimits(6, 0.03, 0.15);
 
-  if ( IsValidValue(alphaLow) )
-  {
-    fitTotal->FixParameter(7, alphaLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(7,0.9);
-    fitTotal->SetParLimits(7,0.1,10.0);
-  }
+  //  new TCanvas;
+  // fHisto->DrawCopy();
+  // return;
   
-  if ( IsValidValue(nLow) )
-  {
-    fitTotal->FixParameter(8, nLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(8,5.0);
-    fitTotal->SetParLimits(8,0.0,10.0);
-  }
 
-  if ( IsValidValue(alphaUp) )
-  {
-    fitTotal->FixParameter(9, alphaUp);
-  }
-  else
-  {
-    fitTotal->SetParameter(9, 2.0);
-    fitTotal->SetParLimits(9,0.1,10.0);
-  }
 
-  if ( IsValidValue(nUp) )
-  {
-    fitTotal->FixParameter(10, nUp);
-  }
-  else
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 5; ++i )
   {
-    fitTotal->SetParameter(10,3.0);
-    fitTotal->SetParLimits(10,0.0,10.0);
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
   }
 
-  bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
-  
-//  fitTotal->SetParameter(12, 3.7); // mean PsiP
-//  fitTotal->SetParLimits(12, 3.6, 3.71);
-//  
-//  fitTotal->SetParameter(13, 0.08/3.096916*3.68609); // sigma PsiP
-//  fitTotal->SetParLimits(13, 0.03/3.096916*3.68609, 0.15/3.096916*3.68609);
-  
-  if ( IsValidValue(alphaLowP) )
-  {
-    fitTotal->FixParameter(12, alphaLowP);
-  }
-  else
-  {
-    fitTotal->SetParameter(12,0.9);
-    fitTotal->SetParLimits(12,0.1,10.0);
-  }
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(5, fHisto->GetBinContent(bin)); // norm
 
-  if ( IsValidValue(nLowP) )
-  {
-    fitTotal->FixParameter(13, nLowP);
-  }
-  else
-  {
-    fitTotal->SetParameter(13,5.0);
-    fitTotal->SetParLimits(13,0.0,10.0);
-  }
+  fitTotal->SetParameter(6, 3.15); // mean
+  fitTotal->SetParLimits(6, 2.95, 3.2);
   
-  if ( IsValidValue(alphaUpP) )
-  {
-    fitTotal->FixParameter(14, alphaUpP);
-  }
-  else
-  {
-    fitTotal->SetParameter(14, 2.0);
-    fitTotal->SetParLimits(14,0.1,10.0);
-  }
+  fitTotal->SetParameter(7, 0.08); // sigma
+  fitTotal->SetParLimits(7, 0.03, 0.2);
 
-  if ( IsValidValue(nUpP) )
-  {
-    fitTotal->FixParameter(15, nUpP);
-  }
-  else
-  {
-    fitTotal->SetParameter(15,3.0);
-    fitTotal->SetParLimits(15,0.0,10.0);
+  if ( IsValidValue(alphaLow) ) {
+    fitTotal->FixParameter(8, alphaLow);
+  } else {
+    fitTotal->SetParameter(8,0.9);
+    fitTotal->SetParLimits(8,0.1,10.0);
   }
 
-  //  SetFitRejectRange();
-  
-  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
-  
-  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
-  
-  if ( static_cast<int>(fitResult) )
-  {
-    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
-    {
-      std::cout << "//-------Refitting again (setting Psi'norm= Psi'norm/2)" << std::endl;
-      
-      fitTotal->SetParameter(11, fHisto->GetBinContent(bin)/2.);
+  if ( IsValidValue(nLow) ) {
+    fitTotal->FixParameter(9, nLow);
+  } else {
+    fitTotal->SetParameter(9,5.0);
+    fitTotal->SetParLimits(9,0.0,10.0);
   }
 
-    if ( fitTotal->GetParameter(0) <= fitTotal->GetParError(0) ) //kVWG
-    {
-      std::cout << "//-------Refitting again (setting VWG norm= VWG norm /2)" << std::endl;
-      bin = fHisto->FindBin(fitRangeLow);
-      
-      fitTotal->SetParameter(0, fHisto->GetBinContent(bin)/2.);
+  if ( IsValidValue(alphaUp) ) {
+    fitTotal->FixParameter(10, alphaUp);
+  } else {
+    fitTotal->SetParameter(10, 2.0);
+    fitTotal->SetParLimits(10,0.1,10.0);
   }
 
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
-    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  if ( IsValidValue(nUp) ) {
+    fitTotal->FixParameter(11, nUp);
+  } else {
+    fitTotal->SetParameter(11,3.0);
+    fitTotal->SetParLimits(11,0.0,10.0);
   }
 
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(12, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(12, 0.,fHisto->GetBinContent(bin));
+  //______________
 
-  if ( static_cast<int>(fitResult) )
-  {
-    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
-    {
-      std::cout << "//-------Refitting again (setting Psi'norm=0)" << std::endl;
 
-      fitTotal->FixParameter(11, 0.);
-    }
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
 
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
-  }
-  
-  if ( static_cast<int>(fitResult) )
-  {
-    std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
-    
-    fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
 
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
-    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
-  }
 
-  if ( static_cast<int>(fitResult) )
-  {
-    std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
-  }
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,12,4);
+  if ( static_cast<int>(fitResult->CovMatrixStatus())!=3.) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,12,4);
+  //___________
 
+  delete bckInit; //Delete the initial background funtion
 
+  //___________Set parameters and fit functions to store in the result
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
 
-  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  
-  Set("mPsiP",3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,fitTotal->GetParError(5)/3.096916*3.68609);
-  Set("sPsiP",fitTotal->GetParameter(6)*paramSPsiP,fitTotal->GetParError(6)*paramSPsiP);
+  Set("mJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("sJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
 
   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalJPsi->SetParameters(fitTotal->GetParameter(4),
-                        fitTotal->GetParameter(5),
+  signalJPsi->SetParameters(fitTotal->GetParameter(5),
                      fitTotal->GetParameter(6),
                      fitTotal->GetParameter(7),
                      fitTotal->GetParameter(8),
                      fitTotal->GetParameter(9),
-                        fitTotal->GetParameter(10));
+                     fitTotal->GetParameter(10),
+                     fitTotal->GetParameter(11));
 
   TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalPsiP->SetParameters(fitTotal->GetParameter(11),
-                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
-                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
-                            fitTotal->GetParameter(12),
-                            fitTotal->GetParameter(13),
-                            fitTotal->GetParameter(14),
-                            fitTotal->GetParameter(15));
+  signalPsiP->SetParameters(fitTotal->GetParameter(12),
+                        3.68609+(fitTotal->GetParameter(6)-3.096916)/3.096916*3.68609,
+                        fitTotal->GetParameter(7)*paramSPsiP, // /3.096916*3.68609,
+                        fitTotal->GetParameter(8),
+                        fitTotal->GetParameter(9),
+                        fitTotal->GetParameter(10),
+                        fitTotal->GetParameter(11));
 
   bck->SetParameters(fitTotal->GetParameter(0),
                      fitTotal->GetParameter(1),
                      fitTotal->GetParameter(2),
-                     fitTotal->GetParameter(3));
+                     fitTotal->GetParameter(3),
+                     fitTotal->GetParameter(4));
 
 
-  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
-  
-  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("kVWG2",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("mVWG2",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("s1VWG2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("s2VWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("gVWG2",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("kJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
 
-  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
-  Set("alPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
-  Set("nlPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
-  Set("auPsiP",fitTotal->GetParameter(14),fitTotal->GetParError(14));
-  Set("nuPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+  Set("alJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("nlJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("auJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("nuJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
 
+  Set("kPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
 
 
-//  SetFitRejectRange();
+  SetFitRejectRange();
 
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
 
@@ -2091,14 +2419,14 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWGINDEPTAILS()
 
   for ( int ix = 0; ix < 7; ++ix )
   {
-    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+    cbParameters[ix] = fitTotal->GetParameter(ix+5);
   }
 
   for ( int iy = 0; iy < 7; ++iy )
   {
     for ( int ix = 0; ix < 7; ++ix )
     {
-      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+5,iy+5);
     }
   }
 
@@ -2115,24 +2443,61 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWGINDEPTAILS()
   double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
 
   Set("NofJPsi3s",njpsi3s,nerr3s);
-}
+  //_____________________________
 
-//_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2EXP()
-{
-  /// Fit using 2 extended crystal balls (signal) + pol2 x exp (background)
-  /// 13 parameters
 
-  fHisto->GetListOfFunctions()->Delete();
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[5];
+  Double_t bkgcovarianceMatrix[5][5];
 
-  //__________ Get tails parameters, fitting range and SigmaPsiP
-  Double_t alphaLow = GetValue("alJPsi");
+  for ( int ix = 0; ix < 5; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 5; ++iy )
+  {
+    for ( int ix = 0; ix < 5; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________________________
+  
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL1POL2()
+{
+  /// Fit using 2 extended crystal balls (signal) + variable width gaussian (background)
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  const char* fitOption = "SERL";
+  const char* fitOptionBg = "SER";
+
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
   Double_t paramSPsiP = GetValue("FSigmaPsiP");
 
   TString msg;
@@ -2143,102 +2508,1593 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2EXP()
   if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
   //__________
 
-  AliDebug(1,Form("Fit with jpsi + psiprime Pol2 x Exp %s",msg.Data()));
+
+  AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
+
 
   //__________ Define the function to fit the spectrum, and the background just for plotting
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp,fitRangeLow,fitRangeHigh,12,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol2Exp");
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol1Pol2,fitRangeLow,fitRangeHigh,13,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol1Pol2");
 
-  fitTotal->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","alJPsi",
+  fitTotal->SetParNames("a","b","a'","b'","c'","kJPsi","mJPsi","sJPsi",
 //                        0  1   2    3    4      5      6       7
-                        "nlJPsi","auJPsi","nuJPsi");
+                        "alJPsi","nlJPsi","auJPsi");
 //                         8        9        10
-  fitTotal->SetParName(11,"kPsiP");
+  fitTotal->SetParName(11, "nuJPsi");
   //                          11
+  fitTotal->SetParName(12, "kPsiP");
+//                            12
 
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  //__________
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
+
+  //___________
 
 
   //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,1.7,6.,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
 
-  Int_t bin = fHisto->FindBin(0.26);
+  Int_t bin = fHisto->FindBin(0.70);
+  // Int_t bin = fHisto->FindBin(1.2); // just after a low mass pick
+  // Int_t bin = fHisto->FindBin(0.40);
 
-  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin)/3.,100.,0.05);//fHisto->GetBinContent(bin)
+  bckInit->SetParameters(0.,bin,0.,1.,1.);
+  bckInit->SetParLimits(0,-200,50);
+  bckInit->SetParLimits(2,-50,2000);
+  bckInit->SetParLimits(3,-300,100);
+  bckInit->FixParameter(4, 1.);
+//  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
 
-  SetFitRejectRange(2.7,4.0);
+  SetFitRejectRange(2.6,3.4);
 
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
 
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol1Pol2",fitOptionBg);
   //___________
 
+  int j =0.;
+  //___________ Further attempts to fit if the second one fails
+  if(!CheckRoots(bckInit,2,bckInit->GetParameter(2),bckInit->GetParameter(3),bckInit->GetParameter(4),0.))
+  {
+    std::cout << "" <<  std::endl;
+    std::cout << "removing poles attempt "<< j+1 <<"..." <<  std::endl;
+    std::cout << "" <<  std::endl;
+
+    fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
+    std::cout << "FitResult=" << static_cast<int>(fitResultInit) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResultInit->CovMatrixStatus() << std::endl;
+
+    if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol1Pol2",fitOptionBg);
+
+    // //___________
+    // if(j==2)break;
+    // j++;
+  }
+
   SetFitRejectRange();
   //____________
 
 
   //__________ Set initial parameters in fitting function
-  for ( Int_t i = 0; i < 4; ++i )
+  for ( Int_t i = 0; i < 5; ++i )
   {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    if(i > 1 && static_cast<Double_t>(fitTotal->GetParError(i))) fitTotal->SetParLimits(i,bckInit->GetParameter(i)-fitTotal->GetParError(i),bckInit->GetParameter(i)+fitTotal->GetParError(i));
+    else if( i > 1 ) fitTotal->SetParLimits(i,bckInit->GetParameter(i)- 0.1*bckInit->GetParameter(i),bckInit->GetParameter(i)+0.1*bckInit->GetParameter(i));
+    if(i==4)fitTotal->FixParameter(i, 1.);
   }
+  // fitTotal->SetParLimits(0,-200,50);
+  // fitTotal->SetParLimits(2,-50,2000);
+  // fitTotal->SetParLimits(3,-300,100);
 
   bin = fHisto->FindBin(3.09);
-  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
+  fitTotal->SetParameter(5, fHisto->GetBinContent(bin)); // norm
 
-  fitTotal->SetParameter(5, 3.1);
-  fitTotal->SetParLimits(5, 3.07, 3.2);
-  fitTotal->SetParameter(6, 0.08);
-  fitTotal->SetParLimits(6, 0.05, 0.15);
+  fitTotal->SetParameter(6, 3.15); // mean
+  fitTotal->SetParLimits(6, 2.95, 3.2);
+
+  fitTotal->SetParameter(7, 0.08); // sigma
+  fitTotal->SetParLimits(7, 0.05, 0.09);
 
   if ( IsValidValue(alphaLow) )
   {
-    fitTotal->FixParameter(7, alphaLow);
+    fitTotal->FixParameter(8, alphaLow);
   }
   else
   {
-    fitTotal->SetParameter(7,0.9);
-    fitTotal->SetParLimits(7,0.1,10.0);
+    fitTotal->SetParameter(8,0.9);
+    fitTotal->SetParLimits(8,0.1,10.0);
   }
 
   if ( IsValidValue(nLow) )
   {
-    fitTotal->FixParameter(8, nLow);
+    fitTotal->FixParameter(9, nLow);
   }
   else
   {
-    fitTotal->SetParameter(8,5.0);
-    fitTotal->SetParLimits(8,0.0,10.0);
+    fitTotal->SetParameter(9,5.0);
+    fitTotal->SetParLimits(9,0.0,10.0);
   }
 
   if ( IsValidValue(alphaUp) )
   {
-    fitTotal->FixParameter(9, alphaUp);
+    fitTotal->FixParameter(10, alphaUp);
   }
   else
   {
-    fitTotal->SetParameter(9, 2.0);
-    fitTotal->SetParLimits(9,0.1,10.0);
+    fitTotal->SetParameter(10, 2.0);
+    fitTotal->SetParLimits(10,0.1,10.0);
   }
 
   if ( IsValidValue(nUp) )
   {
-    fitTotal->FixParameter(10, nUp);
+    fitTotal->FixParameter(11, nUp);
   }
   else
   {
-    fitTotal->SetParameter(10,3.0);
-    fitTotal->SetParLimits(10,0.0,10.0);
+    fitTotal->SetParameter(11,3.0);
+    fitTotal->SetParLimits(11,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(12, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(12, 0.,fHisto->GetBinContent(bin));
+  //______________
+
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,12,4);
+  //___________
+
+  //___________ Further attempts to fit if the second one fails
+  if(!CheckRoots(fitTotal,2,fitTotal->GetParameter(2),fitTotal->GetParameter(3),fitTotal->GetParameter(4),0.))
+  {
+
+    std::cout << "" <<  std::endl;
+    std::cout << "removing poles attempt ..." <<  std::endl;
+    std::cout << "" <<  std::endl;
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+    //___________
+  }
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("sJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(5),
+                     fitTotal->GetParameter(6),
+                     fitTotal->GetParameter(7),
+                     fitTotal->GetParameter(8),
+                     fitTotal->GetParameter(9),
+                     fitTotal->GetParameter(10),
+                     fitTotal->GetParameter(11));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(12),
+                        3.68609+(fitTotal->GetParameter(6)-3.096916)/3.096916*3.68609,
+                        fitTotal->GetParameter(7)*paramSPsiP, // /3.096916*3.68609,
+                        fitTotal->GetParameter(8),
+                        fitTotal->GetParameter(9),
+                        fitTotal->GetParameter(10),
+                        fitTotal->GetParameter(11));
+
+  bck->SetParameters(fitTotal->GetParameter(0),
+                     fitTotal->GetParameter(1),
+                     fitTotal->GetParameter(2),
+                     fitTotal->GetParameter(3),
+                     fitTotal->GetParameter(4));
+
+
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("a'",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("b'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("c'",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("kJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+
+  Set("alJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("nlJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("auJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("nuJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+
+  Set("kPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+
+  SetFitRejectRange();
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+5);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+5,iy+5);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[5];
+  Double_t bkgcovarianceMatrix[5][5];
+
+  for ( int ix = 0; ix < 5; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 5; ++iy )
+  {
+    for ( int ix = 0; ix < 5; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________________________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2POL3()
+{
+  /// Fit using 2 extended crystal balls (signal) + Pol2/Pol3 (background)
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  const char* fitOption = "SERL"; //We can add NO to avoid plotting
+  const char* fitOptionBg = "SRI"; //We can add NO to avoid plotting
+
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow     = GetValue("alJPsi");
+  Double_t nLow         = GetValue("nlJPsi");
+  Double_t alphaUp      = GetValue("auJPsi");
+  Double_t nUp          = GetValue("nuJPsi");
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+  Double_t paramSPsiP   = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow))     msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp))  msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp))      msg += TString::Format("nUp=%e ",nUp);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Pol3,fitRangeLow,fitRangeHigh,15,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol2Pol3");
+
+  fitTotal->SetParNames("a","b","c","a'","b'","c'","d'","kJPsi","mJPsi","sJPsi","alJPsi");
+//                        0  1   2   3    4    5    6    7         8      9       10
+  fitTotal->SetParName(11,"nlJPsi");
+  //                         11
+  fitTotal->SetParName(12,"auJPsi");
+  //                         12
+  fitTotal->SetParName(13,"nuJPsi");
+  //                         13
+  fitTotal->SetParName(14,"kPsiP");
+//                            14
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,fitRangeLow,fitRangeHigh,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
+
+  //___________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,1.7,8.,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
+
+  Int_t bin = fHisto->FindBin(0.7);
+
+  bckInit->SetParameters(0.,0.,bin,0.,0.,1.,1.);
+  bckInit->FixParameter(6.,1);
+
+  bckInit->SetParLimits(0.,-30,30);
+  bckInit->SetParLimits(1.,-10,10);
+  bckInit->SetParLimits(2.,-10,100);
+  bckInit->SetParLimits(3.,-10,10);
+  bckInit->SetParLimits(4.,-10,10);
+  bckInit->SetParLimits(5.,-30,30);
+
+//  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
+
+  SetFitRejectRange(2.3,3.6);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
+  // std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Pol3",fitOptionBg);
+
+  int j =0.;
+  //___________ Further attempts to fit if a pole is founded
+  if(!CheckRoots(bckInit,3,bckInit->GetParameter(3),bckInit->GetParameter(4),bckInit->GetParameter(5),bckInit->GetParameter(6)))
+  {
+    std::cout << "" <<  std::endl;
+    std::cout << "removing poles attempt "<< j+1 <<"..." <<  std::endl;
+    std::cout << "" <<  std::endl;
+
+    fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
+    std::cout << "FitResult=" << static_cast<int>(fitResultInit) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResultInit->CovMatrixStatus() << std::endl;
+
+    if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Pol3",fitOptionBg);
+
+    // //___________
+    // if(j==2)break;
+    // j++;
+  }
+
+  SetFitRejectRange();
+  //____________
+  
+  // new TCanvas;
+  // fHisto->DrawCopy();
+  // return;
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 7; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    // if(i > 2 && static_cast<Double_t>(fitTotal->GetParError(i))) fitTotal->SetParLimits(i,bckInit->GetParameter(i)-fitTotal->GetParError(i),bckInit->GetParameter(i)+fitTotal->GetParError(i));
+    // fitTotal->SetParLimits(i,bckInit->GetParameter(i)-10*bckInit->GetParameter(i),bckInit->GetParameter(i)+10*bckInit->GetParameter(i));
+    if(i==6) fitTotal->FixParameter(6, 1.);
+  }
+  // fitTotal->SetParLimits(0.,-30,30);
+  // fitTotal->SetParLimits(1.,-10,10);
+  // fitTotal->SetParLimits(2.,-10,100);
+  // fitTotal->SetParLimits(3.,-10,10);
+  // fitTotal->SetParLimits(4.,-10,10);
+  // fitTotal->SetParLimits(5.,-30,30);
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(7, fHisto->GetBinContent(bin)); // norm
+
+  fitTotal->SetParameter(8, 3.15); // mean
+  fitTotal->SetParLimits(8, 2.95, 3.2);
+
+  fitTotal->SetParameter(9, 0.08); // sigma
+  fitTotal->SetParLimits(9, 0.05, 0.09);
+
+  if ( IsValidValue(alphaLow) )
+  {
+    fitTotal->FixParameter(10, alphaLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(10,0.9);
+    fitTotal->SetParLimits(10,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) )
+  {
+    fitTotal->FixParameter(11, nLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(11,5.0);
+    fitTotal->SetParLimits(11,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) )
+  {
+    fitTotal->FixParameter(12, alphaUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(12, 2.0);
+    fitTotal->SetParLimits(12,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) )
+  {
+    fitTotal->FixParameter(13, nUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(13,3.0);
+    fitTotal->SetParLimits(13,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(14, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(14, fHisto->GetBinContent(bin)*0.01,1.5*fHisto->GetBinContent(bin));
+  //______________
+
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,14,6);
+  //___________
+
+  int k =0.;
+  //___________ Further attempts to fit if a pole is founded
+  CheckRoots(fitTotal,3,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6));
+  // {
+  //   std::cout << "" <<  std::endl;
+  //   std::cout << "removing poles attempt "<< k+1 <<"..." <<  std::endl;
+  //   std::cout << "" <<  std::endl;
+
+  //   fitResultInit = fHisto->Fit(fitTotal,fitOption);
+
+  //   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  //   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+  //   if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,14,6);
+
+  //   // //___________
+  //   // if(k==2)break;
+  //   // k++;
+  // }
+
+  SetFitRejectRange();
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("sJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+
+   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(7),
+                     fitTotal->GetParameter(8),
+                     fitTotal->GetParameter(9),
+                     fitTotal->GetParameter(10),
+                     fitTotal->GetParameter(11),
+                     fitTotal->GetParameter(12),
+                     fitTotal->GetParameter(13));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(14),
+                        3.68609+(fitTotal->GetParameter(8)-3.096916)/3.096916*3.68609,
+                        fitTotal->GetParameter(9)*paramSPsiP, // /3.096916*3.68609,
+                        fitTotal->GetParameter(10),
+                        fitTotal->GetParameter(11),
+                        fitTotal->GetParameter(12),
+                        fitTotal->GetParameter(13));
+
+  bck->SetParameters(fitTotal->GetParameter(0),
+                     fitTotal->GetParameter(1),
+                     fitTotal->GetParameter(2),
+                     fitTotal->GetParameter(3),
+                     fitTotal->GetParameter(4),
+                     fitTotal->GetParameter(5),
+                     fitTotal->GetParameter(6));
+
+
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("c",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("a'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("b'",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("c'",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("d'",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("kJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+
+  Set("alJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("nlJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("auJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("nuJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+  Set("kPsiP",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+
+
+  SetFitRejectRange();
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+7);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+7,iy+7);
+    }
+  }
+
+  Double_t a   = fHisto->GetXaxis()->GetXmin();
+  Double_t b   = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr  = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m       = GetValue("mJPsi");
+  double s       = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s  = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[7];
+  Double_t bkgcovarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+  
+  double nbck3s      = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr   = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+  
+  double sOverB3s    = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig    = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________________________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWGINDEPTAILS()
+{
+  /// Fit using 2 extended crystal balls with independent tails (signal) + variable width gaussian (background)
+  // Was used as a test of the Psi' tails effect, since it was negligible is not used anymore
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  Double_t alphaLow = GetValue("alJPsi");
+  Double_t nLow = GetValue("nlJPsi");
+  Double_t alphaUp = GetValue("auJPsi");
+  Double_t nUp = GetValue("nuJPsi");
+
+  Double_t alphaLowP = GetValue("alPsiP");
+  Double_t nLowP = GetValue("nlPsiP");
+  Double_t alphaUpP = GetValue("auPsiP");
+  Double_t nUpP = GetValue("nuPsiP");
+
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+
+  if (IsValidValue(alphaLowP)) msg += TString::Format("alphaLowP=%e ",alphaLowP);
+  if (IsValidValue(nLowP)) msg += TString::Format("nLowP=%e ",nLowP);
+  if (IsValidValue(alphaUpP)) msg += TString::Format("alphaUpP=%e ",alphaUpP);
+  if (IsValidValue(nUpP)) msg += TString::Format("nUpP=%e ",nUpP);
+
+  AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
+
+  // Add fit with indep tails
+
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWGINDEPTAILS,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWGINDEPTAILS");
+
+  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
+  //                        0      1       2       3       4      5      6
+                        "alJPsi","nlJPsi","auJPsi","nuJPsi");
+  //                       7        8        9        10
+//  fitTotal->SetParName(11, "kPsiP");
+//  //                            11
+//  fitTotal->SetParName(12, "mPsiP");
+//  //                            12
+//  fitTotal->SetParName(13, "sPsiP");
+//  //                            13
+//  fitTotal->SetParName(14, "alPsiP");
+//  //                            14
+//  fitTotal->SetParName(15, "nlPsiP");
+//  //                            15
+//  fitTotal->SetParName(16, "auPsiP");
+//  //                            16
+//  fitTotal->SetParName(17, "nuPsiP");
+//  //                            17
+
+  fitTotal->SetParName(11, "kPsiP");
+  //                            11
+   fitTotal->SetParName(12, "alPsiP");
+  //                            12
+  fitTotal->SetParName(13, "nlPsiP");
+  //                            13
+  fitTotal->SetParName(14, "auPsiP");
+  //                            14
+  fitTotal->SetParName(15, "nuPsiP");
+  //                            15
+
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+  const char* fitOption = "SERI";
+
+#if 0
+  bck->SetParameter(0,fHisto->GetMaximum());
+  bck->SetParameter(1,3);
+  bck->SetParameter(2,10);
+  bck->SetParameter(3,10);
+
+  bck->SetParLimits(1, 0., 100.);
+  bck->SetParLimits(2, 0., 100.);
+  bck->SetParLimits(3, 0., 100.);
+
+  SetFitRejectRange(2.7,3.5);
+
+  fHisto->Fit(bck,fitOption,"");
+
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    Double_t a,b;
+    bck->GetParLimits(i,a,b);
+    fitTotal->SetParameter(i,bck->GetParameter(i));
+    fitTotal->SetParLimits(i,a,b);
+  }
+#endif
+
+  Int_t bin = fHisto->FindBin(fitRangeLow);
+  fitTotal->SetParameter(0, fHisto->GetBinContent(bin)); // kVWG
+  fitTotal->SetParameter(1, 1.9); // mVWG
+
+  fitTotal->SetParameter(2, 0.5); // sVWG1
+  fitTotal->SetParLimits(2, 0., 100.);
+
+  fitTotal->SetParameter(3, 0.3); // sVWG2
+  fitTotal->SetParLimits(3, 0., 100.);
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
+
+  fitTotal->SetParameter(5, 3.1); // mean
+  fitTotal->SetParLimits(5, 3.0, 3.2);
+
+  fitTotal->SetParameter(6, 0.08); // sigma
+  fitTotal->SetParLimits(6, 0.03, 0.15);
+
+  if ( IsValidValue(alphaLow) )
+  {
+    fitTotal->FixParameter(7, alphaLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(7,0.9);
+    fitTotal->SetParLimits(7,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) )
+  {
+    fitTotal->FixParameter(8, nLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(8,5.0);
+    fitTotal->SetParLimits(8,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) )
+  {
+    fitTotal->FixParameter(9, alphaUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(9, 2.0);
+    fitTotal->SetParLimits(9,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) )
+  {
+    fitTotal->FixParameter(10, nUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(10,3.0);
+    fitTotal->SetParLimits(10,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+
+//  fitTotal->SetParameter(12, 3.7); // mean PsiP
+//  fitTotal->SetParLimits(12, 3.6, 3.71);
+//
+//  fitTotal->SetParameter(13, 0.08/3.096916*3.68609); // sigma PsiP
+//  fitTotal->SetParLimits(13, 0.03/3.096916*3.68609, 0.15/3.096916*3.68609);
+
+  if ( IsValidValue(alphaLowP) )
+  {
+    fitTotal->FixParameter(12, alphaLowP);
+  }
+  else
+  {
+    fitTotal->SetParameter(12,0.9);
+    fitTotal->SetParLimits(12,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLowP) )
+  {
+    fitTotal->FixParameter(13, nLowP);
+  }
+  else
+  {
+    fitTotal->SetParameter(13,5.0);
+    fitTotal->SetParLimits(13,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUpP) )
+  {
+    fitTotal->FixParameter(14, alphaUpP);
+  }
+  else
+  {
+    fitTotal->SetParameter(14, 2.0);
+    fitTotal->SetParLimits(14,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUpP) )
+  {
+    fitTotal->FixParameter(15, nUpP);
+  }
+  else
+  {
+    fitTotal->SetParameter(15,3.0);
+    fitTotal->SetParLimits(15,0.0,10.0);
+  }
+
+  //  SetFitRejectRange();
+
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+
+  if ( static_cast<int>(fitResult) )
+  {
+    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
+    {
+      std::cout << "//-------Refitting again (setting Psi'norm= Psi'norm/2)" << std::endl;
+
+      fitTotal->SetParameter(11, fHisto->GetBinContent(bin)/2.);
+    }
+
+    if ( fitTotal->GetParameter(0) <= fitTotal->GetParError(0) ) //kVWG
+    {
+      std::cout << "//-------Refitting again (setting VWG norm= VWG norm /2)" << std::endl;
+      bin = fHisto->FindBin(fitRangeLow);
+
+      fitTotal->SetParameter(0, fHisto->GetBinContent(bin)/2.);
+    }
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  }
+
+
+  if ( static_cast<int>(fitResult) )
+  {
+    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
+    {
+      std::cout << "//-------Refitting again (setting Psi'norm=0)" << std::endl;
+
+      fitTotal->FixParameter(11, 0.);
+    }
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  }
+
+  if ( static_cast<int>(fitResult) )
+  {
+    std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+
+    fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  }
+
+  if ( static_cast<int>(fitResult) )
+  {
+    std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+  }
+
+
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+
+  Set("mPsiP",3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,fitTotal->GetParError(5)/3.096916*3.68609);
+  Set("sPsiP",fitTotal->GetParameter(6)*paramSPsiP,fitTotal->GetParError(6)*paramSPsiP);
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(4),
+                        fitTotal->GetParameter(5),
+                        fitTotal->GetParameter(6),
+                        fitTotal->GetParameter(7),
+                        fitTotal->GetParameter(8),
+                        fitTotal->GetParameter(9),
+                        fitTotal->GetParameter(10));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(11),
+                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14),
+                            fitTotal->GetParameter(15));
+
+  bck->SetParameters(fitTotal->GetParameter(0),
+                     fitTotal->GetParameter(1),
+                     fitTotal->GetParameter(2),
+                     fitTotal->GetParameter(3));
+
+
+  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+
+  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+
+  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("alPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("nlPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+  Set("auPsiP",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("nuPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+
+
+
+//  SetFitRejectRange();
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2EXP()
+{
+  /// Fit using 2 extended crystal balls (signal) + pol2 x exp (background)
+  /// 13 parameters
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow = GetValue("alJPsi");
+  Double_t nLow = GetValue("nlJPsi");
+  Double_t alphaUp = GetValue("auJPsi");
+  Double_t nUp = GetValue("nuJPsi");
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime Pol2 x Exp %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp,fitRangeLow,fitRangeHigh,12,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol2Exp");
+
+  fitTotal->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","alJPsi",
+  //                      0      1       2     3      4      5       6       7
+                        "nlJPsi","auJPsi","nuJPsi");
+  //                          8       9        10
+  fitTotal->SetParName(11,"kPsiP");
+  //                            11
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
+  //__________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
+
+  Int_t bin = fHisto->FindBin(0.26);
+
+  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin)/3.,100.,0.05);//fHisto->GetBinContent(bin)
+
+  SetFitRejectRange(2.7,4.0);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SRL");
+  //___________
+
+  SetFitRejectRange();
+  //____________
+
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+  }
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
+
+  fitTotal->SetParameter(5, 3.1);
+  fitTotal->SetParLimits(5, 3.07, 3.2);
+  fitTotal->SetParameter(6, 0.08);
+  fitTotal->SetParLimits(6, 0.05, 0.15);
+
+  if ( IsValidValue(alphaLow) )
+  {
+    fitTotal->FixParameter(7, alphaLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(7,0.9);
+    fitTotal->SetParLimits(7,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) )
+  {
+    fitTotal->FixParameter(8, nLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(8,5.0);
+    fitTotal->SetParLimits(8,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) )
+  {
+    fitTotal->FixParameter(9, alphaUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(9, 2.0);
+    fitTotal->SetParLimits(9,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) )
+  {
+    fitTotal->FixParameter(10, nUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(10,3.0);
+    fitTotal->SetParLimits(10,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+
+  const char* fitOption = "SERL";
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,11,3);
+  //___________
+
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(4),
+                            fitTotal->GetParameter(5),
+                            fitTotal->GetParameter(6),
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(11),
+                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10));
+
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    bck->SetParameter(i, fitTotal->GetParameter(i));
+  }
+
+//  Set("kPol2Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("exp",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+
+  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+
+  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[4];
+  Double_t bkgcovarianceMatrix[4][4];
+
+  for ( int ix = 0; ix < 4; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 4; ++iy )
+  {
+    for ( int ix = 0; ix < 4; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                              TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL4EXP()
+{
+  /// Fit using 2 extended crystal balls (signal) + pol4 x exp (background)
+  /// 15 parameters
+  // Not used in pA Jpsi analysis: too many parameters for correct convergence (Error matrix not pos. def.)
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow = GetValue("alJPsi");
+  Double_t nLow = GetValue("nlJPsi");
+  Double_t alphaUp = GetValue("auJPsi");
+  Double_t nUp = GetValue("nuJPsi");
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime Pol4 x Exp %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol4Exp,fitRangeLow,fitRangeHigh,14,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol4Exp");
+
+  fitTotal->SetParNames("pol0","pol1","pol2","pol3","pol4","exp","kJPsi",
+  //                      0       1      2      3     4       5     6
+                        "mJPsi","sJPsi","alJPsi","nlJPsi");
+  //                       7      8       9         10
+  fitTotal->SetParName(11,"auJPsi");
+  //                        11
+  fitTotal->SetParName(12,"nuJPsi");
+  //                         12
+  fitTotal->SetParName(13,"kPsiP");
+  //                         13
+
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,fitRangeLow,fitRangeHigh,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
+  //__________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,1.6,7.,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
+
+  Int_t bin = fHisto->FindBin(1.6);
+
+  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin),fHisto->GetBinContent(bin)/2.,-fHisto->GetBinContent(bin)/10.,fHisto->GetBinContent(bin)/100.,-2.);
+
+  SetFitRejectRange(2.6,4.0);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SRL");
+  //___________
+
+  SetFitRejectRange();
+  //____________
+
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 6; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+  }
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(6, fHisto->GetBinContent(bin)); // norm(kJPsi)
+
+  fitTotal->SetParameter(7, 3.1); // mean
+  fitTotal->SetParLimits(7, 3.0, 3.2);
+
+  fitTotal->SetParameter(8, 0.08); // sigma
+  fitTotal->SetParLimits(8, 0.03, 0.15);
+
+  if ( IsValidValue(alphaLow) )
+  {
+    fitTotal->FixParameter(9, alphaLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(9,0.9);
+    fitTotal->SetParLimits(9,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) )
+  {
+    fitTotal->FixParameter(10, nLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(10,5.0);
+    fitTotal->SetParLimits(10,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) )
+  {
+    fitTotal->FixParameter(11, alphaUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(11, 2.0);
+    fitTotal->SetParLimits(11,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) )
+  {
+    fitTotal->FixParameter(12, nUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(12,3.0);
+    fitTotal->SetParLimits(12,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(13, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(13, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+
+  const char* fitOption = "SERI";
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,13,4);
+  //___________
+
+
+  delete bckInit; //Delete the initial background funtion
+
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("sJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(6),
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(13),
+                            3.68609+(fitTotal->GetParameter(7)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(8)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12));
+
+  for ( Int_t i = 0; i < 7; ++i )
+  {
+    bck->SetParameter(i, fitTotal->GetParameter(i));
+  }
+
+  Set("alJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("nlJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("auJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("nuJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+//  Set("kPol4Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("pol3",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("pol4",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("exp",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+
+  Set("kJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("kPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+6);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+6,iy+6);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[6];
+  Double_t bkgcovarianceMatrix[6][6];
+
+  for ( int ix = 0; ix < 6; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 6; ++iy )
+  {
+    for ( int ix = 0; ix < 6; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                              TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //_____________________________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
+{
+  /// Fit using 2 NA60(new) (signal) + variable width gaussian (background)
+
+  fHisto->GetListOfFunctions()->Delete();
+  const char* fitOption = "SERL";
+  const char* fitOptionBg = "SER";
+
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t p1Left = GetValue("p1LJPsi");
+  Double_t p2Left = GetValue("p2LJPsi");
+  Double_t p3Left = GetValue("p3LJPsi");
+  Double_t p1Right = GetValue("p1RJPsi");
+  Double_t p2Right = GetValue("p2RJPsi");
+  Double_t p3Right = GetValue("p3RJPsi");
+
+  Double_t alphaLeft = GetValue("aLJPsi");
+  Double_t alphaRight = GetValue("aRJPsi");
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  TString msg;
+
+  if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
+  if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
+  if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
+  if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
+  if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
+  if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
+
+  if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
+  if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and VWG %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewVWG");
+
+  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
+  //                       0      1      2       3       4       5       6
+                        "p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
+  //                        7         8         9        10
+  fitTotal->SetParName(11, "p2RJPsi");
+  //                           11
+  fitTotal->SetParName(12, "p3RJPsi");
+  //                           12
+  fitTotal->SetParName(13, "aLJPsi");
+  //                           13
+  fitTotal->SetParName(14, "aRJPsi");
+  //                           14
+  fitTotal->SetParName(15, "kPsiP");
+  //                           15
+
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+  //__________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+  Int_t bin = fHisto->FindBin(0.26);
+
+  bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+
+  SetFitRejectRange(2.7,4.0);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG",fitOptionBg);
+  //___________
+
+  SetFitRejectRange();
+  //____________
+
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
   }
 
-  bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
 
-  const char* fitOption = "SER";
+  fitTotal->SetParameter(5, 3.1); // mean
+  fitTotal->SetParLimits(5, 3.0, 3.2);
+
+  fitTotal->SetParameter(6, 0.08); // sigma
+  fitTotal->SetParLimits(6, 0.03, 0.2);
+
+  fitTotal->FixParameter(7, p1Left);
+  fitTotal->FixParameter(8, p2Left);
+  fitTotal->FixParameter(9, p3Left);
+  fitTotal->FixParameter(10, p1Right);
+  fitTotal->FixParameter(11, p2Right);
+  fitTotal->FixParameter(12, p3Right);
+
+  fitTotal->FixParameter(13, alphaLeft);
+  fitTotal->FixParameter(14, alphaRight);
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(15, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(15, 0.,fHisto->GetBinContent(bin)*1.5);
 
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
@@ -2248,87 +4104,106 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2EXP()
   //___________
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,11,3);
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,15,3);
   //___________
 
-
   delete bckInit;//Delete the initial background funtion
 
-  //___________Set parameters and fit functions to store in the result
-  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
-  Set("FitNDF",fitTotal->GetNDF(),0.0);
 
-  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  //___________Set parameters and fit functions to store in the result
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
 
-  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
   signalJPsi->SetParameters(fitTotal->GetParameter(4),
                             fitTotal->GetParameter(5),
                             fitTotal->GetParameter(6),
                             fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
-                            fitTotal->GetParameter(10));
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13));
 
-  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalPsiP->SetParameters(fitTotal->GetParameter(11),
+  signalJPsi->SetParameter(10,fitTotal->GetParameter(14));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalPsiP->SetParameters(fitTotal->GetParameter(15),
                             3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
                             fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
                             fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
-                            fitTotal->GetParameter(10));
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13));
 
-  for ( Int_t i = 0; i < 4; ++i )
-  {
-    bck->SetParameter(i, fitTotal->GetParameter(i));
-  }
+  signalPsiP->SetParameter(10,fitTotal->GetParameter(14));
+
+  bck->SetParameter(0,fitTotal->GetParameter(0));
+  bck->SetParameter(1,fitTotal->GetParameter(1));
+  bck->SetParameter(2,fitTotal->GetParameter(2));
+  bck->SetParameter(3,fitTotal->GetParameter(3));
+
+  Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
 
-//  Set("kPol2Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("exp",fitTotal->GetParameter(3),fitTotal->GetParError(3));
   Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("kPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
 
-  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
 
-  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p1LJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("p2LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("p3LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("p1RJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("p2RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p3RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+  Set("aLJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+  Set("aRJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
 
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
 
-  Double_t cbParameters[7];
-  Double_t covarianceMatrix[7][7];
+  Double_t na60Parameters[11];
+  Double_t covarianceMatrix[11][11];
 
-  for ( int ix = 0; ix < 7; ++ix )
+  for ( int ix = 0; ix < 11; ++ix )
   {
-    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+    na60Parameters[ix] = fitTotal->GetParameter(ix+4);
   }
 
-  for ( int iy = 0; iy < 7; ++iy )
+  for ( int iy = 0; iy < 11; ++iy )
   {
-    for ( int ix = 0; ix < 7; ++ix )
+    for ( int ix = 0; ix < 11; ++ix )
     {
       covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
     }
   }
 
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
-  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
 
   Set("NofJPsi",njpsi,nerr);
 
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
-  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
 
   Set("NofJPsi3s",njpsi3s,nerr3s);
+
   //_____________________________
 
 
@@ -2362,139 +4237,156 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2EXP()
                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
 
   Set("Significance3s",sig,sigErr);
-  //__________
+  //___________________
 
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL4EXP()
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL1POL2()
 {
-  /// Fit using 2 extended crystal balls (signal) + pol4 x exp (background)
-  /// 15 parameters
-  // Not used in pA Jpsi analysis: too many parameters for correct convergence (Error matrix not pos. def.)
+  /// Fit using 2 NA60(new) (signal) + POL1/POL2 (background)
 
   fHisto->GetListOfFunctions()->Delete();
 
+  const char* fitOption = "SERL";
+  const char* fitOptionBg = "SER";
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
-  Double_t alphaLow = GetValue("alJPsi");
-  Double_t nLow = GetValue("nlJPsi");
-  Double_t alphaUp = GetValue("auJPsi");
-  Double_t nUp = GetValue("nuJPsi");
-  Double_t fitRangeLow = GetValue(kFitRangeLow);
-  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+  Double_t p1Left = GetValue("p1LJPsi");
+  Double_t p2Left = GetValue("p2LJPsi");
+  Double_t p3Left = GetValue("p3LJPsi");
+  Double_t p1Right = GetValue("p1RJPsi");
+  Double_t p2Right = GetValue("p2RJPsi");
+  Double_t p3Right = GetValue("p3RJPsi");
+
+  Double_t alphaLeft = GetValue("aLJPsi");
+  Double_t alphaRight = GetValue("aRJPsi");
 
   Double_t paramSPsiP = GetValue("FSigmaPsiP");
 
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
   TString msg;
 
-  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
-  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
-  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
-  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+  if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
+  if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
+  if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
+  if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
+  if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
+  if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
+
+  if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
+  if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
   //__________
 
-  AliDebug(1,Form("Fit with jpsi + psiprime Pol4 x Exp %s",msg.Data()));
+  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and pol1/pol2 %s",msg.Data()));
 
   //__________ Define the function to fit the spectrum, and the background just for plotting
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol4Exp,fitRangeLow,fitRangeHigh,14,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol4Exp");
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol1Pol2,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewPol1Pol2");
 
-  fitTotal->SetParNames("pol0","pol1","pol2","pol3","pol4","exp","kJPsi",
-  //                      0       1      2      3     4       5     6
-                        "mJPsi","sJPsi","alJPsi","nlJPsi");
-  //                       7      8       9         10
-  fitTotal->SetParName(11,"auJPsi");
+  fitTotal->SetParNames("a","b","a'","b'","c'","kJPsi","mJPsi","sJPsi",
+  //                     0   1   2    3    4      5       6       7
+                        "p1LJPsi","p2LJPsi","p3LJPsi");
+  //                        8         9         10
+  fitTotal->SetParName(11, "p1RJPsi");
   //                           11
-  fitTotal->SetParName(12,"nuJPsi");
+  fitTotal->SetParName(12, "p2RJPsi");
   //                           12
-  fitTotal->SetParName(13,"kPsiP");
+  fitTotal->SetParName(13, "p3RJPsi");
   //                           13
+  fitTotal->SetParName(14, "aLJPsi");
+  //                           14
+  fitTotal->SetParName(15, "aRJPsi");
+  //                           15
+  fitTotal->SetParName(16, "kPsiP");
+  //                           16
 
 
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,fitRangeLow,fitRangeHigh,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
-  //__________
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
+
+  //___________
 
 
   //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,1.6,7.,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,1.7,6.,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
 
-  Int_t bin = fHisto->FindBin(1.6);
+  Int_t bin = fHisto->FindBin(0.70);
+  // Int_t bin = fHisto->FindBin(1.2); // just after a low mass pick
+  // Int_t bin = fHisto->FindBin(0.40);
 
-  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin),fHisto->GetBinContent(bin)/2.,-fHisto->GetBinContent(bin)/10.,fHisto->GetBinContent(bin)/100.,-2.);
+  bckInit->SetParameters(0.,bin,0.,1.,1.);
+  bckInit->SetParLimits(0,-200,50);
+  bckInit->SetParLimits(2,-50,2000);
+  bckInit->SetParLimits(3,-300,100);
+  bckInit->FixParameter(4, 1.);
+//  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
 
-  SetFitRejectRange(2.6,4.0);
+  SetFitRejectRange(2.6,3.4);
 
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
 
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol1Pol2",fitOptionBg);
   //___________
 
+  int j =0.;
+  //___________ Further attempts to fit if the second one fails
+  if(!CheckRoots(bckInit,2,bckInit->GetParameter(2),bckInit->GetParameter(3),bckInit->GetParameter(4),0.))
+  {
+    std::cout << "" <<  std::endl;
+    std::cout << "removing poles attempt "<< j+1 <<"..." <<  std::endl;
+    std::cout << "" <<  std::endl;
+
+    fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
+    std::cout << "FitResult=" << static_cast<int>(fitResultInit) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResultInit->CovMatrixStatus() << std::endl;
+
+    if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol1Pol2",fitOptionBg);
+
+    // //___________
+    // if(j==2)break;
+    // j++;
+  }
+
   SetFitRejectRange();
   //____________
 
-  
   //__________ Set initial parameters in fitting function
-  for ( Int_t i = 0; i < 6; ++i )
+  for ( Int_t i = 0; i < 5; ++i )
   {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    if(i > 1 && static_cast<Double_t>(fitTotal->GetParError(i))) fitTotal->SetParLimits(i,bckInit->GetParameter(i)-fitTotal->GetParError(i),bckInit->GetParameter(i)+fitTotal->GetParError(i));
+    else if( i > 1 ) fitTotal->SetParLimits(i,bckInit->GetParameter(i)- 0.1*bckInit->GetParameter(i),bckInit->GetParameter(i)+0.1*bckInit->GetParameter(i));
+    if(i==4)fitTotal->FixParameter(i, 1.);
   }
+  // fitTotal->SetParLimits(0,-200,50);
+  // fitTotal->SetParLimits(2,-50,2000);
+  // fitTotal->SetParLimits(3,-300,100);
 
-  bin = fHisto->FindBin(3.09);
-  fitTotal->SetParameter(6, fHisto->GetBinContent(bin)); // norm(kJPsi)
-  
-  fitTotal->SetParameter(7, 3.1); // mean
-  fitTotal->SetParLimits(7, 3.0, 3.2);
-  
-  fitTotal->SetParameter(8, 0.08); // sigma
-  fitTotal->SetParLimits(8, 0.03, 0.15);
 
-  if ( IsValidValue(alphaLow) )
-  {
-    fitTotal->FixParameter(9, alphaLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(9,0.9);
-    fitTotal->SetParLimits(9,0.1,10.0);
-  }
+  fitTotal->SetParameter(6, 3.1); // mean
+  fitTotal->SetParLimits(6, 3.0, 3.2);
 
-  if ( IsValidValue(nLow) )
-  {
-    fitTotal->FixParameter(10, nLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(10,5.0);
-    fitTotal->SetParLimits(10,0.0,10.0);
-  }
+  fitTotal->SetParameter(7, 0.08); // sigma
+  fitTotal->SetParLimits(7, 0.03, 0.2);
 
-  if ( IsValidValue(alphaUp) )
-  {
-    fitTotal->FixParameter(11, alphaUp);
-  }
-  else
-  {
-    fitTotal->SetParameter(11, 2.0);
-    fitTotal->SetParLimits(11,0.1,10.0);
-  }
+  fitTotal->FixParameter(8, p1Left);
+  fitTotal->FixParameter(9, p2Left);
+  fitTotal->FixParameter(10, p3Left);
+  fitTotal->FixParameter(11, p1Right);
+  fitTotal->FixParameter(12, p2Right);
+  fitTotal->FixParameter(13, p3Right);
 
-  if ( IsValidValue(nUp) )
-  {
-    fitTotal->FixParameter(12, nUp);
-  }
-  else
-  {
-    fitTotal->SetParameter(12,3.0);
-    fitTotal->SetParLimits(12,0.0,10.0);
-  }
+  fitTotal->FixParameter(14, alphaLeft);
+  fitTotal->FixParameter(15, alphaRight);
 
   bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(13, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(13, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
-
-  const char* fitOption = "SERI";
+  fitTotal->SetParameter(16, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(16, 0.,fHisto->GetBinContent(bin)*1.5);
 
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
@@ -2504,107 +4396,138 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL4EXP()
   //___________
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,13,4);
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,17,4);
   //___________
 
+  //___________ Further attempts to fit if the second one fails
+  if(!CheckRoots(fitTotal,2,fitTotal->GetParameter(2),fitTotal->GetParameter(3),fitTotal->GetParameter(4),0.))
+  {
+    std::cout << "" <<  std::endl;
+    std::cout << "removing poles attempt ..." <<  std::endl;
+    std::cout << "" <<  std::endl;
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+    if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,17,4);
+
+  }
 
   delete bckInit;//Delete the initial background funtion
 
 
   //___________Set parameters and fit functions to store in the result
-  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
-  Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
-  Set("mJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("sJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
 
-  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalJPsi->SetParameters(fitTotal->GetParameter(6),
+  signalJPsi->SetParameters(fitTotal->GetParameter(5),
+                            fitTotal->GetParameter(6),
                             fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
-                            fitTotal->GetParameter(12));
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14));
 
-  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalPsiP->SetParameters(fitTotal->GetParameter(13),
-                            3.68609+(fitTotal->GetParameter(7)-3.096916)/3.096916*3.68609,
-                            fitTotal->GetParameter(8)*paramSPsiP, // /3.096916*3.68609,
+  signalJPsi->SetParameter(10,fitTotal->GetParameter(15));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalPsiP->SetParameters(fitTotal->GetParameter(16),
+                            3.68609+(fitTotal->GetParameter(6)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(7)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
-                            fitTotal->GetParameter(12));
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14));
 
-  for ( Int_t i = 0; i < 7; ++i )
-  {
-    bck->SetParameter(i, fitTotal->GetParameter(i));
-  }
+  signalPsiP->SetParameter(10,fitTotal->GetParameter(15));
 
-  Set("alJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("nlJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  Set("auJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
-  Set("nuJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  bck->SetParameter(0,fitTotal->GetParameter(0));
+  bck->SetParameter(1,fitTotal->GetParameter(1));
+  bck->SetParameter(2,fitTotal->GetParameter(2));
+  bck->SetParameter(3,fitTotal->GetParameter(3));
+  bck->SetParameter(4,fitTotal->GetParameter(4));
 
-//  Set("kPol4Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("pol3",fitTotal->GetParameter(3),fitTotal->GetParError(3));
-  Set("pol4",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  Set("exp",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
 
-  Set("kJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  Set("kPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("a'",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("b'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+
+  Set("kJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("kPsiP",fitTotal->GetParameter(16),fitTotal->GetParError(16));
 
+  Set("mJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("sJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
 
+  Set("p1LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("p2LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("p3LJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("p1RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p2RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("p3RJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+  Set("aLJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("aRJPsi",fitTotal->GetParameter(15),fitTotal->GetParError(15));
 
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
 
-  Double_t cbParameters[7];
-  Double_t covarianceMatrix[7][7];
+  Double_t na60Parameters[11];
+  Double_t covarianceMatrix[11][11];
 
-  for ( int ix = 0; ix < 7; ++ix )
+  for ( int ix = 0; ix < 11; ++ix )
   {
-    cbParameters[ix] = fitTotal->GetParameter(ix+6);
+    na60Parameters[ix] = fitTotal->GetParameter(ix+5);
   }
 
-  for ( int iy = 0; iy < 7; ++iy )
+  for ( int iy = 0; iy < 11; ++iy )
   {
-    for ( int ix = 0; ix < 7; ++ix )
+    for ( int ix = 0; ix < 11; ++ix )
     {
-      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+6,iy+6);
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+5,iy+5);
     }
   }
 
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
-  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
 
   Set("NofJPsi",njpsi,nerr);
 
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
-  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
 
   Set("NofJPsi3s",njpsi3s,nerr3s);
+
   //_____________________________
 
 
   //_____Computation of bin significance and signal over background
-  Double_t bkgParameters[6];
-  Double_t bkgcovarianceMatrix[6][6];
+  Double_t bkgParameters[5];
+  Double_t bkgcovarianceMatrix[5][5];
 
-  for ( int ix = 0; ix < 6; ++ix )
+  for ( int ix = 0; ix < 5; ++ix )
   {
     bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
 
-  for ( int iy = 0; iy < 6; ++iy )
+  for ( int iy = 0; iy < 5; ++iy )
   {
-    for ( int ix = 0; ix < 6; ++ix )
+    for ( int ix = 0; ix < 5; ++ix )
     {
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
@@ -2623,17 +4546,21 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL4EXP()
                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
 
   Set("Significance3s",sig,sigErr);
-  //_____________________________
+  //___________________
 
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2POL3()
 {
-  /// Fit using 2 NA60(new) (signal) + variable width gaussian (background)
+  /// Fit using 2 NA60(new) (signal) + POL2/POL3 (background)
 
   fHisto->GetListOfFunctions()->Delete();
 
+  const char* fitOption = "SERL";
+  const char* fitOptionBg = "SER";
+
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
@@ -2663,81 +4590,122 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
   if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
   //__________
 
-  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and VWG %s",msg.Data()));
+  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and pol2/pol3 %s",msg.Data()));
 
   //__________ Define the function to fit the spectrum, and the background just for plotting
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewVWG");
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol2Pol3,fitRangeLow,fitRangeHigh,19,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewPol2Pol3");
 
-  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
-  //                       0      1      2       3       4       5       6
-                        "p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
-  //                        7         8         9        10
-  fitTotal->SetParName(11, "p2RJPsi");
+  fitTotal->SetParNames("a","b","c","a'","b'","c'","d'","kJPsi","mJPsi","sJPsi",
+  //                     0   1   2   3    4    5    6      7      8       9
+                        "p1LJPsi");
+  //                        10
+  fitTotal->SetParName(11, "p2LJPsi");
   //                           11
-  fitTotal->SetParName(12, "p3RJPsi");
+  fitTotal->SetParName(12, "p3LJPsi");
   //                           12
-  fitTotal->SetParName(13, "aLJPsi");
+  fitTotal->SetParName(13, "p1RJPsi");
   //                           13
-  fitTotal->SetParName(14, "aRJPsi");
+  fitTotal->SetParName(14, "p2RJPsi");
   //                           14
-  fitTotal->SetParName(15, "kPsiP");
+  fitTotal->SetParName(15, "p3RJPsi");
   //                           15
+  fitTotal->SetParName(16, "aLJPsi");
+  //                           16
+  fitTotal->SetParName(17, "aRJPsi");
+  //                           17
+  fitTotal->SetParName(18, "kPsiP");
+  //                           18
 
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,fitRangeLow,fitRangeHigh,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
 
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
 
-  //__________
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,1.7,8.,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
 
+  Int_t bin = fHisto->FindBin(0.7);
 
-  //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+  bckInit->SetParameters(0.,0.,bin,0.,0.,1.,1.);
+  bckInit->FixParameter(6.,1);
 
-  Int_t bin = fHisto->FindBin(0.26);
+  bckInit->SetParLimits(0.,-30,30);
+  bckInit->SetParLimits(1.,-10,10);
+  bckInit->SetParLimits(2.,-10,100);
+  bckInit->SetParLimits(3.,-10,10);
+  bckInit->SetParLimits(4.,-10,10);
+  bckInit->SetParLimits(5.,-30,30);
 
-  bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
 
-  SetFitRejectRange(2.7,4.0);
+  SetFitRejectRange(2.8,3.5);
 
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
 
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG","SR");
-  //___________
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Pol3",fitOptionBg);
+
+  int j =0.;
+  //___________ Further attempts to fit if the second one fails
+  if(!CheckRoots(bckInit,3,bckInit->GetParameter(3),bckInit->GetParameter(4),bckInit->GetParameter(5),bckInit->GetParameter(6)))
+  {
+    std::cout << "" <<  std::endl;
+    std::cout << "removing poles attempt "<< j+1 <<"..." <<  std::endl;
+    std::cout << "" <<  std::endl;
+
+    fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
+    std::cout << "FitResult=" << static_cast<int>(fitResultInit) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResultInit->CovMatrixStatus() << std::endl;
+
+    if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Pol3",fitOptionBg);
+
+    // //___________
+    // if(j==2)break;
+    // j++;
+  }
 
   SetFitRejectRange();
   //____________
+  //
 
+  // printf("Set limits to total fit function with epsilon = %f\n",epsilon );
 
   //__________ Set initial parameters in fitting function
-  for ( Int_t i = 0; i < 4; ++i )
+  for ( Int_t i = 0; i < 7; ++i )
   {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    if(i > 3 && static_cast<Double_t>(fitTotal->GetParError(i))) fitTotal->SetParLimits(i,bckInit->GetParameter(i)-fitTotal->GetParError(i),bckInit->GetParameter(i)+fitTotal->GetParError(i));
+    else if( i > 3 ) fitTotal->SetParLimits(i,bckInit->GetParameter(i)- 0.1*bckInit->GetParameter(i),bckInit->GetParameter(i)+0.1*bckInit->GetParameter(i));
+    if(i==6)fitTotal->FixParameter(i, 1.);
   }
+  fitTotal->SetParLimits(0.,-30,30);
+  fitTotal->SetParLimits(1.,-10,10);
+  fitTotal->SetParLimits(2.,-10,100);
+  // fitTotal->SetParLimits(3.,-10,10);
+  // fitTotal->SetParLimits(4.,-10,10);
+  // fitTotal->SetParLimits(5.,-30,30);
 
 
-  fitTotal->SetParameter(5, 3.1); // mean
-  fitTotal->SetParLimits(5, 3.0, 3.2);
+  fitTotal->SetParameter(8, 3.1); // mean
+  fitTotal->SetParLimits(8, 3.0, 3.2);
 
-  fitTotal->SetParameter(6, 0.08); // sigma
-  fitTotal->SetParLimits(6, 0.05, 0.15);
+  fitTotal->SetParameter(9, 0.08); // sigma
+  fitTotal->SetParLimits(9, 0.03, 0.2);
 
-  fitTotal->FixParameter(7, p1Left);
-  fitTotal->FixParameter(8, p2Left);
-  fitTotal->FixParameter(9, p3Left);
-  fitTotal->FixParameter(10, p1Right);
-  fitTotal->FixParameter(11, p2Right);
-  fitTotal->FixParameter(12, p3Right);
+  fitTotal->FixParameter(10, p1Left);
+  fitTotal->FixParameter(11, p2Left);
+  fitTotal->FixParameter(12, p3Left);
+  fitTotal->FixParameter(13, p1Right);
+  fitTotal->FixParameter(14, p2Right);
+  fitTotal->FixParameter(15, p3Right);
 
-  fitTotal->FixParameter(13, alphaLeft);
-  fitTotal->FixParameter(14, alphaRight);
+  fitTotal->FixParameter(16, alphaLeft);
+  fitTotal->FixParameter(17, alphaRight);
 
   bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(15, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(15, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
-  
-  const char* fitOption = "SERI";
+  fitTotal->SetParameter(18, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(18, fHisto->GetBinContent(bin)*0.1,fHisto->GetBinContent(bin)*1.5);
 
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
@@ -2747,72 +4715,98 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
   //___________
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,15,3);
+  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,18,6);
   //___________
 
-  delete bckInit;//Delete the initial background funtion
+  int k =0.;
+  //___________ Further attempts to fit if the second one fails
+  CheckRoots(fitTotal,3,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6));
+  // {
+  //   std::cout << "" <<  std::endl;
+  //   std::cout << "removing poles attempt "<< k+1 <<"..." <<  std::endl;
+  //   std::cout << "" <<  std::endl;
+
+  //   fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  //   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  //   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
 
+  //   if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,18,6);
+
+
+  //   // //___________
+  //   // if(k==2)break;
+  //   // k++;
+  // }
+
+  delete bckInit;//Delete the initial background funtion
 
   //___________Set parameters and fit functions to store in the result
   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
 
-  signalJPsi->SetParameters(fitTotal->GetParameter(4),
-                            fitTotal->GetParameter(5),
-                            fitTotal->GetParameter(6),
-                            fitTotal->GetParameter(7),
+  signalJPsi->SetParameters(fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
                             fitTotal->GetParameter(12),
-                            fitTotal->GetParameter(13));
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14),
+                            fitTotal->GetParameter(15),
+                            fitTotal->GetParameter(16));
 
-  signalJPsi->SetParameter(10,fitTotal->GetParameter(14));
+  signalJPsi->SetParameter(10,fitTotal->GetParameter(17));
 
   TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
 
-  signalPsiP->SetParameters(fitTotal->GetParameter(15),
-                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
-                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
-                            fitTotal->GetParameter(7),
-                            fitTotal->GetParameter(8),
-                            fitTotal->GetParameter(9),
+  signalPsiP->SetParameters(fitTotal->GetParameter(18),
+                            3.68609+(fitTotal->GetParameter(8)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(9)*paramSPsiP, // /3.096916*3.68609,
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
                             fitTotal->GetParameter(12),
-                            fitTotal->GetParameter(13));
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14),
+                            fitTotal->GetParameter(15),
+                            fitTotal->GetParameter(16));
 
-  signalPsiP->SetParameter(10,fitTotal->GetParameter(14));
+  signalPsiP->SetParameter(10,fitTotal->GetParameter(17));
 
   bck->SetParameter(0,fitTotal->GetParameter(0));
   bck->SetParameter(1,fitTotal->GetParameter(1));
   bck->SetParameter(2,fitTotal->GetParameter(2));
   bck->SetParameter(3,fitTotal->GetParameter(3));
+  bck->SetParameter(4,fitTotal->GetParameter(4));
+  bck->SetParameter(5,fitTotal->GetParameter(5));
+  bck->SetParameter(6,fitTotal->GetParameter(6));
 
   Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
 
-  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("c",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("a'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("b'",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("c''",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("d'",fitTotal->GetParameter(6),fitTotal->GetParError(6));
 
-  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  Set("kPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+  Set("kJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("kPsiP",fitTotal->GetParameter(18),fitTotal->GetParError(18));
 
-  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("mJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("sJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
 
-  Set("p1LJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("p2LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  Set("p3LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("p1RJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  Set("p2RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
-  Set("p3RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("p1LJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("p2LJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p3LJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("p1RJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+  Set("p2RJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("p3RJPsi",fitTotal->GetParameter(15),fitTotal->GetParError(15));
 
-  Set("aLJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
-  Set("aRJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("aLJPsi",fitTotal->GetParameter(16),fitTotal->GetParError(16));
+  Set("aRJPsi",fitTotal->GetParameter(17),fitTotal->GetParError(17));
 
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
 
@@ -2821,14 +4815,14 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
 
   for ( int ix = 0; ix < 11; ++ix )
   {
-    na60Parameters[ix] = fitTotal->GetParameter(ix+4);
+    na60Parameters[ix] = fitTotal->GetParameter(ix+7);
   }
 
   for ( int iy = 0; iy < 11; ++iy )
   {
     for ( int ix = 0; ix < 11; ++ix )
     {
-      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+7,iy+7);
     }
   }
 
@@ -2851,17 +4845,17 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
 
 
   //_____Computation of bin significance and signal over background
-  Double_t bkgParameters[4];
-  Double_t bkgcovarianceMatrix[4][4];
+  Double_t bkgParameters[7];
+  Double_t bkgcovarianceMatrix[7][7];
 
-  for ( int ix = 0; ix < 4; ++ix )
+  for ( int ix = 0; ix < 7; ++ix )
   {
     bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
 
-  for ( int iy = 0; iy < 4; ++iy )
+  for ( int iy = 0; iy < 7; ++iy )
   {
-    for ( int ix = 0; ix < 4; ++ix )
+    for ( int ix = 0; ix < 7; ++ix )
     {
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
@@ -2882,6 +4876,9 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
   Set("Significance3s",sig,sigErr);
   //___________________
 
+  // new TCanvas;
+  // fHisto->DrawCopy();
+
 }
 
 //_____________________________________________________________________________
@@ -2956,12 +4953,12 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
 
   SetFitRejectRange(2.7,4.0);
 
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
 
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SRL");
   //___________
 
   SetFitRejectRange();
@@ -3221,13 +5218,13 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
 
   SetFitRejectRange(2.6,4.0);
 
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
 
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   //___________
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SRL");
   //___________
 
   SetFitRejectRange();
@@ -3471,7 +5468,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
 
   SetFitRejectRange(2.7,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -3644,7 +5641,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -3835,7 +5832,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -4015,7 +6012,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -4211,7 +6208,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -4415,7 +6412,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -4618,7 +6615,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -4814,7 +6811,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -5012,7 +7009,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
 
   SetFitRejectRange(2.3,4.0);
 
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -5155,7 +7152,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTLIN()
 
   SetFitRejectRange(2.0,4.0);
 
-  fHisto->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
+  fHisto->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
 
   SetFitRejectRange();
 
@@ -5535,7 +7532,7 @@ Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
 
   if (callEnv.IsValid())
   {
-    callEnv.Execute(r);
+    callEnv.Execute(r);// here fit Method ("fit<SOMETHING>") is called and the fit is proceed.
   }
   else
   {
@@ -5878,15 +7875,17 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
 {
   // If a Minv fit fails this algorithm changes some initial parameters to get the fit converged
   
+  TString fitopt = Form("%sM",fitOption);
+
   Int_t bin(0);
-  if ( static_cast<int>(fitResult) )
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.)
   {
     if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip)) || (fitResult->CovMatrixStatus() != 3)) //kPsi'
     {
-      std::cout << "//------- Setting Psi'norm= Psi' norm*0.2" << std::endl;
+      std::cout << "//------- Setting Psi'norm= Psi' norm*0.8" << std::endl;
       bin = fHisto->FindBin(3.68);
-      fitTotal->SetParLimits(iParKPsip, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin)*0.7); // we further restrict the range of psi' norm
-      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.2);
+      fitTotal->SetParLimits(iParKPsip, 0.,fHisto->GetBinContent(bin)*1.5); // we further restrict the range of psi' norm
+      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.8);
     }
 
     if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
@@ -5897,19 +7896,19 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
     }
 
     std::cout << "//======== Refitting again =======\\" << std::endl;
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    fitResult = fHisto->Fit(fitTotal,fitopt.Data(),"");
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   }
 
-  if ( static_cast<int>(fitResult) )
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.)
   {
       if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip))  || (fitResult->CovMatrixStatus() != 3) ) //kPsi'
       {
-        std::cout << "//------- Setting Psi'norm= Psi' norm*0.1)" << std::endl;
+        std::cout << "//------- Setting Psi'norm= Psi' norm*0.5)" << std::endl;
         bin = fHisto->FindBin(3.68);
-        fitTotal->SetParLimits(iParKPsip, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin)*0.5); // we further restrict the range of psi' norm
-        fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.1);
+        fitTotal->SetParLimits(iParKPsip, 0.,fHisto->GetBinContent(bin)*1.5); // we further restrict the range of psi' norm
+        fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.5);
       }
 
       if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
@@ -5920,19 +7919,19 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
       }
 
     std::cout << "//======== Refitting again =======\\" << std::endl;
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    fitResult = fHisto->Fit(fitTotal,fitopt.Data(),"");
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   }
 
-  if ( static_cast<int>(fitResult) )
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.)
   {
 
     std::cout << "//======== Refitting bkg again (setting range rejected 2.7-3.5, and fit range 1.7-5)" << std::endl;
 
     SetFitRejectRange(2.7,3.5);
 
-    TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR","",1.7,5.);
+    TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SER","",1.7,5.);
 
     SetFitRejectRange();
 
@@ -5941,12 +7940,33 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
       fitTotal->SetParameter(i, bckInit->GetParameter(i));
     }
 
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    fitResult = fHisto->Fit(fitTotal,fitopt.Data(),"");
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   }
 
-  if ( static_cast<int>(fitResult) )
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.)
+  {
+
+    std::cout << "//======== Refitting bkg again (setting range rejected 2.7-3.5, and fit range 1.5-5)" << std::endl;
+
+    SetFitRejectRange(2.7,3.5);
+
+    TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SER","",1.5,5.);
+
+    SetFitRejectRange();
+
+    for ( Int_t i = 0; i < iLastParBkg+1 ; ++i )
+    {
+      fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    }
+
+    fitResult = fHisto->Fit(fitTotal,fitopt.Data(),"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  }
+
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.)
   {
     for ( Int_t i = 0; i < iLastParBkg+1 ; ++i )
     {
@@ -5955,10 +7975,10 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
 
     if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip))  || (fitResult->CovMatrixStatus() != 3) ) //kPsi'
     {
-      std::cout << "//------- Setting Psi'norm= Psi' norm*0.1)" << std::endl;
+      std::cout << "//------- Setting Psi'norm= Psi' norm*0.3)" << std::endl;
       bin = fHisto->FindBin(3.68);
-      fitTotal->SetParLimits(iParKPsip, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin)*0.4); // we further restrict the range of psi' norm
-      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.1);
+      fitTotal->SetParLimits(iParKPsip, 0.,fHisto->GetBinContent(bin)*1.5); // we further restrict the range of psi' norm
+      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.3);
     }
 
     if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
@@ -5970,11 +7990,11 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
     }
 
     std::cout << "//======== Refitting again =======\\" << std::endl;
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    fitResult = fHisto->Fit(fitTotal,fitopt.Data(),"");
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
 
-    if ( static_cast<int>(fitResult) ) std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+    if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.) std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
   }
 
 }
@@ -5989,26 +8009,21 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
   TArrayD* initPars(0x0);
 
   Int_t bin = fHisto->FindBin(0.82); // We change the bin from where we get the initial value for 1st parameter
-  if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundVWG") )
-  {
+  if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundVWG")|| !sbkgFuncName.CompareTo("FitFunctionBackgroundVWG2") ) {
     nParsBkg = 4;
     initPars = new TArrayD(nParsBkg);
     initPars->AddAt(fHisto->GetBinContent(bin),0);
     initPars->AddAt(2.,1);
     initPars->AddAt(0.5,2);
     initPars->AddAt(0.3,3);
-  }
-  else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Exp") )
-  {
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Exp") ) {
     nParsBkg = 4;
     initPars = new TArrayD(nParsBkg);
     initPars->AddAt(fHisto->GetBinContent(bin),0);
     initPars->AddAt(-fHisto->GetBinContent(bin)/3.,1);
     initPars->AddAt(100.,2);
     initPars->AddAt(0.05,3);
-  }
-  else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol4Exp") )
-  {
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol4Exp") ) {
     nParsBkg = 6;
     bin = fHisto->FindBin(1.6);
     bckInit->SetParameters(0.,1.,1.,1.,2.,0.5);
@@ -6025,9 +8040,26 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
 //    initPars->AddAt(1.,3);
 //    initPars->AddAt(2.,4);
 //    initPars->AddAt(0.5,5);
-  }
-  else
-  {
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol1Pol2") ) {
+    nParsBkg = 4;
+    initPars = new TArrayD(nParsBkg);
+
+    initPars->AddAt(0,0);
+    initPars->AddAt(fHisto->GetBinContent(bin),1);
+    initPars->AddAt(0.,2);
+    initPars->AddAt(1.,3);
+    // initPars->AddAt(1,4);
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Pol3") ) {
+    bin = fHisto->FindBin(1.5);
+    nParsBkg = 6;
+    initPars = new TArrayD(nParsBkg);
+    initPars->AddAt(0.9,0);
+    initPars->AddAt(-9,1);
+    initPars->AddAt(bin,2);
+    initPars->AddAt(1,3);
+    initPars->AddAt(-6,4);
+    initPars->AddAt(9,5);
+  } else {
     AliError("Unrecognized Background function");
     return;
   }
@@ -6046,7 +8078,7 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
     }
 
     std::cout << "//======== Fitting background again =======\\" << std::endl;
-    fitResultInit = fHisto->Fit(bckInit,"SR");
+    fitResultInit = fHisto->Fit(bckInit,"SRL");
 
     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   }
@@ -6055,7 +8087,7 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
   {
     // Same initial parameters but change the fitting range
 
-    std::cout << "//------- Changing fitting range to (1.7,5.0)" << std::endl;
+    std::cout << "//------- Changing fitting range to (1.5,5.0)" << std::endl;
 
     for ( Int_t i = 0 ; i < nParsBkg ; i++ )
     {
@@ -6064,7 +8096,7 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
     SetFitRejectRange(2.8,3.4);
 
     std::cout << "//======== Fitting background again =======\\" << std::endl;
-    fitResultInit = fHisto->Fit(bckInit,"SR","",1.5,5.);
+    fitResultInit = fHisto->Fit(bckInit,"SRL","",1.5,5.);
 
     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   }
@@ -6080,10 +8112,10 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
       if ( i == 0 ) par =2*par + 1.;
       bckInit->SetParameter(i,par);
     }
-    SetFitRejectRange(2.7,3.5);
+    SetFitRejectRange(2.7,4.0);
 
     std::cout << "//======== Fitting background again =======\\" << std::endl;
-    fitResultInit = fHisto->Fit(bckInit,"SR","",2.0,5.);
+    fitResultInit = fHisto->Fit(bckInit,"SRL","",1.5,5.);
 
     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   }
@@ -6201,6 +8233,7 @@ void AliAnalysisMuMuJpsiResult::SetNofInputParticles(const char* particle, int n
     r->Set(Form("AccEff%s",particle),
            npart/ninput,
            (npart/ninput)*ErrorAB(npart,npartErr,ninput,ninputErr));
+    printf("AccEff : %f \n", npart/ninput);
 
   }
 }
@@ -6238,6 +8271,97 @@ void AliAnalysisMuMuJpsiResult::SetParameter(TF1* func, Int_t npar, Double_t fix
 }
 
 //_____________________________________________________________________________
+Bool_t AliAnalysisMuMuJpsiResult::CheckRoots(TF1* fitFunction, Int_t deg, Double_t a, Double_t b, Double_t c, Double_t d )
+{
+  /// Check if there is no roots founs in the x axis inside the fit range. If there are some, refit again.
+  /// Meant to work for polynomial ratio background function.
+
+  if(!fitFunction){
+    AliError("Cannot check roots without functons ...");
+    return kFALSE;
+  }
+
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+  Double_t epsilon= 0.1;
+
+  if(deg == 2) {
+    Double_t delta = b*b -4*a*c;
+    if(delta <= 0.) return kTRUE;
+    Double_t x1 = (-b - TMath::Sqrt(delta ))/(2.*a);
+    Double_t x2 = (-b + TMath::Sqrt(delta ))/(2.*a);
+    if ((fitRangeLow < x1 && x1 < fitRangeHigh )){
+       printf(" !!!!!! Roots founded at %f !!!!!! \n",x1);
+       fitFunction->SetParameters(2,a+epsilon);
+       return kFALSE;
+    }
+    if ((fitRangeLow < x2 && x2 < fitRangeHigh )){
+       printf(" !!!!!! Roots founded at %f !!!!!! \n",x2);
+       fitFunction->SetParameters(2,a+epsilon);
+       return kFALSE;
+    }
+  }
+
+  if(deg == 3 && a != 0.) {
+    // Cardan methods, see https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Cardan
+
+    Double_t p = -b*b/(3.*a*a) + c/a;
+    // printf("p =%f\n",p );
+    Double_t q =b/(27.*a) * (2.*b*b/a/a -9*c/a ) +d/a;
+    // printf("q =%f\n",q );
+    Double_t delta = -(4*p*p*p + 27*q*q);
+    // printf("delta =%f\n",delta );
+
+    Double_t z1 = 0.5*(-q - TMath::Sqrt(-0.037*delta));
+    // printf("z1 =%f\n",z1 );
+    Double_t z2 = 0.5*(-q + TMath::Sqrt(-0.037*delta));
+    // printf("z2 =%f\n",z2 );
+
+    Double_t r1 = z1/TMath::Abs(z1)*TMath::Power(TMath::Abs(z1),0.33) ;
+    // printf("r1 =%f\n",r1 );
+    Double_t r2 = z2/TMath::Abs(z2)*TMath::Power(TMath::Abs(z2),0.33) ;
+    // printf("r2 =%f\n",r2 );
+
+    Double_t R1 =0.;
+    Double_t R2 =0.;
+    Double_t R3 =0.;
+
+    if( delta < 0) R1 = r1 + r2 -0.333*b/a;
+    else if(delta == 0){
+      R1 = 3*q/p -0.333*b/a;
+      R2 = -1.5*q*p -0.333*b/a;
+      R3 = -1.5*q*p -0.333*b/a;
+    }
+    else if(delta > 0.){
+      R1 = 2*TMath::Sqrt(-0.333*p)*TMath::Cos(0.333*TMath::ACos(-0.5*q*TMath::Sqrt(-27/p/p/p) + 0.*0.666*3.14)) -0.333*b/a;
+      // R2 = 2*TMath::Sqrt(-0.333*p)*TMath::Cos(0.333*TMath::ACos(-0.5*q*TMath::Sqrt(-27/p/p/p) + 1.*0.666*3.14)) -0.333*b/a;
+      // R3 = 2*TMath::Sqrt(-0.333*p)*TMath::Cos(0.333*TMath::ACos(-0.5*q*TMath::Sqrt(-27/p/p/p) + 2.*0.666*3.14)) -0.333*b/a;
+    }
+
+    if (fitRangeLow < R1  && R1 < fitRangeHigh){
+      printf(" !!!!!! Roots founded at %f !!!!!! \n", R1);
+      fitFunction->SetParameters(3,a+epsilon*a);
+      return kFALSE;
+    }
+    if (fitRangeLow < R2  && R2 < fitRangeHigh){
+      printf(" !!!!!! Roots founded at %f !!!!!! \n", R2);
+      fitFunction->SetParameters(3,a+epsilon*a);
+      return kFALSE;
+    }
+    if (fitRangeLow < R3  && R3 < fitRangeHigh){
+      printf(" !!!!!! Roots founded at %f !!!!!! \n", R3);
+      fitFunction->SetParameters(3,a+epsilon*a);
+      return kFALSE;
+    }
+
+
+  }
+  return kTRUE;
+
+
+}
+
+//_____________________________________________________________________________
 Bool_t AliAnalysisMuMuJpsiResult::StrongCorrelation(TFitResultPtr& r,
                                                     TF1* fitFunction,
                                                     Int_t npar1,
diff --git a/PWG/muondep/AliAnalysisMuMuJpsiResult.h b/PWG/muondep/AliAnalysisMuMuJpsiResult.h
index f8cff58..874b3f7 100644
--- a/PWG/muondep/AliAnalysisMuMuJpsiResult.h
+++ b/PWG/muondep/AliAnalysisMuMuJpsiResult.h
@@ -77,9 +77,15 @@ public:
   void FitPSICB2();
   void FitPSINA60NEW();
 
+  // void FitPSICB2VWG();
   void FitPSIPSIPRIMECB2VWG();
+  void FitPSIPSIPRIMECB2VWG2();
+  void FitPSIPSIPRIMECB2POL1POL2();
+  void FitPSIPSIPRIMECB2POL2POL3();
   void FitPSIPSIPRIMECB2POL2EXP();
   void FitPSIPSIPRIMENA60NEWVWG();
+  void FitPSIPSIPRIMENA60NEWPOL1POL2();
+  void FitPSIPSIPRIMENA60NEWPOL2POL3();
   void FitPSIPSIPRIMENA60NEWPOL2EXP();
 
   void FitPSIPSIPRIMECB2POL4EXP();
@@ -162,6 +168,10 @@ private:
 
   Double_t FitFunctionBackgroundLin(Double_t *x, Double_t *par);
 
+  Double_t FitFunctionBackgroundPol1Pol2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionBackgroundPol2Pol3(Double_t *x, Double_t *par);
+
   Double_t FitFunctionBackgroundPol2Exp(Double_t* x, Double_t* par);
 
   Double_t FitFunctionBackgroundPol4Exp(Double_t *x, Double_t *par);
@@ -174,22 +184,36 @@ private:
 
   Double_t FitFunctionBackgroundVWG(Double_t* x, Double_t* par);
   
+  Double_t FitFunctionBackgroundVWG2(Double_t* x, Double_t* par);
+
   Double_t FitFunctionSignalCrystalBallExtended(Double_t *x,Double_t *par);
 
   Double_t FitFunctionNA60New(Double_t *x,Double_t *par);
 
+  // Double_t FitFunctionTotalOneCB2VWG(Double_t *x,Double_t *par); // Correction here
+
   Double_t FitFunctionTotalTwoNA60NewVWG(Double_t *x, Double_t *par);
 
+  Double_t FitFunctionTotalTwoNA60NewPol1Pol2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionTotalTwoNA60NewPol2Pol3(Double_t *x, Double_t *par);
+
   Double_t FitFunctionTotalTwoNA60NewPol2Exp(Double_t *x, Double_t *par);
 
   Double_t FitFunctionTotalTwoNA60NewPol4Exp(Double_t *x, Double_t *par);
 
   Double_t FitFunctionTotalTwoCB2Pol2Exp(Double_t *x, Double_t *par);
 
+  Double_t FitFunctionTotalTwoCB2Pol1Pol2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionTotalTwoCB2Pol2Pol3(Double_t *x, Double_t *par);
+
   Double_t FitFunctionTotalTwoCB2Pol4Exp(Double_t *x, Double_t *par);
 
   Double_t FitFunctionTotalTwoCB2VWG(Double_t *x, Double_t *par);
   
+  Double_t FitFunctionTotalTwoCB2VWG2(Double_t *x, Double_t *par);
+
   Double_t FitFunctionTotalTwoCB2Lin(Double_t *x, Double_t *par);
 
   Double_t FitFunctionTotalTwoCB2VWGINDEPTAILS(Double_t *x, Double_t *par);
@@ -244,6 +268,8 @@ private:
   void SetParameter(TF1* func, Int_t npar, Double_t fix, Double_t initialValue,
                     Double_t min, Double_t max) const;
 
+  Bool_t CheckRoots(TF1* fitFunction, Int_t deg, Double_t a, Double_t b, Double_t c, Double_t d );
+
   Bool_t WrongParameter(TF1* fitFunction, Int_t npar, Double_t fixValueIfWrong);
 
   Bool_t StrongCorrelation(TFitResultPtr& fitResult, TF1* fitFunction, Int_t npar1, Int_t npar2, Double_t fixValueIfWrong);
diff --git a/PWG/muondep/AliAnalysisMuMuSpectra.cxx b/PWG/muondep/AliAnalysisMuMuSpectra.cxx
index 9211ec9..843f6bd 100644
--- a/PWG/muondep/AliAnalysisMuMuSpectra.cxx
+++ b/PWG/muondep/AliAnalysisMuMuSpectra.cxx
@@ -457,9 +457,12 @@ TH1* AliAnalysisMuMuSpectra::Plot(const char* what, const char* subresult, Bool_
       std::cout << b.AsString();
       r->PrintValue(swhat.Data(),"",y,yerr);
       
+      //__________Config. Histo
       h->SetBinContent(j+1,y);
       h->SetBinError(j+1,yerr);
       h->GetXaxis()->SetBinLabel(j+1,b.AsString().Data());
+      h->GetYaxis()->SetTitle(swhat.Data());
+      //__________
     }
   }
   
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
new file mode 100644
index 0000000..b2452fe
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
@@ -0,0 +1,201 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Mother class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsule)
+
+
+#include "AliLog.h"
+#include "TObject.h"
+#include <TString.h>
+#include <iostream>
+#include <string>
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "TObjArray.h"
+#include "TString.h"
+#include <fstream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsule::AliAnalysisMuMuSpectraCapsule() : TObject()
+{
+  /// Default ctor
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsule::~AliAnalysisMuMuSpectraCapsule()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(const char* file, Double_t* constantArray, const TString* spectraName)
+{
+  /**
+   *
+   * Set member constants depending on centrality bin from an ewternfile.
+   *
+   */
+
+    // Reset on fConstant
+    for (int i = 0; i < 10; ++i) constantArray[i]=0.;
+    Bool_t ok= kFALSE;
+    AliDebug(1,Form("Reading from file %s",file));
+
+    //________Open file
+    ifstream infile(file,std::ios::in);
+    TString line;
+    TObjArray* lineArray;
+
+    if (infile){
+        AliDebug(1, " ==== opening file ==== ");
+        // Loop until end of file is reached
+        while(infile.eof()!=kTRUE){
+
+            //read the line
+            line.ReadLine(infile,kFALSE);
+            if (line.BeginsWith("#"))continue;
+            AliDebug(1,Form(" Read line : %s",line.Data()));
+
+            // Put the line in a TObjArray
+            lineArray = line.Tokenize(" ");
+
+
+            // Select the good interval. Since interval is written in <binAsString>, just need them to match
+            TString centrality   =  static_cast<TObjString*>(lineArray->At(0))->String().Data();
+            TString intervalLow  =  TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(1))->String().Atof());
+            TString intervalHigh =  TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(2))->String().Atof());
+             AliDebug(1,Form(" --__--__-- interval low = %s",intervalLow.Data()));
+              AliDebug(1,Form(" --__--__-- interval high = %s",intervalHigh.Data()));
+            if (intervalLow.EqualTo("0.00")) intervalLow ="00.00";
+
+            // Select the good interval. Since interval is written in <binAsString>, just need them to match
+            if(spectraName->Contains(Form("%s",centrality.Data()))&& spectraName->Contains(Form("%s_%s",intervalLow.Data(),intervalHigh.Data())) && spectraName->Contains(Form("%s_%s",centrality.Data(),intervalLow.Data()))){
+                AliDebug(1,Form(" spectraName = %s",spectraName->Data()));
+                AliDebug(1,Form(" -- line selected -- "));
+                ok = kTRUE;
+                break;
+            }
+            else continue;
+        }
+        infile.close();
+        AliDebug(1, " ==== closing file ==== ");
+
+        // Store the value
+        for (int i =0 ; i<10 ; i++) {
+            constantArray[i]= static_cast<TObjString*>(lineArray->At(i+3))->String().Atof();
+        }
+        return ok;
+    }
+    else return ok;
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsule::PrintNofWhat(const char* what) const
+{
+  /// Print whar number for each results on terminal.
+
+
+  //Check point
+  if(!GetSpectra() || strcmp(what,"")==1 )
+    {
+      AliError("No Spectra or no arguments given !");
+      return ;
+    }
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+  // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  //Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    Int_t nofSubResult = 0; // Counter for subresult
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+
+    //Some variables
+    TString  binAsString(r->AsString());// Usefull for the coming loop
+
+    cout << Form(" -_-_-_-_- %s_%s -_-_-_-_- ",binAsString.Data(),GetSpectraName().Data()) << endl;
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+        AliError(Form("Cannot find subresult "));
+        return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      //Get quantities
+      Double_t NofJPsiSub      = subresult->GetValue(what);
+      Double_t NofJPsiErrorStat = subresult->GetErrorStat(what);
+
+      //Output messages
+      cout << Form(" -------- ") << endl;
+      cout << Form(" -- subresult %s :  %.0f +/- %.0f ",sr->GetName(),NofJPsiSub,NofJPsiErrorStat) << endl;
+      nofSubResult++;
+
+    }
+    cout << Form(" -------- ") << endl;
+    cout << Form(" ------ Mean :  %.0f +/- %.0f +/- %.0f ------ ",result->GetValue(what),result->GetErrorStat(what),result->GetRMS(what)) << endl;
+    cout << "" << endl;
+    nofResult++;
+  }
+}
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
new file mode 100644
index 0000000..1d9e0c3
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
@@ -0,0 +1,67 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULE_H
+#define ALINANALYSISMUMUSPECTRACAPSULE_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsule : mother class to all capsule class.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include <TString.h>
+#include "TObject.h"
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectraCapsule : public TObject
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsule();
+  //dctor
+  virtual ~AliAnalysisMuMuSpectraCapsule();
+  // Compute Yield
+  virtual TGraphErrors* ComputeYield(const char* what, const TH1* histo, const char* sResName) = 0;
+  // Draw fit results and save them if wanted
+  virtual void DrawResults(const char* printDirectoryPath, Bool_t Print, const char* particle)const = 0 ;
+  // Print some data members
+  virtual void Print(Option_t* opt) const = 0;
+  // Print constants used
+  virtual void PrintConst() const = 0;
+  // Number of "what" for all subresults
+  void PrintNofWhat(const char* what="") const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file, Double_t* constantArray, const TString* spectraName);
+
+  // Protection to be sure each daughter class returns data members
+  const virtual Double_t              * GetConstArray()   const =0;
+
+  const virtual AliAnalysisMuMuSpectra* GetSpectra()      const =0;
+
+  const virtual TString                 GetSpectraName() const  =0;
+
+  private:
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsule(const AliAnalysisMuMuSpectraCapsule& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsule& operator=(const AliAnalysisMuMuSpectraCapsule& rhs);// not implemented on purpose
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsule,1)
+/// \endcond;
+};
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx
new file mode 100644
index 0000000..04a5e4f
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx
@@ -0,0 +1,446 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePP.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePP)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePP.h"
+#include <fstream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+namespace
+{
+  const Double_t BR           = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME                     : Fnorm store in TH1, make in general
+  const Double_t Fnorm        = 11.827;    // Normalization
+  const Double_t FnormStat    = 0.011;     // Normalization
+  const Double_t FnormSyst    = 0.00;     // Normalization
+  //luminosity
+  const Double_t lumi        = 111.31; // nb^-1
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError = 3/100;
+  // Corr. error for centrality
+  const Double_t Traj         = 1./100.;
+  const Double_t Trigg        = 1./100.;
+  const Double_t Pair         = 2./100.;
+  const Double_t Tails        = 2./100.;
+  // Corr. error for pt case
+  const Double_t TrajPT       = 4./100.;
+  const Double_t TriggPT      = 2./100.;
+  const Double_t PairPt       = 2./100.;
+  // Corr. error for y case
+  const Double_t TrajY        = 4./100.;
+  const Double_t TriggY       = 2./100.;
+  const Double_t PairY        = 2./100.;
+}
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePP::AliAnalysisMuMuSpectraCapsulePP(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+  for (int i = 0; i < 10; ++i) fConstArray[i]=0.;
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePP::~AliAnalysisMuMuSpectraCapsulePP() 
+{
+  // dtor
+}
+
+TList* AliAnalysisMuMuSpectraCapsulePP::ComputePPCrossSection(const char* what) const
+{
+  /// Compute the PP cross section
+
+
+  AliAnalysisMuMuBinning* binning = fSpectra->Binning();
+  TObjArray* bins = binning->CreateBinObjArray();
+  TIter nextBin(bins);
+  AliAnalysisMuMuBinning::Range* bin;
+  Int_t i(0);
+  AliAnalysisMuMuResult* r;
+
+  const Double_t * binArrayX = binning->CreateBinArrayX();
+  Int_t nBinX = binning->GetNBinsX();
+
+  TGraphErrors * gCrossSection = new TGraphErrors(nBinX);
+  TGraphErrors * gSys = new TGraphErrors(nBinX);
+  TString sbin;
+
+  int j= 1;
+  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
+  {
+      r = static_cast<AliAnalysisMuMuResult*>(fSpectra->GetResultForBin(bin->AsString()));
+      if(j==1 && bin->AsString().Contains("PT"))sbin ="PT";
+      else if(j==1 && bin->AsString().Contains("Y"))sbin ="Y";
+      printf("sbin = %s\n",sbin.Data() );
+
+      if(sbin.Contains("PT") || sbin.Contains("Y"))
+      {
+        Double_t sigma      =0.;
+        Double_t sigmaerror =0.;
+
+        Double_t CorrNofJPsi=0.;
+        Double_t NofJPsi =0.;
+        Double_t NofJPsiError =0.;
+
+        CorrNofJPsi  =r->GetValue(what);
+        NofJPsi      =r->GetValue("NofJPsi");
+        NofJPsiError =r->GetErrorStat("NofJPsi");
+
+        if(CorrNofJPsi==0. || NofJPsi ==0.){
+          printf(" cannot found Corrected NofJpsi or NofJpsi, did you compute AccEff ? Abording...");
+          continue;
+        }
+
+        sigma      = r->GetValue(what)/(lumi*BR*1000.*bin->WidthX());
+        sigmaerror = sigma*(r->GetErrorStat("NofJPsi")/r->GetValue("NofJPsi"));
+
+        
+         // Get X
+        Double_t xmin = bin->Xmin();
+        Double_t xmax = bin->Xmax();
+        Double_t x = xmin + (xmax-xmin)/2;
+
+        Double_t error2 =(r->GetRMS("NofJPsi")/r->GetValue("NofJPsi"))*(r->GetRMS("NofJPsi")/r->GetValue("NofJPsi")) +0.01*0.01 + 0.01*0.01 + 0.02*0.02;
+        printf("  -------- cross section for bin %s = %f +/- %f +/- %f  -------- \n",bin->AsString().Data(), sigma, sigmaerror , sigma*TMath::Sqrt(error2));
+
+        gCrossSection->SetPoint(j,x,sigma);
+        gCrossSection->SetPointError(j,bin->WidthX()/2,sigmaerror);
+
+        gSys->SetPoint(j,x,sigma);
+        gSys->SetPointError(j,bin->WidthX()/2,sigma*TMath::Sqrt(error2));
+
+        j++;
+      }
+      else /*if(!sbin.Contains("PT") || !sbin.Contains("Y"))*/
+      {
+         Double_t jpsi = fSpectra->GetResultForBin("INTEGRATED")->GetValue("NofJPsi");
+         // Double_t AccEff = fSpectra->GetResultForBin("INTEGRATED")->GetValue("AccEffJPsi");
+         Double_t corrjpsi = fSpectra->GetResultForBin("INTEGRATED")->GetValue(what);
+         Double_t jpsisys = fSpectra->GetResultForBin("INTEGRATED")->GetRMS("NofJPsi");
+         Double_t jpsistat = fSpectra->GetResultForBin("INTEGRATED")->GetErrorStat("NofJPsi");
+
+         Double_t sigma = corrjpsi/(lumi*BR*1000.);
+         Double_t sigmastat = sigma*jpsistat/jpsi;
+         Double_t sigmasys2 = jpsisys/jpsi*jpsisys/jpsi  +Traj*Traj +    Pair*Pair +    Trigg*Trigg +   Tails*Tails;
+         //                                                   Tracking    Matching       Trigger        tails
+         //
+
+          printf("integrated cross section for  %s = %f +/- %f +/- %f #mubarn\n",fSpectra->GetName(),sigma,sigmastat,sigma*TMath::Sqrt(sigmasys2) );
+          return 0x0;
+      }
+  }
+
+
+  //Add and merge all Graph
+  TList* l = new TList();
+  l->SetOwner(kTRUE);
+  l->Add(gCrossSection);
+  l->Add(gSys);
+
+  delete binArrayX;
+
+  return l ;  
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePP::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+
+ printf("Not implemented yet \n");
+ return 0x0;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePP::DrawResults( const char* printDirectoryPath,Bool_t Print,const char* particle) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+
+  //Pointer for functions
+    TF1* f1 = 0x0;
+    TF1* f2 = 0x0;
+    TF1* f3 = 0x0;
+    TF1* f4 = 0x0;
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+  if ( fSpectraName.Contains(particle))
+      {
+      xmin = 2;
+      xmax = 6;
+      }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) {histos->Add(h);}
+      else
+      {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 )
+      {
+      nx = 2;
+      ny=0;
+      }
+  else if ( nofResult > 2 )
+      {
+      ny = TMath::Nint(TMath::Sqrt(nofResult));
+      nx = TMath::Nint((nofResult/ny) +0.6);
+      }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny,0,0);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      gPad->SetLogy();
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->GetXaxis()->SetRangeUser(1.,5.);
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      f1 = h->GetFunction("signal");
+      if(f1) f1->DrawCopy("same");
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  if (Print)
+  {
+    // Save Canvas
+    cout << "Printing ..." << endl;
+    c->Print(Form("%s/%s.pdf",printDirectoryPath,c->GetTitle()));
+  }
+  delete bins;
+  delete histos;
+}
+
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePP::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePP::PrintConst() const
+{
+    ///
+    /// Print member constants on the terminal
+    ///
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else{
+      cout <<      " ================================================================ " << endl;
+      cout << Form("      Constants for Spectra %s",fSpectraName.Data()) << endl;
+      cout <<      " ================================================================ " << endl;
+      cout <<  "   Branching ratio     = " <<  5.93/100 << endl; // 
+      //Normalization factor
+      //FIXME                          : Fnorm store in TH1, make in general
+      cout <<  "   FNorm               = " <<  11.827 << endl;    // 
+      cout <<  "   FNorm stat.         = " <<  0.011 << endl;     // Normalization
+      cout <<  "   FNorm syst.         = " <<  0.00 << endl;     // Normalization
+      
+      // Global MC sys. err. for centrality integrated in pt and Y
+      cout <<  "   Global MC sys. err. = " <<  3/100 << endl;
+      // Corr. error for centrality
+      cout <<  "  Traj. error          = " <<  4./100. << endl;
+      cout <<  "   Trigg. error        = " <<  2./100. << endl;
+      cout <<  "    Pari error         = " <<  2./100. << endl;
+      // Corr. error for pt case
+      cout <<  "  TrajPt. error        = " <<  4./100. << endl;
+      cout <<  "   TriggPt. error      = " <<  2./100. << endl;
+      cout <<  "    PariPt. error      = " <<  2./100. << endl;
+      // Corr. error for y case
+      cout <<  "  TrajY. error         = " <<  4./100. << endl;
+      cout <<  "   TriggY. error       = " <<  2./100. << endl;
+      cout <<  "    PariY. error       = " <<  2./100. << endl;
+  }
+}
+
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h
new file mode 100644
index 0000000..ddb8dc4
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h
@@ -0,0 +1,80 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPP_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPP_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbPb : helper class to deal with results stored in a spectra with PbPb methods.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePP : public AliAnalysisMuMuSpectraCapsule
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePP(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePP();
+  // Compute Yield
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Compute Cross-Section
+  TList* ComputePPCrossSection(const char* what ="CorrNofJPsi") const ;
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* printDirectoryPath="histo",Bool_t Print=kFALSE,const char* particle="PSI")const;
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const AliAnalysisMuMuSpectra* GetSpectra()       const {return fSpectra;};
+  const TString                GetSpectraName()    const {return fSpectraName;};
+   const Double_t              * GetConstArray()     const {return fConstArray;};
+
+private:
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePP(const AliAnalysisMuMuSpectraCapsulePP& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePP& operator=(const AliAnalysisMuMuSpectraCapsulePP& rhs);// not implemented on purpose
+
+
+private:
+
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+  Double_t fConstArray[10]; // Array to store constant according to centrality bins
+
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePP,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
new file mode 100644
index 0000000..2a61949
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
@@ -0,0 +1,819 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePbP)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+#include <iostream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+namespace
+{
+
+  const Double_t BR             = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME : Fnorm store in TH1, make in general
+  const Double_t Fnorm          = 27.51;    // Normalization
+  const Double_t FnormStat      = 0.01;     // Normalization
+  const Double_t FnormSyst      = 0.97;     // Normalization
+  //pp Cross-section integrated in pt,y
+  const Double_t sigmaPP        = 3.343;    // for fully integrated case
+  const Double_t dsigmaPP       = 0.033;    // idem
+  const Double_t dsigmaPPCorr   = 0.022;    // for fully integrated case
+  const Double_t dsigmaPPUncorr = 0.021;    // idem
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError   = 3/100;
+  // Corr. error for centrality
+  const Double_t TrajCENT       = 11/100;
+  const Double_t TriggCENT      = 2/100;
+  const Double_t PairCENT       = 1/100;
+  // Corr. error for pt case
+  const Double_t TrajPT         = 1/100;
+  const Double_t TriggPT        = 1/100;
+  const Double_t PairPt         = 1/100;
+  // Corr. error for y case
+  const Double_t TrajY          = 1/100;
+  const Double_t TriggY         = 1/100;
+  const Double_t PairY          = 1/100;
+}
+
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePbP::AliAnalysisMuMuSpectraCapsulePbP(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath,
+const char                  * externFile,
+const char                  * externFile2)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath),
+  fExternFile(externFile),
+  fExternFile2(externFile2)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+
+  if(!AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(fExternFile2,&fConstArray[0],&fSpectraName))
+  {
+    AliWarning(Form("No extern file readed"));
+  }
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePbP::~AliAnalysisMuMuSpectraCapsulePbP()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePbP::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+
+  if(!GetSpectra() || histo==0x0|| strcmp(what,"")==1) return 0x0;
+
+  // Some constants
+  const TString graphTitle = Form("%s-YIELD",GetSpectraName().Data());
+  TString sres(sResName);
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  // TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (GetSpectraName().Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    // graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (GetSpectraName().Contains("-PT")|| GetSpectraName().Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    // graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Store quantities
+    Double_t NofWhattTot = result->GetValue(what,sres.Data());
+    Double_t NofWhattTotError = result->GetErrorStat(what,sres.Data());
+
+    Double_t nEqMBTot      = histo->GetBinContent(nofResult+1);
+    Double_t nEqMBTotError = histo->GetBinError(nofResult+1);
+
+    AliDebug(1,Form("histo used    : %s",histo->GetTitle()));
+    AliDebug(1,Form("%s            = %f",what,NofWhattTot));
+    AliDebug(1,Form("%s error      = %f",what,NofWhattTotError));
+    AliDebug(1,Form("nEqMBTot      = %f",nEqMBTot));
+    AliDebug(1,Form("nEqMBTotError = %f",nEqMBTotError));
+
+    if( NofWhattTot==0||NofWhattTotError==0||nEqMBTot==0||nEqMBTotError==0)
+    {
+      AliError("Cannot set quantities properly");
+      return 0x0;
+    }
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(GetSpectraName().Contains("-INTEGRATED"))
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],yieldInt);
+      graph->SetPointError(nofResult,fConstArray[1],yieldIntError);
+      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult];
+      graph->SetPoint(nofResult,binCenter,yieldInt);
+      graph->SetPointError(nofResult,r->WidthX()/5,yieldInt);
+      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(GetSpectraName().Contains("-INTEGRATED"))graph->GetXaxis()->SetTitle(Form("INTEGRATED"));
+  else if (GetSpectraName().Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (GetSpectraName().Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("Yield");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+ return graph ;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::DrawResults( const char* printDirectoryPath,Bool_t Print,const char* particle) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+
+  //Pointer for functions
+    TF1* f1 = 0x0;
+    TF1* f2 = 0x0;
+    TF1* f3 = 0x0;
+    TF1* f4 = 0x0;
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+  if ( fSpectraName.Contains(particle))
+      {
+      xmin = 2;
+      xmax = 6;
+      }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) {histos->Add(h);}
+      else
+      {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 )
+      {
+      nx = 2;
+      ny=0;
+      }
+  else if ( nofResult > 2 )
+      {
+      ny = TMath::Nint(TMath::Sqrt(nofResult));
+      nx = TMath::Nint((nofResult/ny) +0.6);
+      }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  if (Print)
+  {
+    // Save Canvas
+    cout << "Printing ..." << endl;
+    c->Print(Form("%s/%s.pdf",printDirectoryPath,c->GetTitle()));
+  }
+  delete bins;
+  delete histos;
+}
+
+
+//_____________________________________________________________________________
+TGraphErrors * AliAnalysisMuMuSpectraCapsulePbP::RpAAsGraphic(Double_t MUL) const
+{
+  /**
+   *
+   * Run over each bin, calculate R_pA according to fBinType throught GetValuesFromExternFiles() :
+   * Return a graph to be deleted by owner.
+   *
+   */
+
+  // Some constants
+  const TString histoName = Form("%s",fSpectraName.Data());
+
+  //Check point
+  if(!GetSpectra() || fExternFile.IsNull() ) return 0x0 ;
+
+  //Check point
+  if (MUL==0)
+  {
+    AliError(Form("NofMUL is null"));
+    return 0x0;
+  }
+
+  AliError("To be implemented !");
+  return 0x0;
+
+
+ //  // Pointers to handle results and subresults and binning
+ //  AliAnalysisMuMuResult    * result;
+ //  AliAnalysisMuMuBinning   ::Range* r;
+
+ // // Array to store bins for the while loop
+ //  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+ //  if (!bins)
+ //  {
+ //    AliError(Form("Cannot find bins"));
+ //    return 0x0;
+ //  }
+ //  // Array for listed quantities
+ //  Double_t num[8]={0.};
+ //  //  num[0]   ,  num[1]   ,   num[2]   ,   num[3]  ,  num[4] ,  num[5]  ,   num[6]   ,   num[7]
+ //  //  NofJpsi     JPsiStat     JPsiSyst     NormTot    RAA       StatErr     SystCorrErr  SystUnCorrErr
+ //  // --------------------------
+
+ //  // Here we define some pointers
+ //  TGraphErrors*graph(0x0);
+ //  // TGraphErrors*graph_sysUncorr(0x0);
+
+ //  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+ //  Int_t binsX = 0;
+
+ //  //________Define histo according to bin type
+ //  if (fSpectraName.Contains("-INTEGRATED"))
+ //  {
+ //    graph           = new TGraphErrors(1);
+ //    // graph_sysUncorr = new TGraphErrors(1);
+ //    graph->SetTitle(histoName.Data());
+ //    graph->SetMinimum(0.);
+ //    graph->SetMaximum(1.2);
+ //    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+ //  }
+ //  else if (fSpectraName.Contains("-PT")|| fSpectraName.Contains("-Y"))
+ //  {
+ //    binArray =GetSpectra()->Binning()->CreateBinArray();
+ //    binsX    = GetSpectra()->Binning()->GetNBinsX();
+
+ //    if (!binArray)
+ //    {
+ //      AliError(Form("Cannot set binArray"));
+ //      return 0x0;
+ //    }
+ //    if (binsX==0)
+ //    {
+ //      AliError(Form("Cannot set binsX"));
+ //      return 0x0;
+ //    }
+
+ //    graph           = new TGraphErrors(binsX);
+ //    // graph_sysUncorr = new TGraphErrors(binsX);
+ //    graph->SetTitle(histoName.Data());
+ //    graph->SetMinimum(0.);
+ //    graph->SetMaximum(1.2);
+ //    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+ //  }
+ //  else
+ //  {
+ //    cout << "Unknowned Bin type !" << endl;
+ //    return 0x0;
+ //  }
+ //  //________
+
+ //  //________Counters and Iterator for bin
+ //  Int_t nofResult = 0;
+ //  TIter nextBin(bins);
+ //  nextBin.Reset();
+ //  //________
+
+ //  // Loop on bins
+ //  //==============================================================================
+ //  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+ //  {
+ //    //________Make bin a MuMuResult
+ //    result = GetSpectra()->GetResultForBin(*r);
+ //    if (!result)
+ //    {
+ //      AliError(Form("Cannot find result "));
+ //      return 0x0;
+ //    }
+ //    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+ //    //________
+
+ //    // Get a string with bin name
+ //    TString binAsString = r->AsString();
+
+ //    // Store quantities
+ //    num[0] = result->GetValue("NofJPsi");
+ //    num[1] = result->GetErrorStat("NofJPsi");
+ //    num[2] = result->GetRMS("NofJPsi");
+
+ //    GetValuesFromExternFile(binAsString,&num[0],MUL);
+
+ //    //________Compute R_AA in case of fully integrated spectra
+ //    if(fSpectraName.Contains("-INTEGRATED"))
+ //    {
+ //      //Output messages
+ //      cout << Form("") << endl;
+ //      cout << Form("  |    %s    |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+
+ //      // Add results to TGraphs
+ //      graph->SetPoint(nofResult,fConstArray[0],num[4]);
+ //      graph->SetPointError(nofResult,fConstArray[1],num[5]);
+ //      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+ //      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+ //    }
+ //    else
+ //    {
+ //      num[4]=num[4]/(r->WidthX());
+ //      cout << Form("") << endl;
+ //      cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+ //      //Fill graph
+ //      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult] ;
+ //      graph->SetPoint(nofResult,binCenter,num[4]);
+ //      graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+ //      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+ //      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+ //    }
+ //    //________
+
+ //    nofResult++;
+ //  }
+
+ //  // Config. graphics
+ //  if(fSpectraName.Contains("INTEGRATED"))graph->GetXaxis()->SetTitle(Form("<NPart>"));
+ //  else if (fSpectraName.Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+ //  else if (fSpectraName.Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+ //  graph->GetYaxis()->SetTitle("R_{pA}");
+ //  graph->SetMarkerColor(4);
+ //  graph->SetMarkerStyle(21);
+
+ //  // delete graph;
+ //  // delete graph_sysUncorr;
+ //  delete bins;
+ //  delete binArray;
+
+ // return graph ;
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::GetValuesFromExternFile(TString sbin, Double_t numArray[], Double_t MUL) const
+{
+  /**
+   *
+   * Checks bin type and read files (or not) accordingly. Then computes and stores several results in numArray.
+   *
+   */
+
+  AliWarning("INNER NORMALIZATION FACTOR, YOU MIGHT CHECK THE CODE !!");
+
+  AliError("To be implemented !");
+  return;
+
+  // //________PT and Y case
+  // if (fSpectraName.Contains("-PT") || fSpectraName.Contains("-Y"))
+  // {
+  //   char status;
+
+  //    //________Arrays to store quantities from externFile
+  //   float intervalArray[2];
+  //   // intervalLow , intervalHight
+  //   //      0      ,      1
+  //   float valueArray[10];
+  //   //    sigmapp   dsigmapp   dsigmappCorr   dsigmappUncorr  AccEff   dAccEff  sysMC   TrajEffError  TriggerError   PairError
+  //   //________ﬁ
+
+  //   //________Open file
+  //   FILE*  infile;
+  //   infile = fopen(fExternFile.Data(),"rb") ;
+
+  //   if (infile != NULL)
+  //   {
+  //     AliDebug(1, " ==== opening file ==== ");
+  //     // Loop until end of file is reached
+  //     while(!feof(infile))
+  //     {
+  //       // Reminder :
+  //       // intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff sysMC TrajEffError  TriggerError   PairError;
+  //       // Store value in array
+  //       fscanf(infile,"%s %f_%f %f %f %f %f %f %f %f %f %f %f",&status,&intervalArray[0],&intervalArray[1],
+  //                                                  &valueArray[0],&valueArray[1],&valueArray[2],&valueArray[3],&valueArray[4],
+  //                                                  &valueArray[5],&valueArray[6],&valueArray[7],&valueArray[8],&valueArray[9]);
+  //       if(status == 'F') continue; // F = false, T =true
+  //       // Make intervalArray a string
+  //       TString intervalLow  = TString::Format("%.2f",intervalArray[0]);
+  //       TString intervalHigh = TString::Format("%.2f",intervalArray[1]);
+
+  //       // Select the good interval. Since interval is written in <binAsString>, just need them to match
+  //       if(sbin.Contains(Form("%s",intervalLow.Data())) && sbin.Contains(Form("%s",intervalHigh.Data())))
+  //       {
+  //         // Check Point
+  //         AliDebug(1,Form(" -- Selected line :"));
+  //         AliDebug(1,Form(" -- intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff  sysMC TrajEffError  TriggerError   PairErrorﬁ"));
+  //         AliDebug(1,Form(" --  %.2f  %.2f  %f  %f  %f  %f  %f  %f  %f  %f  %f  %f ",
+  //         intervalArray[0],intervalArray[1],valueArray[0],valueArray[1],valueArray[2],valueArray[3],valueArray[4],valueArray[5],valueArray[6],valueArray[7],valueArray[8],valueArray[9]));
+
+  //         //Normalization according to centrality bin
+  //         if (fSpectraName.Contains("V0M_00.00_90.00"))
+  //         {
+  //           numArray[3] = fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+  //         }
+  //         else
+  //         {
+  //           numArray[3] = (1./9.)*fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+  //         }
+
+  //         numArray[4] = numArray[0]/numArray[3];
+
+  //       }
+  //       else
+  //       {
+  //         AliDebug(1,Form("Not the good interval, so continue ...."));
+  //         continue;
+  //       }
+  //     }
+  //     fclose(infile);
+  //     AliDebug(1, " ==== Closing file ==== ");
+  //   }
+  //   else
+  //   {
+  //     cout << Form("Cannot open configuration file %s ",fExternFile.Data()) << endl;
+  //     return;
+  //   }
+  //   //________
+
+  //   if (fSpectraName.Contains("-PT") )
+  //   {
+  //     // Normalization factor due to how PP cross-section are calculated
+  //     numArray[4] = numArray[4]/1.5;
+
+  //     //Corr
+  //     numArray[6] = numArray[4] * TMath::Sqrt(TrajPT                       *TrajPT                       + // Traj. reconstruction Eff.
+  //                                             TriggPT                      *TriggPT                      + // Trigg Eff.
+  //                                             FnormSyst/Fnorm              *FnormSyst/Fnorm              + // Fnorm Syst
+  //                                             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2]+ // TAA syst.
+  //                                             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);  // dsigma_pp_Corr/sigma_pp
+
+
+  //   }
+  //   else if (fSpectraName.Contains("-Y"))
+  //   {
+  //     //Corr
+  //     numArray[6] = numArray[4] * TMath::Sqrt(TrajY                        *TrajY                         + // Traj. reconstruction Eff.
+  //                                             TriggY                       *TriggY                        + // Trigg Eff.
+  //                                             FnormSyst/Fnorm              *FnormSyst/Fnorm               + // Fnorm Syst
+  //                                             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2] + // TAA syst.
+  //                                             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);   // dsigma_pp_Corr/sigma_pp
+
+  //   }
+  //   else
+  //   {
+  //     AliError("Unowned bin type... I Told you !");
+  //     return;
+  //   }
+
+  //   //Stat
+  //   numArray[5] = numArray[4] * TMath::Sqrt(numArray[1]/numArray[0]    *numArray[1]/numArray[0]     + // Jpsi extraction
+  //                                           valueArray[1]/valueArray[0]*valueArray[1]/valueArray[0] ); // dsigma_pp/sigma_pp
+
+  //   //UnCorr
+  //   numArray[7] = numArray[4] * TMath::Sqrt(valueArray[6]             *valueArray[6]                   + // MC param.
+  //                                           numArray[2]/numArray[0]   *numArray[2]/numArray[0]         + // Signal extraction
+  //                                           valueArray[7]             *valueArray[7]                   + // Traj. Eff.
+  //                                           valueArray[8]             *valueArray[8]                   + // Trigg. Eff.
+  //                                           valueArray[9]             *valueArray[9]                   + // Pair. Eff.
+  //                                           valueArray[3]/valueArray[0]*valueArray[3]/valueArray[0]);     // dsigma_pp_Uncorr/sigma_pp
+  // }
+
+  // //________Compute R_AA in case of integrated spectra in PT and Y
+  // else if(fSpectraName.Contains("-INTEGRATED"))
+  // {
+  //   //Get quantities
+
+  //   //Normalization according to centrality bin
+  //   if (!fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = BR*fConstArray[2]*(Fnorm*MUL/9)*(sigmaPP/1000)*(fConstArray[8]);
+  //   else                                           numArray[3] = BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+  //   numArray[4] = numArray[0]/numArray[3];
+
+  //   //Stat error
+  //   numArray[5] = numArray[4] * TMath::Sqrt((numArray[1]/numArray[0])*(numArray[1]/numArray[0]) + // Jpsi extraction
+  //                                                    dsigmaPP/sigmaPP*dsigmaPP/sigmaPP          ); // dsigma_pp/sigma_pp
+  //   //Corr error
+  //   numArray[6] = numArray[4] * TMath::Sqrt(MCParamError        *MCParamError         + // MCParamError
+  //                                           fConstArray[4]      *fConstArray[4]       + // Traj. reconstruction Eff.
+  //                                           fConstArray[5]      *fConstArray[5]       + // Trig. Eff.
+  //                                           fConstArray[6]      *fConstArray[6]       + // Pair Reconst. Eff.
+  //                                           dsigmaPPCorr/sigmaPP*dsigmaPPCorr/sigmaPP + // dsigma_pp_Corr/sigma_pp
+  //                                           FnormSyst/Fnorm     *FnormSyst/Fnorm);      // Fnorm Syst
+  //   //Uncorr error
+  //   numArray[7] = numArray[4] * TMath::Sqrt(numArray[2]/numArray[0]      *numArray[2]/numArray[0]      + // Signal extraction
+  //                                           fConstArray[1]/fConstArray[0]*fConstArray[1]/fConstArray[0]);// TAA syst.
+  // }
+  // else
+  // {
+  //   AliError("Unowned bin type... I Told you !");
+  //   return;
+  // }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::PrintConst() const
+{
+  /**
+   *
+   * Print member constants
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else
+  {
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" Constants for Spectra %s",fSpectraName.Data()) << endl;
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" -- Value of <Npart>     = %f",fConstArray[0]) << endl;
+    cout << Form(" -- Value of d<Npart>    = %f",fConstArray[1]) << endl;
+    cout << Form(" -- Value of TAA         = %f",fConstArray[2]) << endl;
+    cout << Form(" -- Value of dTAA        = %f",fConstArray[3]) << endl;
+    cout << Form(" -- Value of sys.AP      = %f",fConstArray[4]) << endl;
+    cout << Form(" -- Value of Traj. err.  = %f",fConstArray[5]) << endl;
+    cout << Form(" -- Value of Trigg. err. = %f",fConstArray[6]) << endl;
+    cout << Form(" -- Value of Pair. err.  = %f",fConstArray[7]) << endl;
+    cout << Form(" -- Value of AccEff      = %f",fConstArray[8]) << endl;
+    cout << Form(" -- Value of dAccEff     = %f",fConstArray[9]) << endl;
+  }
+}
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
new file mode 100644
index 0000000..9f727d5
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
@@ -0,0 +1,87 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPBP_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPBP_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbP : helper class to deal with results stored in a spectra with pPb methods.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePbP : public AliAnalysisMuMuSpectraCapsule
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePbP(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="",
+                             const char                              * externFile="",
+                             const char                              * externFile2="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePbP();
+  // Compute Yield
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* printDirectoryPath="histo",Bool_t Print=kFALSE,const char* particle="PSI")const;
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+  // Compute R_pA
+  TGraphErrors* RpAAsGraphic(Double_t MUL) const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const Double_t              * GetConstArray() const {return fConstArray;};
+  const AliAnalysisMuMuSpectra* GetSpectra()    const {return fSpectra;};
+  const TString                GetSpectraName() const {return fSpectraName;};
+
+private:
+  // Read and compute values from extern file
+  void GetValuesFromExternFile(TString sbin, Double_t numArray[],Double_t MUL) const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file);
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePbP(const AliAnalysisMuMuSpectraCapsulePbP& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePbP& operator=(const AliAnalysisMuMuSpectraCapsulePbP& rhs);// not implemented on purpose
+
+
+private:
+  TString fExternFile;      // name of spectra selected
+  TString fExternFile2;     // name of spectra selected
+  Double_t fConstArray[10]; // Array to store constant according to centrality bins
+
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePbP,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
new file mode 100644
index 0000000..61c8a76
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
@@ -0,0 +1,806 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePbPb)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+#include <fstream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+namespace
+{
+  const Double_t BR             = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME : Fnorm store in TH1, make in general
+  const Double_t Fnorm          = 11.827;    // Normalization
+  const Double_t FnormStat      = 0.011;     // Normalization
+  const Double_t FnormSyst      = 0.12;     // Normalization
+  //pp Cross-section integrated in pt,y
+  const Double_t sigmaPP        = 5.457857;    // for fully integrated case
+  const Double_t dsigmaPP       = 9.950825e-02;    // idem
+  const Double_t dsigmaPPCorr   = 0.022;    // for fully integrated case
+  const Double_t dsigmaPPUncorr = 0.021;    // idem
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError   = 3.;//%
+  // Corr. error for centrality
+  const Double_t TrajCENT       = 4.;//%
+  const Double_t TriggCENT      = 2.;//%
+  const Double_t PairCENT       = 2.;//%
+  // Corr. error for pt case
+  const Double_t TrajPT         = 4.;//%
+  const Double_t TriggPT        = 2.;//%
+  const Double_t PairPt         = 2.;//%
+  // Corr. error for y case
+  const Double_t TrajY          = 4.;//%
+  const Double_t TriggY         = 2.;//%
+  const Double_t PairY          = 2.;//%
+}
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePbPb::AliAnalysisMuMuSpectraCapsulePbPb(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath,
+const char                  * externFile,
+const char                  * externFile2)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath),
+  fExternFile(externFile),
+  fExternFile2(externFile2)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+
+  if(!AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(fExternFile2,&fConstArray[0],&fSpectraName))
+  {
+    AliWarning(Form("No extern file readed"));
+  }
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePbPb::~AliAnalysisMuMuSpectraCapsulePbPb()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePbPb::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+
+  if(!GetSpectra() || histo==0x0|| strcmp(what,"")==1) return 0x0;
+
+  // Some constants
+  const TString graphTitle = Form("%s-YIELD",GetSpectraName().Data());
+  TString sres(sResName);
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  // TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (GetSpectraName().Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    // graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (GetSpectraName().Contains("-PT")|| GetSpectraName().Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    // graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Store quantities
+    Double_t NofWhattTot = result->GetValue(what,sres.Data());
+    Double_t NofWhattTotError = result->GetErrorStat(what,sres.Data());
+
+    Double_t nEqMBTot      = histo->GetBinContent(nofResult+1);
+    Double_t nEqMBTotError = histo->GetBinError(nofResult+1);
+
+    AliDebug(1,Form("histo used    : %s",histo->GetTitle()));
+    AliDebug(1,Form("%s            = %f",what,NofWhattTot));
+    AliDebug(1,Form("%s error      = %f",what,NofWhattTotError));
+    AliDebug(1,Form("nEqMBTot      = %f",nEqMBTot));
+    AliDebug(1,Form("nEqMBTotError = %f",nEqMBTotError));
+
+    if( NofWhattTot==0||NofWhattTotError==0||nEqMBTot==0||nEqMBTotError==0)
+    {
+      AliError("Cannot set quantities properly");
+      return 0x0;
+    }
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(GetSpectraName().Contains("-INTEGRATED"))
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],yieldInt);
+      graph->SetPointError(nofResult,fConstArray[1],yieldIntError);
+      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult];
+      graph->SetPoint(nofResult,binCenter,yieldInt);
+      graph->SetPointError(nofResult,r->WidthX()/5,yieldInt);
+      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(GetSpectraName().Contains("-INTEGRATED"))graph->GetXaxis()->SetTitle(Form("INTEGRATED"));
+  else if (GetSpectraName().Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (GetSpectraName().Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("Yield");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+ return graph ;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::DrawResults( const char* printDirectoryPath,Bool_t Print,const char* particle) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+
+  //Pointer for functions
+    TF1* f1 = 0x0;
+    TF1* f2 = 0x0;
+    TF1* f3 = 0x0;
+    TF1* f4 = 0x0;
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+  if ( fSpectraName.Contains(particle))
+      {
+      xmin = 2;
+      xmax = 6;
+      }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) {histos->Add(h);}
+      else
+      {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 )
+      {
+      nx = 2;
+      ny=0;
+      }
+  else if ( nofResult > 2 )
+      {
+      ny = TMath::Nint(TMath::Sqrt(nofResult));
+      nx = TMath::Nint((nofResult/ny) +0.6);
+      }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny,0,0);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      gPad->SetLogy();
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->GetXaxis()->SetRangeUser(1.,5.);
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      f1 = h->GetFunction("signal");
+      if(f1) f1->DrawCopy("same");
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  if (Print)
+  {
+    // Save Canvas
+    cout << "Printing ..." << endl;
+    c->Print(Form("%s/%s.pdf",printDirectoryPath,c->GetTitle()));
+  }
+  delete bins;
+  delete histos;
+}
+
+
+//_____________________________________________________________________________
+TList * AliAnalysisMuMuSpectraCapsulePbPb::RAAasGraphic(Double_t MUL) const
+{
+  /**
+   *
+   * Run over each bin, calculate RAA according to fBinType throught GetValuesFromExternFiles() :
+   * Return a graph to be deleted by owner.
+   *
+   */
+
+  // Some constants
+  const TString histoName = Form("%s",fSpectraName.Data());
+
+  //Check point
+  if(!GetSpectra() || fExternFile.IsNull() ) return 0x0 ;
+
+  //Check point
+  if (MUL==0)
+  {
+    AliError(Form("NofMUL is null"));
+    return 0x0;
+  }
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+  // Array for listed quantities
+  Double_t num[8]={0.};
+  //  num[0]   ,  num[1]   ,   num[2]   ,   num[3]  ,  num[4] ,  num[5]  ,   num[6]   ,   num[7]
+  //  NofJpsi     JPsiStat     JPsiSyst     NormTot    RAA       StatErr     SystCorrErr  SystUnCorrErr
+  // --------------------------
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (fSpectraName.Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(histoName.Data());
+    graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (fSpectraName.Contains("-PT")|| fSpectraName.Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX    = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(histoName.Data());
+    graph->SetMinimum(0.);
+    graph->SetMaximum(1.2);
+    graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Get a string with bin name
+    TString binAsString = r->AsString();
+
+    // Store quantities
+    num[0] = result->GetValue("NofJPsi");
+    num[1] = result->GetErrorStat("NofJPsi");
+    num[2] = result->GetRMS("NofJPsi");
+
+    //Main methods
+    if(!ComputeRAA(binAsString,&num[0],MUL)) continue;
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(fSpectraName.Contains("-INTEGRATED"))
+    {
+      //Output messages
+      cout << Form("") << endl;
+      cout << Form("  |    %s    |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.1f   %.1f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],num[4]);
+      graph->SetPointError(nofResult,fConstArray[1],num[5]);
+      graph_sysUncorr->SetPoint(nofResult,fConstArray[0],num[4]);
+      graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else if (fSpectraName.Contains("-PT"))
+    {
+      num[4]=num[4]/(r->WidthX());
+      cout << Form("") << endl;
+      cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.1f   %.1f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult] ;
+      graph->SetPoint(nofResult,binCenter,num[4]);
+      graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+      graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    else if (fSpectraName.Contains("-Y"))
+        {
+        num[4]=num[4]/(r->WidthX());
+        cout << Form("") << endl;
+        cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.1f   %.1f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+        //Fill graph
+        Double_t binCenter = -((binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult]) ;
+        graph->SetPoint(nofResult,binCenter,num[4]);
+        graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+        graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+        graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+        }
+    else return 0x0;
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(fSpectraName.Contains("INTEGRATED"))graph->GetXaxis()->SetTitle(Form("<NPart>"));
+  else if (fSpectraName.Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (fSpectraName.Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("R_{AA}");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  //Add and merge all Graph
+  TList* l = new TList();
+  l->SetOwner(kTRUE);
+  l->Add(graph);
+  l->Add(graph_sysUncorr);
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+  return l ;
+}
+
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsulePbPb::ComputeRAA(TString sbin, Double_t numArray[], Double_t MUL) const
+{
+  /**
+   *
+   * Checks bin type and read files (or not) accordingly. Then computes and stores several results in numArray.
+   *
+   */
+
+  AliWarning("INNER NORMALIZATION FACTOR, YOU MIGHT CHECK THE CODE !!");
+
+  //________PT and Y case
+  if (fSpectraName.Contains("-PT") || fSpectraName.Contains("-Y"))
+  {
+    // read exterfile and get the correct value
+    float valueArray[10];
+    //  valueArray[0], valueArray[1], valueArray[2], valueArray[3],  valueArray[4], valueArray[5], valueArray[6], valueArray[7], valueArray[8], valueArray[9]
+    //  sigmapp         dsigmapp      dsigmappCorr   dsigmappUncorr  AccEff         dAccEff        sysMC          TrajEffError    TriggerError  PairError
+
+    if(ReadFromFile(sbin,&valueArray[0])==kFALSE) return kFALSE;
+    AliDebug(1, " Values correctly read from extern file");
+
+    //Normalization according to centrality bin
+    if (fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+    else numArray[3] = (1./9.)*fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+
+    AliDebug(1,Form("BR          = %f\n", BR));
+    AliDebug(1,Form("Fnorm       = %f\n", Fnorm));
+    AliDebug(1,Form("sigma pp    = %f ub \n", valueArray[0]));
+    AliDebug(1,Form("AccEff      = %f\n", valueArray[4]));
+    AliDebug(1,Form("TAA         = %f\n", fConstArray[2]));
+    AliDebug(1,Form("MUL         = %f\n", MUL));
+    AliDebug(1,Form("denominator = %f\n", numArray[3]));
+
+    //Compute RAA
+    numArray[4] = numArray[0]/numArray[3];
+
+    //Corr
+    if (fSpectraName.Contains("-PT") ) numArray[6]    = numArray[4] * AliAnalysisMuMuResult::ErrorABCDE(100.,TrajPT,100.,TriggPT,Fnorm,FnormSyst,fConstArray[2],fConstArray[3],valueArray[0],valueArray[2]);
+    else if (fSpectraName.Contains("-Y")) numArray[6] = numArray[4] * AliAnalysisMuMuResult::ErrorABCDE(100.,TrajY,100.,TriggY,Fnorm,FnormSyst,fConstArray[2],fConstArray[3],valueArray[0],valueArray[2]);
+    else {
+      AliError("Unowned bin type... I Told you !");
+      return kFALSE;
+    }
+
+    //Stat error
+    numArray[5] = numArray[4] * AliAnalysisMuMuResult::ErrorABC(numArray[0],numArray[1],valueArray[0],valueArray[1],Fnorm,FnormStat);
+    //                                                                      signal                    sigmaPP               FNorm
+    //UnCorr error
+    numArray[7] = numArray[4] * AliAnalysisMuMuResult::ErrorABCD(100.,valueArray[6],numArray[0],numArray[2],100.,valueArray[7],100.,valueArray[8])
+    //                                                                sysMC                 signal           TrajEffError      TriggerError
+                + numArray[4] * AliAnalysisMuMuResult::ErrorAB(100.,valueArray[9],valueArray[0],valueArray[3]);
+    //                                                                pair                sigmapp
+  }
+  //________Integrated case
+  else if(fSpectraName.Contains("-INTEGRATED")){
+    //Normalization according to centrality bin
+    if (!fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = (1./9.)*BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+    else                                           numArray[3] = BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+    numArray[4] = numArray[0]/numArray[3];
+    //Stat error
+    numArray[5] = numArray[4] * AliAnalysisMuMuResult::ErrorAB(numArray[0],numArray[1],sigmaPP,dsigmaPP);
+    //                                                          signal                 sigmaPP
+    //Corr error
+    numArray[6] = numArray[4] * AliAnalysisMuMuResult::ErrorABC(100.,MCParamError,100.,fConstArray[5],100.,fConstArray[6])
+    //                                                         MC                  sys.AP             Traj. err
+                              * AliAnalysisMuMuResult::ErrorABC(100.,fConstArray[6],sigmaPP,dsigmaPPCorr,Fnorm,FnormSyst);
+    //                                                              Trigg. err          sigmaCorr          Fnorm
+    //Uncorr error
+    numArray[7] = numArray[4] * AliAnalysisMuMuResult::ErrorABC(numArray[0],numArray[2],fConstArray[2],fConstArray[3], 100.,fConstArray[4]);
+    //                                                                  signal                       TAA                       AP
+  }
+  else {
+    AliError("Unowned bin type... I Told you !");
+    return kFALSE;
+  }
+ 
+ return kTRUE;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::PrintConst() const
+{
+    ///
+    /// Print member constants on the terminal
+    ///
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else{
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" Constants for Spectra %s",fSpectraName.Data()) << endl;
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" -- Value of <Npart>     = %f",fConstArray[0]) << endl;
+    cout << Form(" -- Value of d<Npart>    = %f",fConstArray[1]) << endl;
+    cout << Form(" -- Value of TAA         = %f",fConstArray[2]) << endl;
+    cout << Form(" -- Value of dTAA        = %f",fConstArray[3]) << endl;
+    cout << Form(" -- Value of sys.AP      = %f",fConstArray[4]) << endl;
+    cout << Form(" -- Value of Traj. err.  = %f",fConstArray[5]) << endl;
+    cout << Form(" -- Value of Trigg. err. = %f",fConstArray[6]) << endl;
+    cout << Form(" -- Value of Pair. err.  = %f",fConstArray[7]) << endl;
+    cout << Form(" -- Value of AccEff      = %f",fConstArray[8]) << endl;
+    cout << Form(" -- Value of dAccEff     = %f",fConstArray[9]) << endl;
+  }
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsulePbPb::ReadFromFile(TString sbin, float valueArray[]) const
+{
+    ///
+    /// Read extern file lines and store associated values. Exemple of line :
+    /// #intervalLow    intervalHight   sigmapp dsigmapp    dsigmappCorr    dsigmappUncorr  AccEff dAccEff  sysMC TrajEffError  TriggerError    PairError
+    /// 00              01              0.6413  0.02611     0.000           0.000           0.1435 0.0009   0.000 0.000         0.04            0.00
+    ///
+    /// All white space must be single whitespace, i.e " " and not "<tab>"
+
+    Bool_t ok =kFALSE;
+
+    //________Open file
+    ifstream infile(fExternFile.Data(),std::ios::in);
+    TString line;
+    TObjArray* lineArray;
+
+    if (infile)
+    {
+      AliDebug(1, " ==== opening file ==== ");
+      // Loop until end of file is reached
+      while(infile.eof()!=kTRUE){
+
+        //read the line
+        line.ReadLine(infile,kFALSE);
+        if (line.BeginsWith("#"))continue;
+        AliDebug(1,Form(" Read line : %s",line.Data()));
+
+        // Put the line in a TObjArray
+        lineArray = line.Tokenize(" ");
+
+        // Select the good interval. Since interval is written in <binAsString>, just need them to match
+        TString intervalLow  = TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(0))->String().Atof());
+        TString intervalHigh = TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(1))->String().Atof());
+        if(sbin.Contains(Form("%s",intervalLow.Data())) && sbin.Contains(Form("%s",intervalHigh.Data()))){
+            AliDebug(1,Form(" -- line selected -- "));
+            ok = kTRUE;
+            break;
+        }
+        else continue;
+      }
+      infile.close();
+      AliDebug(1, " ==== closing file ==== ");
+
+      // Store the value
+        for (int i =0 ; i<10 ; i++) {
+            valueArray[i]= static_cast<TObjString*>(lineArray->At(i+2))->String().Atof();
+        }
+        return ok;
+    }
+    else return ok;
+}
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h
new file mode 100644
index 0000000..96d3b22
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h
@@ -0,0 +1,89 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPBPB_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPBPB_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbPb : helper class to deal with results stored in a spectra with PbPb methods.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePbPb : public AliAnalysisMuMuSpectraCapsule
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePbPb(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="",
+                             const char                              * externFile="",
+                             const char                              * externFile2="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePbPb();
+  // Compute Yield
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* printDirectoryPath="histo",Bool_t Print=kFALSE,const char* particle="PSI")const;
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+  // Compute quantities linked to RAA
+  TList* RAAasGraphic(Double_t MUL) const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const Double_t              * GetConstArray()     const {return fConstArray;};
+  const AliAnalysisMuMuSpectra* GetSpectra()       const {return fSpectra;};
+  const TString                GetSpectraName()    const {return fSpectraName;};
+
+private:
+  // Read and compute values from extern file
+  Bool_t ComputeRAA(TString sbin, Double_t numArray[],Double_t MUL) const;
+  // Read exterfil for Pt and Y case
+  Bool_t ReadFromFile(TString sbin, float valueArray[]) const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file);
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePbPb(const AliAnalysisMuMuSpectraCapsulePbPb& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePbPb& operator=(const AliAnalysisMuMuSpectraCapsulePbPb& rhs);// not implemented on purpose
+
+
+private:
+  TString fExternFile;      // name of spectra selected
+  TString fExternFile2;     // name of spectra selected
+  Double_t fConstArray[10]; // Array to store constant according to centrality bins
+
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePbPb,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliMuonAccEffSubmitter.cxx b/PWG/muondep/AliMuonAccEffSubmitter.cxx
index 969d556..05e15f2 100644
--- a/PWG/muondep/AliMuonAccEffSubmitter.cxx
+++ b/PWG/muondep/AliMuonAccEffSubmitter.cxx
@@ -152,6 +152,20 @@ fUseAODMerging(kFALSE)
   SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P2","0.141776");
   SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P3","0.0130173");
 
+  // some default values for single muons ben
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PTMIN","0.35");
+
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P0","135.137");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P1","0.555323");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P2","0.578374");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P3","10.1345");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P4","0.000232233");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P5","-0.924726");
+
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P0","1.95551");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P1","-0.104761");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P2","0.00311324");
+
   // some default values for GenBox
   
   SetVar("VAR_GENMUBOX_PTMIN","0");
diff --git a/PWG/muondep/CMakeLists.txt b/PWG/muondep/CMakeLists.txt
index bc35348..2ef25b5 100644
--- a/PWG/muondep/CMakeLists.txt
+++ b/PWG/muondep/CMakeLists.txt
@@ -35,8 +35,12 @@ set(SRCS
   AliAnalysisTriggerScalers.cxx
   AliAnalysisMuMu.cxx
   AliAnalysisMuMuConfig.cxx
-  AliAnalysisMuMuResult.cxx
   AliAnalysisMuMuJpsiResult.cxx
+  AliAnalysisMuMuResult.cxx
+  AliAnalysisMuMuSpectraCapsule.cxx
+  AliAnalysisMuMuSpectraCapsulePbPb.cxx
+  AliAnalysisMuMuSpectraCapsulePbP.cxx
+  AliAnalysisMuMuSpectraCapsulePP.cxx
   AliAnalysisMuMuFnorm.cxx
   AliAnalysisMuMuGraphUtil.cxx
   AliAnalysisMuMuSpectra.cxx
diff --git a/PWG/muondep/PWGmuondepLinkDef.h b/PWG/muondep/PWGmuondepLinkDef.h
index 53f8b36..43f8607 100644
--- a/PWG/muondep/PWGmuondepLinkDef.h
+++ b/PWG/muondep/PWGmuondepLinkDef.h
@@ -14,6 +14,10 @@
 #pragma link C++ class AliAnalysisMuMuConfig+;
 #pragma link C++ class AliAnalysisMuMuResult+;
 #pragma link C++ class AliAnalysisMuMuJpsiResult+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsule+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePbPb+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePbP+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePP+;
 #pragma link C++ class AliAnalysisMuMuFnorm+;
 #pragma link C++ class AliAnalysisMuMuGraphUtil+;
 #pragma link C++ class AliAnalysisMuMuSpectra+;
-- 
2.5.4 (Apple Git-61)

