diff --git a/PWG/muon/AddTaskMuMuTrain.C b/PWG/muon/AddTaskMuMuTrain.C
new file mode 100644
index 0000000..9535f1c
--- /dev/null
+++ b/PWG/muon/AddTaskMuMuTrain.C
@@ -0,0 +1,281 @@
+///
+/// Configuration example of a task to get invariant mass spectrum of dimuons
+///
+/// \author: L. Aphecetche (Subatech) (laurent.aphecetche - at - subatech.in2p3.fr)
+///
+
+AliAnalysisTask* AddTaskMuMu(const char* outputname,
+                             const char* beamYear,
+                             Bool_t simulations)
+{
+
+  AliAnalysisManager *mgr = AliAnalysisManager::GetAnalysisManager(); // Get the manager
+  if (!mgr) {
+    ::Error("AddTaskMuMu", "No analysis manager to connect to.");
+    return NULL;
+  }  
+  
+  // Check the analysis type using the event handlers connected to the analysis manager.
+  //==============================================================================
+  if (!mgr->GetInputEventHandler()) {
+    ::Error("AddTaskMuMu", "This task requires an input event handler");
+    return NULL;
+  }
+
+  // Fill the trigger list with desired trigger combinations (See on ALICE log book for denomination)
+  //==============================================================================
+  TList* triggerClassesToConsider = new TList; // Create pointer for trigger list
+  triggerClassesToConsider->SetOwner(kTRUE); // Give rights to trigger liser
+  if (!simulations && triggerClassesToConsider)
+  {
+      // PbPb trigger
+      
+      triggerClassesToConsider->Add(new TObjString("CINT7-B-NOPF-MUFAST"));//MB &0MUL 
+      triggerClassesToConsider->Add(new TObjString("CINT7-B-NOPF-MUFAST&0MSL"));//MB &0MUL 
+      triggerClassesToConsider->Add(new TObjString("CINT7-B-NOPF-MUFAST&0MUL"));//MB &0MUL
+      triggerClassesToConsider->Add(new TObjString("CMUL7-B-NOPF-MUFAST"));// MUL
+      triggerClassesToConsider->Add(new TObjString("CMSL7-B-NOPF-MUFAST"));// MSL
+      triggerClassesToConsider->Add(new TObjString("CMSL7-B-NOPF-MUFAST&0MUL"));// MSL &0MUL
+  }
+  else if (simulations && triggerClassesToConsider)
+  {
+   triggerClassesToConsider->Add(new TObjString("CMULLO-B-NOPF-MUON"));
+   triggerClassesToConsider->Add(new TObjString("CMSNGL-B-NOPF-MUON"));
+   triggerClassesToConsider->Add(new TObjString("V0L"));
+   triggerClassesToConsider->Add(new TObjString("V0R"));
+//
+// for dpmjet simulations (at least) we have the following "triggers" :
+//    C0T0A,C0T0C,MB1,MBBG1,V0L,V0R,MULow,EMPTY,MBBG3,MULL,MULU,MUHigh
+  }
+  
+  //  Configure inputmaps (Default on is in AliMuonEventCuts)
+  //===========================================================================
+  TList* triggerInputsMap = new TList();
+  triggerInputsMap->SetOwner(kTRUE);
+
+  // triggerInputsMap->Add(new TObjString("0VBA:1,")); 
+  triggerInputsMap->Add(new TObjString("0VBA:1"));
+  triggerInputsMap->Add(new TObjString("0VBC:2"));
+  triggerInputsMap->Add(new TObjString("0TVX:3"));
+  triggerInputsMap->Add(new TObjString("0V0M:4"));
+  triggerInputsMap->Add(new TObjString("0T0A:5"));
+  triggerInputsMap->Add(new TObjString("0SMB:6"));
+  triggerInputsMap->Add(new TObjString("0UBA:7"));
+  triggerInputsMap->Add(new TObjString("0UBC:8"));
+  triggerInputsMap->Add(new TObjString("0PH0:9"));
+  triggerInputsMap->Add(new TObjString("0T0C:10"));
+  triggerInputsMap->Add(new TObjString("0VHM:11"));
+  triggerInputsMap->Add(new TObjString("0OMU:12"));
+  triggerInputsMap->Add(new TObjString("0SH1:13"));
+  triggerInputsMap->Add(new TObjString("0STP:14"));
+  triggerInputsMap->Add(new TObjString("0BPA:15"));
+  triggerInputsMap->Add(new TObjString("0BPC:16"));
+  triggerInputsMap->Add(new TObjString("0EMC:17"));
+  triggerInputsMap->Add(new TObjString("0MSL:18"));
+  triggerInputsMap->Add(new TObjString("0MSH:19"));
+  triggerInputsMap->Add(new TObjString("0MLL:20"));
+  triggerInputsMap->Add(new TObjString("0MUL:21"));
+  triggerInputsMap->Add(new TObjString("0OM2:22"));
+  triggerInputsMap->Add(new TObjString("0DMC:23"));
+  triggerInputsMap->Add(new TObjString("0LSR:24"));
+  triggerInputsMap->Add(new TObjString("1EJ1:1"));
+  triggerInputsMap->Add(new TObjString("1EG1:2"));
+  triggerInputsMap->Add(new TObjString("1EJ2:3"));
+  triggerInputsMap->Add(new TObjString("1EG2:4"));
+  triggerInputsMap->Add(new TObjString("1PHL:5"));
+  triggerInputsMap->Add(new TObjString("1PHM:6"));
+  triggerInputsMap->Add(new TObjString("1PHH:7"));
+  triggerInputsMap->Add(new TObjString("1HCO:9"));
+  triggerInputsMap->Add(new TObjString("1HJT:10"));
+  triggerInputsMap->Add(new TObjString("1HSE:11"));
+  triggerInputsMap->Add(new TObjString("1H12:12"));
+  triggerInputsMap->Add(new TObjString("1HQU:13"));
+  triggerInputsMap->Add(new TObjString("1H14:14"));
+  triggerInputsMap->Add(new TObjString("1ZED:15"));
+  triggerInputsMap->Add(new TObjString("1ZMS:16"));
+  triggerInputsMap->Add(new TObjString("1ZMB:17"));
+  triggerInputsMap->Add(new TObjString("1ZMD:18"));
+  triggerInputsMap->Add(new TObjString("1ZAC:19"));
+  triggerInputsMap->Add(new TObjString("1DJ1:20"));
+  triggerInputsMap->Add(new TObjString("1DG1:21"));
+  triggerInputsMap->Add(new TObjString("1DJ2:22"));
+  triggerInputsMap->Add(new TObjString("1DG2:23"));
+  triggerInputsMap->Add(new TObjString("2DUM:12"));
+
+
+  //  Configure task
+  //===========================================================================
+  AliAnalysisTaskMuMu       * task = new AliAnalysisTaskMuMu; // Call the task
+  AliAnalysisMuMuEventCutter* eventCutter = new AliAnalysisMuMuEventCutter(triggerClassesToConsider,triggerInputsMap); // To handle cuts on event
+  AliAnalysisMuMuCutRegistry* cr = task->CutRegistry(); // Set CutRegistry
+
+  // Default cuts on trigger and event level
+  AliAnalysisMuMuCutElement * eventTrue = cr->AddEventCut(*eventCutter,"IsTrue","const AliVEvent&",""); 
+  AliAnalysisMuMuCutElement * triggerSelection = cr->AddTriggerClassCut(*eventCutter,"SelectTriggerClass","const TString&,TString&,UInt_t,UInt_t,UInt_t","");
+  AliAnalysisMuMuCutElement* ps = eventTrue;
+  
+  if (!simulations)
+  {
+    ps = cr->AddEventCut(*eventCutter,"IsPhysicsSelected","const AliInputEventHandler&","");
+  }
+
+  // Apply default cut
+  cr->AddCutCombination(eventTrue);
+  cr->AddCutCombination(ps);
+  cr->AddCutCombination(triggerSelection);
+
+  task->SetBeamYear(beamYear);
+
+  AliAnalysisMuMuGlobal* globalAnalysis =  new AliAnalysisMuMuGlobal; // Basic histograms analysis;
+  AliAnalysisMuMuSingle* singleAnalysis = new AliAnalysisMuMuSingle;// Analysis dealing with single muon
+  AliAnalysisMuMuMinv  * minvAnalysis = new AliAnalysisMuMuMinv;// Analysis creating invariant mass spectrum
+
+    
+  // Configure sub analysis
+  //===========================================================================
+  if ( globalAnalysis )
+  {
+    // Cuts on trigger level
+    AliAnalysisMuMuCutElement* triggerAll = cr->AddTriggerClassCut(*globalAnalysis,"SelectAnyTriggerClass","const TString&,TString&","");
+    // Adding this cut on trigger level  
+    cr->AddCutCombination(triggerAll);
+    task->AdoptSubAnalysis(globalAnalysis);
+  }
+  if ( singleAnalysis )
+  {
+    // Cuts on tracks
+    AliAnalysisMuMuCutElement* trackTrue = cr->AddTrackCut(*cr,"AlwaysTrue","const AliVParticle&",""); // Apply "AlwaysTrue" cut on AliVParticle derived from AliAnalysisMuMuSingle
+    AliAnalysisMuMuCutElement* rabs = cr->AddTrackCut(*singleAnalysis,"IsRabsOK","const AliVParticle&","");
+    AliAnalysisMuMuCutElement* matchlow = cr->AddTrackCut(*singleAnalysis,"IsMatchingTriggerLowPt","const AliVParticle&","");
+    AliAnalysisMuMuCutElement* eta = cr->AddTrackCut(*singleAnalysis,"IsEtaInRange","const AliVParticle&","");
+    AliAnalysisMuMuCutElement* pdca = cr->AddTrackCut(*singleAnalysis,"IsPDCAOK","const AliVParticle&","");
+    
+    // Create combination of cuts to apply
+    cr->AddCutCombination(trackTrue);
+    cr->AddCutCombination(matchlow);
+    cr->AddCutCombination(rabs); 
+    cr->AddCutCombination(eta); 
+    cr->AddCutCombination(pdca); 
+    // Adding the sub analysis
+    task->AdoptSubAnalysis(singleAnalysis); 
+
+    if ( minvAnalysis )
+    {
+      // Array of cut elements
+      TObjArray cutElements;
+
+      // Cuts on track level
+      AliAnalysisMuMuCutElement* pairTrue = cr->AddTrackPairCut(*cr,"AlwaysTrue","const AliVParticle&,const AliVParticle&","");// Apply "AlwaysTrue" cut on AliVParticle derived from AliAnalysisMuMuMinv
+      AliAnalysisMuMuCutElement* pairy = cr->AddTrackPairCut(*minvAnalysis,"IsRapidityInRange","const AliVParticle&,const AliVParticle&","");
+      AliAnalysisMuMuCutElement* ptRange = cr->AddTrackPairCut(*minvAnalysis,"IsPtInRange","const AliVParticle&,const AliVParticle&,Double_t&,Double_t&","0.,10.");
+
+      cutElements.Add(pairTrue);
+      cutElements.Add(pairy);
+      cutElements.Add(ptRange);
+      cutElements.Add(rabs);
+      cutElements.Add(matchlow);
+      cutElements.Add(eta);
+      cutElements.Add(pdca);
+
+      // add them
+      cr->AddCutCombination(cutElements);    
+      // Adding the sub analysis
+      task->AdoptSubAnalysis(minvAnalysis); 
+    }
+  }
+
+  /// below are the kind of configurations that can be performed :
+  /// - adding cuts (at event, track or pair level)
+  /// - adding bins (in pt, y, centrality, etc...) for minv (and meanpt)
+    
+  // Configure sub analysis
+  //===========================================================================
+  AliAnalysisMuMuBinning* binning = task->Binning(); // Create and set the "binning manager"
+  
+  if (minvAnalysis)
+  {  
+    // Integrated
+    binning->AddBin("psi","integrated");
+    // pt binning for low pt exces
+    binning->AddBin("psi","pt", 0.0, 0.1,"BENJ");
+    binning->AddBin("psi","pt", 0.1, 0.2,"BENJ");
+    binning->AddBin("psi","pt", 0.2, 0.3,"BENJ");
+    binning->AddBin("psi","pt", 0.3, 0.4,"BENJ");
+    binning->AddBin("psi","pt", 0.4, 0.5,"BENJ");
+    binning->AddBin("psi","pt", 0.5, 0.6,"BENJ");
+    binning->AddBin("psi","pt", 0.6, 0.7,"BENJ");
+    binning->AddBin("psi","pt", 0.7, 0.8,"BENJ");
+    binning->AddBin("psi","pt", 0.8, 0.9,"BENJ");
+    binning->AddBin("psi","pt", 0.9, 1.0,"BENJ");
+    binning->AddBin("psi","pt", 1.0, 1.1,"BENJ");
+    binning->AddBin("psi","pt", 1.1, 1.2,"BENJ");
+    binning->AddBin("psi","pt", 1.2, 1.3,"BENJ");
+    binning->AddBin("psi","pt", 1.3, 1.4,"BENJ");
+    binning->AddBin("psi","pt", 1.4, 1.5,"BENJ");
+    binning->AddBin("psi","pt", 1.5, 1.6,"BENJ");
+    binning->AddBin("psi","pt", 1.6, 1.7,"BENJ");
+    binning->AddBin("psi","pt", 1.7, 1.8,"BENJ");
+    binning->AddBin("psi","pt", 0.0, 0.3,"BENJ");
+    binning->AddBin("psi","pt", 0.3, 1.0,"BENJ");
+    binning->AddBin("psi","pt", 1.0, 8.0,"BENJ");
+    // pt binning
+    binning->AddBin("psi","pt", 0.0, 1.0,"BENJ");
+    binning->AddBin("psi","pt", 1.0, 2.0,"BENJ");
+    binning->AddBin("psi","pt", 2.0, 3.0,"BENJ");
+    binning->AddBin("psi","pt", 3.0, 4.0,"BENJ");
+    binning->AddBin("psi","pt", 4.0, 5.0,"BENJ");
+    binning->AddBin("psi","pt", 5.0, 6.0,"BENJ");
+    binning->AddBin("psi","pt", 6.0, 8.0,"BENJ");
+    // y binning
+    binning->AddBin("psi","y",-4,-3.75,"BENJ");
+    binning->AddBin("psi","y",-3.75,-3.5,"BENJ");
+    binning->AddBin("psi","y",-3.5,-3.25,"BENJ");
+    binning->AddBin("psi","y",-3.25,-3,"BENJ");
+    binning->AddBin("psi","y",-3,-2.75,"BENJ");
+    binning->AddBin("psi","y",-2.75,-2.5,"BENJ");
+  }
+  // v0 centrality binning
+  binning->AddBin("centrality","V0M",0.,90.);
+  binning->AddBin("centrality","V0M",0.,10.);
+  binning->AddBin("centrality","V0M",10.,20.);
+  binning->AddBin("centrality","V0M",20.,30.);
+  binning->AddBin("centrality","V0M",30.,40.);
+  binning->AddBin("centrality","V0M",40.,50.);
+  binning->AddBin("centrality","V0M",50.,60.);
+  binning->AddBin("centrality","V0M",60.,70.);
+  binning->AddBin("centrality","V0M",70.,80.);
+  binning->AddBin("centrality","V0M",80.,90.);
+  // v0 centrality binning for low pt exces
+  binning->AddBin("centrality","V0M",0.,10.);
+  binning->AddBin("centrality","V0M",10.,30.);
+  binning->AddBin("centrality","V0M",30.,50.);
+  binning->AddBin("centrality","V0M",50.,70.);
+  binning->AddBin("centrality","V0M",70.,90.);
+
+
+  // task->Print("-");
+
+  // add the configured task to the analysis manager
+  mgr->AddTask(task);  
+  
+  // Create containers for input/output
+  AliAnalysisDataContainer *cinput = mgr->GetCommonInputContainer();  
+
+  AliAnalysisDataContainer *coutputHC = 
+  mgr->CreateContainer("OC",AliMergeableCollection::Class(),AliAnalysisManager::kOutputContainer,outputname);
+
+  AliAnalysisDataContainer *coutputCC = 
+  mgr->CreateContainer("CC",AliCounterCollection::Class(),AliAnalysisManager::kOutputContainer,outputname);
+  
+  AliAnalysisDataContainer* cparam = 
+  mgr->CreateContainer("BIN", AliAnalysisMuMuBinning::Class(),AliAnalysisManager::kParamContainer,outputname);
+  
+  // Connect input/output
+  mgr->ConnectInput(task, 0, cinput);
+  mgr->ConnectOutput(task, 1, coutputHC);
+  mgr->ConnectOutput(task, 2, coutputCC);
+  mgr->ConnectOutput(task, 3, cparam);
+  
+  return task;
+}
+
diff --git a/PWG/muon/AliAnalysisMuMuEventPool.cxx b/PWG/muon/AliAnalysisMuMuEventPool.cxx
new file mode 100644
index 0000000..b8139c3
--- /dev/null
+++ b/PWG/muon/AliAnalysisMuMuEventPool.cxx
@@ -0,0 +1,415 @@
+#include "AliAnalysisMuMuEventPool.h"
+
+/**
+ *
+ * \ingroup pwg-muon-mumu
+ *
+ * \class AliAnalysisMuMuEventPool
+ *
+ * Histogramming of single muon tracks. Mostly to get control plots for
+ * the AliAnalysisMuMuMinv sub-analysis, with respect to track cuts used,
+ * like Rabs, p x DCA, etc...
+ *
+ */
+
+#include "TH2F.h"
+#include "AliCodeTimer.h"
+#include "AliMuonTrackCuts.h"
+#include "AliAnalysisMuonUtility.h"
+#include "TMath.h"
+#include "AliLog.h"
+#include "AliVParticle.h"
+#include "TLorentzVector.h"
+#include "AliAnalysisMuMuCutCombination.h"
+#include "AliAnalysisMuMuCutRegistry.h"
+#include "AliMergeableCollection.h"
+#include "AliVEvent.h"
+
+ClassImp(AliAnalysisMuMuEventPool)
+
+//_____________________________________________________________________________
+AliAnalysisMuMuEventPool::AliAnalysisMuMuEventPool()
+: AliAnalysisMuMuBase(),
+fMuonTrackCuts(0x0),
+fShouldSeparatePlusAndMinus(kFALSE)
+{
+  /// ctor
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuEventPool::~AliAnalysisMuMuEventPool()
+{
+  /// dtor
+  delete fMuonTrackCuts;
+  delete fPool;
+}
+
+
+//_____________________________________________________________________________
+void
+AliAnalysisMuMuEventPool::CreateTrackHisto(const char* eventSelection,
+                                        const char* triggerClassName,
+                                        const char* centrality,
+                                        const char* hname, const char* htitle,
+                                        Int_t nbinsx, Double_t xmin, Double_t xmax,
+                                        Int_t nbinsy, Double_t ymin, Double_t ymax,
+                                        Bool_t separatePlusAndMinus) const
+{
+  /// Append histograms for single track to our histogram collection
+  
+  if ( IsHistogramDisabled(hname) ) return;
+  
+  if ( separatePlusAndMinus )
+  {
+    const char* suffix[] = { "Plus", "Minus" };
+    const char* symbol[] = { "+", "-" };
+    
+    for ( Int_t i = 0; i < 2; ++i )
+    {
+      TString shtitle(htitle);
+      TString shname(hname);
+      
+      shtitle.ReplaceAll("#mu",Form("#mu^{%s}",symbol[i]));
+      
+      shname += suffix[i];
+      
+      CreateTrackHistos(kHistoForData | kHistoForMCInput,eventSelection,triggerClassName,centrality,shname.Data(),shtitle.Data(),
+                        nbinsx,xmin,xmax,nbinsy,ymin,ymax);
+    }
+  }
+  else
+  {
+    CreateTrackHistos(kHistoForData | kHistoForMCInput,eventSelection,triggerClassName,centrality,hname,htitle,
+                nbinsx,xmin,xmax,nbinsy,ymin,ymax);
+  }
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuEventPool::IsPDCAOK(const AliVParticle& part)
+{
+  UInt_t selectionMask = MuonTrackCuts() ? MuonTrackCuts()->GetSelectionMask(&part) : 0;
+
+  return ( ( selectionMask & AliMuonTrackCuts::kMuPdca ) == AliMuonTrackCuts::kMuPdca );
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuEventPool::IsRabsOK(const AliVParticle& part) const
+{
+  Double_t thetaAbsEndDeg = AliAnalysisMuonUtility::GetThetaAbsDeg(&part);
+  
+  return ( thetaAbsEndDeg > 2. && thetaAbsEndDeg < 10. );
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuEventPool::IsEtaInRange(const AliVParticle& part) const
+{
+  return (part.Eta() > -4.0 && part.Eta() < -2.5);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuEventPool::SetRun(const AliInputEventHandler* eventHandler)
+{
+  MuonTrackCuts()->SetRun(eventHandler);
+}
+
+//_____________________________________________________________________________
+Int_t AliAnalysisMuMuEventPool::EAGetNumberOfMuonTracks() const
+{
+  // Get the number of muon tracks *that are not ghosts*
+  
+  Int_t ntracks = AliAnalysisMuonUtility::GetNTracks(Event());
+  
+  for ( Int_t i = 0; i < ntracks; ++i )
+  {
+    AliVParticle* track = AliAnalysisMuonUtility::GetTrack(i,Event());
+    if (AliAnalysisMuonUtility::IsMuonGhost(track)) --ntracks;
+  }
+  
+  return ntracks;
+}
+
+////_____________________________________________________________________________
+//Int_t AliAnalysisMuMuEventPool::EAGetNumberOfSelectMuonTracks() const
+//{
+//  // Get the number of "very good" muon tracks :
+//  // Rabs + DCA + pT > 1.5 Gev/C
+//  
+//  Int_t nTracks = AliAnalysisMuonUtility::GetNTracks(Event());
+//  
+//  UInt_t check = kAll | kMatched | kRabs | kDCA | kEta | kPt1dot5;
+//  
+//  Int_t nGood(0);
+//  
+//  for ( Int_t i = 0; i < nTracks; ++i )
+//  {
+//    ULong64_t m = GetTrackMask(i);
+//    if ( ( m & check ) == check )
+//    {
+//      ++nGood;
+//    }
+//  }
+//  return nGood;
+//}
+
+//_____________________________________________________________________________
+Double_t AliAnalysisMuMuEventPool::EAGetTrackDCA(const AliVParticle& track) const
+{
+  // Get track DCA
+  
+  Double_t xdca = AliAnalysisMuonUtility::GetXatDCA(&track);
+  Double_t ydca = AliAnalysisMuonUtility::GetYatDCA(&track);
+  
+  return TMath::Sqrt(xdca*xdca+ydca*ydca);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuEventPool::DefineHistogramCollection(const char* eventSelection,
+                                                      const char* triggerClassName,
+                                                      const char* centrality)
+{
+  /// Actually create the histograms for phyics/triggerClassName
+ 
+  
+  if ( Histo(eventSelection,triggerClassName,centrality,"AliAnalysisMuMuEventPool") )
+  {
+    return;
+  }
+
+  AliAnalysisMuMuBase::EDataType dt = AliAnalysisMuMuBase::kHistoForData;
+  
+  // dummy histogram to signal that we already defined all our histograms (see above)
+  CreateEventHistos(dt,eventSelection,triggerClassName,centrality,"AliAnalysisMuMuEventPool","Dummy semaphore",1,0,1);
+  
+  Double_t ptMin = 0;
+  Double_t ptMax = 12*3;
+  Int_t nbinsPt = GetNbins(ptMin,ptMax,0.5);
+  Double_t pMin = 0;
+  Double_t pMax = 100*3;
+  Int_t nbinsP = GetNbins(pMin,pMax,2.0);
+  Double_t etaMin = -5;
+  Double_t etaMax = -2;
+  Int_t nbinsEta = GetNbins(etaMin,etaMax,0.05);
+  
+  Double_t rapidityMin = -5;
+  Double_t rapidityMax = -2;
+  Int_t nbinsRapidity = GetNbins(rapidityMin,rapidityMax,0.05);
+  
+  Double_t phiMin = -TMath::Pi();
+  Double_t phiMax = TMath::Pi();
+  Int_t nbinsPhi = GetNbins(phiMin,phiMax,0.05);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"Chi2MatchTrigger","Chi2 Match Trigger",72,0,72);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"EtaRapidityMu", "Eta distribution vs Rapidity for #mu", nbinsRapidity,rapidityMin,rapidityMax,nbinsEta,etaMin,etaMax, fShouldSeparatePlusAndMinus);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"PtEtaMu", "P_{T} distribution vs Eta for #mu", nbinsEta,etaMin,etaMax, nbinsPt,ptMin,ptMax,fShouldSeparatePlusAndMinus);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"PtRapidityMu", "P_{T} distribution vs Rapidity for #mu", nbinsRapidity,rapidityMin,rapidityMax, nbinsPt,ptMin,ptMax,fShouldSeparatePlusAndMinus);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"PtPhiMu", "P_{T} distribution vs phi for #mu", nbinsPhi,phiMin,phiMax, nbinsPt,ptMin,ptMax,fShouldSeparatePlusAndMinus);
+  
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"PEtaMu", "P distribution for #mu",nbinsEta,etaMin,etaMax,nbinsP,pMin,pMax,fShouldSeparatePlusAndMinus);
+  
+  Double_t chi2min = 0;
+  Double_t chi2max = 20;
+  Int_t nbinchi2 = GetNbins(chi2min,chi2max,0.05);
+  
+  CreateTrackHisto(eventSelection, triggerClassName, centrality, "Chi2Mu", "chisquare per NDF #mu", nbinchi2, chi2min, chi2max,-1, 0.0, 0.0, fShouldSeparatePlusAndMinus);
+  
+  Double_t xmin = 0;
+  Double_t xmax = 150;
+  Int_t nbins = GetNbins(xmin,xmax,2.0);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"dcaP23Mu","#mu DCA vs P for 2-3 degrees;P (GeV);DCA (cm)",nbinsP,pMin,pMax,nbins,xmin,xmax,fShouldSeparatePlusAndMinus);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"dcaP310Mu","#mu DCA vs P for 3-10 degrees;P (GeV);DCA (cm)",nbinsP,pMin,pMax,nbins,xmin,xmax,fShouldSeparatePlusAndMinus);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"dcaPwPtCut23Mu","#mu DCA vs P for 2-3 degrees with Pt Cut;P (GeV);DCA (cm)",nbinsP,pMin,pMax,nbins,xmin,xmax,fShouldSeparatePlusAndMinus);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"dcaPwPtCut310Mu","#mu DCA vs P for 3-10 degrees with Pt Cut;P (GeV);DCA (cm)",nbinsP,pMin,pMax,nbins,xmin,xmax,fShouldSeparatePlusAndMinus);
+  
+  xmin = 0;
+  xmax = 3564;
+  nbins = GetNbins(xmin,xmax,1.0);
+  
+  CreateTrackHisto(eventSelection,triggerClassName,centrality,"BCX","bunch-crossing ids",nbins,xmin-0.5,xmax-0.5);
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuEventPool::FillHistosForMuonTrack(AliMergeableCollectionProxy& proxy,
+                                                   const AliVParticle& track)
+{
+  /// Fill histograms for one track
+ 
+  AliCodeTimerAuto("",0);
+  
+  if ( HasMC() )
+  {
+    MuonTrackCuts()->SetIsMC();
+  }
+  
+  TLorentzVector p(track.Px(),track.Py(),track.Pz(),
+                   TMath::Sqrt(AliAnalysisMuonUtility::MuonMass2()+track.P()*track.P()));
+  
+  
+  TString charge("");
+  
+  if ( ShouldSeparatePlusAndMinus() )
+  {
+    if ( track.Charge() < 0 )
+    {
+      charge = "Minus";
+    }
+    else
+    {
+      charge = "Plus";
+    }
+  }
+  
+  Double_t dca = EAGetTrackDCA(track);
+  
+  Double_t theta = AliAnalysisMuonUtility::GetThetaAbsDeg(&track);
+  
+  if (!IsHistogramDisabled("BCX"))
+  {
+    proxy.Histo("BCX")->Fill(1.0*Event()->GetBunchCrossNumber());
+  }
+  
+  if (!IsHistogramDisabled("Chi2MatchTrigger"))
+  {
+    proxy.Histo("Chi2MatchTrigger")->Fill(AliAnalysisMuonUtility::GetChi2MatchTrigger(&track));
+  }
+  
+  if (!IsHistogramDisabled("EtaRapidityMu*"))
+  {
+    proxy.Histo(Form("EtaRapidityMu%s",charge.Data()))->Fill(p.Rapidity(),p.Eta());
+  }
+  
+  if (!IsHistogramDisabled("PtEtaMu*"))
+  {
+    TH1* h = proxy.Histo(Form("PtEtaMu%s",charge.Data()));
+    
+    h->Fill(p.Eta(),p.Pt());
+
+    if  ( fPtEtaSpectraPerBCX )
+    {
+      if (!IsHistogramDisabled("BCX"))
+      {
+        TH1* hbcx = proxy.Histo(Form("PtEtaMu%sBCX%d",charge.Data(),Event()->GetBunchCrossNumber()));
+      
+        if (!hbcx)
+        {
+          hbcx = static_cast<TH1*>(h->Clone(Form("PtEtaMu%sBCX%d",charge.Data(),Event()->GetBunchCrossNumber())));
+          proxy.Adopt(hbcx);
+        }
+      }
+    }
+  }
+  
+  if (!IsHistogramDisabled("PtRapidityMu*"))
+  {
+    proxy.Histo(Form("PtRapidityMu%s",charge.Data()))->Fill(p.Rapidity(),p.Pt());
+  }
+  
+  if (!IsHistogramDisabled("PEtaMu*"))
+  {
+    proxy.Histo(Form("PEtaMu%s",charge.Data()))->Fill(p.Eta(),p.P());
+  }
+  
+  if (!IsHistogramDisabled("PtPhiMu*"))
+  {
+    proxy.Histo(Form("PtPhiMu%s",charge.Data()))->Fill(p.Phi(),p.Pt());
+  }
+  
+  if (!IsHistogramDisabled("Chi2Mu*"))
+  {
+    proxy.Histo(Form("Chi2Mu%s",charge.Data()))->Fill(AliAnalysisMuonUtility::GetChi2perNDFtracker(&track));
+  }
+  
+  if (!fDCAHistos)
+  {
+    return;
+  }
+  
+  if ( theta >= 2.0 && theta < 3.0 )
+  {
+    
+    if (!IsHistogramDisabled("dcaP23Mu*"))
+    {
+      proxy.Histo(Form("dcaP23Mu%s",charge.Data()))->Fill(p.P(),dca);
+    }
+    
+    if ( p.Pt() > 2 )
+    {
+      if (!IsHistogramDisabled("dcaPwPtCut23Mu*"))
+      {
+        proxy.Histo(Form("dcaPwPtCut23Mu%s",charge.Data()))->Fill(p.P(),dca);
+      }
+    }
+  }
+  else if ( theta >= 3.0 && theta < 10.0 )
+  {
+    if (!IsHistogramDisabled("dcaP310Mu*"))
+    {
+      proxy.Histo(Form("dcaP310Mu%s",charge.Data()))->Fill(p.P(),dca);
+    }
+    if ( p.Pt() > 2 )
+    {
+      if (!IsHistogramDisabled("dcaPwPtCut310Mu*"))
+      {
+        proxy.Histo(Form("dcaPwPtCut310Mu%s",charge.Data()))->Fill(p.P(),dca);
+      }
+    }
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuEventPool::FillHistosForTrack(const char* eventSelection,
+                                               const char* triggerClassName,
+                                               const char* centrality,
+                                               const char* trackCutName,
+                                               const AliVParticle& track)
+{
+  /// Fill histograms for one track
+
+  if (!AliAnalysisMuonUtility::IsMuonTrack(&track) ) return;
+
+  AliMergeableCollectionProxy* proxy = HistogramCollection()->CreateProxy(BuildPath(eventSelection,triggerClassName,centrality,trackCutName));
+
+  FillHistosForMuonTrack(*proxy,track);
+  
+  delete proxy;
+}
+
+//_____________________________________________________________________________
+AliMuonTrackCuts* AliAnalysisMuMuEventPool::MuonTrackCuts()
+{
+  /// Get (and create the first time) our internal track cuts
+  if (!fMuonTrackCuts)
+  {
+    fMuonTrackCuts = new AliMuonTrackCuts;
+    
+    fMuonTrackCuts->SetAllowDefaultParams(kTRUE);
+    
+    fMuonTrackCuts->SetFilterMask(AliMuonTrackCuts::kMuEta |
+                                  AliMuonTrackCuts::kMuThetaAbs |
+                                  AliMuonTrackCuts::kMuPdca |
+                                  AliMuonTrackCuts::kMuMatchApt |
+                                  AliMuonTrackCuts::kMuMatchLpt |
+                                  AliMuonTrackCuts::kMuMatchHpt |
+                                  AliMuonTrackCuts::kMuTrackChiSquare);
+    
+  }
+  
+  return fMuonTrackCuts;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuEventPool::SetMuonTrackCuts(const AliMuonTrackCuts& trackCuts)
+{
+  /// Set our muontrackcuts from external source
+  delete fMuonTrackCuts;
+  fMuonTrackCuts = static_cast<AliMuonTrackCuts*>(trackCuts.Clone());
+}
diff --git a/PWG/muon/AliAnalysisMuMuEventPool.h b/PWG/muon/AliAnalysisMuMuEventPool.h
new file mode 100644
index 0000000..a2f6355
--- /dev/null
+++ b/PWG/muon/AliAnalysisMuMuEventPool.h
@@ -0,0 +1,121 @@
+#ifndef ALIANALYSISMUMUEVENTPOOL_H
+#define ALIANALYSISMUMUEVENTPOOL_H
+
+#include "AliAnalysisMuMuBase.h"
+
+/**
+ *
+ * \class AliAnalysisMuMuEventPool
+ *
+ * \brief Histogramming of single muon tracks.
+ *
+ * \author L. Aphecetche (Subatech)
+ *
+ */
+
+#include "AliAnalysisMuonUtility.h"
+
+class AliMergeableCollectionProxy;
+class AliMuonTrackCuts;
+class TH2F;
+class TObjArray;
+
+class AliAnalysisMuMuEventPool : public AliAnalysisMuMuBase
+{
+public:
+  
+  AliAnalysisMuMuEventPool();
+  virtual ~AliAnalysisMuMuEventPool();
+  
+  virtual void ShouldSeparatePlusAndMinus(Bool_t value) { fShouldSeparatePlusAndMinus = value; }
+  
+  virtual Bool_t ShouldSeparatePlusAndMinus() const { return fShouldSeparatePlusAndMinus; }
+
+  AliMuonTrackCuts* MuonTrackCuts();
+  
+  void SetMuonTrackCuts(const AliMuonTrackCuts& trackCuts);
+  
+  Bool_t IsPDCAOK(const AliVParticle& part);
+  void NameOfIsPDCAOK(TString& name) const { name = "PDCA";}
+  
+  Bool_t IsMatchingTriggerAnyPt(const AliVParticle& part) const { return ( AliAnalysisMuonUtility::GetMatchTrigger(&part) >= 1 ); }
+  void NameOfIsMatchingTriggerAnyPt(TString& name) const { name = "MATCHANY";}
+  
+  Bool_t IsMatchingTriggerLowPt(const AliVParticle& part) const { return ( AliAnalysisMuonUtility::GetMatchTrigger(&part) >= 2 ); }
+  void NameOfIsMatchingTriggerLowPt(TString& name) const { name = "MATCHLOW";}
+  
+  Bool_t IsMatchingTriggerHighPt(const AliVParticle& part) const { return ( AliAnalysisMuonUtility::GetMatchTrigger(&part) >= 3 ); }
+  void NameOfIsMatchingTriggerHighPt(TString& name) const { name = "MATCHHIGH";}
+  
+  Bool_t IsRabsOK(const AliVParticle& part) const;
+  void NameOfIsRabsOK(TString& name) const { name = "RABS"; }
+
+  Bool_t IsEtaInRange(const AliVParticle& part) const;
+  void NameOfIsEtaInRange(TString& name) const
+  { name = "ETA"; }
+
+  void SetBufferSize(Int_t buffer) { fBufferSize = buffer; }
+
+  void SetMixNumber(Int_t numMix) { fMixNumber = numMix; }
+
+  void SetRun(const AliInputEventHandler* eventHandler);
+
+
+    
+protected:
+  
+  void DefineHistogramCollection(const char* eventSelection, const char* triggerClassName,
+                                 const char* centrality);
+
+  virtual void FillHistosForTrack(const char* eventSelection, const char* triggerClassName,
+                                  const char* centrality,
+                                  const char* trackCutName,
+                                  const AliVParticle& part);
+  
+  void FillHistosForMuonTrack(AliMergeableCollectionProxy& proxy, const AliVParticle& track);
+
+
+private:
+  
+  void CreateTrackHisto(const char* eventSelection,
+                        const char* triggerClassName,
+                        const char* centrality,
+                        const char* hname, const char* htitle,
+                        Int_t nbinsx, Double_t xmin, Double_t xmax,
+                        Int_t nbinsy=-1, Double_t ymin=0.0, Double_t ymax=0.0,
+                        Bool_t separatePlusAndMinus=kFALSE) const;
+
+  Double_t GetTrackTheta(const AliVParticle& particle) const;
+  
+  /* methods prefixed with EA should really not exist at all. They are there
+   only because the some of our base interfaces are shamelessly incomplete or
+   inadequate...
+   */
+  
+  Int_t EAGetNumberOfMuonTracks() const;
+  
+//  Int_t EAGetNumberOfSelectMuonTracks() const;
+  
+  Double_t EAGetTrackDCA(const AliVParticle& particle) const;
+     
+private:
+  
+  /// not implemented on purpose
+  AliAnalysisMuMuEventPool& operator=(const AliAnalysisMuMuEventPool& rhs);
+  /// not implemented on purpose
+  AliAnalysisMuMuEventPool(const AliAnalysisMuMuEventPool& rhs);
+  
+  AliMuonTrackCuts* fMuonTrackCuts; //! common cuts for muon tracks (from Diego)
+  Bool_t fShouldSeparatePlusAndMinus; // whether or not to histogram mu+ and mu- separately
+
+  TObjArray *fPool;
+
+  Int_t       fMixNumber;             // mixing number
+  Int_t nGoodClusters[5];
+  Int_t nGoodClusters2[5];
+  
+  
+  ClassDef(AliAnalysisMuMuEventPool,1) // implementation of AliAnalysisMuMuBase for single mu analysis
+};
+
+#endif
diff --git a/PWG/muon/AliAnalysisMuMuMinv.cxx b/PWG/muon/AliAnalysisMuMuMinv.cxx
index 7cbb113..de621df 100644
--- a/PWG/muon/AliAnalysisMuMuMinv.cxx
+++ b/PWG/muon/AliAnalysisMuMuMinv.cxx
@@ -64,6 +64,7 @@ AliAnalysisMuMuMinv::DefineHistogramCollection(const char* eventSelection,
 {
   /// Define the histograms this analysis will use
   
+  // Check if histo is not already here
   if ( ExistSemaphoreHistogram(eventSelection,triggerClassName,centrality) )
   {
     return;
@@ -79,29 +80,39 @@ AliAnalysisMuMuMinv::DefineHistogramCollection(const char* eventSelection,
   
   /// Create invariant mass histograms
   
-  Double_t minvMin = 0;
-  Double_t minvMax = 16;
+  //__________mass range
+  Double_t minvMin = 2;
+  Double_t minvMax = 8;
   Int_t nMinvBins = GetNbins(minvMin,minvMax,0.025);
   
   Int_t nMCMinvBins = GetNbins(minvMin,minvMax,0.1);
+  //__________
   
+  //__________Rapidity range
   Double_t rapidityMin = -5;
   Double_t rapidityMax = -2;
   Int_t nbinsRapidity = GetNbins(rapidityMin,rapidityMax,0.05);
+  //__________
   
+  //__________eta range
   Double_t etaMin = -5;
   Double_t etaMax = -2;
   Int_t nbinsEta = GetNbins(etaMin,etaMax,0.05);
   
-  CreatePairHistos(kHistoForData | kHistoForMCInput,eventSelection,triggerClassName,centrality,"Pt","#mu+#mu- Pt distribution",
-                   200,0,20,-2);
+
+  //__________Set histo
+  
+  //___Histos for pair
+  TObjArray* bins = Binning()->CreateBinObjArray("psi","integrated,ptvsy,yvspt,pt,y,phi,nch,dnchdeta,ntrcorr,ntrcorrpt,ntrcorry,relntrcorr,v0acorr,v0ccorr,v0mcorr","");//We may include ,v0a,v0acent
+
+  CreatePairHistos(kHistoForData | kHistoForMCInput,eventSelection,triggerClassName,centrality,"Pt","#mu+#mu- Pt distribution",200,0,20,-2);
   
   CreatePairHistos(kHistoForData | kHistoForMCInput,eventSelection,triggerClassName,centrality,"Y","#mu+#mu- Y distribution",
                    nbinsRapidity,rapidityMin,rapidityMax,-2);
   
   CreatePairHistos(kHistoForData | kHistoForMCInput,eventSelection,triggerClassName,centrality,"Eta","#mu+#mu- Eta distribution",
                    nbinsEta,etaMin,etaMax);
-  
+  //____
   
   //___Histos for pure MC
   CreateEventHistos(kHistoForMCInput,eventSelection,triggerClassName,centrality,"Pt","MCINPUT #mu+#mu- Pt distribution",
@@ -114,7 +125,7 @@ AliAnalysisMuMuMinv::DefineHistogramCollection(const char* eventSelection,
                     nbinsEta,etaMin,etaMax);
   
   CreateEventHistos(kHistoForMCInput,eventSelection,triggerClassName,Form("%s/INYRANGE",centrality),"Pt","MCINPUT #mu+#mu- Pt distribution",
-                    200,0,20,-2);
+                    nMinvBins,minvMax,minvMax,-2);
   
   CreateEventHistos(kHistoForMCInput,eventSelection,triggerClassName,Form("%s/INYRANGE",centrality),"Y","MCINPUT #mu+#mu- Y distribution",
                     nbinsRapidity,rapidityMin,rapidityMax,-2);
@@ -143,10 +154,10 @@ AliAnalysisMuMuMinv::DefineHistogramCollection(const char* eventSelection,
   TIter next(fBinsToFill);
   AliAnalysisMuMuBinning::Range* r;
   Int_t nb(0);
-  
+  //__________Create Minv Histos for each bin 
   while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
   {
-    TString minvName(GetMinvHistoName(*r,kFALSE));
+    TString minvName(GetMinvHistoName(*r,kFALSE));// Histos name
     
     ++nb;
     
@@ -200,7 +211,7 @@ AliAnalysisMuMuMinv::DefineHistogramCollection(const char* eventSelection,
       //        HistogramCollection()->Adopt(Form("/%s/INYRANGE",MCInputPrefix()),static_cast<TH1*>(h->Clone()));
       //      }
     }
-    
+    //__________Create corrected histo
     if ( ShouldCorrectDimuonForAccEff() )
     {
       minvName = GetMinvHistoName(*r,kTRUE);
@@ -353,7 +364,6 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
       pair4MomentumMC = &mcpj;
       
     }
-    
     delete mcProxy;
   }
   
@@ -499,8 +509,7 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
         }
         
       }
-      
-      else
+      else// the rest
       {
         AliError(Form("Don't know how to deal with 2D bin %s",r->AsString().Data()));
       }
@@ -652,17 +661,15 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
             }
           }
         }
-        
       }
-      
-      
     }
     
-    if ( ok || okMC )
+    if ( ok || okMC ) // Pair pass all conditions, either MC or not
     {
       TString minvName = GetMinvHistoName(*r,kFALSE);
       
       if (!IsHistogramDisabled(minvName.Data()))
+
       {
         TH1* h(0x0);
         if ( ok )
@@ -702,7 +709,6 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
             {
               AliError(Form("Could not get %s",hprofName.Data()));
             }
-            
             else
             {
               //              hprof->Approximate(); //I dont think its necessary here
@@ -726,14 +732,11 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
               hprof->Fill(pair4MomentumMC->M(),pair4MomentumMC->Pt(),inputWeightMC);
             }
           }
-          
         }
-        
       }
       
       if ( ShouldCorrectDimuonForAccEff() )
       {
-        
         Double_t AccxEff(0);
         Bool_t okAccEff(kFALSE);
         if ( ok )
@@ -858,12 +861,12 @@ void AliAnalysisMuMuMinv::FillHistosForMCEvent(const char* eventSelection,const
   
   for ( Int_t i = 0; i < nMCTracks; ++i )
   {
-    AliVParticle* part = MCEvent()->GetTrack(i);
+    AliVParticle* part = MCEvent()->GetTrack(i);// Get particle
     
     if  (AliAnalysisMuonUtility::IsPrimary(part,MCEvent()) &&
          part->GetMother()==-1)
     {
-      Double_t inputWeight = WeightDistribution(part->Pt(),part->Y());
+      Double_t inputWeight = WeightDistribution(part->Pt(),part->Y());// get the default WeightDistribution
       
       mcProxy->Histo("Pt")->Fill(part->Pt(),inputWeight);
       mcProxy->Histo("Y")->Fill(part->Y(),inputWeight);
@@ -875,9 +878,11 @@ void AliAnalysisMuMuMinv::FillHistosForMCEvent(const char* eventSelection,const
         mcInYRangeProxy->Histo("Y")->Fill(part->Y(),inputWeight);
         mcInYRangeProxy->Histo("Eta")->Fill(part->Eta());
       }
+      //__________
       
       nextBin.Reset();
       
+      //__________Check if all bin are in range
       while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
       {
         Bool_t ok(kFALSE);
@@ -916,7 +921,9 @@ void AliAnalysisMuMuMinv::FillHistosForMCEvent(const char* eventSelection,const
             ok = r->IsInRange(part->Phi());
           }
         }
+        //__________
         
+        //__________Fill histo if ok
         if ( ok )
         {
           TString hname = GetMinvHistoName(*r,kFALSE);
diff --git a/PWG/muon/AliAnalysisTaskMuMu.cxx b/PWG/muon/AliAnalysisTaskMuMu.cxx
index a1cb194..7ba2f39 100644
--- a/PWG/muon/AliAnalysisTaskMuMu.cxx
+++ b/PWG/muon/AliAnalysisTaskMuMu.cxx
@@ -181,16 +181,26 @@ AliAnalysisTaskMuMu::Event() const
 //_____________________________________________________________________________
 void AliAnalysisTaskMuMu::SetCountInBins( const char* binWhat, const char* binQuantity, const char* binFlavor, Bool_t disableHistoLoop )
 {
-  // fCountInBins serve to add a rubric for bins in the Event counter collection
-  // Bin to count, can be set like in AliAnalysisMuMuBinning class, and has to be the same as one of the binnings we give to the task through this class
-  // Only one kind of binning can be used in the counters, since otherwise the bin integrated counts will not be correct (events counted several times)
+  /// fCountInBins serve to add a rubric for bins in the Event counter collection
+  /// Bin to count, can be set like in AliAnalysisMuMuBinning class, and has to be the same as one of the binnings we give to the task through this class
+  /// Only one kind of binning can be used in the counters, since otherwise the bin integrated counts will not be correct (events counted several times)
+  /// ONLY FOR EVENT PROPERTIES !
+  /// 
+  ///  FIXME: make a new protection 
 
+  if ( !fCountInBins)
+  {
   fCountInBins = kTRUE;
   fbinWhat = binWhat;
   fbinQuantity = binQuantity;
   fbinFlavor = binFlavor;
   fDisableHistoLoop = disableHistoLoop;
 }
+  else
+  {
+    AliFatal("Can't be called twice");
+  }
+}
 
 
 //_____________________________________________________________________________
@@ -300,6 +310,7 @@ void AliAnalysisTaskMuMu::FillHistos(const char* eventSelection,
   // loop on single tracks (whatever the type of tracks
   if ( !IsHistogrammingDisabled() && !fDisableHistoLoop )
   {
+    //__________ The main part, loop over subanalysis and fill histo
     while ( ( analysis = static_cast<AliAnalysisMuMuBase*>(nextAnalysis()) ) )
     {
       analysis->DefineHistogramCollection(eventSelection,triggerClassName,centrality);
@@ -452,7 +463,7 @@ void AliAnalysisTaskMuMu::GetSelectedTrigClassesInEvent(const AliVEvent* event,
   
   if (!event)
   {
-    AliError("Will get a hard time selecting trigger classes with an empty event...");
+    AliError("Will get a hard time selecting trigger classes with an empty event...");// Ah ah ah ...
     return;
   }
   
@@ -670,6 +681,8 @@ void AliAnalysisTaskMuMu::UserExec(Option_t* /*opt*/)
   
   TIter nextAnalysis(fSubAnalysisVector);
   AliAnalysisMuMuBase* analysis;  
+
+  //----- Loop over each subanalysis ------
   while ( ( analysis = static_cast<AliAnalysisMuMuBase*>(nextAnalysis()) ) )
   {
     if ( MCEvent() ) // Set the MC flag for all analysis (prior to call anything from them
@@ -682,26 +695,30 @@ void AliAnalysisTaskMuMu::UserExec(Option_t* /*opt*/)
   }
 
 
+
   TString firedTriggerClasses(Event()->GetFiredTriggerClasses());
 
-  // first loop to count things not associated to a specific trigger
   TIter nextEventCutCombination(CutRegistry()->GetCutCombinations(AliAnalysisMuMuCutElement::kEvent));
   AliAnalysisMuMuCutCombination* cutCombination;
 
+  // ----- loop over cut combination on event level. Fill counters ------
   while ( ( cutCombination = static_cast<AliAnalysisMuMuCutCombination*>(nextEventCutCombination())))
   {
-    if ( cutCombination->Pass(*fInputHandler) )
+    if ( cutCombination->Pass(*fInputHandler) ) // If event pass the cut
     {
+      // Fill counters
       FillCounters(cutCombination->GetName(), "EVERYTHING",  "ALL", fCurrentRunNumber);
       
+      // Default counter
       if ( firedTriggerClasses == "" )
       {
         FillCounters(cutCombination->GetName(),"EMPTY","ALL",fCurrentRunNumber);
       }
     }
   }
+  //==============================================================================
 
-  // second loop to count only the triggers we're interested in
+  // ----- loop over trigger selected list and cut combination on event level. Fill histos -----
   TObjArray selectedTriggerClasses;
 
   GetSelectedTrigClassesInEvent(Event(),selectedTriggerClasses);
@@ -721,6 +738,7 @@ void AliAnalysisTaskMuMu::UserExec(Option_t* /*opt*/)
       }
     }
   }
+  //==============================================================================
   
   // Post output data.
   PostData(1, fHistogramCollection);
diff --git a/PWG/muondep/AliAnalysisMuMu.cxx b/PWG/muondep/AliAnalysisMuMu.cxx
index 6113205..1f21dcd 100644
--- a/PWG/muondep/AliAnalysisMuMu.cxx
+++ b/PWG/muondep/AliAnalysisMuMu.cxx
@@ -25,6 +25,8 @@
 #include "AliAnalysisMuMuGraphUtil.h"
 #include "AliAnalysisMuMuJpsiResult.h"
 #include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
 #include "AliAnalysisTriggerScalers.h"
 #include "AliCounterCollection.h"
 #include "AliHistogramCollection.h"
@@ -51,6 +53,7 @@
 #include "TList.h"
 #include "TMap.h"
 #include "TMath.h"
+#include "TMethodCall.h"
 #include "TObjArray.h"
 #include "TObjString.h"
 #include "TParameter.h"
@@ -64,6 +67,7 @@
 #include <map>
 #include <set>
 #include <string>
+#include <vector>
 #include "TLatex.h"
 
 using std::cout;
@@ -74,8 +78,7 @@ ClassImp(AliAnalysisMuMu)
 
 //_____________________________________________________________________________
 AliAnalysisMuMu::AliAnalysisMuMu(const char* filename, AliAnalysisMuMuConfig& config) : TObject(),
-fFilename(),
-fDirectory(""),
+fFilename(gSystem->ExpandPathName(filename)),
 fCounterCollection(0x0),
 fBinning(0x0),
 fMergeableCollection(0x0),
@@ -86,21 +89,17 @@ fAssociatedSimulation2(0x0),
 fParticleName(""),
 fConfig(new AliAnalysisMuMuConfig(config))
 {
-  GetFileNameAndDirectory(filename);
-  
-  GetCollections(fFilename,fDirectory,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
-  
-  if ( IsSimulation() )
-  {
-    SetParticleNameFromFileName(fFilename);
-  }
+    GetCollections(fFilename,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
+    
+    if ( IsSimulation() )
+        {
+        SetParticleNameFromFileName(fFilename);
+        }
 }
 
-
 //_____________________________________________________________________________
 AliAnalysisMuMu::AliAnalysisMuMu(const char* filename, const char* associatedSimFileName, const char* associatedSimFileName2, const char* configurationFile) : TObject(),
 fFilename(filename),
-fDirectory(""),
 fCounterCollection(0x0),
 fBinning(0x0),
 fMergeableCollection(0x0),
@@ -111,58 +110,56 @@ fAssociatedSimulation2(0x0),
 fParticleName(""),
 fConfig(0x0)
 {
-  // ctor
-  
-  GetFileNameAndDirectory(filename);
-
-  GetCollections(fFilename,fDirectory,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
-  
-  if ( IsSimulation() )
-  {
-    SetParticleNameFromFileName(fFilename);
-  }
-  
-  if ( fCounterCollection )
-  {
-    if ( strlen(associatedSimFileName) )
-    {
-      fAssociatedSimulation = new AliAnalysisMuMu(associatedSimFileName);
-    }
+    // ctor
     
-    if ( strlen(associatedSimFileName2) )
-    {
-      fAssociatedSimulation2 = new AliAnalysisMuMu(associatedSimFileName2);
-    }
+    GetCollections(fFilename,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
     
-    fConfig = new AliAnalysisMuMuConfig;
+    if ( IsSimulation() )
+        {
+        SetParticleNameFromFileName(fFilename);
+        }
     
-    fConfig->ReadFromFile(configurationFile);
-  }
+    if ( fCounterCollection )
+        {
+        if ( strlen(associatedSimFileName) )
+            {
+            fAssociatedSimulation = new AliAnalysisMuMu(associatedSimFileName);
+            }
+        
+        if ( strlen(associatedSimFileName2) )
+            {
+            fAssociatedSimulation2 = new AliAnalysisMuMu(associatedSimFileName2);
+            }
+        
+        fConfig = new AliAnalysisMuMuConfig;
+        
+        fConfig->ReadFromFile(configurationFile);
+        }
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMu::~AliAnalysisMuMu()
 {
-  // dtor
-  
-  if ( fAssociatedSimulation )
-  {
-    fAssociatedSimulation->Update();
-  }
-  if ( fAssociatedSimulation2 )
-  {
-    fAssociatedSimulation2->Update();
-  }
-  
-  Update();
-  
-  delete fCounterCollection;
-  delete fBinning;
-  delete fMergeableCollection;
-  delete fCorrectionPerRun;
-  delete fAssociatedSimulation;
-  delete fAssociatedSimulation2;
-  delete fConfig;
+    // dtor
+    
+    if ( fAssociatedSimulation )
+        {
+        fAssociatedSimulation->Update();
+        }
+    if ( fAssociatedSimulation2 )
+        {
+        fAssociatedSimulation2->Update();
+        }
+    
+    Update();
+    
+    delete fCounterCollection;
+    delete fBinning;
+    delete fMergeableCollection;
+    delete fCorrectionPerRun;
+    delete fAssociatedSimulation;
+    delete fAssociatedSimulation2;
+    delete fConfig;
 }
 
 //_____________________________________________________________________________
@@ -171,288 +168,422 @@ void AliAnalysisMuMu::BasicCounts(Bool_t detailTriggers,
                                   ULong64_t* totalNmsl,
                                   ULong64_t* totalNmul)
 {
-  // Report of some basic trigger counts (for MB,MUL and MSL)
-  // both before and after physics selection.
-  //
-  // Amount all the triggers available in our counter collection,
-  // we only consider the triggers that are defined in the configuration
-  //
-  // If detailTriggers is kTRUE, will show the detail, including Physics Selection fraction,
-  // for each trigger found (as opposed to just showing info for MB,MSL and MUL triggers)
-  
-  if (!fMergeableCollection || !fCounterCollection) return;
-  
-  TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
-  TIter nextRun(runs);
-
-  TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
-  TIter nextTrigger(triggers);
-
-  TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
-
-  Bool_t doPS = (events->FindObject("PSALL") != 0x0);
-  
-  TObjString* srun;
-  TObjString* strigger;
-
-  ULong64_t localNmb(0);
-  ULong64_t localNmsl(0);
-  ULong64_t localNmul(0);
-  
-  if ( totalNmb) *totalNmb = 0;
-  if ( totalNmsl) *totalNmsl = 0;
-  if ( totalNmul ) *totalNmul = 0;
-
-  while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
-  {
-    std::cout << Form("RUN %09d ",srun->String().Atoi());
+    // Report of some basic trigger counts (for MB,MUL and MSL)
+    // both before and after physics selection.
+    //
+    // Amount all the triggers available in our counter collection,
+    // we only consider the triggers that are defined in the configuration
+    //
+    // If detailTriggers is kTRUE, will show the detail, including Physics Selection fraction,
+    // for each trigger found (as opposed to just showing info for MB,MSL and MUL triggers)
     
-    TString details;
-    ULong64_t nmb(0);
-    ULong64_t nmsl(0);
-    ULong64_t nmul(0);
+    if (!fMergeableCollection || !fCounterCollection) return;
     
-    nextTrigger.Reset();
+    TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
+    TIter nextRun(runs);
     
-    Int_t nofPS(0);
+    TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
+    TIter nextTrigger(triggers);
     
-    while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
-    {
-      
-      if ( !Config()->Has(Config()->MinbiasTriggerKey(),strigger->String().Data(),IsSimulation()) &&
-           !Config()->Has(Config()->DimuonTriggerKey(),strigger->String().Data(),IsSimulation()) &&
-           !Config()->Has(Config()->MuonTriggerKey(),strigger->String().Data(),IsSimulation()) ) continue;
-          
-      ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d/centrality:all",
-                                                    strigger->String().Data(),"ALL",srun->String().Atoi())));
-
-      details += TString::Format("\n%50s %10lld",strigger->String().Data(),n);
-      
-
-      if ( doPS )
-      {
-        ULong64_t nps = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d/centrality:all",
-                                                                    strigger->String().Data(),"PSALL",srun->String().Atoi())));
-        
-        details += TString::Format(" PS %5.1f %%",nps*100.0/n);
-
-        if (nps)
+    TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
+    
+    Bool_t doPS = (events->FindObject("PSALL") != 0x0);
+    
+    TObjString* srun;
+    TObjString* strigger;
+    
+    ULong64_t localNmb(0);
+    ULong64_t localNmsl(0);
+    ULong64_t localNmul(0);
+    
+    if ( totalNmb) *totalNmb = 0;
+    if ( totalNmsl) *totalNmsl = 0;
+    if ( totalNmul ) *totalNmul = 0;
+    
+    while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
         {
-          ++nofPS;
+        std::cout << Form("RUN %09d ",srun->String().Atoi());
+        
+        TString details;
+        ULong64_t nmb(0);
+        ULong64_t nmsl(0);
+        ULong64_t nmul(0);
+        
+        nextTrigger.Reset();
+        
+        Int_t nofPS(0);
+        
+        while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
+            {
+            
+            if ( !Config()->Has(Config()->MinbiasTriggerKey(),strigger->String().Data(),IsSimulation()) &&
+                !Config()->Has(Config()->DimuonTriggerKey(),strigger->String().Data(),IsSimulation()) &&
+                !Config()->Has(Config()->MuonTriggerKey(),strigger->String().Data(),IsSimulation()) ) continue;
+            
+            ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d/centrality:all",
+                                                                      strigger->String().Data(),"ALL",srun->String().Atoi())));
+            
+            details += TString::Format("\n%50s %10lld",strigger->String().Data(),n);
+            
+            
+            if ( doPS )
+                {
+                ULong64_t nps = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d/centrality:all",
+                                                                            strigger->String().Data(),"PSALL",srun->String().Atoi())));
+                
+                details += TString::Format(" PS %5.1f %%",nps*100.0/n);
+                
+                if (nps)
+                    {
+                    ++nofPS;
+                    }
+                
+                }
+            
+            if ( Config()->Has(Config()->MinbiasTriggerKey(),strigger->String(),IsSimulation() ) )
+                {
+                nmb += n;
+                if ( totalNmb) (*totalNmb) += n;
+                localNmb += n;
+                }
+            else if ( Config()->Has(Config()->MuonTriggerKey(),strigger->String(),IsSimulation()))
+                {
+                nmsl += n;
+                if ( totalNmsl) (*totalNmsl) += n;
+                localNmsl += n;
+                }
+            else if ( Config()->Has(Config()->DimuonTriggerKey(),strigger->String(),IsSimulation()) )
+                {
+                nmul += n;
+                if ( totalNmul ) (*totalNmul) += n;
+                localNmul += n;
+                }
+            }
+        
+        std::cout << Form("MB %10lld MSL %10lld MUL %10lld %s",
+                          nmb,nmsl,nmul,(nofPS == 0 ? "(NO PS AVAIL)": ""));
+        
+        
+        if ( detailTriggers )
+            {
+            std::cout << details.Data();
+            }
+        std::cout << std::endl;
         }
-
-      }
-
-      if ( Config()->Has(Config()->MinbiasTriggerKey(),strigger->String(),IsSimulation() ) )
-      {
-        nmb += n;
-        if ( totalNmb) (*totalNmb) += n;
-        localNmb += n;
-      }
-      else if ( Config()->Has(Config()->MuonTriggerKey(),strigger->String(),IsSimulation()))
-      {
-        nmsl += n;
-        if ( totalNmsl) (*totalNmsl) += n;
-        localNmsl += n;
-      }
-      else if ( Config()->Has(Config()->DimuonTriggerKey(),strigger->String(),IsSimulation()) )
-      {
-        nmul += n;
-        if ( totalNmul ) (*totalNmul) += n;
-        localNmul += n;
-      }      
-    }
     
-    std::cout << Form("MB %10lld MSL %10lld MUL %10lld %s",
-                 nmb,nmsl,nmul,(nofPS == 0 ? "(NO PS AVAIL)": ""));
+    if ( !totalNmul && !totalNmsl && !totalNmb )
+        {
+        std::cout << std::endl << Form("%13s MB %10lld MSL %10lld MUL %10lld ","TOTAL",
+                                       localNmb,localNmsl,localNmul) << std::endl;
+        }
     
-
-    if ( detailTriggers )
-    {
-      std::cout << details.Data();
-    }
-    std::cout << std::endl;
-  }
-
-  if ( !totalNmul && !totalNmsl && !totalNmb )
-  {
-    std::cout << std::endl << Form("%13s MB %10lld MSL %10lld MUL %10lld ","TOTAL",
-                                   localNmb,localNmsl,localNmul) << std::endl;
-  }
-
-  delete runs;
-  delete triggers;
-  delete events;
+    delete runs;
+    delete triggers;
+    delete events;
 }
 
 
 
+
 //_____________________________________________________________________________
 void AliAnalysisMuMu::CleanAllSpectra()
 {
-  /// Delete all the spectra we may have
+    /// Delete all the spectra we may have
+    
+    OC()->RemoveByType("AliAnalysisMuMuSpectra");
+    Update();
+}
 
-  OC()->RemoveByType("AliAnalysisMuMuSpectra");
-  Update();
+//_____________________________________________________________________________
+void AliAnalysisMuMu::CleanFNorm()
+{
+    /// Delete all the spectra we may have
+    
+    OC()->Prune("/FNORM");
+    Update();
 }
 
 
 //_____________________________________________________________________________
 TObjArray* AliAnalysisMuMu::CompareJpsiPerCMUUWithBackground(const char* jpsiresults,
-                                                                   const char* backgroundresults)
+                                                             const char* backgroundresults)
 {
-  TFile* fjpsi = FileOpen(jpsiresults);
-  TFile* fbck = FileOpen(backgroundresults);
-  
-  if (!fjpsi || !fbck) return 0x0;
-  
-  TGraph* gjpsi = static_cast<TGraph*>(fjpsi->Get("jpsipercmuu"));
+    TFile* fjpsi = FileOpen(jpsiresults);
+    TFile* fbck = FileOpen(backgroundresults);
     
-  std::vector<std::string> checks;
-
-  checks.push_back("muminus-CMUU7-B-NOPF-ALLNOTRD");
-  checks.push_back("muplus-CMUU7-B-NOPF-ALLNOTRD");
-  checks.push_back("muminus-CMUSH7-B-NOPF-MUON");
-  checks.push_back("muplus-CMUSH7-B-NOPF-MUON");
-  
-  if (!gjpsi) return 0x0;
-
-  TObjArray* a = new TObjArray;
-  a->SetOwner(kTRUE);
-  
-  for ( std::vector<std::string>::size_type j = 0; j < checks.size(); ++j )
-  {
+    if (!fjpsi || !fbck) return 0x0;
     
-    TGraph* gback = static_cast<TGraph*>(fbck->Get(checks[j].c_str()));
+    TGraph* gjpsi = static_cast<TGraph*>(fjpsi->Get("jpsipercmuu"));
     
-    if (!gback) continue;
-
-    if ( gjpsi->GetN() != gback->GetN() )
-    {
-      AliErrorClass("graphs have different number of points !");
-      continue;
-    }
+    std::vector<std::string> checks;
     
-    TGraphErrors* g = new TGraphErrors(gjpsi->GetN());
+    checks.push_back("muminus-CMUU7-B-NOPF-ALLNOTRD");
+    checks.push_back("muplus-CMUU7-B-NOPF-ALLNOTRD");
+    checks.push_back("muminus-CMUSH7-B-NOPF-MUON");
+    checks.push_back("muplus-CMUSH7-B-NOPF-MUON");
     
-    for ( int i = 0; i < gjpsi->GetN(); ++i ) 
-    {
-      double r1,r2,y1,y2;
-      
-      gjpsi->GetPoint(i,r1,y1);
-      gback->GetPoint(i,r2,y2);
-      
-      if ( r1 != r2 ) 
-      {
-        AliWarningClass(Form("run[%d]=%d vs %d",i,(int)r1,(int)r2));
-        continue;
-      }
-      
-      g->SetPoint(i,y2,y1);
-      //    g->SetPointError(i,gjpsi->GetErrorY(i),gback->GetErrorY(i));
-    }
+    if (!gjpsi) return 0x0;
     
-    g->SetMarkerStyle(25+j);
-    g->SetMarkerSize(1.2);
-    if (j==0)
-    {
-      g->Draw("ap");
-    }
-    else
-    {
-      g->Draw("p");
-    }
-    g->SetLineColor(j+1);
-    g->SetMarkerColor(j+1);
-    g->SetName(checks[j].c_str());
-    a->AddLast(g);
-  }
-  
-  return a;
+    TObjArray* a = new TObjArray;
+    a->SetOwner(kTRUE);
+    
+    for ( std::vector<std::string>::size_type j = 0; j < checks.size(); ++j )
+        {
+        
+        TGraph* gback = static_cast<TGraph*>(fbck->Get(checks[j].c_str()));
+        
+        if (!gback) continue;
+        
+        if ( gjpsi->GetN() != gback->GetN() )
+            {
+            AliErrorClass("graphs have different number of points !");
+            continue;
+            }
+        
+        TGraphErrors* g = new TGraphErrors(gjpsi->GetN());
+        
+        for ( int i = 0; i < gjpsi->GetN(); ++i )
+            {
+            double r1,r2,y1,y2;
+            
+            gjpsi->GetPoint(i,r1,y1);
+            gback->GetPoint(i,r2,y2);
+            
+            if ( r1 != r2 )
+                {
+                AliWarningClass(Form("run[%d]=%d vs %d",i,(int)r1,(int)r2));
+                continue;
+                }
+            
+            g->SetPoint(i,y2,y1);
+            //    g->SetPointError(i,gjpsi->GetErrorY(i),gback->GetErrorY(i));
+            }
+        
+        g->SetMarkerStyle(25+j);
+        g->SetMarkerSize(1.2);
+        if (j==0)
+            {
+            g->Draw("ap");
+            }
+        else
+            {
+            g->Draw("p");
+            }
+        g->SetLineColor(j+1);
+        g->SetMarkerColor(j+1);
+        g->SetName(checks[j].c_str());
+        a->AddLast(g);
+        }
+    
+    return a;
 }
 
 //_____________________________________________________________________________
 TGraph* AliAnalysisMuMu::CompareJpsiPerCMUUWithSimu(const char* realjpsiresults,
-                                                             const char* simjpsiresults)
+                                                    const char* simjpsiresults)
 {
-  TFile* freal = FileOpen(realjpsiresults);
-  TFile* fsim = FileOpen(simjpsiresults);
-  
-  if (!freal || !fsim) return 0x0;
-  
-  TGraph* greal = static_cast<TGraph*>(freal->Get("jpsipercmuu"));
-  TGraph* gsim = static_cast<TGraph*>(fsim->Get("jpsipercmuu"));
-  
-  TObjArray* a = new TObjArray;
-  a->SetOwner(kTRUE);
-  
-  if ( greal->GetN() != gsim->GetN() )
-  {
-    AliErrorClass("graphs have different number of points !");
-    return 0x0;
-  }
+    TFile* freal = FileOpen(realjpsiresults);
+    TFile* fsim = FileOpen(simjpsiresults);
     
-  TGraphErrors* g = new TGraphErrors(greal->GetN());
-  TGraphErrors* gratio = new TGraphErrors(greal->GetN());
+    if (!freal || !fsim) return 0x0;
     
-  for ( int i = 0; i < greal->GetN(); ++i ) 
-  {
-    double r1,r2,y1,y2;
+    TGraph* greal = static_cast<TGraph*>(freal->Get("jpsipercmuu"));
+    TGraph* gsim = static_cast<TGraph*>(fsim->Get("jpsipercmuu"));
     
-    greal->GetPoint(i,r1,y1);
-    gsim->GetPoint(i,r2,y2);
+    TObjArray* a = new TObjArray;
+    a->SetOwner(kTRUE);
     
-    if ( r1 != r2 ) 
-    {
-      AliWarningClass(Form("run[%d]=%d vs %d",i,(int)r1,(int)r2));
-      continue;
-    }
+    if ( greal->GetN() != gsim->GetN() )
+        {
+        AliErrorClass("graphs have different number of points !");
+        return 0x0;
+        }
     
-    double ratio(0.0);
+    TGraphErrors* g = new TGraphErrors(greal->GetN());
+    TGraphErrors* gratio = new TGraphErrors(greal->GetN());
     
-    if ( TMath::Abs(y1)<1E-6 || TMath::Abs(y2)<1E-6)
-    {
-      g->SetPoint(i,0,0);
-      g->SetPointError(i,0,0);
-    }
-    else
-    {    
-      g->SetPoint(i,y2,y1);
-      g->SetPointError(i,greal->GetErrorY(i),gsim ->GetErrorY(i));
-      ratio = y2/y1;
-    }
-    gratio->SetPoint(i,r1,ratio);
-  }
+    for ( int i = 0; i < greal->GetN(); ++i )
+        {
+        double r1,r2,y1,y2;
+        
+        greal->GetPoint(i,r1,y1);
+        gsim->GetPoint(i,r2,y2);
+        
+        if ( r1 != r2 )
+            {
+            AliWarningClass(Form("run[%d]=%d vs %d",i,(int)r1,(int)r2));
+            continue;
+            }
+        
+        double ratio(0.0);
+        
+        if ( TMath::Abs(y1)<1E-6 || TMath::Abs(y2)<1E-6)
+            {
+            g->SetPoint(i,0,0);
+            g->SetPointError(i,0,0);
+            }
+        else
+            {
+                g->SetPoint(i,y2,y1);
+                g->SetPointError(i,greal->GetErrorY(i),gsim ->GetErrorY(i));
+                ratio = y2/y1;
+            }
+        gratio->SetPoint(i,r1,ratio);
+        }
     
-  g->SetMarkerStyle(25);
-  g->SetMarkerSize(1.2);
-
-  new TCanvas;
-  
-  g->Draw("ap");
-
-  g->SetLineColor(1);
-  g->SetMarkerColor(1);
-  g->SetName("jpsipercmuurealvssim");
-
-  new TCanvas;
-  
-  greal->Draw("alp");
-  gsim->SetLineColor(4);
-  
-  gsim->Draw("lp");
-
-  new TCanvas;
-  gratio->Draw("alp");
-  
-  return g;
+    g->SetMarkerStyle(25);
+    g->SetMarkerSize(1.2);
+    
+    new TCanvas;
+    
+    g->Draw("ap");
+    
+    g->SetLineColor(1);
+    g->SetMarkerColor(1);
+    g->SetName("jpsipercmuurealvssim");
+    
+    new TCanvas;
+    
+    greal->Draw("alp");
+    gsim->SetLineColor(4);
+    
+    gsim->Draw("lp");
+    
+    new TCanvas;
+    gratio->Draw("alp");
+    
+    return g;
 }
 
+
 //_____________________________________________________________________________
-AliAnalysisMuMuConfig* AliAnalysisMuMu::Config()
+void AliAnalysisMuMu::DrawFitResults(const char* particle,
+                                     const char* binType,
+                                     const char* printDirectoryPath,
+                                     Bool_t Print,
+                                     Bool_t AccEffCorr
+                                     )const
 {
-  /// Return the configuration
-  return fConfig;
+    /// A function to use after JPsi()
+    /// Draw all results/subresults (i.e fit functions) spectras on a single canvas for every combination of Trigger / event Type / centrality / Pair cut.
+    
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    
+    
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+    
+    // Iterater for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextBinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+    
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+    
+    AliAnalysisMuMuSpectra * spectra=0x0;
+    
+    //Loop on particle
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+        
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextCentrality.Reset();
+                
+                // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                    AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+                    nextPairCut.Reset();
+                    
+                    // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                        {
+                        AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+                        nextBinType.Reset();
+                        
+                        // Loop on each binType (PT or Y)
+                        //==============================================================================
+                        while ( ( sbinType = static_cast<TObjString*>(nextBinType()) ) )
+                            {
+                            AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
+                            // Output message
+                            cout << "---------------------" << endl;
+                            cout << "Looking for spectras ..."<< endl;
+                            
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+                            
+                            // Create pointer on fitted spectra. Any kind of capsule do the job
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,"","");
+                            if(!capsule)
+                                {
+                                AliError("Could not find spetra !");
+                                return;
+                                }
+                            // Draw results
+                            capsule->DrawResults(printDirectoryPath,Print,particle);
+                            delete capsule;
+                            
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+    
+    return ;
 }
 
 //_____________________________________________________________________________
@@ -465,352 +596,639 @@ void AliAnalysisMuMu::DrawMinv(const char* type,
                                const char* subresultname,
                                const char* flavour) const
 {
-  /// Draw minv spectra for binning of given type
-  
-  if (!OC() || !BIN()) return;
-  
-  TObjArray* bins = BIN()->CreateBinObjArray(particle,type,flavour);
-  if (!bins)
-  {
-    AliError(Form("Could not get %s bins",type));
-    return;
-  }
-  
-  Double_t xmin(-1);
-  Double_t xmax(-1);
-  
-  TString sparticle(particle);
-  if ( sparticle=="PSI" )
-  {
-    xmin = 2;
-    xmax = 6;
-  }
-  
-  Int_t nx(1);
-  Int_t ny(1);
-  
-  Int_t n = bins->GetEntries();
-  
-  if ( n == 2 )
-  {
-    nx = 2;
-  }
-  else if ( n > 2 )
-  {
-    ny = TMath::Nint(TMath::Sqrt(n));
-    nx = n/ny;
-  }
-  
-  TString stype(type);
-  stype.ToUpper();
-  
-  TString spectraName(Form("/%s/%s/%s/%s/%s-%s",eventType,trigger,centrality,pairCut,particle,stype.Data()));
-  
-  if ( strlen(flavour))
-  {
-    spectraName += "-";
-    spectraName += flavour;
-  }
-  
-  AliAnalysisMuMuSpectra* spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraName.Data()));
-  
-  AliDebug(1,Form("spectraName=%s spectra=%p",spectraName.Data(),spectra));
-
-  TObjArray* spectraBins(0x0);
-  if ( spectra )
-  {
-    spectraBins = spectra->BinContentArray();
-  }
-  
-  TCanvas* c = new TCanvas;
-  c->Divide(nx,ny);
-  c->Draw();
-  gStyle->SetOptFit(1112);
-  
-  c->Connect("ProcessedEvent(Int_t,Int_t,Int_t,TObject*)", "AliAnalysisMuMu",
-              (void*)this, "ExecuteCanvasEvent(Int_t,Int_t,Int_t,TObject*)");
-
-  
-  TIter next(bins);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t ci(0);
-  
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
-  {
-    TString name(Form("/%s/%s/%s/%s/MinvUS+%s",eventType,trigger,centrality,pairCut,r->AsString().Data()));
-
-    AliDebug(1,name.Data());
+    /// Draw minv spectra for binning of given type
     
-    AliAnalysisMuMuJpsiResult* spectraBin(0x0);
+    if (!OC() || !BIN()) return;
     
-    if ( spectraBins )
-    {
-      AliAnalysisMuMuResult* sr = static_cast<AliAnalysisMuMuResult*>(spectraBins->At(ci));
-      
-      spectraBin = static_cast<AliAnalysisMuMuJpsiResult*>(sr->SubResult(subresultname));
-      
-      AliDebug(1,Form("spectraBin(%s)=%p",subresultname,spectraBin));
-    }
+    TObjArray* bins = BIN()->CreateBinObjArray(particle,type,flavour);
+    if (!bins)
+        {
+        AliError(Form("Could not get %s bins",type));
+        return;
+        }
     
-    TH1* h = OC()->Histo(name.Data());
+    Double_t xmin(-1);
+    Double_t xmax(-1);
     
-    if ( spectraBin )
-    {
-      h = spectraBin->Histo();
-    }
+    TString sparticle(particle);
+    if ( sparticle=="PSI" )
+        {
+        xmin = 2;
+        xmax = 6;
+        }
     
-    if (h)
-    {
-      ++ci;
-      c->cd(ci);
-      gPad->SetLogy();
-      if (xmin>0)
-      {
-        h->GetXaxis()->SetRangeUser(xmin,xmax);
-      }
-      h->Draw("histes");
-      
-      TObject* f1 = h->GetListOfFunctions()->FindObject("fitTotal");
-      if (f1)
-      {
-        f1->Draw("same");
-      }
-      
-      gPad->Modified();
-      gPad->Update();
-      
-      TObject* stats = h->FindObject("stats");
-      if (stats)
-      {
-        stats->Draw("same");
-      }
-    }
-  }
-  
-  delete bins;
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::DrawMinv(const char* type, const char* particle, const char* flavour, const char* subresultname) const
-{
-  /// Draw minv spectra for binning of given type
-
-//  AliWarning("Reimplement me!");
-  
-  if (!fConfig)
-  {
-    AliError("No configuration available yet. Don't know what to draw");
-    return;
-  }
-  
-  const AliAnalysisMuMuConfig& c = *(Config());
-  
-  DrawMinv(type,particle,
-           c.First(c.DimuonTriggerKey(),IsSimulation()),
-           c.First(c.EventSelectionKey(),IsSimulation()),
-           c.First(c.PairSelectionKey(),IsSimulation()),
-           c.First(c.CentralitySelectionKey(),IsSimulation()),
-           subresultname,
-           flavour);
-}
-
-//___________________________________________________________________
-void AliAnalysisMuMu::ExecuteCanvasEvent(Int_t event, Int_t /*px*/, Int_t /*py*/, TObject *sel)
+    Int_t nx(1);
+    Int_t ny(1);
+    
+    Int_t n = bins->GetEntries();
+    
+    if ( n == 2 )
+        {
+        nx = 2;
+        }
+    else if ( n > 2 )
+        {
+        ny = TMath::Nint(TMath::Sqrt(n));
+        nx = n/ny;
+        }
+    
+    TString stype(type);
+    stype.ToUpper();
+    
+    TString spectraName(Form("/%s/%s/%s/%s/%s-%s",eventType,trigger,centrality,pairCut,particle,stype.Data()));
+    
+    if ( strlen(flavour))
+        {
+        spectraName += "-";
+        spectraName += flavour;
+        }
+    
+    AliAnalysisMuMuSpectra* spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraName.Data()));
+    
+    AliDebug(1,Form("spectraName=%s spectra=%p",spectraName.Data(),spectra));
+    
+    TObjArray* spectraBins(0x0);
+    if ( spectra )
+        {
+        spectraBins = spectra->BinContentArray();
+        }
+    
+    TCanvas* c = new TCanvas;
+    c->Divide(nx,ny);
+    c->Draw();
+    gStyle->SetOptFit(1112);
+    
+    c->Connect("ProcessedEvent(Int_t,Int_t,Int_t,TObject*)", "AliAnalysisMuMu",
+               (void*)this, "ExecuteCanvasEvent(Int_t,Int_t,Int_t,TObject*)");
+    
+    
+    TIter next(bins);
+    AliAnalysisMuMuBinning::Range* r;
+    Int_t ci(0);
+    
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
+        {
+        TString name(Form("/%s/%s/%s/%s/MinvUS%s",eventType,trigger,centrality,pairCut,r->AsString().Data()));
+        
+        AliDebug(1,name.Data());
+        
+        AliAnalysisMuMuJpsiResult* spectraBin(0x0);
+        
+        if ( spectraBins )
+            {
+            AliAnalysisMuMuResult* sr = static_cast<AliAnalysisMuMuResult*>(spectraBins->At(ci));
+            
+            spectraBin = static_cast<AliAnalysisMuMuJpsiResult*>(sr->SubResult(subresultname));
+            
+            AliDebug(1,Form("spectraBin(%s)=%p",subresultname,spectraBin));
+            }
+        
+        TH1* h = OC()->Histo(name.Data());
+        
+        if ( spectraBin )
+            {
+            h = spectraBin->Histo();
+            }
+        
+        if (h)
+            {
+            ++ci;
+            c->cd(ci);
+            gPad->SetLogy();
+            if (xmin>0)
+                {
+                h->GetXaxis()->SetRangeUser(xmin,xmax);
+                }
+            h->Draw("histes");
+            
+            TObject* f1 = h->GetListOfFunctions()->FindObject("fitTotal");
+            if (f1)
+                {
+                f1->Draw("same");
+                }
+            
+            gPad->Modified();
+            gPad->Update();
+            
+            TObject* stats = h->FindObject("stats");
+            if (stats)
+                {
+                stats->Draw("same");
+                }
+            }
+        }
+    
+    delete bins;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::DrawMinv(const char* type, const char* particle, const char* flavour, const char* subresultname) const
 {
-  // Actions in reponse to mouse button events.
-  
-  TCanvas* c = static_cast<TCanvas*>(gTQSender);
-  TPad* pad = static_cast<TPad*>(c->GetSelectedPad());
-  if (!pad) return;
-  
-//  if ((event == kButton1Down) ||
-  if (event == kButton1Double) 
-  {
-    
-//    Float_t x = pad->AbsPixeltoX(px);
-//    Float_t y = pad->AbsPixeltoY(py);
-//    x = pad->PadtoX(x);
-//    y = pad->PadtoY(y);
+    /// Draw minv spectra for binning of given type
+    
+    //  AliWarning("Reimplement me!");
+    
+    if (!fConfig)
+        {
+        AliError("No configuration available yet. Don't know what to draw");
+        return;
+        }
+    const AliAnalysisMuMuConfig& c = *(Config());
+    
+    DrawMinv(type,particle,
+             c.First(c.DimuonTriggerKey(),IsSimulation()),
+             c.First(c.EventSelectionKey(),IsSimulation()),
+             c.First(c.PairSelectionKey(),IsSimulation()),
+             c.First(c.CentralitySelectionKey(),IsSimulation()),
+             subresultname,
+             flavour);
+}
 
-//    std::cout << "event=" << event << " px=" << px << " py=" << py << " ";
+//___________________________________________________________________
+void AliAnalysisMuMu::ExecuteCanvasEvent(Int_t event, Int_t /*px*/, Int_t /*py*/, TObject *sel)
+{
+    // Actions in reponse to mouse button events.
     
-    if ( sel && sel->InheritsFrom("TH1") )
-    {
-      TCanvas* clocal = new TCanvas;
-      clocal->SetLogy();
-      clocal->Draw();
-      sel->Draw();
-    }
-    else
-    {
-      TList* list = pad->GetListOfPrimitives();
-      TIter next(list);
-      TObject* h;
-      
-      while ( ( h = next() ) )
-      {
-        if ( h->InheritsFrom("TH1") )
-        {
-          TCanvas* clocal = new TCanvas;
-          clocal->SetLogy();
-          clocal->Draw();
-          h->Draw();
-          break;
-        }
-      }
-      
-    }
+    TCanvas* c = static_cast<TCanvas*>(gTQSender);
+    TPad* pad = static_cast<TPad*>(c->GetSelectedPad());
+    if (!pad) return;
+    
+    //  if ((event == kButton1Down) ||
+    if (event == kButton1Double)
+        {
+        
+        //    Float_t x = pad->AbsPixeltoX(px);
+        //    Float_t y = pad->AbsPixeltoY(py);
+        //    x = pad->PadtoX(x);
+        //    y = pad->PadtoY(y);
+        
+        //    std::cout << "event=" << event << " px=" << px << " py=" << py << " ";
+        
+        if ( sel && sel->InheritsFrom("TH1") )
+            {
+            TCanvas* clocal = new TCanvas;
+            clocal->SetLogy();
+            clocal->Draw();
+            sel->Draw();
+            }
+        else
+            {
+            TList* list = pad->GetListOfPrimitives();
+            TIter next(list);
+            TObject* h;
+            
+            while ( ( h = next() ) )
+                {
+                if ( h->InheritsFrom("TH1") )
+                    {
+                    TCanvas* clocal = new TCanvas;
+                    clocal->SetLogy();
+                    clocal->Draw();
+                    h->Draw();
+                    break;
+                    }
+                }
+            
+            }
+        
+        //      std::cout  << std::endl;
+        
+        pad->Modified();
+        }
+    
+}
 
-//      std::cout  << std::endl;
 
-      pad->Modified();
-  }
-  
+//_____________________________________________________________________________
+void AliAnalysisMuMu::RAAasGraphic(const char* particle,
+                                   const char* binType,
+                                   const char* externfile,
+                                   const char* externfile2,
+                                   const char* RefCent,
+                                   Bool_t AccEffCorr
+                                   )const
+{
+    /**
+     * Function to use after fitting procedur ( Jpsi() for instance ).
+     * Loops over all combination of /eventype/trigger/centrality (etc.), compute, store and print RAA on terminal.
+     * <binType> can be either "PT"/"Y"/"INTEGRATED" for the moment.
+     *
+     * Some comments: In case of PT/Y/CENTRALITY(single bin), the method implemented in AliAnalysisMuMuSpectraCapsulePbPb does the job, but for RAAvsCENTRALITY,
+     * we have to create a new TGraph (see inside for details)
+     */
+    
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                             Computing RAA                             " << endl;
+        cout <<      " ================================================================ " << endl;
+        }
+    
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+    
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+    
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+    
+    // Pointers
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphCent=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+    
+    //Loop on particle type
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                        
+                        //canvas
+                        TCanvas *c1 = new TCanvas;
+                        c1->Draw();
+                        //Divide canvas for pt and y bin
+                        if (!sbinType->String().Contains("INTEGRATED"))
+                            {
+                            Int_t nx(1);
+                            Int_t ny(1);
+                            Int_t nofGraph = centralityArray->GetEntries(); // # of histo
+                            if ( nofGraph == 2 )
+                                {
+                                nx=2;
+                                ny=0;
+                                }
+                            else if ( nofGraph > 2 )
+                                {
+                                ny = TMath::Nint(TMath::Sqrt(nofGraph));
+                                nx = TMath::Nint((nofGraph/ny) +0.6);
+                                }
+                            c1->Divide(nx,ny);
+                            }
+                        else if (sbinType->String().Contains("INTEGRATED"))
+                            {
+                            graphCent = new TGraphErrors(centralityArray->GetEntries());
+                            graphCent->SetMinimum(0.);
+                            graphCent->SetMaximum(1.2);
+                            }
+                        gStyle->SetOptStat(0);
+                        
+                        cout << Form("  __________________________________________________________ ") << endl;
+                        cout << Form("  |         bin      |   JPsi  Stat.  Syst. | RAA  Stat.  Syst. | <NPART>  d<NPART> |") << endl;
+                        
+                        Int_t n=1; // counter
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                            {
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+                            
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+                            
+                            //________Get Trigger sum
+                            Int_t NofMUL = TMath::Nint(CC()->GetSum(Form("trigger:%s/event:%s/centrality:%s",strigger->String().Data(),seventType->String().Data(),RefCent)));
+                            //________
+                            
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,externfile,externfile2);
+                            if(!capsule) continue;
+                            AliDebug(1,Form("Spectra = %p",capsule));
+                            // capsule->PrintConst();
+                            
+                            // Get Graph with RAA results
+                            graph = capsule->RAAasGraphic(NofMUL);
+                            
+                            if(!graph) continue;
+                            AliDebug(1,Form("Graphic = %p",graph));
+                            
+                            // Draw Graph according to bin type
+                            if (!sbinType->String().Contains("INTEGRATED")) // PT/Y/single centrality
+                                {
+                                // Select subcanvas
+                                c1->cd(n);
+                                //legend
+                                TLegend * leg = new TLegend(0.2,0.7,0.90,0.9);
+                                leg->SetTextSize(0.04);
+                                leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=2.76 TeV, L_{int}=70 #mub^{-1}, %s",scentrality->String().Data()));
+                                leg->AddEntry(graph,"Inclusive J/#psi","pe");
+                                //Draw it
+                                graph->GetYaxis()->SetRangeUser(0,1.41);
+                                graph->Draw("ap");
+                                leg->Draw();
+                                }
+                            else
+                                {
+                                //Check point
+                                if(!sbinType->String().Contains("INTEGRATED"))
+                                    {
+                                    cout << "Cannot plot INTEGRATED  ! Check it please :) " << endl;
+                                    delete c1;
+                                    return;
+                                    }
+                                Double_t x=0;
+                                Double_t y=0;
+                                // Get point for each centrality
+                                Double_t dx = graph->GetErrorX(0);
+                                Double_t dy = graph->GetErrorY(0);
+                                graph->GetPoint(0,x,y);
+                                // Set them to a new graphic
+                                graphCent->SetPoint(n-1,x,y);
+                                graphCent->SetPointError(n-1,dx,dy);
+                                graphCent->SetTitle(graph->GetTitle());
+                                }
+                            n++;
+                            delete capsule;
+                            }
+                        cout << "" << endl;
+                        if (sbinType->String().Contains("INTEGRATED"))
+                            {
+                            
+                            graphCent->GetXaxis()->SetTitle("<N_{part}>");
+                            graphCent->GetYaxis()->SetTitle("R_{AA}");
+                            graphCent->GetYaxis()->SetRangeUser(0,1.41);
+                            graphCent->SetMarkerColor(4);
+                            graphCent->SetMarkerStyle(21);
+                            graphCent->SetTitle(Form("%s/%s/%s/%s/%s",seventType->String().Data(),
+                                                     strigger->String().Data(),
+                                                     spairCut->String().Data(),
+                                                     sparticle->String().Data(),
+                                                     sbinType->String().Data()));
+                            TLegend * leg = new TLegend(0.2,0.7,0.90,0.9);
+                            leg->SetHeader("ALICE, Pb-Pb #sqrt{s_{NN}}=5.02 TeV, L_{int}=74 #mub^{-1}, PT/Y integrated");
+                            leg->SetTextSize(0.03);
+                            leg->AddEntry(graphCent,"Inclusive J/#psi","pe");
+                            graphCent->Draw("ap");
+                            leg->Draw();
+                            }
+                        //________ Update resultes in Mergeable collection
+                        TString id(Form("/RAA-%s/%s/%s/%s/%s",strigger->String().Data(),seventType->String().Data(),spairCut->String().Data(),sbinType->String().Data(),sparticle->String().Data()));
+                        
+                        
+                        TObject* o = 0x0;
+                        
+                        if (graph)// first graph
+                            {
+                            o = fMergeableCollection->GetObject(Form("%s/%s",id.Data(),graph->GetName()));
+                            
+                            if (o)
+                                {
+                                AliWarning(Form("Replacing %s/%s",id.Data(),graph->GetName()));
+                                fMergeableCollection->Remove(Form("%s/%s",id.Data(),graph->GetName()));
+                                }
+                            
+                            Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),graph);
+                            
+                            if ( adoptOK ) std::cout << "+++RAA graph " << graph->GetName() << " adopted" << std::endl;
+                            else AliError(Form("Could not adopt RAA grap %s",graph->GetName()));
+                            }
+                        
+                        
+                        if (graphCent)// second graph
+                            {
+                            o = fMergeableCollection->GetObject(Form("%s/%s",id.Data(),graphCent->GetName()));
+                            
+                            if (o)
+                                {
+                                AliWarning(Form("Replacing %s/%s",id.Data(),graphCent->GetName()));
+                                fMergeableCollection->Remove(Form("%s/%s",id.Data(),graphCent->GetName()));
+                                }
+                            
+                            Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),graphCent);
+                            
+                            if ( adoptOK ) std::cout << "+++RAA graph " << graphCent->GetName() << " adopted" << std::endl;
+                            else AliError(Form("Could not adopt RAA graph %s",graphCent->GetName()));
+                            }
+                        //________
+                        }
+                    }
+                }
+            }
+        }
+    
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+    
+    return ;
+    
 }
 
+
 //_____________________________________________________________________________
-TString 
+TString
 AliAnalysisMuMu::ExpandPathName(const char* file)
 {
-  // An expand method that lives alien URL as they are
-  TString sfile;
-  
-  if ( !sfile.BeginsWith("alien://") )
-  {
-    return gSystem->ExpandPathName(file);
-  }
-  else
-  {
-    if (!gGrid) TGrid::Connect("alien://");
-    if (!gGrid) return "";    
-  }
-  
-  return file;
+    // An expand method that lives alien URL as they are
+    TString sfile;
+    
+    if ( !sfile.BeginsWith("alien://") )
+        {
+        return gSystem->ExpandPathName(file);
+        }
+    else
+        {
+        if (!gGrid) TGrid::Connect("alien://");
+        if (!gGrid) return "";
+        }
+    
+    return file;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::TwikiOutputFnorm(const char* series) const
 {
-  // make a twiki-compatible output of the Fnorm factor(s)
-  TObjArray* what = TString(series).Tokenize(",");
-  TObjString* s;
-  TObjArray graphs;
-  TIter next(what);
-
-  std::cout << "| *Run* |";
-  while ( ( s = static_cast<TObjString*>(next())) )
-  {
-    TGraph* g = static_cast<TGraph*>(OC()->GetObject(Form("/FNORM/GRAPHS/%s",s->String().Data())));
-    if (!g)
-    {
-      AliError(Form("Could not find graph for %s",s->String().Data()));
-      continue;
-    }
-    std::cout << " *" << s->String().Data();
-    if ( s->String().BeginsWith("RelDif") ) std::cout << " %";
-    std::cout << "*|";
-    graphs.Add(g);
-  }
-  
-  std::cout << std::endl;
-  
-  TGraphErrors* g0 = static_cast<TGraphErrors*>(graphs.First());
-  if (!g0) return;
-  
-  for ( Int_t i = 0; i < g0->GetN(); ++i )
-  {
-    TString msg;
+    // make a twiki-compatible output of the Fnorm factor(s)
+    TObjArray* what = TString(series).Tokenize(",");
+    TObjString* s;
+    TObjArray graphs;
+    TIter next(what);
+    
+    std::cout << "| *Run* |";
+    while ( ( s = static_cast<TObjString*>(next())) )
+        {
+        TGraph* g = static_cast<TGraph*>(OC()->GetObject(Form("/FNORM/GRAPHS/%s",s->String().Data())));
+        if (!g)
+            {
+            AliError(Form("Could not find graph for %s",s->String().Data()));
+            continue;
+            }
+        std::cout << " *" << s->String().Data();
+        if ( s->String().BeginsWith("RelDif") ) std::cout << " %";
+        std::cout << "*|";
+        graphs.Add(g);
+        }
     
-    msg.Form("|%6d|",TMath::Nint(g0->GetX()[i]));
+    std::cout << std::endl;
     
-    for ( Int_t j = 0; j < graphs.GetEntries(); ++j )
-    {
-      TGraphErrors* g = static_cast<TGraphErrors*>(graphs.At(j));
-      
-      msg += TString::Format(" %6.2f +- %6.2f |",g->GetY()[i],g->GetEY()[i]);
-    }
+    TGraphErrors* g0 = static_cast<TGraphErrors*>(graphs.First());
+    if (!g0) return;
     
-    std::cout << msg.Data() << std::endl;
-  }
-  
-  next.Reset();
-  
-  std::cout << "|*Weigthed mean (*)*|";
-
-  AliAnalysisMuMuResult* r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
-  
-  if (!r)
-  {
-    AliError("Could not find Fnorm result !");
-    return;
-  }
-
-  
-  while ( ( s = static_cast<TObjString*>(next())) )
-  {
-    TString var("Fnorm");
-    TString unit;
+    for ( Int_t i = 0; i < g0->GetN(); ++i )
+        {
+        TString msg;
+        
+        msg.Form("|%6d|",TMath::Nint(g0->GetX()[i]));
+        
+        for ( Int_t j = 0; j < graphs.GetEntries(); ++j )
+            {
+            TGraphErrors* g = static_cast<TGraphErrors*>(graphs.At(j));
+            
+            msg += TString::Format(" %6.2f +- %6.2f |",g->GetY()[i],g->GetEY()[i]);
+            }
+        
+        std::cout << msg.Data() << std::endl;
+        }
     
-    if ( s->String().BeginsWith("Fnorm") )
-    {
-      r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
-    }
-    else if ( s->String().BeginsWith("RelDif") )
-    {
-      r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/RelDif"));
-      unit = "%";
-    }
-      
-    r->Exclude("*");
-    r->Include(s->String().Data());
-
-    std::cout << Form(" * %5.2f +- %5.2f %s * |",
-                      r->GetValue(var.Data()),
-                      r->GetErrorStat(var.Data()),
-                      unit.Data());
-  }
-  
-  next.Reset();
-  
-  std::cout << std::endl;
-
-  std::cout << "|*RMS*|";
-
-  while ( ( s = static_cast<TObjString*>(next())) )
-  {
-    TString var("Fnorm");
+    next.Reset();
     
-    if ( s->String().BeginsWith("Fnorm") )
-    {
-      r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
-    }
-    else if ( s->String().BeginsWith("RelDif") )
-    {
-      r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/RelDif"));
-    }
+    std::cout << "|*Weigthed mean (*)*|";
     
-    r->Exclude("*");
-    r->Include(s->String().Data());
+    AliAnalysisMuMuResult* r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
+    
+    if (!r)
+        {
+        AliError("Could not find Fnorm result !");
+        return;
+        }
     
-    Double_t d = 100.0*r->GetRMS(var.Data())/r->GetValue(var.Data());
     
-    std::cout << Form(" * %5.2f (%5.2f %%) * |",
-                      r->GetRMS(var.Data()),d);
-  }
-  
-  std::cout << std::endl;
-  std::cout << "(*) weight is the number of CMUL7-B-NOPF-MUON triggers (physics-selected and pile-up corrected) in each run" << std::endl;
-  
-  delete what;
+    while ( ( s = static_cast<TObjString*>(next())) )
+        {
+        TString var("Fnorm");
+        TString unit;
+        
+        if ( s->String().BeginsWith("Fnorm") )
+            {
+            r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
+            }
+        else if ( s->String().BeginsWith("RelDif") )
+            {
+            r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/RelDif"));
+            unit = "%";
+            }
+        
+        r->Exclude("*");
+        r->Include(s->String().Data());
+        
+        std::cout << Form(" * %5.2f +- %5.2f %s * |",
+                          r->GetValue(var.Data()),
+                          r->GetErrorStat(var.Data()),
+                          unit.Data());
+        }
+    
+    next.Reset();
+    
+    std::cout << std::endl;
+    
+    std::cout << "|*RMS*|";
+    
+    while ( ( s = static_cast<TObjString*>(next())) )
+        {
+        TString var("Fnorm");
+        
+        if ( s->String().BeginsWith("Fnorm") )
+            {
+            r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
+            }
+        else if ( s->String().BeginsWith("RelDif") )
+            {
+            r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/RelDif"));
+            }
+        
+        r->Exclude("*");
+        r->Include(s->String().Data());
+        
+        Double_t d = 100.0*r->GetRMS(var.Data())/r->GetValue(var.Data());
+        
+        std::cout << Form(" * %5.2f (%5.2f %%) * |",
+                          r->GetRMS(var.Data()),d);
+        }
+    
+    std::cout << std::endl;
+    std::cout << "(*) weight is the number of CMUL7-B-NOPF-MUON triggers (physics-selected and pile-up corrected) in each run" << std::endl;
+    
+    delete what;
 }
 
 //_____________________________________________________________________________
-TFile* 
+TFile*
 AliAnalysisMuMu::FileOpen(const char* file)
 {
-  // Open a file after expansion of its name
-  
-  return TFile::Open(ExpandPathName(file).Data());
+    // Open a file after expansion of its name
+    
+    return TFile::Open(ExpandPathName(file).Data());
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMu::First(const TString& list) const
+{
+    TObjArray* a = list.Tokenize(",");
+    if ( a->GetLast() < 0 ) return "";
+    
+    TString rv = static_cast<TObjString*>(a->First())->String();
+    
+    delete a;
+    
+    return rv;
 }
 
 //_____________________________________________________________________________
@@ -824,332 +1242,356 @@ AliAnalysisMuMu::FitParticle(const char* particle,
                              const char* spectraType,
                              Bool_t corrected)
 {
-  // Fit the minv/mpt spectra to find the given particle
-  // Returns an array of AliAnalysisMuMuResult objects
-  
-  TProfile::Approximate(); //To avoid bins with error=0 due to low statstics
-  
-  static int n(0);
-  
-  TObjArray* bins = binning.CreateBinObjArray(particle);
-  if (!bins)
-  {
-    AliError(Form("Did not get any bin for particle %s",particle));
-    return 0x0;
-  }
-  
-  TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
-  if ( !triggers->FindObject(trigger) )
-  {
-    AliError(Form("Did not find trigger %s",trigger));
-    delete bins;
+    // Fit the minv/mpt spectra to find the given particle
+    // Returns an array of AliAnalysisMuMuResult objects
+    
+    TProfile::Approximate(); //To avoid bins with error=0 due to low statstics
+    
+    static int n(0);
+    
+    //Check Binning list
+    TObjArray* bins = binning.CreateBinObjArray(particle);
+    if (!bins)
+        {
+        AliError(Form("Did not get any bin for particle %s",particle));
+        return 0x0;
+        }
+    
+    //Check trigger list
+    TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
+    if ( !triggers->FindObject(trigger) )
+        {
+        AliError(Form("Did not find trigger %s",trigger));
+        delete bins;
+        delete triggers;
+        return 0x0;
+        }
     delete triggers;
-    return 0x0;
-  }
-  delete triggers;
-  
-  TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
-  if ( !events->FindObject(eventType) )
-  {
-    AliError(Form("Did not find eventType %s",eventType));
-    delete bins;
+    
+    //Check event list
+    TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
+    if ( !events->FindObject(eventType) )
+        {
+        AliError(Form("Did not find eventType %s",eventType));
+        delete bins;
+        delete events;
+        return 0x0;
+        }
     delete events;
-    return 0x0;
-  }
-  delete events;
-
-  Int_t ntrigger = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s",trigger,eventType)));
-  
-  if  (ntrigger<=0)
-  {
-    AliError(Form("No trigger for trigger:%s/event:%s",trigger,eventType));
-    delete bins;
-    return 0x0;
-  }
-
-  TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
-  Int_t nruns = runs->GetEntries();
-  delete runs;
-  
-  
-  TString id(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut));
-  
-//  binning.Print();
-  
-  AliAnalysisMuMuSpectra* spectra(0x0);
-  
-  AliAnalysisMuMuBinning::Range* bin;
-  TIter next(bins);
-  
-  TObjArray* fitTypeArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());
-  TIter nextFitType(fitTypeArray);
-  TObjString* fitType;
-  TString flavour;
-  TString sSpectraType(spectraType);
-  
-  TString spectraName(binning.GetName());
-  if ( flavour.Length() > 0 )
-  {
-    spectraName += "-";
-    spectraName += flavour;
-  }
-  if ( corrected )
-  {
-    spectraName += "-";
-    spectraName += "AccEffCorr";
-  }
-  
-//  Int_t binN(0);
-  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
-  {
-    TString hname;
-    if (!sSpectraType.CompareTo("minv"))
-    {
-      hname = corrected ? Form("MinvUS%s_AccEffCorr",bin->AsString().Data()) : Form("MinvUS+%s",bin->AsString().Data());
-    }
-    else if (!sSpectraType.CompareTo("mpt"))
-    {
-      hname = corrected ? Form("MeanPtVsMinvUS%s_AccEffCorr",bin->AsString().Data()) : Form("MeanPtVsMinvUS%s",bin->AsString().Data());
-    }
-    else
-    {
-      AliError("Wrong spectra type choice: Posibilities are: 'minv' or 'mpt' ");
-      return 0x0;
-    }
     
-    TString isCorr(corrected ? " AccEffCorr " : " ");
-    std::cout << "---------------------------------//---------------------------------" << std::endl;
-    std::cout << "Fitting" << isCorr.Data() << sSpectraType.Data() << " spectra in " << id.Data() << std::endl;
+    Int_t ntrigger = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s",trigger,eventType)));
     
-    TH1* histo = OC()->Histo(id.Data(),hname.Data());
-
-    if (!histo)
-    {
-//      if (!fBinning && bin->IsIntegrated() )
-//      {
-//        // old file, we only had MinvUSPt
-//        hminv = fMergeableCollection->Histo(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut),"MinvUSPt:py");
-//      }
-//      
-//      if (!hminv)
-//      {
-        AliError(Form("Could not find histo %s",hname.Data()));
-        continue;
-//      }
-    }
+    //Check trigger
+    if  (ntrigger<=0)
+        {
+        AliError(Form("No trigger for trigger:%s/event:%s",trigger,eventType));
+        delete bins;
+        return 0x0;
+        }
     
-    histo = static_cast<TH1*>(histo->Clone(Form("%s%d",sSpectraType.Data(),n++)));
+    //Get number of runs and store it in nruns
+    TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
+    Int_t nruns = runs->GetEntries();
+    delete runs;
     
-    const char* particleTmp = IsSimulation() ? GetParticleName() : "JPsi"; //At some point particleTmp should become particle (but for now particle is always = "psi")
-  
-    TString sparticleTmp(particleTmp);
+    // Create ID for the fit which will be used to name results
+    TString id(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut));
     
-    AliAnalysisMuMuJpsiResult* r = new AliAnalysisMuMuJpsiResult(particleTmp,
-                                                                 *histo, // Result for current bin
-                                                                 trigger,
-                                                                 eventType,
-                                                                 pairCut,
-                                                                 centrality,
-                                                                 *bin);
+    //  binning.Print();
     
-    r->SetNofTriggers(ntrigger);
-    r->SetNofRuns(nruns);
+    //The result pointer, will be return at the end
+    AliAnalysisMuMuSpectra* spectra(0x0);
     
-    nextFitType.Reset();
-
-    Int_t added(0);    
+    // The binning pointer, which point at Pt binning, Y binning etc.
+    AliAnalysisMuMuBinning::Range* bin;
+    TIter next(bins);
     
-    while ( ( fitType = static_cast<TObjString*>(nextFitType())) )
-    {
-      // In this loop we create a Subresult for each fit inside the Result for current bin (AddFit will do)
-      
-      TString sFitType(fitType->String());
-      
-      if ( !sFitType.Contains(sSpectraType.Data()) ) continue;
-      
-      AliDebug(1,Form("<<<<<< fitType=%s bin=%s",sFitType.Data(),bin->Flavour().Data()));
-      
-      std::cout << "" << std::endl;
-      std::cout << "---------------" << "Fit " << added + 1 << "------------------" << std::endl;
-      std::cout << "Fitting " << hname.Data() << " with " << sFitType.Data() << std::endl;
-      std::cout << "" << std::endl;
-      
-      if ( sFitType.Contains("mctails",TString::kIgnoreCase) ) //FIXME: Find a univoque way to determine the correctly the fit type
-      {
-        TString sbin = bin->AsString();
-        TString spectraMCName = spectraName;
-        AliAnalysisMuMuBinning::Range* binMC = bin;
-        
-        if ((sbin.Contains("MULT") || sbin.Contains("NCH") || sbin.Contains("DNCHDETA") || sbin.Contains("V0A") || sbin.Contains("V0ACENT") || sbin.Contains("V0C") || sbin.Contains("V0M") || sbin.Contains("NTRCORR")|| sbin.Contains("RELNTRCORR")) && !sbin.Contains("NTRCORRPT") && !sbin.Contains("NTRCORRY"))
-        {
-          //-------has to have a better way to do it
-          AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
-          b->AddBin("psi","INTEGRATED");
-          
-          binMC = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
-          
-          spectraMCName = b->GetName();
-          delete b;
-          
-//          if ( flavour.Length() > 0 ) //Commented cause we set no flavour in "INTEGRATED" bin in the analysis task
-//          {
-//            spectraMCName += "-";
-//            spectraMCName += flavour;
-//          }
-          if ( corrected )
-          {
-            spectraMCName += "-";
-            spectraMCName += "AccEffCorr";
-          }
-          //-----------
-
-        }
-//        if( sbin.Contains("NTRCORRPT") || !sbin.Contains("NTRCORRY") )
-//        {
-//          spectraMCName.Remove(4,7);
-//          
-//          if ( spectraMCName.Contains("PT") )
-//          {
-//            AliAnalysisMuMuBinning* b = SIM()->BIN();
-//            
-//            TObjArray* binsPt = b->CreateBinObjArray(particle,"PT","");
-//            
-//            Int_t nEntrBinMC = binsPt->GetEntries();
-//            
-////            binsPt->Print();
-//            
-//            binMC = static_cast<AliAnalysisMuMuBinning::Range*>(binsPt->At(binN));
-//            
-//            if ( binN == nEntrBinMC - 1 ) binN = -1;
-//            
-//          }
-//          
-//        }
-        
-        //par = GetCB2Tails(*binInt,"MCTAILS",eventType,trigger,pairCut,corrected);Why I was taking the tails from the fitted data spectra?
-        GetParametersFromMC(sFitType,Form("/%s/%s",centrality,pairCut),spectraMCName.Data(),binMC);
-        
-        if (sFitType.Length()>0)
+    // Create an array (fitTypeArray) pointing on AliAnalysisMuMuConfig and store kFitTypeList.  Also create pointers and strings for several pointers
+    TObjArray* fitTypeArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());
+    TIter nextFitType(fitTypeArray);// Iterater for every fit types, i.e fitting functions and their config.
+    TObjString* fitType;// To point to the array (??)
+    TString flavour;// Flavour of the binning (ex: "JAVI","IGOR" ...)
+    TString sSpectraType(spectraType);// Make spectratype a string
+    
+    // Add some element to ID
+    TString spectraName(binning.GetName());
+    if ( flavour.Length() > 0 )
         {
-          added += ( r->AddFit(sFitType.Data()) == kTRUE );
+        spectraName += "-";
+        spectraName += flavour;
         }
-      }
-      
-      else if ( sFitType.Contains("mpt",TString::kIgnoreCase) && !sFitType.Contains("minv",TString::kIgnoreCase) )
-      {
-        std::cout << "++The Minv parameters will be taken from " << spectraName.Data() << std::endl;
-        std::cout << "" << std::endl;
-        
-        AliAnalysisMuMuSpectra* minvSpectra = dynamic_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(id.Data(),spectraName.Data()));
-       
-        if ( !minvSpectra )
+    if ( corrected )
         {
-          AliError(Form("Cannot fit mean pt: could not get the minv spectra for %s",id.Data()));
-          continue;//return 0x0;
+        spectraName += "-";
+        spectraName += "AccEffCorr";
         }
+    
+    //  Int_t binN(0);
+    
+    //MAIN PART : Loop on every binning range
+    //==============================================================================
+    while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
+        {
         
-        AliAnalysisMuMuJpsiResult* minvResult = static_cast<AliAnalysisMuMuJpsiResult*>(minvSpectra->GetResultForBin(*bin));
+        // Choose correct histo type with <spectraType> and set it in <hname>
+        TString hname;
+        if (!sSpectraType.CompareTo("minv"))
+            {
+            hname = corrected ? Form("MinvUS+%s_AccEffCorr",bin->AsString().Data()) : Form("MinvUS+%s",bin->AsString().Data());
+            }
+        else if (!sSpectraType.CompareTo("mpt"))
+            {
+            hname = corrected ? Form("MeanPtVsMinvUS%s",bin->AsString().Data()) : Form("MeanPtVsMinvUS%s",bin->AsString().Data());
+            }
+        else
+            {
+            AliError("Wrong spectra type choice: Posibilities are: 'minv' or 'mpt' ");
+            return 0x0;
+            }
         
-        if ( !minvResult )
-        {
-          AliError(Form("Cannot fit mean pt: could not get the minv result for bin %s in %s",bin->AsString().Data(),id.Data()));
-          continue; //return 0x0;
-        }
+        // Print the fitting process on the terminal
+        TString isCorr(corrected ? " AccEffCorr " : " ");
+        std::cout << "---------------------------------//---------------------------------" << std::endl;
+        std::cout << "Fitting" << isCorr.Data() << sSpectraType.Data() << " spectra in " << id.Data() << std::endl;
         
-        TObjArray* minvSubResults = minvResult->SubResults();
-        TIter nextSubResult(minvSubResults);
-        AliAnalysisMuMuJpsiResult* fitMinv;
-        TString subResultName;
+        // Pointer to the histo from histo collection
+        TH1* histo = OC()->Histo(id.Data(),hname.Data());
+        if (!histo)
+            {
+            //      if (!fBinning && bin->IsIntegrated() )
+            //      {
+            //        // old file, we only had MinvUSPt
+            //        hminv = fMergeableCollection->Histo(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut),"MinvUSPt:py");
+            //      }
+            //
+            //      if (!hminv)
+            //      {
+            AliError(Form("Could not find histo %s",hname.Data()));
+            continue;
+            //      }
+            }
         
-        Int_t nSubFit(0);
-        while ( ( fitMinv = static_cast<AliAnalysisMuMuJpsiResult*>(nextSubResult())) )
-        {
-          TString fitMinvName(fitMinv->GetName());
-          fitMinvName.Remove(fitMinvName.First("_"),fitMinvName.Sizeof()-fitMinvName.First("_"));
-          
-          if ( !sFitType.Contains(fitMinvName) ) continue; //FIXME: Ambiguous, i.e. NA60NEWPOL2EXP & NA60NEWPOL2 (now its ok cause only VWG and POL2EXP are used, but care)
-          
-          std::cout << "" << std::endl;
-          std::cout <<  "      /-- SubFit " << nSubFit + 1 << " --/ " << std::endl;
-          std::cout << "" << std::endl;
-
-          TString sMinvFitType(sFitType);
-          
-          GetParametersFromResult(sMinvFitType,fitMinv);//FIXME: Think about if this is necessary
-          
-          added += ( r->AddFit(sMinvFitType.Data()) == kTRUE );
-          
-          nSubFit++;
-        }
-      }
-      
-      else if ( sFitType.Contains("minv&mpt",TString::kIgnoreCase) )
-      {
-        AliWarning("Implement here the method to do the combined minv mpt fits");
-        //FIXME: Shall we use the fitType or spectraType to choose to perform combined fits? Cause we have to check what kind of object is returned by the combined fit in order to decide if we put it in a different spectra(spectraType would be the flag,and here we should update the spectraName) or as a subresult(fitType in this case)
-      }
-      
-      else
-      {
-        if ( sFitType.Contains("PSICB2",TString::kIgnoreCase) || sFitType.Contains("PSINA60NEW",TString::kIgnoreCase)) std::cout << "+Free tails fit... " << std::endl;
-        else if ( sFitType.Contains("PSICOUNT",TString::kIgnoreCase) )  std::cout << Form("+Just counting %s...",GetParticleName()) << std::endl;
-        else std::cout << "+Using predefined tails... " << std::endl; 
-        
-        if ( sFitType.Contains("minvJPsi") && !sparticleTmp.Contains("JPsi") )
-        {
-          std::cout << "This fitting funtion is set to fit JPsi: Skipping fit..." << std::endl;
-          continue;
-        }
-        if ( sFitType.Contains("minvPsiP") && !sparticleTmp.Contains("PsiP") )
-        {
-          std::cout << "This fitting funtion is set to fit PsiP: Skipping fit..." << std::endl;
-          continue;
-        }
-        
-        added += ( r->AddFit(sFitType.Data()) == kTRUE );
-      }
-      
-      std::cout << "-------------------------------------" << std::endl;
-      std::cout << "" << std::endl;
-    }
-  
-    if ( !added ) continue;
-    
-//    TObjArray* a = r->SubResults(); // TEST
-//    a->Print();
-    
-    flavour = bin->Flavour();
-    
-    if (!spectra)
-    {
-      TString spectraSaveName = spectraName;
-      if ( !sSpectraType.CompareTo("mpt") )
-      {
-        spectraSaveName += "-";
-        spectraSaveName += "MeanPtVsMinvUS";
-      }
-      
-      spectra = new AliAnalysisMuMuSpectra(spectraSaveName.Data());
-    }
-    
-    Bool_t adoptOk = spectra->AdoptResult(*bin,r); // We adopt the Result for current bin into the spectra
+        // Make a clone of the histo to work with. Pointer changes for every iteration (n++)
+        histo = static_cast<TH1*>(histo->Clone(Form("%s%d",sSpectraType.Data(),n++)));
+        
+        const char* particleTmp = IsSimulation() ? GetParticleName() : "JPsi"; //At some point particleTmp should become particle (but for now particle is always = "psi")
+        
+        cout << "particleTmp =" << particleTmp << endl;
+        
+        TString sparticleTmp(particleTmp);// Make a string of it
+        
+        // Object that fit/work on the histo
+        AliAnalysisMuMuJpsiResult* r = new AliAnalysisMuMuJpsiResult(particleTmp,
+                                                                     *histo, // Result for current bin
+                                                                     trigger,
+                                                                     eventType,
+                                                                     pairCut,
+                                                                     centrality,
+                                                                     *bin);
+        
+        r->SetNofTriggers(ntrigger);
+        r->SetNofRuns(nruns);
+        
+        nextFitType.Reset();
+        
+        Int_t added(0);
+        
+        // Loop on every fittype and create a subresult inside the spectra.
+        while ( ( fitType = static_cast<TObjString*>(nextFitType())) )
+            {
+            // In this loop we create a Subresult for each fit inside the Result for current bin (AddFit will do)
+            TString sFitType(fitType->String());// Get fitType as a string
+            
+            if ( !sFitType.Contains(sSpectraType.Data()) ) continue;// Checkpoint
+            
+            AliDebug(1,Form("<<<<<< fitType=%s bin=%s",sFitType.Data(),bin->Flavour().Data()));
+            
+            std::cout << "" << std::endl;
+            std::cout << "---------------" << "Fit " << added + 1 << "------------------" << std::endl;
+            std::cout << "Fitting " << hname.Data() << " with " << sFitType.Data() << std::endl;
+            std::cout << "" << std::endl;
+            
+            // Conf. for MC Tails (see function type)
+            if ( sFitType.Contains("mctails",TString::kIgnoreCase) ) //FIXME: Find a univoque way to determine the correctly the fit type
+                {
+                TString sbin = bin->AsString();
+                TString spectraMCName = spectraName;
+                AliAnalysisMuMuBinning::Range* binMC = bin;
+                
+                if ((sbin.Contains("MULT") || sbin.Contains("NCH") || sbin.Contains("DNCHDETA") || sbin.Contains("V0A") || sbin.Contains("V0ACENT") || sbin.Contains("V0C") || sbin.Contains("V0M") || sbin.Contains("NTRCORR")|| sbin.Contains("RELNTRCORR")) && !sbin.Contains("NTRCORRPT") && !sbin.Contains("NTRCORRY"))
+                    {
+                    //-------has to have a better way to do it
+                    AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
+                    b->AddBin("psi","INTEGRATED");
+                    
+                    binMC = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
+                    
+                    spectraMCName = b->GetName();
+                    delete b;
+                    
+                    //          if ( flavour.Length() > 0 ) //Commented cause we set no flavour in "INTEGRATED" bin in the analysis task
+                    //          {
+                    //            spectraMCName += "-";
+                    //            spectraMCName += flavour;
+                    //          }
+                    if ( corrected )
+                        {
+                        spectraMCName += "-";
+                        spectraMCName += "AccEffCorr";
+                        }
+                    //-----------
+                    
+                    }
+                //        if( sbin.Contains("NTRCORRPT") || !sbin.Contains("NTRCORRY") )
+                //        {
+                //          spectraMCName.Remove(4,7);
+                //
+                //          if ( spectraMCName.Contains("PT") )
+                //          {
+                //            AliAnalysisMuMuBinning* b = SIM()->BIN();
+                //
+                //            TObjArray* binsPt = b->CreateBinObjArray(particle,"PT","");
+                //
+                //            Int_t nEntrBinMC = binsPt->GetEntries();
+                //
+                ////            binsPt->Print();
+                //
+                //            binMC = static_cast<AliAnalysisMuMuBinning::Range*>(binsPt->At(binN));
+                //
+                //            if ( binN == nEntrBinMC - 1 ) binN = -1;
+                //
+                //          }
+                //
+                //        }
+                
+                //par = GetCB2Tails(*binInt,"MCTAILS",eventType,trigger,pairCut,corrected);Why I was taking the tails from the fitted data spectra?
+                GetParametersFromMC(sFitType,Form("/%s/%s",centrality,pairCut),spectraMCName.Data(),binMC);
+                
+                if (sFitType.Length()>0)
+                    {
+                    added += ( r->AddFit(sFitType.Data()) == kTRUE );
+                    }
+                }
+            
+            //Config. for mpt (see function type)
+            else if ( sFitType.Contains("mpt",TString::kIgnoreCase) && !sFitType.Contains("minv",TString::kIgnoreCase) )
+                {
+                std::cout << "++The Minv parameters will be taken from " << spectraName.Data() << std::endl;
+                std::cout << "" << std::endl;
+                
+                AliAnalysisMuMuSpectra* minvSpectra = dynamic_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(id.Data(),spectraName.Data()));
+                
+                if ( !minvSpectra )
+                    {
+                    AliError(Form("Cannot fit mean pt: could not get the minv spectra for %s",id.Data()));
+                    continue;//return 0x0;
+                    }
+                
+                AliAnalysisMuMuJpsiResult* minvResult = static_cast<AliAnalysisMuMuJpsiResult*>(minvSpectra->GetResultForBin(*bin));
+                
+                if ( !minvResult )
+                    {
+                    AliError(Form("Cannot fit mean pt: could not get the minv result for bin %s in %s",bin->AsString().Data(),id.Data()));
+                    continue; //return 0x0;
+                    }
+                
+                TObjArray* minvSubResults = minvResult->SubResults();
+                TIter nextSubResult(minvSubResults);
+                AliAnalysisMuMuJpsiResult* fitMinv;
+                TString subResultName;
+                
+                Int_t nSubFit(0);
+                while ( ( fitMinv = static_cast<AliAnalysisMuMuJpsiResult*>(nextSubResult())) )
+                    {
+                    TString fitMinvName(fitMinv->GetName());
+                    fitMinvName.Remove(fitMinvName.First("_"),fitMinvName.Sizeof()-fitMinvName.First("_"));
+                    
+                    if ( !sFitType.Contains(fitMinvName) ) continue; //FIXME: Ambiguous, i.e. NA60NEWPOL2EXP & NA60NEWPOL2 (now its ok cause only VWG and POL2EXP are used, but care)
+                    
+                    std::cout << "" << std::endl;
+                    std::cout <<  "      /-- SubFit " << nSubFit + 1 << " --/ " << std::endl;
+                    std::cout << "" << std::endl;
+                    
+                    TString sMinvFitType(sFitType);
+                    
+                    GetParametersFromResult(sMinvFitType,fitMinv);//FIXME: Think about if this is necessary
+                    
+                    added += ( r->AddFit(sMinvFitType.Data()) == kTRUE );
+                    
+                    nSubFit++;
+                    }
+                }
+            
+            //Config. for mpt and minv (see function type)
+            else if ( sFitType.Contains("minv&mpt",TString::kIgnoreCase) )
+                {
+                AliWarning("Implement here the method to do the combined minv mpt fits");
+                //FIXME: Shall we use the fitType or spectraType to choose to perform combined fits? Cause we have to check what kind of object is returned by the combined fit in order to decide if we put it in a different spectra(spectraType would be the flag,and here we should update the spectraName) or as a subresult(fitType in this case)
+                }
+            
+            //Config. for the rest (see function type)
+            else
+                {
+                if ( sFitType.Contains("PSICB2",TString::kIgnoreCase) || sFitType.Contains("PSINA60NEW",TString::kIgnoreCase)) std::cout << "+Free tails fit... " << std::endl;
+                else if ( sFitType.Contains("PSICOUNT",TString::kIgnoreCase) )  std::cout << Form("+Just counting %s...",GetParticleName()) << std::endl;
+                else std::cout << "+Using predefined tails... " << std::endl;
+                
+                if ( sFitType.Contains("minvJPsi") && !sparticleTmp.Contains("JPsi") )
+                    {
+                    std::cout << "This fitting funtion is set to fit JPsi: Skipping fit..." << std::endl;
+                    continue;
+                    }
+                if ( sFitType.Contains("minvPsiP") && !sparticleTmp.Contains("PsiP") )
+                    {
+                    std::cout << "This fitting funtion is set to fit PsiP: Skipping fit..." << std::endl;
+                    continue;
+                    }
+                
+                added += ( r->AddFit(sFitType.Data()) == kTRUE );// Here we call the fit functions
+                }
+            
+            std::cout << "-------------------------------------" << std::endl;
+            std::cout << "" << std::endl;
+            }
+        
+        if ( !added ) continue;// checkpoint
+        
+        //    TObjArray* a = r->SubResults(); // TEST
+        //    a->Print();
+        
+        flavour = bin->Flavour();// Get >flavour>
+        
+        // Implement <spectra> and set its name
+        if (!spectra)
+            {
+            TString spectraSaveName = spectraName;
+            if ( !sSpectraType.CompareTo("mpt") )
+                {
+                spectraSaveName += "-";
+                spectraSaveName += "MeanPtVsMinvUS";
+                }
+            
+            spectra = new AliAnalysisMuMuSpectra(spectraSaveName.Data());
+            }
+        
+        Bool_t adoptOk = spectra->AdoptResult(*bin,r); // We adopt the Result for current bin into the spectra
+        
+        if ( adoptOk ) std::cout << "Result " << r->GetName() << " adopted in spectra " << spectra->GetName() << std::endl;
+        else AliError(Form("Error adopting result %s in spectra %s",r->GetName(),spectra->GetName()));
+        
+        
+        if ( IsSimulation() )
+            {
+            SetNofInputParticles(*r);
+            }
+        
+        //    binN++;
+        } // loop on bins
     
-    if ( adoptOk ) std::cout << "Result " << r->GetName() << " adopted in spectra " << spectra->GetName() << std::endl;
-    else AliError(Form("Error adopting result %s in spectra %s",r->GetName(),spectra->GetName()));
-      
+    delete fitTypeArray;
+    delete bins;
     
-    if ( IsSimulation() )
-    {
-      SetNofInputParticles(*r);
-    }
-  
-//    binN++;
-  } // loop on bins
-  
-  delete fitTypeArray;
-  delete bins;
-  
-  return spectra;
+    return spectra;
 }
 
 
@@ -1164,28 +1606,28 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //{
 //  // Fit the dimuon mean pt spectra to find the particle mean pt
 //  // Returns an array of AliAnalysisMuMuResult objects
-//  
+//
 //  TObjArray* bins = binning.CreateBinObjArray(particle);
 //  if (!bins)
 //  {
 //    AliError(Form("Did not get any bin for particle %s",particle));
 //    return 0x0;
 //  }
-//  
+//
 //  //  AliAnalysisMuMuBinning* binningMinv(0x0);
 //  //  TObjArray* binsMinv(0x0);
 //  //  AliAnalysisMuMuBinning::Range* binInt(0x0);
 //  //  AliAnalysisMuMuBinning::Range* testbin = static_cast<AliAnalysisMuMuBinning::Range*>(bins->At(0));
 //  //  TString sbins = testbin->AsString();
-//  
+//
 //  //  if ( sbins.Contains("MULT")) //For the multiplicity bins we will use the tails from the integrated Minv spectra
 //  //  {
 //  //    binningMinv = spectraMinv.Binning();
 //  //    binsMinv = binningMinv->CreateBinObjArray(particle);
 //  //    binInt = static_cast<AliAnalysisMuMuBinning::Range*>(binsMinv->At(0));
 //  //  }
-//  
-//  
+//
+//
 //  TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
 //  if ( !triggers->FindObject(trigger) )
 //  {
@@ -1195,7 +1637,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //    return 0x0;
 //  }
 //  delete triggers;
-//  
+//
 //  TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
 //  if ( !events->FindObject(eventType) )
 //  {
@@ -1205,50 +1647,50 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //    return 0x0;
 //  }
 //  delete events;
-//  
+//
 //  Int_t ntrigger = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s",trigger,eventType)));
-//  
+//
 //  if  (ntrigger<=0)
 //  {
 //    AliError(Form("No trigger for trigger:%s/event:%s",trigger,eventType));
 //    delete bins;
 //    return 0x0;
 //  }
-//  
+//
 //  AliAnalysisMuMuSpectra* sMinv = static_cast<AliAnalysisMuMuSpectra*>(spectraMinv.Clone());
 //  if(!sMinv)
 //  {
 //    AliError("Did not find inv mass spectra");
 //  }
-//  
-//  
+//
+//
 //  //  binning.Print();
-//  
+//
 //  AliAnalysisMuMuSpectra* spectra(0x0);
-//  
+//
 //  AliAnalysisMuMuBinning::Range* bin;
 //  //  AliAnalysisMuMuBinning::Range* binMinv;
 //  TIter next(bins);
-//  
+//
 //  //  TObjArray* fitTypeArray = fFitTypeList.Tokenize(",");
 //  //  TIter nextFitType(fitTypeArray);
 //  //  TObjString* fitType;
 //  TString flavour;
-//  
-//  
+//
+//
 //  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
 //  {
 //    std::cout << "---------------------------------" << std::endl;
 //    std::cout << "Fitting mean Pt in " << bin->AsString().Data() << " " << "for" << " " << eventType << "/" << trigger << "/" << centrality << "/" << pairCut << std::endl;
 //    std::cout << "---------------------------------" << std::endl;
-//    
-//    
+//
+//
 //    TString pname;
 //    if ( corrected ) pname = Form("MeanPtVsMinvUS%s_Corr",bin->AsString().Data());
 //    else pname = Form("MeanPtVsMinvUS%s",bin->AsString().Data());
-//    
+//
 //    TProfile* hmPt = static_cast<TProfile*>(fMergeableCollection->GetObject(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut),pname.Data()));
-//    
+//
 //    if (!hmPt)
 //    {
 //      //      if (!fBinning && bin->IsNullObject() )
@@ -1256,7 +1698,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //      //        // old file, we only had MinvUSPt
 //      //        hminv = fMergeableCollection->Histo(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut),"MinvUSPt:py");
 //      //      }
-//      
+//
 //      //      if (!hmPt)
 //      //      {
 //      AliDebug(1,Form("Could not find histo profile %s",pname.Data()));
@@ -1264,10 +1706,10 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //      //      }
 //    }
 //    hmPt->Approximate();
-//    
-//    
+//
+//
 //    //    hmPt = static_cast<TH1*>(hmPt->Clone(Form("mPtv%d",n++))); //Reuse this
-//    
+//
 //    //    if ( sbins.Contains("MULT") )
 //    //    {
 //    //      binMinv = binInt;
@@ -1276,50 +1718,50 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //    //    {
 //    //      binMinv = bin;
 //    //    }
-//    
+//
 //    AliAnalysisMuMuJpsiResult* rMinv = static_cast<AliAnalysisMuMuJpsiResult*>(sMinv->GetResultForBin(*bin/*Minv*/));
-//    
+//
 //    if( !rMinv )
 //    {
 //      AliError(Form("Did not find inv mass result inside spectra for bin %s",bin/*Minv*/->Quantity().Data()));
 //    }
-//    
+//
 //    TObjArray* fits = rMinv->SubResults();
 //    AliAnalysisMuMuResult* fitMinv;
 //    TIter nextFit(fits);
 //    TString fitName;
-//    
+//
 //    AliAnalysisMuMuJpsiResult* r = new AliAnalysisMuMuJpsiResult(*hmPt,
 //                                                         trigger,
 //                                                         eventType,
 //                                                         pairCut,
 //                                                         centrality,
 //                                                         *bin);
-//    
+//
 //    r->SetNofTriggers(ntrigger);
-//    
+//
 //    nextFit.Reset();
-//    
+//
 //    //    new TCanvas;
 //    Int_t i = 1;
-//    
+//
 //    while ( ( fitMinv = static_cast<AliAnalysisMuMuJpsiResult*>(nextFit())) )
 //    {
 //      std::cout << "" << std::endl;
 //      std::cout << "---------------" << "Fit " << i << "------------------" << std::endl;
 //      i++;
-//      
+//
 //      fitName = fitMinv->Alias();
 //      std::cout << "" << std::endl;
 //      std::cout << "Getting signal parameters from " << eventType << "/" << trigger << "/" << centrality << "/" << pairCut << "/" << spectraMinv.GetName()  << std::endl;
 //      std::cout << "" << std::endl;
-//      
+//
 //      if(fitName.BeginsWith("JPSI2CB2VWG") || fitName.BeginsWith("MCTAILS"))
 //      {
 //        Double_t par[14] = {fitMinv->GetValue("kVWG"),fitMinv->GetValue("mVWG"),fitMinv->GetValue("sVWG1"),
 //          fitMinv->GetValue("sVWG2"),fitMinv->GetValue("kPsi"),fitMinv->GetValue("MeanJpsi"),fitMinv->GetValue("SigmaJpsi"),
 //          fitMinv->GetValue("alPsi"),fitMinv->GetValue("nlPsi"),fitMinv->GetValue("auPsi"),fitMinv->GetValue("nuPsi"),fitMinv->GetValue("kPsi'"),fitMinv->GetValue("NofJpsi"),fitMinv->GetErrorStat("NofJpsi")}; //Create a method to get the parameters //The last 2 parameters are not used in the fit
-//        
+//
 //        if(fitName.BeginsWith("JPSI2CB2VWG"))
 //        {
 //          std::cout << "PRE-SET TAILS" << std::endl;
@@ -1332,16 +1774,16 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //          std::cout << "" << std::endl;
 //          r->AddMeanPtFit("MCTAILS-JPSI2CB2VWG:2",&par[0]);
 //        }
-//        
-//        
+//
+//
 //      }
-//      
+//
 //      //Make a part for NA48 and the rest of fitting functions.
-//      
+//
 //    }
-//    
+//
 //    flavour = bin->Flavour();
-//    
+//
 //    if (!spectra)
 //    {
 //      TString spectraName(Form("MeanPtVsMinvUS-%s",binning.GetName()));
@@ -1355,24 +1797,24 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //        spectraName += "-";
 //        spectraName += "Corr";
 //      }
-//      
+//
 //      spectra = new AliAnalysisMuMuSpectra(spectraName.Data());
 //    }
-//    
+//
 //    spectra->AdoptResult(*bin,r);
-//    
+//
 //    //    if ( IsSimulation() )
 //    //    {
 //    //      SetNofInputParticles(*r);
 //    //    }
-//    
-//    
+//
+//
 //  } // loop on bins
-//  
+//
 //  //  delete fitTypeArray;
 //  delete sMinv;
 //  delete bins;
-//  
+//
 //  return spectra;
 //}
 
@@ -1380,4335 +1822,3886 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 void
 AliAnalysisMuMu::GetParametersFromMC(TString& fitType, const char* pathCentrPairCut, const char* spectraName, AliAnalysisMuMuBinning::Range* bin) const
 {
-  /// Get the parameters from the associated simulation. Is intended to be used in minv fits, where we need the tails from JPsi (and Psi')
-  // We can choose between the 2 associated simulations (a JPsi and Psi' ones) by setting the sim variable to "sim1" (fAssociatedSimulation by default) or "sim2" (fAssociatedSimulation2)
-  
-  if ( !SIM() && !SIM2() )
-  {
-    AliError("Cannot get MC tails without associated simulation(s) file(s) !");
-    fitType = "";
-    return;
-  }
-  
-  TString subResultName("");
-  if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) ) subResultName = "PSINA60NEW";//_1.5_4.2
-  else if ( fitType.Contains("CB2",TString::kIgnoreCase) ) subResultName = "PSICB2";//_2.2_3.9
-  else
-  {
-    AliError("I don't know from which MC subresult take the tails");
-    return;
-  }
-    
-  TObjArray* simArr = new TObjArray;
-  if ( SIM() ) simArr->Add(SIM());
-  if ( SIM2() && fitType.Contains("INDEPTAILS",TString::kIgnoreCase) ) simArr->Add(SIM2()); // If we have set the key to get the JPsi ans PsiP tails
-  
-  TIter nextSim(simArr);
-  AliAnalysisMuMu* currentSIM;
-  
-  TString spath(pathCentrPairCut);
-  
-  spath.Prepend(Form("/%s",Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data()));//FIXME: Care with this when there is more than one selection in the list
-  spath.Prepend(Form("/%s",Config()->First(Config()->EventSelectionKey(),kTRUE).Data()));
-  
-  
-  while ( (currentSIM = static_cast<AliAnalysisMuMu*>(nextSim())) )
-  {
-    AliAnalysisMuMuSpectra* minvMCSpectra = currentSIM->SPECTRA(Form("%s/%s",spath.Data(),spectraName));
-    if (!minvMCSpectra)
-    {
-      AliError(Form("Could not find spectra %s/%s for associated simulation",spath.Data(),spectraName));
-      currentSIM->OC()->Print("*:Ali*");
-      fitType = "";
-      continue;
-    }
+    /// Get the parameters from the associated simulation. Is intended to be used in minv fits, where we need the tails from JPsi (and Psi')
+    // We can choose between the 2 associated simulations (a JPsi and Psi' ones) by setting the sim variable to "sim1" (fAssociatedSimulation by default) or "sim2" (fAssociatedSimulation2)
     
-    AliAnalysisMuMuJpsiResult* minvMCResult = static_cast<AliAnalysisMuMuJpsiResult*>(minvMCSpectra->GetResultForBin(*bin));
-    if ( !minvMCResult )
-    {
-      AliError(Form("Cannot get MC tails cause the minv result for bin %s in %s/%s was not found",bin->AsString().Data(),spath.Data(),spectraName));
-      fitType = "";
-      continue;
-    }
+    if ( !SIM() && !SIM2() )
+        {
+        AliError("Cannot get MC tails without associated simulation(s) file(s) !");
+        fitType = "";
+        return;
+        }
     
-    AliAnalysisMuMuJpsiResult* r = dynamic_cast<AliAnalysisMuMuJpsiResult*>(minvMCResult->SubResult(subResultName.Data())); //FIXME: Find an independet way of naming results
-    if  ( r && subResultName.Contains("PSICB2") )
-    {
-      fitType += Form(":al%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("al%s",currentSIM->GetParticleName())));
-      fitType += Form(":nl%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nl%s",currentSIM->GetParticleName())));
-      fitType += Form(":au%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("au%s",currentSIM->GetParticleName())));
-      fitType += Form(":nu%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nu%s",currentSIM->GetParticleName())));
-      
-      std::cout << " Using MC " << currentSIM->GetParticleName() << " CB2 tails... " << std::endl;
-      std::cout << std::endl;
-    }
-    else if ( r && subResultName.Contains("PSINA60NEW") )
-    {
-      fitType += Form(":p1L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1L%s",currentSIM->GetParticleName())));
-      fitType += Form(":p2L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2L%s",currentSIM->GetParticleName())));
-      fitType += Form(":p3L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3L%s",currentSIM->GetParticleName())));
-      fitType += Form(":p1R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1R%s",currentSIM->GetParticleName())));
-      fitType += Form(":p2R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2R%s",currentSIM->GetParticleName())));
-      fitType += Form(":p3R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3R%s",currentSIM->GetParticleName())));
-      
-      fitType += Form(":aL%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aL%s",currentSIM->GetParticleName())));
-      fitType += Form(":aR%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aR%s",currentSIM->GetParticleName())));
-      
-      std::cout << " Using MC " << currentSIM->GetParticleName() << " NA60New tails... " << std::endl;
-      std::cout << std::endl;
-    }
+    TString subResultName("");
+    if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) ) subResultName = "PSINA60NEW";//_1.5_4.2
+    else if ( fitType.Contains("CB2",TString::kIgnoreCase) ) subResultName = "PSICB2";//_2.2_3.9
     else
-    {
-      AliError(Form("Cannot get MC tails. MC Subresult %s not found",minvMCResult->GetName()));
-      fitType = "";
-    }
-  }
-  delete simArr;
-}
-
-//_____________________________________________________________________________
-void
-AliAnalysisMuMu::GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const
-{
-  // Gets the parameters from a result, is intended to be used for mean pt fits where we need the signal and backgroud parameters
-  
-  AliWarning("Re-implement me !!!"); //FIXME: The parameters to get will depend on the fit function and also in this way is not suitable for other particles (ie Upsilon)(Find a way to get the particle(s) name)
-  
-  TString msg("");
-  if ( minvResult )
-  {
-    // We take the usual parameters (the ones from JPsi and the normalization of the Psi')
-    fitType += Form(":kJPsi=%f",minvResult->GetValue("kJPsi")); //FIXME: Names are not correct
-    fitType += Form(":mJPsi=%f",minvResult->GetValue("mJPsi"));
-    fitType += Form(":sJPsi=%f",minvResult->GetValue("sJPsi"));
+        {
+        AliError("I don't know from which MC subresult take the tails");
+        return;
+        }
     
-    fitType += Form(":NofJPsi=%f",minvResult->GetValue("NofJPsi"));
-    fitType += Form(":ErrStatNofJPsi=%f",minvResult->GetErrorStat("NofJPsi"));
+    TObjArray* simArr = new TObjArray;
+    if ( SIM() ) simArr->Add(SIM());
+    if ( SIM2() && fitType.Contains("INDEPTAILS",TString::kIgnoreCase) ) simArr->Add(SIM2()); // If we have set the key to get the JPsi ans PsiP tails
     
-    fitType += Form(":kPsiP=%f",minvResult->GetValue("kPsiP"));
+    TIter nextSim(simArr);
+    AliAnalysisMuMu* currentSIM;
     
-    TString minvName(minvResult->GetName());
+    TString spath(pathCentrPairCut);
     
-    TString minvRangeParam = minvName;
-    minvRangeParam.Remove(0,minvRangeParam.First("_") + 1);
-    fitType += Form(":MinvRS=%s",minvRangeParam.Data());
+    spath.Prepend(Form("/%s",Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data()));//FIXME: Care with this when there is more than one selection in the list
+    spath.Prepend(Form("/%s",Config()->First(Config()->EventSelectionKey(),kTRUE).Data()));
     
-    fitType += Form(":FSigmaPsiP=%f",minvResult->GetValue("FSigmaPsiP"));
     
-    if ( fitType.Contains("CB2",TString::kIgnoreCase) )
-    {
-      fitType += Form(":alJPsi=%f",minvResult->GetValue("alJPsi"));
-      fitType += Form(":nlJPsi=%f",minvResult->GetValue("nlJPsi"));
-      fitType += Form(":auJPsi=%f",minvResult->GetValue("auJPsi"));
-      fitType += Form(":nuJPsi=%f",minvResult->GetValue("nuJPsi"));
-      
-      msg += "JPsi CB2 signal parameters";
-      //    fitType += Form(":NofPsiP=%f",minvResult->GetValue("NofPsiP"));
-      //    fitType += Form(":ErrStatNofPsiP=%f",minvResult->GetErrorStat("NofPsiP"));
-      
-      if ( fitType.Contains("INDEPTAILS") )
-      {
-//        minvName = minvResult->GetName();
-        if ( minvName.Contains("INDEPTAILS") )
-        {
-          // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
-          fitType += Form(":alPsiP=%f",minvResult->GetValue("alPsiP"));
-          fitType += Form(":nlPsiP=%f",minvResult->GetValue("nlPsiP"));
-          fitType += Form(":auPsiP=%f",minvResult->GetValue("auPsiP"));
-          fitType += Form(":nuPsiP=%f",minvResult->GetValue("nuPsiP"));
-          fitType += Form(":mPsiP=%f",minvResult->GetValue("mPsiP"));
-          fitType += Form(":sPsiP=%f",minvResult->GetValue("sPsiP"));
-          
-          msg += " + PsiP CB2 signal parameters";
-        }
-        else
+    while ( (currentSIM = static_cast<AliAnalysisMuMu*>(nextSim())) )
         {
-          AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
-          fitType = "";
-          return;
-        }
-      }
-    }
-    else if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) )
-    {
-      fitType += Form(":p1LJPsi=%f",minvResult->GetValue("p1LJPsi"));
-      fitType += Form(":p2LJPsi=%f",minvResult->GetValue("p2LJPsi"));
-      fitType += Form(":p3LJPsi=%f",minvResult->GetValue("p3LJPsi"));
-      fitType += Form(":p1RJPsi=%f",minvResult->GetValue("p1RJPsi"));
-      fitType += Form(":p2RJPsi=%f",minvResult->GetValue("p2RJPsi"));
-      fitType += Form(":p3RJPsi=%f",minvResult->GetValue("p3RJPsi"));
-      
-      fitType += Form(":aLJPsi=%f",minvResult->GetValue("aLJPsi"));
-      fitType += Form(":aRJPsi=%f",minvResult->GetValue("aRJPsi"));
-      
-      msg += "JPsi NA60New signal parameters";
-      
-      if ( fitType.Contains("INDEPTAILS") )
-      {
-//        TString minvName(minvResult->GetName());
-        if ( minvName.Contains("INDEPTAILS") )
-        {
-          // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
-          fitType += Form(":p1LPsiP=%f",minvResult->GetValue("p1LPsiP"));
-          fitType += Form(":p2LPsiP=%f",minvResult->GetValue("p2LPsiP"));
-          fitType += Form(":p3LPsiP=%f",minvResult->GetValue("p3LPsiP"));
-          fitType += Form(":p1RPsiP=%f",minvResult->GetValue("p1RPsiP"));
-          fitType += Form(":p2RPsiP=%f",minvResult->GetValue("p2RPsiP"));
-          fitType += Form(":p3RPsiP=%f",minvResult->GetValue("p3RPsiP"));
-          
-          fitType += Form(":aLPsiP=%f",minvResult->GetValue("aLPsiP"));
-          fitType += Form(":aRPsiP=%f",minvResult->GetValue("aRPsiP"));
-          
-          msg += " + PsiP NA60New signal parameters";
-          
-        }
+        AliAnalysisMuMuSpectra* minvMCSpectra = currentSIM->SPECTRA(Form("%s/%s",spath.Data(),spectraName));
+        if (!minvMCSpectra)
+            {
+            AliError(Form("Could not find spectra %s/%s for associated simulation",spath.Data(),spectraName));
+            currentSIM->OC()->Print("*:Ali*");
+            fitType = "";
+            continue;
+            }
+        
+        AliAnalysisMuMuJpsiResult* minvMCResult = static_cast<AliAnalysisMuMuJpsiResult*>(minvMCSpectra->GetResultForBin(*bin));
+        if ( !minvMCResult )
+            {
+            AliError(Form("Cannot get MC tails cause the minv result for bin %s in %s/%s was not found",bin->AsString().Data(),spath.Data(),spectraName));
+            fitType = "";
+            continue;
+            }
+        
+        AliAnalysisMuMuJpsiResult* r = dynamic_cast<AliAnalysisMuMuJpsiResult*>(minvMCResult->SubResult(subResultName.Data())); //FIXME: Find an independet way of naming results
+        if  ( r && subResultName.Contains("PSICB2") )
+            {
+            fitType += Form(":al%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("al%s",currentSIM->GetParticleName())));
+            fitType += Form(":nl%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nl%s",currentSIM->GetParticleName())));
+            fitType += Form(":au%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("au%s",currentSIM->GetParticleName())));
+            fitType += Form(":nu%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nu%s",currentSIM->GetParticleName())));
+            
+            std::cout << " Using MC " << currentSIM->GetParticleName() << " CB2 tails... " << std::endl;
+            std::cout << std::endl;
+            }
+        else if ( r && subResultName.Contains("PSINA60NEW") )
+            {
+            fitType += Form(":p1L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1L%s",currentSIM->GetParticleName())));
+            fitType += Form(":p2L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2L%s",currentSIM->GetParticleName())));
+            fitType += Form(":p3L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3L%s",currentSIM->GetParticleName())));
+            fitType += Form(":p1R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1R%s",currentSIM->GetParticleName())));
+            fitType += Form(":p2R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2R%s",currentSIM->GetParticleName())));
+            fitType += Form(":p3R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3R%s",currentSIM->GetParticleName())));
+            
+            fitType += Form(":aL%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aL%s",currentSIM->GetParticleName())));
+            fitType += Form(":aR%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aR%s",currentSIM->GetParticleName())));
+            
+            std::cout << " Using MC " << currentSIM->GetParticleName() << " NA60New tails... " << std::endl;
+            std::cout << std::endl;
+            }
         else
-        {
-          AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
-          fitType = "";
-          return;
+            {
+            AliError(Form("Cannot get MC tails. MC Subresult %s not found",minvMCResult->GetName()));
+            fitType = "";
+            }
         }
-      }
-    }
-    else
-    {
-      AliError(Form("Cannot get the parameters from %s",minvResult->GetName()));
-      fitType = "";
-      return;
-    }
-    // Now we take the background parameters
-    if ( fitType.Contains("VWG_") || fitType.Contains("VWGINDEPTAILS") ) //FIXME: Check that cannot be misunderstood(like Exp x Pol2..). In fact it can be misunderstood since the meanpt function name has also the name of the function to fit the bkg (free parameters). Also add the rest of the BKG functions
-    {
-      fitType += Form(":kVWG=%f",minvResult->GetValue("kVWG"));
-      fitType += Form(":mVWG=%f",minvResult->GetValue("mVWG"));
-      fitType += Form(":sVWG1=%f",minvResult->GetValue("sVWG1"));
-      fitType += Form(":sVWG2=%f",minvResult->GetValue("sVWG2"));
-      
-      msg += " + VWG Bkg parameters";
-    }
-    else if ( fitType.Contains("POL2EXP_") || fitType.Contains("POL2EXPINDEPTAILS") )
-    {
-      fitType += Form(":kPol2Exp=%f",minvResult->GetValue("kPol2Exp"));
-      fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
-      fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
-      fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
-      fitType += Form(":exp=%f",minvResult->GetValue("exp"));
-      
-      msg += " + Pol2xExp Bkg parameters";
-    }
-    else if ( fitType.Contains("POL4EXP_") || fitType.Contains("POL4EXPINDEPTAILS") )
-    {
-      fitType += Form(":kPol4Exp=%f",minvResult->GetValue("kPol4Exp"));
-      fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
-      fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
-      fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
-      fitType += Form(":pol3=%f",minvResult->GetValue("pol3"));
-      fitType += Form(":pol4=%f",minvResult->GetValue("pol4"));
-      fitType += Form(":exp=%f",minvResult->GetValue("exp"));
-      
-      msg += " + Pol4xExp Bkg parameters";
-    }
-    std::cout << "Using " << msg.Data() << " from " << minvResult->GetName() <<  " inv mass result" << std::endl;
-    std::cout << "" << std::endl;
-  }
-  else
-  {
-    AliError(Form("Cannot get tails from result. Result %s not found",minvResult->GetName()));
-    fitType = "";
-    return;
-  }
-}
-
-//_____________________________________________________________________________
-ULong64_t AliAnalysisMuMu::GetTriggerScalerCount(const char* triggerList, Int_t runNumber)
-{
-  // Get the expected (from OCDB scalers) trigger count
-  
-  AliAnalysisTriggerScalers ts(runNumber,Config()->OCDBPath());
-  
-  TObjArray* triggers = TString(triggerList).Tokenize(",");
-  TObjString* trigger;
-  TIter next(triggers);
-  ULong64_t n(0);
-  
-  while ( ( trigger = static_cast<TObjString*>(next()) ) )
-  {
-    AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L2A",trigger->String().Data());
-    if (item)
-    {
-      n += item->Value();
-    }
-    delete item;
-  }
-  delete triggers;
-  
-  return n;
-}
-
-//_____________________________________________________________________________
-AliAnalysisMuMuSpectra* AliAnalysisMuMu::GetSpectra(const char* what, const char* flavour) const
-{
-  /// get a given spectra
-  
-  TString swhat(what);
-  TString sflavour(flavour);
-  swhat.ToUpper();
-  sflavour.ToUpper();
-  
-  TString spectraName(Form("/%s/%s/PP/%s/PSI-%s",
-                           Config()->First(Config()->EventSelectionKey(),IsSimulation()).Data(),
-                           Config()->First(Config()->DimuonTriggerKey(),IsSimulation()).Data(),
-                           Config()->First(Config()->PairSelectionKey(),IsSimulation()).Data(),
-                           swhat.Data()));
-
-  if (sflavour.Length()>0)
-  {
-    spectraName += "-";
-    spectraName += sflavour.Data();
-  }
-
-  return SPECTRA(spectraName.Data());
-}
-
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::PlotAccEfficiency(const char* whatever)
-{
-  //FIXME::Make it general
-  if ( !IsSimulation() )
-  {
-    AliError("Could not get AccxEff histo: Not simulation file");
-    return 0x0;
-  }
-  
-  TString path(Form("/%s/%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kTRUE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kTRUE).Data(),
-                    Config()->First(Config()->PairSelectionKey(),kTRUE).Data()));
-  
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/%s",path.Data(),whatever)));
-  if ( !s )
-  {
-    AliError(Form("No AccEff spectra %s found in %s",whatever,path.Data()));
-    return 0x0;
-  }
-  
-  return s->Plot(Form("AccEff%s",GetParticleName()),"PSICOUNT",kFALSE);//_2.2_3.9
-                                                                                         
+    delete simArr;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeRelativeValueAndSESystematics(const char* quantity,const char* flavour,const char* value2Test, const char* binListToExclude, const char* fNormType, const char* evSelInt, const char* evSelDiff, const char* triggerCluster)
+void
+AliAnalysisMuMu::GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const
 {
-  /// Compute the relative (bin/integrated) Jpsi yield or <pT> in "quantity,flavour" bins from the mean value of the relative values of the tests used for the systematic uncertainty of signal extraction computation. Store also the systematic uncertainty tests.
-  ///
-  /// Important considerations:
-  ///   - No corrections can be applied to the yields or x-axis with this method
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL (for the integrated signal extraction) and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly.
-  ///
-  /// Parameters:
-  ///   - what,quantity and flavour defines the binning to test (output will be 1 plot per bin)
-  /// value2test is the observable we want to test ( i.e. NJpsi(bin)/integratedNJpsi, <pt>(bin)/integrated<pt>... )
-  ///   - value2test == yield -> NJpsi(bin)/integratedNJpsi
-  ///   - value2test == mpt -> <pt>(bin)/integrated<pt>
-  ///   - relative: kTRUE if relative yield (y/y_int) wants to be computed. Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
-  ///   - fNormType: Desired FNorm to use: "offline", "global" or "mean"
-  ///   - evSelInt: Event selection to compute integrated NofJpsi
-  ///   - evSelDiff: Event selection to compute diferential NofJpsi
-  ///   - triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-
-
-  TString sfNormType(fNormType);
-  TString sevSelInt(evSelInt);
-  TString sevSelDiff(evSelDiff);
-
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi yield: Is a simulation file");
-    return;
-  }
-
-  TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
-  TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
-  TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
-  
-  //Path to get/store integrated results from Mergeable Collection
-  TString intPath(Form("%s/%s/%s/%s",
-                       sevSelInt.Data(),
-                       dimuonTriggerClassName.Data(),
-                       centralitySelection.Data(),
-                       pairSelection.Data()));
-
-  //Path to get/store differential results from Mergeable Collection
-  TString diffPath(Form("%s/%s/%s/%s",
-                        sevSelDiff.Data(),
-                        dimuonTriggerClassName.Data(),
-                        centralitySelection.Data(),
-                        pairSelection.Data()));
-
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-
-  TString svalue2Test(value2Test);
-  TString shName("");
-  TString sObsInt("");
-  TString sObsBin("");
-  TString sflavour(flavour);
-  TString squantity(quantity);
-  squantity.ToUpper();
-  
-  TH1* hMB(0x0);
-  Double_t nEqMBTot(0.),nEqMBTotError(0.);
-  if ( !svalue2Test.CompareTo("yield",TString::kIgnoreCase) )
-  {
-    sObsInt = "PSI-INTEGRATED-AccEffCorr";
-    sObsBin = Form("PSI-%s-AccEffCorr",squantity.Data());
-    svalue2Test = "NofJPsi";
-    shName = "N^{J/#psi}_{bin}/N^{J/#psi}_{int}";
-
-     TH1* hMBTot = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data()));
-    if ( !hMBTot )
-    {
-      AliWarning(Form("No eq Nof MB events found in %s: Yield will not be calculated",Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data())));
-    }
-    nEqMBTot = hMBTot->GetBinContent(1);
-    nEqMBTotError = hMBTot->GetBinError(1);
-
-
-    if ( sfNormType.Contains("offline") )
-    {
-      hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),sevSelDiff.Data(),quantity));
-      if ( !hMB )
-      {
-        AliWarning(Form("Histo hNofEqMBVS%s not found: Yield will not be calculated",quantity));
-      }
-
-      std::cout << " Using Fnorm from offline method " << std::endl;
-      std::cout <<  std::endl;
-    }
-    else if ( sfNormType.Contains("global") )
-    {
-      hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),sevSelDiff.Data(),quantity));
-      if ( !hMB )
-      {
-        AliError(Form("Histo hNofEqMBVS%sFromGlobal not found: Yield will not be calculated",quantity));
-      }
-
-      std::cout << " Using Fnorm from global method " << std::endl;
-      std::cout <<  std::endl;
-    }
-    else if ( sfNormType.Contains("mean") )
-    {
-      hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromMean",striggerCluster.Data(),sevSelDiff.Data(),quantity));
-      if ( !hMB )
-      {
-        AliError(Form("Histo hNofEqMBVS%sFromMean not found: Yield will not be calculated",quantity));
-      }
-
-      std::cout << " Using mean Fnorm " << std::endl;
-      std::cout <<  std::endl;
-    }
-    else
-    {
-      AliWarning("Dont know what Fnorm use: Yield will not be calculated");
-    }
-
-  }
-  else if ( !svalue2Test.CompareTo("mpt",TString::kIgnoreCase) )
-  {
-    sObsInt = "PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS";
-    sObsBin = Form("PSI-%s-AccEffCorr-MeanPtVsMinvUS",squantity.Data());
-    svalue2Test = "MeanPtJPsi";
-    shName = "<p_{t}>^{bin}/<p_{t}>^{int}";
-  }
-  else
-  {
-    AliError("unrecognized value to test");
-    return;
-  }
-
-  TString id(Form("/TESTSYST/%s/%s",sevSelInt.Data(),sevSelDiff.Data()));
-
-  //________Get the integrated results
-  AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),sObsInt.Data())));
-  if ( !sInt )
-  {
-    AliError(Form("No integrated spectra %s found in %s",sObsInt.Data(),intPath.Data()));
-    return;
-  }
-
-  TObjArray* bin = BIN()->CreateBinObjArray("psi","integrated","");
-  if ( !bin )
-  {
-    AliError("No integrated bin found");
-    return;
-  }
-  AliAnalysisMuMuBinning::Range* r = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(0));
-
-  AliAnalysisMuMuJpsiResult* resInt =  static_cast<AliAnalysisMuMuJpsiResult*>(sInt->GetResultForBin(*r));
-  if ( !resInt )
-  {
-    AliError(Form("No integrated result found in spectra %s at %s",sObsInt.Data(),intPath.Data()));
-    return;
-  }
-  TObjArray* sresIntArray = resInt->SubResults();
-
-  delete bin;
-  //_________________________
-
-
-  bin = BIN()->CreateBinObjArray("psi",squantity.Data(),sflavour.Data());
-  if ( !bin )
-  {
-    AliError(Form("%s-%s-%s binning does not exist","psi",squantity.Data(),sflavour.Data()));
-    return;
-  }
-  
-  //_______ Exclude desired bins
-  TIter nextBinTest(bin);
-
-  TString sbinListToExclude(binListToExclude);
-  TObjArray* abinListToExclude = sbinListToExclude.Tokenize(",");
-  TIter nextBinToExclude(abinListToExclude);
-  Int_t excl(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBinTest()) ) ) //Bin loop
-  {
-    nextBinToExclude.Reset();
-    TObjString* s(0x0);
-    while ( (s = static_cast<TObjString*>(nextBinToExclude())) )
-    {
-      if ( !r->AsString().CompareTo(s->GetString().Data()) )
-      {
-        std::cout << "Removing bin " << s->GetString().Data() << std::endl;
-        bin->RemoveAt(excl);
-      }
-    }
-    excl++;
-  }
-  std::cout <<  std::endl;
-  bin->Compress();
-  //_________________
-
-
-  //______Create arrays to store values inside
-  Int_t nbin = bin->GetEntries();
-  Int_t nsres = sresIntArray->GetEntries();
-  TObjArray* sResultNameArray= new TObjArray();
-  sResultNameArray->SetOwner();
-  std::vector<std::vector<double> > valuesArr;
-  valuesArr.resize(nbin+1, std::vector<double>(nsres,0));
-  std::vector<std::vector<double> > valuesErrorArr;
-  valuesErrorArr.resize(nbin+1, std::vector<double>(nsres,0));
-  //_________________________
-
-
-  //________Get the integrated values from results
-  TIter nextIntSubResult(sresIntArray);
-  AliAnalysisMuMuResult* sresInt(0x0);
-
-  TString testSig(""); //Strings for testing the name of the subresult to extract the number of tests for the systematics
-  TString testSPsip("");
-  TString testSresIntNameSig("");
-  TString testSresIntNameSPsip("");
-
-  Int_t nFitsSameSignal(0);
-  Int_t j(0);
-  while ( ( sresInt = static_cast<AliAnalysisMuMuResult*>(nextIntSubResult()) ) ) //Integrated SubResult loop
-  {
-    TString sresIntName(sresInt->GetName());
-    
-    valuesArr[0][j] = sresInt->GetValue(svalue2Test.Data());
-    valuesErrorArr[0][j] = sresInt->GetErrorStat(svalue2Test.Data());
-    sResultNameArray->Add(new TObjString(sresIntName.Data()));
-
-    if ( j ==0 ) // Get the first and last part of name of the first subresult
-    {
-      testSresIntNameSig = sresIntName.Data();
-      testSresIntNameSPsip = sresIntName.Data();
-
-      testSresIntNameSig.Remove(3,testSresIntNameSig.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
-      testSresIntNameSPsip.Remove(0,testSresIntNameSPsip.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
-    }
-
-    if ( sresIntName.Contains(testSresIntNameSig.Data()) && sresIntName.Contains(testSresIntNameSPsip.Data()) ) //This counts the number of times a fit with the same signal and same SigmaPsiP is repeated. This will be the number of tests for a given signal.
-    {
-      nFitsSameSignal++;
-    }
-    j++;
-  }
-
-  std::cout << "Number of tests per signal/SigmaPsi' combination = " << nFitsSameSignal << std::endl;
-  std::cout <<  std::endl;
-  //____________________________________
-  
-  //__________Get the bin per bin results and the values
-  AliAnalysisMuMuSpectra* sBin = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),sObsBin.Data())));
-  if ( !sBin )
-  {
-    AliError(Form("No integrated spectra %s found in %s",sObsBin.Data(),diffPath.Data()));
-    delete bin;
-    delete sResultNameArray;
-    return;
-  }
-  
-  TIter nextBin(bin);
-  AliAnalysisMuMuJpsiResult* sresBin(0x0);
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    sresBin =  static_cast<AliAnalysisMuMuJpsiResult*>(sBin->GetResultForBin(*r));
-    if ( !sresBin )
-    {
-      AliError(Form("No result found in spectra %s at %s for bin %s",sObsInt.Data(),diffPath.Data(),r->AsString().Data()));
-      delete bin;
-      delete sResultNameArray;
-      return;
-    }
+    // Gets the parameters from a result, is intended to be used for mean pt fits where we need the signal and backgroud parameters
     
-    TObjArray* sresBinArray = sresBin->SubResults();
+    AliWarning("Re-implement me !!!"); //FIXME: The parameters to get will depend on the fit function and also in this way is not suitable for other particles (ie Upsilon)(Find a way to get the particle(s) name)
     
-    if ( nsres != sresBinArray->GetEntries() )
-    {
-      AliError("Integrated and bins spectra have different number of subresults");
-      delete bin;
-      delete sResultNameArray;
-      return;
-    }
-
-    TIter nextSubResult(sresBinArray);
-    j = 0;
-    while ( (sresBin = static_cast<AliAnalysisMuMuJpsiResult*>(nextSubResult())) ) // Subresults loop
-    {
-      valuesArr[i][j] = sresBin->GetValue(svalue2Test.Data());
-      valuesErrorArr[i][j] = sresBin->GetErrorStat(svalue2Test.Data());
-      
-      j++;
-
-    } //End Subresults loop
-    i++;
-
-  } //End bin loop
-  //___________________________
-
-
-  //____________Compute the value ratios and systematic uncertainties on the ratios bin by bin
-
-      //______ Create histos to store signal extraction systematic uncertainties
-  TH1* hsyst = new TH1F(Form("%s_Systematics",value2Test),Form("%s Systematics results",value2Test),nbin,0,nbin);
-      //_________________________________
-
-      //______ Create histos to store relative Jpsi yield or <p_T> vs bins
-  Int_t size = bin->GetEntriesFast();
-  Double_t* axis = new Double_t[size+1];
-  TIter next(bin);
-  AliAnalysisMuMuBinning::Range* b;
-  TH1* hy(0x0);
-  i = 0;
-  while ( ( b = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    axis[i] = b->Xmin();
-    ++i;
-  }
-
-  b = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(size-1));
-
-  axis[i] = b->Xmax();
-
-  if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
-  {
-    hy = new TH1D(Form("hMeanJPsiYieldVS%sRelative",quantity),Form("Relative J/#psi yield vs %s;%s;Y^{J/#psi}/Y^{J/#psi}_{int}",quantity,quantity)
-                  ,size,axis);
-  }
-  else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
-  {
-    hy = new TH1D(Form("hMeanJPsiMPtVS%sRelative",quantity),Form("Relative J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}/<p_{T}>^{J/#psi}_{int}",quantity,quantity)
-                  ,size,axis);
-  }
-
-  if ( !hy )
-  {
-    AliError("No histogram created to store the results");
-    return;
-  }
-  delete axis;
-       //_________________________________
-
-  TString binName("");
-  for ( Int_t b = 1 ; b <= size ; b++ ) //Bin loop
-  {
-
-    binName = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(b-1))->AsString().Data();
-//    TString savePath(Form("%s/%s",id.Data(),binName.Data()));
-
-    Int_t binUCTotal(1);
-
-    TH1* hratiosBin = new TH1D(Form("SystTests_%s_Bkg_%s",sObsBin.Data(),binName.Data()),
-                               Form("%s Systematics tests for %s",binName.Data(),shName.Data()),j*nFitsSameSignal,0,
-                               j*nFitsSameSignal);
-
-    for ( Int_t k = 0 ; k < j ; k++ ) // Subresults loop for integrated values
-    {
-      //__Get the name of the signal and the Psi' sigma for the integrated result
-      TString signalNameInt(sResultNameArray->At(k)->GetName());
-      TString sPsiPNameInt(signalNameInt.Data());
-
-      signalNameInt.Remove(3,signalNameInt.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
-      sPsiPNameInt.Remove(0,sPsiPNameInt.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
-      //__
-
-      //      Int_t sizeName = signalName.Sizeof();
-      //      signalName.Remove(2,sizeName-3);
-      //      Int_t binUC(1);
-
-      for ( Int_t l = 0; l < j ; l++) //Subresults loop for bins values
-      {
-        TString binSignalName(sResultNameArray->At(l)->GetName());
-
-        Double_t ratio,ratioError(0.);
-
-        ratio = valuesArr[b][l] / valuesArr[0][k];
-        //          ratioError = TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[0][k],2.) + TMath::Power(valuesArr[b][l]*valuesErrorArr[0][k] / TMath::Power(valuesArr[0][k],2.),2.) );
-
-        if ( (valuesErrorArr[b][l] != 0) && (valuesErrorArr[0][k] != 0) ) // We only give an error!=0 if the errors of the int and bin values are both !=0 (Otherwise it means that there was a problem with the fit so we fix the error to 0 to skip the test later on)
+    TString msg("");
+    if ( minvResult )
         {
-          ratioError = ratio*TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[b][l],2.) + TMath::Power(valuesErrorArr[0][k] / valuesArr[0][k],2.) );
-        }
-
-        if ( binSignalName.Contains(signalNameInt.Data()) && binSignalName.Contains(sPsiPNameInt.Data()) ) // In this case the integrated and bin values have the same signal shape and Psi' sigma, so the result is stored
-        {
-          hratiosBin->GetXaxis()->SetBinLabel(binUCTotal,Form("%s/%s",sResultNameArray->At(l)->GetName(),sResultNameArray->At(k)->GetName()));
-
-          hratiosBin->SetBinContent(binUCTotal,ratio);
-          hratiosBin->SetBinError(binUCTotal,ratioError);
-
-          binUCTotal++;
+        // We take the usual parameters (the ones from JPsi and the normalization of the Psi')
+        fitType += Form(":kJPsi=%f",minvResult->GetValue("kJPsi")); //FIXME: Names are not correct
+        fitType += Form(":mJPsi=%f",minvResult->GetValue("mJPsi"));
+        fitType += Form(":sJPsi=%f",minvResult->GetValue("sJPsi"));
+        
+        fitType += Form(":NofJPsi=%f",minvResult->GetValue("NofJPsi"));
+        fitType += Form(":ErrStatNofJPsi=%f",minvResult->GetErrorStat("NofJPsi"));
+        
+        fitType += Form(":kPsiP=%f",minvResult->GetValue("kPsiP"));
+        
+        TString minvName(minvResult->GetName());
+        
+        TString minvRangeParam = minvName;
+        minvRangeParam.Remove(0,minvRangeParam.First("_") + 1);
+        fitType += Form(":MinvRS=%s",minvRangeParam.Data());
+        
+        fitType += Form(":FSigmaPsiP=%f",minvResult->GetValue("FSigmaPsiP"));
+        
+        if ( fitType.Contains("CB2",TString::kIgnoreCase) )
+            {
+            fitType += Form(":alJPsi=%f",minvResult->GetValue("alJPsi"));
+            fitType += Form(":nlJPsi=%f",minvResult->GetValue("nlJPsi"));
+            fitType += Form(":auJPsi=%f",minvResult->GetValue("auJPsi"));
+            fitType += Form(":nuJPsi=%f",minvResult->GetValue("nuJPsi"));
+            
+            msg += "JPsi CB2 signal parameters";
+            //    fitType += Form(":NofPsiP=%f",minvResult->GetValue("NofPsiP"));
+            //    fitType += Form(":ErrStatNofPsiP=%f",minvResult->GetErrorStat("NofPsiP"));
+            
+            if ( fitType.Contains("INDEPTAILS") )
+                {
+                //        minvName = minvResult->GetName();
+                if ( minvName.Contains("INDEPTAILS") )
+                    {
+                    // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
+                    fitType += Form(":alPsiP=%f",minvResult->GetValue("alPsiP"));
+                    fitType += Form(":nlPsiP=%f",minvResult->GetValue("nlPsiP"));
+                    fitType += Form(":auPsiP=%f",minvResult->GetValue("auPsiP"));
+                    fitType += Form(":nuPsiP=%f",minvResult->GetValue("nuPsiP"));
+                    fitType += Form(":mPsiP=%f",minvResult->GetValue("mPsiP"));
+                    fitType += Form(":sPsiP=%f",minvResult->GetValue("sPsiP"));
+                    
+                    msg += " + PsiP CB2 signal parameters";
+                    }
+                else
+                    {
+                    AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
+                    fitType = "";
+                    return;
+                    }
+                }
+            }
+        else if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) )
+            {
+            fitType += Form(":p1LJPsi=%f",minvResult->GetValue("p1LJPsi"));
+            fitType += Form(":p2LJPsi=%f",minvResult->GetValue("p2LJPsi"));
+            fitType += Form(":p3LJPsi=%f",minvResult->GetValue("p3LJPsi"));
+            fitType += Form(":p1RJPsi=%f",minvResult->GetValue("p1RJPsi"));
+            fitType += Form(":p2RJPsi=%f",minvResult->GetValue("p2RJPsi"));
+            fitType += Form(":p3RJPsi=%f",minvResult->GetValue("p3RJPsi"));
+            
+            fitType += Form(":aLJPsi=%f",minvResult->GetValue("aLJPsi"));
+            fitType += Form(":aRJPsi=%f",minvResult->GetValue("aRJPsi"));
+            
+            msg += "JPsi NA60New signal parameters";
+            
+            if ( fitType.Contains("INDEPTAILS") )
+                {
+                //        TString minvName(minvResult->GetName());
+                if ( minvName.Contains("INDEPTAILS") )
+                    {
+                    // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
+                    fitType += Form(":p1LPsiP=%f",minvResult->GetValue("p1LPsiP"));
+                    fitType += Form(":p2LPsiP=%f",minvResult->GetValue("p2LPsiP"));
+                    fitType += Form(":p3LPsiP=%f",minvResult->GetValue("p3LPsiP"));
+                    fitType += Form(":p1RPsiP=%f",minvResult->GetValue("p1RPsiP"));
+                    fitType += Form(":p2RPsiP=%f",minvResult->GetValue("p2RPsiP"));
+                    fitType += Form(":p3RPsiP=%f",minvResult->GetValue("p3RPsiP"));
+                    
+                    fitType += Form(":aLPsiP=%f",minvResult->GetValue("aLPsiP"));
+                    fitType += Form(":aRPsiP=%f",minvResult->GetValue("aRPsiP"));
+                    
+                    msg += " + PsiP NA60New signal parameters";
+                    
+                    }
+                else
+                    {
+                    AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
+                    fitType = "";
+                    return;
+                    }
+                }
+            }
+        else
+            {
+            AliError(Form("Cannot get the parameters from %s",minvResult->GetName()));
+            fitType = "";
+            return;
+            }
+        // Now we take the background parameters
+        if ( fitType.Contains("VWG_") || fitType.Contains("VWGINDEPTAILS") ) //FIXME: Check that cannot be misunderstood(like Exp x Pol2..). In fact it can be misunderstood since the meanpt function name has also the name of the function to fit the bkg (free parameters). Also add the rest of the BKG functions
+            {
+            fitType += Form(":kVWG=%f",minvResult->GetValue("kVWG"));
+            fitType += Form(":mVWG=%f",minvResult->GetValue("mVWG"));
+            fitType += Form(":sVWG1=%f",minvResult->GetValue("sVWG1"));
+            fitType += Form(":sVWG2=%f",minvResult->GetValue("sVWG2"));
+            
+            msg += " + VWG Bkg parameters";
+            }
+        else if ( fitType.Contains("POL2EXP_") || fitType.Contains("POL2EXPINDEPTAILS") )
+            {
+            fitType += Form(":kPol2Exp=%f",minvResult->GetValue("kPol2Exp"));
+            fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
+            fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
+            fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
+            fitType += Form(":exp=%f",minvResult->GetValue("exp"));
+            
+            msg += " + Pol2xExp Bkg parameters";
+            }
+        else if ( fitType.Contains("POL4EXP_") || fitType.Contains("POL4EXPINDEPTAILS") )
+            {
+            fitType += Form(":kPol4Exp=%f",minvResult->GetValue("kPol4Exp"));
+            fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
+            fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
+            fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
+            fitType += Form(":pol3=%f",minvResult->GetValue("pol3"));
+            fitType += Form(":pol4=%f",minvResult->GetValue("pol4"));
+            fitType += Form(":exp=%f",minvResult->GetValue("exp"));
+            
+            msg += " + Pol4xExp Bkg parameters";
+            }
+        std::cout << "Using " << msg.Data() << " from " << minvResult->GetName() <<  " inv mass result" << std::endl;
+        std::cout << "" << std::endl;
         }
-
-      }
-
-    }
-    //____ Take the Eq Nof MB events from the histos
-    Double_t nMBRatio(1.),nMBRatioError(0.);
-    if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
-    {
-      for (Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
-      {
-
-        if ( !binName.CompareTo(hMB->GetXaxis()->GetBinLabel(i)) )
+    else
         {
-          Double_t eqMBBin = hMB->GetBinContent(i);
-
-          nMBRatio = nEqMBTot/eqMBBin;
-          nMBRatioError = nMBRatio*TMath::Sqrt( TMath::Power(nEqMBTotError/nEqMBTot,2.) + TMath::Power(hMB->GetBinError(i)/eqMBBin,2.) );
+        AliError(Form("Cannot get tails from result. Result %s not found",minvResult->GetName()));
+        fitType = "";
+        return;
         }
+}
 
-      }
-    }
-    //_____________________
-
-    //________Mean, error on the mean and systematic uncertainty(signal extraction) computation for bin
-    //__Mean computation
-    Double_t num(0.),deno(0.);
-    for ( Int_t m = 1 ; m <= hratiosBin->GetNbinsX() ; m++ )
-    {
-      Double_t value = hratiosBin->GetBinContent(m); // Bin/Int value
-      Double_t error = hratiosBin->GetBinError(m); // Before this was divided by TMath::Sqrt(value);
-
-      if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
-
-      num += value; // We do not weight the values anymore with TMath::Power(weight,2.);
-      deno += 1.; // We do not weight the values anymore with 1./TMath::Power(weight,2.);
-    }
-
-    Double_t mean = num/deno;
-    Double_t jpsiMean = mean*nMBRatio ; //Compute relative Jpsi yield
-    //__
-
-    //__Error on the mean
-    Int_t nofvalidResults(0),nofTests(0);
-    Double_t w2err2(0.),sumw(0.);
-    for ( Int_t n = 1 ; n <= hratiosBin->GetNbinsX() ; n++ )
-    {
-      Double_t value = hratiosBin->GetBinContent(n);
-      Double_t error = hratiosBin->GetBinError(n);
-      Double_t weight = 1.; // We do not weight the values anymore with (error*error)/value;
-
-      nofTests++;
-
-      if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
-
-      w2err2 += weight*weight*error*error;
-      sumw += 1./weight;
-
-      nofvalidResults++;
-    }
-
-    std::cout << std::endl;
-    std::cout << "Bin " << b << " number of valid tests = " << nofvalidResults << "(" << nofvalidResults*100./nofTests << "%)" << std::endl;
-    std::cout << std::endl;
-
-    Double_t errorMean = TMath::Sqrt(w2err2*nofvalidResults)/sumw;
-    Double_t jpsiErrorMean = jpsiMean*TMath::Sqrt( TMath::Power(errorMean/mean,2.) + TMath::Power(nMBRatioError/nMBRatio,2.) ); //Compute relative Jpsi yield error
-    //__
-
-    Double_t val(0.),err(0.);
-    if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
-    {
-      val = jpsiMean;
-      err = jpsiErrorMean;
-    }
-    else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
-    {
-      val = mean;
-      err = errorMean;
-    }
-
-    hy->SetBinContent(b,val);
-    hy->SetBinError(b,err);
-    hy->GetXaxis()->SetBinLabel(b,binName.Data());
-
-    //__Systematic uncertainty
-    Double_t v1(0.),v2(0.),sum(0.);
-    for ( Int_t l = 1 ; l <= hratiosBin->GetNbinsX() ; l++ )
-    {
-      Double_t value = hratiosBin->GetBinContent(l);
-      Double_t error = hratiosBin->GetBinError(l); // Before this was divided by TMath::Sqrt(value);
-
-      if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
-
-      Double_t wi = 1.; // We do not wight anymore with 1./TMath::Power(error,2.);
-      v1 += wi;
-      v2 += wi*wi;
-      Double_t diff = value - mean;
-      sum += wi*diff*diff;
-      
-    }
-
-    Double_t syst = TMath::Sqrt( (v1/(v1*v1-v2)) * sum);
-    //__
+//_____________________________________________________________________________
+ULong64_t AliAnalysisMuMu::GetTriggerScalerCount(const char* triggerList, Int_t runNumber)
+{
+    // Get the expected (from OCDB scalers) trigger count
     
-    hsyst->GetXaxis()->SetBinLabel(b,binName.Data());
-    hsyst->SetBinContent(b,(syst*100.)/mean);
-    //________
+    AliAnalysisTriggerScalers ts(runNumber,Config()->OCDBPath());
     
-    //___
-    TF1* meanF = new TF1("mean","[0]",0,j*nFitsSameSignal);
-    meanF->SetParameter(0,mean);
+    TObjArray* triggers = TString(triggerList).Tokenize(",");
+    TObjString* trigger;
+    TIter next(triggers);
+    ULong64_t n(0);
     
-    TF1* meanFPS = new TF1("meanPS","[0]",0,j*nFitsSameSignal);
-    meanFPS->SetParameter(0,mean+syst);
-    meanFPS->SetLineStyle(2);
+    while ( ( trigger = static_cast<TObjString*>(next()) ) )
+        {
+        AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L2A",trigger->String().Data());
+        if (item)
+            {
+            n += item->Value();
+            }
+        delete item;
+        }
+    delete triggers;
     
-    TF1* meanFMS = new TF1("meanMS","[0]",0,j*nFitsSameSignal);
-    meanFMS->SetParameter(0,mean-syst);
-    meanFMS->SetLineStyle(2);
+    return n;
+}
 
-    hratiosBin->GetListOfFunctions()->Add(meanF);
-    hratiosBin->GetListOfFunctions()->Add(meanFPS);
-    hratiosBin->GetListOfFunctions()->Add(meanFMS);
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::GetSpectra(const char* what, const char* flavour) const
+{
+    /// get a given spectra
     
-    //___ Save the signal extraction systematic uncertainty histo for each bin
-    TH1* o = OC()->Histo(Form("%s",id.Data()),hratiosBin->GetName());
+    TString swhat(what);
+    TString sflavour(flavour);
+    swhat.ToUpper();
+    sflavour.ToUpper();
     
-    if (o)
-    {
-      AliWarning(Form("Replacing %s/%s",id.Data(),hratiosBin->GetName()));
-      OC()->Remove(Form("%s/%s",id.Data(),hratiosBin->GetName()));
-    }
+    TString spectraName(Form("/%s/%s/%s/%s/PSI-%s",
+                             Config()->First(Config()->EventSelectionKey(),kTRUE).Data(),
+                             Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data(),
+                             Config()->First(Config()->CentralitySelectionKey(),kTRUE).Data(),
+                             Config()->First(Config()->PairSelectionKey(),kTRUE).Data(),
+                             swhat.Data()));
     
-    Bool_t adoptOK = OC()->Adopt(id.Data(),hratiosBin);
+    cout << "spectraName : " << spectraName.Data() << endl;
     
-    if ( adoptOK ) std::cout << "+++syst histo " << hratiosBin->GetName() << " adopted" << std::endl;
-    else AliError(Form("Could not adopt syst histo %s",hratiosBin->GetName()));
-    //__________________
-  }
-  //_____________________________________________________________________________
-  
-  
-  //___ Save the signal extraction systematic uncertainty histo for all the bins
-  TH1* o = OC()->Histo(Form("%s",id.Data()),hsyst->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hsyst->GetName()));
-    OC()->Remove(Form("%s/%s",id.Data(),hsyst->GetName()));
-  }
-  
-  Bool_t adoptOK = OC()->Adopt(id.Data(),hsyst);
-  
-  if ( adoptOK ) std::cout << "+++syst histo " << hsyst->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt syst histo %s",hsyst->GetName()));
-  //__________________
-
-
-  //___ Save the Jpsi relative yield or <pT> histo
-  o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy->GetName());
-
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s","/RESULTS-%s/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/V0A",hy->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),diffPath.Data(),hy->GetName()));
-  }
-
-  adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy);
-
-  if ( adoptOK ) std::cout << "+++Yield histo " << hy->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hy->GetName()));
-  //__________________
-  
-  
-  delete bin;
-  delete sResultNameArray;
-  
-  return;
-  
-}
-
-
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::PlotJpsiYield(const char* whatever)
-{
-  
-  //FIXME::Make it general
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi yield: Is a simulation file");
-    return 0x0;
-  }
-  
-  TString path(Form("/%s/%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
-  
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/%s",path.Data(),whatever)));
-  if ( !s )
-  {
-    AliError(Form("No spectra %s found in %s",whatever,path.Data()));
-    return 0x0;
-  }
-  
-  std::cout << "Number of J/Psi:" << std::endl;
-  TH1* hry = s->Plot("NofJPsi","PSIPSIPRIMECB2VWGINDEPTAILS",kFALSE); //Number of Jpsi
-  std::cout << "" << std::endl;
-  
-  std::cout << "Equivalent number of MB events:" << std::endl;
-  TH1* hN = ComputeEquNofMB();
-  std::cout << "" << std::endl;
-  
-  TH1* hy = static_cast<TH1*>(hry->Clone("CorrJPsiYields"));
-  Double_t bR = 0.0593; // BR(JPsi->mu+mu-)
-  Double_t bRerror = 0.0006 ;
-  
-  for (Int_t i = 1 ; i <= hy->GetNbinsX() ; i++)
-  {
-    Double_t yield = hry->GetBinContent(i)/(hN->GetBinContent(i)*bR);
-    Double_t yieldError = TMath::Sqrt(TMath::Power(hry->GetBinError(i)/(hN->GetBinContent(i)*bR),2.) +
-                                      TMath::Power(hN->GetBinError(i)*bR/TMath::Power(hN->GetBinContent(i)*bR,2.),2.) +
-                                      TMath::Power(hry->GetBinContent(i)*hN->GetBinContent(i)*bRerror/TMath::Power(hN->GetBinContent(i)*bR,2.),2.));
-    
-    std::cout << yield << " +- " << yieldError << std::endl;
-    
-    hy->SetBinContent(i,yield);
-    hy->SetBinError(i,yieldError);
-  }
-  
-  delete hry;
-  delete hN;
-  
-  return hy;
-}
-
-
-//_____________________________________________________________________________
-UInt_t AliAnalysisMuMu::GetSum(AliCounterCollection& cc, const char* triggerList,
-                               const char* eventSelection, Int_t runNumber)
-{
-  TObjArray* ktrigger = cc.GetKeyWords("trigger").Tokenize(",");
-  TObjArray* kevent = cc.GetKeyWords("event").Tokenize(",");
-  TObjArray* a = TString(triggerList).Tokenize(" ");
-  TIter next(a);
-  TObjString* str;
-  
-  UInt_t n(0);
-  
-  TString sEventSelection(eventSelection);
-  sEventSelection.ToUpper();
-  
-  if ( kevent->FindObject(sEventSelection.Data()) ) 
-  {
-    while ( ( str = static_cast<TObjString*>(next()) ) )
-    {
-      if ( ktrigger->FindObject(str->String().Data()) )
-      {
-        if ( runNumber < 0 ) 
-        {
-          n +=  static_cast<UInt_t>(cc.GetSum(Form("trigger:%s/event:%s",str->String().Data(),eventSelection)));              
-        }
-        else
+    if (sflavour.Length()>0)
         {
-          n +=  static_cast<UInt_t>(cc.GetSum(Form("trigger:%s/event:%s/run:%d",str->String().Data(),eventSelection,runNumber)));                        
+        spectraName += "-";
+        spectraName += sflavour.Data();
         }
-      }
-    }
-  }
-  
-  delete a;
-  delete ktrigger;
-  delete kevent;
-  return n;
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::GetCollectionsFromAnySubdir(TDirectory& dir,
-                                                    AliMergeableCollection*& oc,
-                                                    AliCounterCollection*& cc,
-                                                    AliAnalysisMuMuBinning*& bin)
-{
-  /// Find, within dir and its sub-directories, the objects OC,CC and BIN
-  
-  TList* keys = dir.GetListOfKeys();
-  TIter next(keys);
-  
-  TKey* k;
-  
-  while ( ( k = static_cast<TKey*>(next()) ) )
-  {
-    TObject* object = k->ReadObj();
-    
-    if ( object->InheritsFrom("TDirectory") )
-    {
-      TDirectory* d = static_cast<TDirectory*>(object);
-      GetCollectionsFromAnySubdir(*d,oc,cc,bin);
-      continue;
-    }
     
-    if ( ( object->InheritsFrom("AliMergeableCollection") ) &&
-        ( strcmp(object->GetName(),"OC")==0 ) )
-    {
-      oc = dynamic_cast<AliMergeableCollection*>(object);
-      fDirectory = dir.GetName();
-    }
-
-    if ( ( object->InheritsFrom("AliCounterCollection") ) &&
-        ( strcmp(object->GetName(),"CC")==0 ) )
-    {
-      cc = dynamic_cast<AliCounterCollection*>(object);
-      fDirectory = dir.GetName();
-    }
-
-    if ( ( object->InheritsFrom("AliAnalysisMuMuBinning") ) &&
-        ( strncmp(object->GetName(),"BIN",3)==0 ) )
-    {
-      bin = dynamic_cast<AliAnalysisMuMuBinning*>(object);
-      fDirectory = dir.GetName();
-    }
-
-  }
+    return SPECTRA(spectraName.Data());
 }
 
 //_____________________________________________________________________________
-Bool_t
-AliAnalysisMuMu::GetCollections(const char* rootfile,
-                                const char* subdir,
-                                AliMergeableCollection*& oc,
-                                AliCounterCollection*& cc,
-                                AliAnalysisMuMuBinning*& bin,
-                                std::set<int>& runnumbers)
-{
-  /// Get access to the mergeable collection, counter collection and binning
-  /// within file rootfile.
-  /// rootfile is a filename, with an optional directory (with the syntax
-  /// (filename.root:directory)
-  /// where the collections are to be found.
- 
-  oc = 0x0;
-  cc = 0x0;
-  bin = 0x0;
-  
-  
-  TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(rootfile));
-  if (!f)
-  {
-    f = TFile::Open(rootfile);
-  }
-  
-  if ( !f || f->IsZombie() )
-  {
-    return kFALSE;
-  }
-  
-  TString dir = subdir;
-  
-  if (dir.Length())
-  {
-    dir.Remove(TString::kBoth,'/');
-    dir += "/";
-  }
-  
-  f->GetObject(Form("%sOC",dir.Data()),oc);
-  if (!oc)
-  {
-    f->GetObject(Form("%sMC",dir.Data()),oc);
-  }
-  f->GetObject(Form("%sCC",dir.Data()),cc);
-  
-  TIter next(f->GetListOfKeys());
-  TKey* key;
-  
-  while ( ( key = static_cast<TKey*>(next())) && !bin )
-  {
-    if ( strcmp(key->GetClassName(),"AliAnalysisMuMuBinning")==0 )
-    {
-      bin = dynamic_cast<AliAnalysisMuMuBinning*>(key->ReadObj());
-    }
-  }
-  
-  if ( (!oc || !cc) && fDirectory.Length()==0 )
-  {
-    // one more try, searching in subdirectories as well
-    GetCollectionsFromAnySubdir(*f,oc,cc,bin);
-  }
-  
-  if (!oc || !cc)
-  {
-    AliError("Could not get OC, CC and BIN. Is that an old file ? Try to upgrade it or check it's the right file...");
-    return kFALSE;
-  }
-  
-  // get run list
-  TObjArray* runs = cc->GetKeyWords("run").Tokenize(",");
-  runs->Sort();
-  TIter nextRun(runs);
-  TObjString* srun;
-
-  runnumbers.clear();
-  
-  while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
-  {
-    runnumbers.insert(srun->String().Atoi());
-  }
-  
-  delete runs;
-  
-  return kTRUE;
-}
-
-//_____________________________________________________________________________
-Bool_t AliAnalysisMuMu::IsSimulation() const
+TH1* AliAnalysisMuMu::PlotAccEfficiency(const char* whatever)
 {
-  // whether or not we have MC information
-  
-//  return kFALSE;
-  
-  if (!fMergeableCollection) return kFALSE;
-  
-  TList* list = fMergeableCollection->CreateListOfKeys(0);
-  TIter next(list);
-  TObjString* str;
-  Bool_t ok(kFALSE);
-  
-  while ( ( str = static_cast<TObjString*>(next()) ) )
-  {
-    if ( str->String().Contains(AliAnalysisMuMuBase::MCInputPrefix()) ) ok = kTRUE;
-  }
-  delete list;
-  
-  return ok;
+    //FIXME::Make it general
+    if ( !IsSimulation() )
+        {
+        AliError("Could not get AccxEff histo: Not simulation file");
+        return 0x0;
+        }
+    
+    TString path(Form("/%s/%s/%s/%s",
+                      Config()->First(Config()->EventSelectionKey(),kTRUE).Data(),
+                      Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data(),
+                      Config()->First(Config()->CentralitySelectionKey(),kTRUE).Data(),
+                      Config()->First(Config()->PairSelectionKey(),kTRUE).Data()));
+    
+    AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/%s",path.Data(),whatever)));
+    if ( !s )
+        {
+        AliError(Form("No AccEff spectra %s found in %s",whatever,path.Data()));
+        return 0x0;
+        }
+    
+    return s->Plot(Form("AccEff%s",GetParticleName()),"PSICOUNT",kFALSE);//_2.2_3.9
+    
 }
 
 //_____________________________________________________________________________
-Int_t
-AliAnalysisMuMu::Jpsi(const char* what, const char* binningFlavour, Bool_t fitmPt, Bool_t onlyCorrected)
+void AliAnalysisMuMu::ComputeRelativeValueAndSESystematics(const char* quantity,const char* flavour,const char* value2Test, const char* binListToExclude, const char* fNormType, const char* evSelInt, const char* evSelDiff, const char* triggerCluster)
 {
-  /// Fit the J/psi (and psiprime) peaks for the triggers in fDimuonTriggers list
-  /// what="integrated" => fit only fully integrated MinvUS
-  /// what="pt" => fit MinvUS in pt bins
-  /// what="y" => fit MinvUS in y bins
-  /// what="pt,y" => fit MinvUS in (pt,y) bins
-  
-  TStopwatch timer;
-  
-  if (!fMergeableCollection)
-  {
-    AliError("No mergeable collection. Consider Upgrade()");
-    return 0;
-  }
-  
-  Int_t nfits(0);
-  
-  TObjArray* triggerArray = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
-  TObjArray* eventTypeArray = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
-  TObjArray* pairCutArray = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
-  TObjArray* whatArray = TString(what).Tokenize(",");
-  TObjArray* centralityArray = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
-  
-  TIter nextTrigger(triggerArray);
-  TIter nextEventType(eventTypeArray);
-  TIter nextPairCut(pairCutArray);
-  TIter nextWhat(whatArray);
-  TIter nextCentrality(centralityArray);
-  
-  TObjString* trigger;
-  TObjString* eventType;
-  TObjString* pairCut;
-  TObjString* swhat;
-  TObjString* centrality;
-  
-  while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
-  {
-    AliAnalysisMuMuBinning* binning(0x0);
+    /// Compute the relative (bin/integrated) Jpsi yield or <pT> in "quantity,flavour" bins from the mean value of the relative values of the tests used for the systematic uncertainty of signal extraction computation. Store also the systematic uncertainty tests.
+    ///
+    /// Important considerations:
+    ///   - No corrections can be applied to the yields or x-axis with this method
+    ///
+    ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
+    ///
+    ///   - The analysed file must contain the event selection PSALL (for the integrated signal extraction) and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly.
+    ///
+    /// Parameters:
+    ///   - what,quantity and flavour defines the binning to test (output will be 1 plot per bin)
+    /// value2test is the observable we want to test ( i.e. NJpsi(bin)/integratedNJpsi, <pt>(bin)/integrated<pt>... )
+    ///   - value2test == yield -> NJpsi(bin)/integratedNJpsi
+    ///   - value2test == mpt -> <pt>(bin)/integrated<pt>
+    ///   - relative: kTRUE if relative yield (y/y_int) wants to be computed. Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
+    ///   - fNormType: Desired FNorm to use: "offline", "global" or "mean"
+    ///   - evSelInt: Event selection to compute integrated NofJpsi
+    ///   - evSelDiff: Event selection to compute diferential NofJpsi
+    ///   - triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
+    
+    
+    TString sfNormType(fNormType);
+    TString sevSelInt(evSelInt);
+    TString sevSelDiff(evSelDiff);
     
-    if ( fBinning && swhat->String().Length() > 0 )
-    {
-      binning = fBinning->Project("psi",swhat->String().Data(),binningFlavour);
-    }
+    if ( IsSimulation() )
+        {
+        AliError("Cannot compute J/Psi yield: Is a simulation file");
+        return;
+        }
+    TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
+    TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
+    TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
+    
+    TString intPath(Form("%s/%s/%s/%s",
+                         sevSelInt.Data(),
+                         dimuonTriggerClassName.Data(),
+                         centralitySelection.Data(),
+                         pairSelection.Data())); //Path to get/store integrated results from Mergeable Collection
+    
+    TString diffPath(Form("%s/%s/%s/%s",
+                          sevSelDiff.Data(),
+                          dimuonTriggerClassName.Data(),
+                          centralitySelection.Data(),
+                          pairSelection.Data())); //Path to get/store differential results from Mergeable Collection
+    
+    TString striggerCluster(triggerCluster);
+    if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
+    else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
+    else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
     else
-    {
-      binning = new AliAnalysisMuMuBinning;
-      binning->AddBin("psi",swhat->String().Data());
-    }
+        {
+        AliError("Unknown trigger cluster");
+        return;
+        }
     
-    StdoutToAliDebug(1,std::cout << "++++++++++++ swhat=" << swhat->String().Data() << std::endl;);
+    TString svalue2Test(value2Test);
+    TString shName("");
+    TString sObsInt("");
+    TString sObsBin("");
+    TString sflavour(flavour);
+    TString squantity(quantity);
+    squantity.ToUpper();
+    
+    TH1* hMB(0x0);
+    Double_t nEqMBTot(0.),nEqMBTotError(0.);
+    if ( !svalue2Test.CompareTo("yield",TString::kIgnoreCase) )
+        {
+        sObsInt = "PSI-INTEGRATED-AccEffCorr";
+        sObsBin = Form("PSI-%s-AccEffCorr",squantity.Data());
+        svalue2Test = "NofJPsi";
+        shName = "N^{J/#psi}_{bin}/N^{J/#psi}_{int}";
+        
+        TH1* hMBTot = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data()));
+        if ( !hMBTot )
+            {
+            AliWarning(Form("No eq Nof MB events found in %s: Yield will not be calculated",Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data())));
+            }
+        nEqMBTot = hMBTot->GetBinContent(1);
+        nEqMBTotError = hMBTot->GetBinError(1);
+        
+        
+        if ( sfNormType.Contains("offline") )
+            {
+            hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),sevSelDiff.Data(),quantity));
+            if ( !hMB )
+                {
+                AliWarning(Form("Histo hNofEqMBVS%s not found: Yield will not be calculated",quantity));
+                }
+            
+            std::cout << " Using Fnorm from offline method " << std::endl;
+            std::cout <<  std::endl;
+            }
+        else if ( sfNormType.Contains("global") )
+            {
+            hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),sevSelDiff.Data(),quantity));
+            if ( !hMB )
+                {
+                AliError(Form("Histo hNofEqMBVS%sFromGlobal not found: Yield will not be calculated",quantity));
+                }
+            
+            std::cout << " Using Fnorm from global method " << std::endl;
+            std::cout <<  std::endl;
+            }
+        else if ( sfNormType.Contains("mean") )
+            {
+            hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromMean",striggerCluster.Data(),sevSelDiff.Data(),quantity));
+            if ( !hMB )
+                {
+                AliError(Form("Histo hNofEqMBVS%sFromMean not found: Yield will not be calculated",quantity));
+                }
+            
+            std::cout << " Using mean Fnorm " << std::endl;
+            std::cout <<  std::endl;
+            }
+        else
+            {
+            AliWarning("Dont know what Fnorm use: Yield will not be calculated");
+            }
+        
+        }
+    else if ( !svalue2Test.CompareTo("mpt",TString::kIgnoreCase) )
+        {
+        sObsInt = "PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS";
+        sObsBin = Form("PSI-%s-AccEffCorr-MeanPtVsMinvUS",squantity.Data());
+        svalue2Test = "MeanPtJPsi";
+        shName = "<p_{t}>^{bin}/<p_{t}>^{int}";
+        }
+    else
+        {
+        AliError("unrecognized value to test");
+        return;
+        }
     
-    std::cout << "" << std::endl;
-    std::cout << "++++++++++++++++++" << "NEW BIN TYPE" << "+++++++++++++++++++" << std::endl;
-    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
-    std::cout << "++++++++++++ swhat=" << swhat->String().Data() << "++++++++++++++++++++" << std::endl;
-    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
-    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
-    std::cout << "" << std::endl;
-    std::cout << "" << std::endl;
+    TString id(Form("/TESTSYST/%s/%s",sevSelInt.Data(),sevSelDiff.Data()));
     
-    if (!binning)
-    {
-      AliError("oups. binning is NULL");
-      continue;
-    }
+    //________Get the integrated results
+    AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),sObsInt.Data())));
+    if ( !sInt )
+        {
+        AliError(Form("No integrated spectra %s found in %s",sObsInt.Data(),intPath.Data()));
+        return;
+        }
     
-    StdoutToAliDebug(1,binning->Print(););
+    TObjArray* bin = BIN()->CreateBinObjArray("psi","integrated","");
+    if ( !bin )
+        {
+        AliError("No integrated bin found");
+        return;
+        }
+    AliAnalysisMuMuBinning::Range* r = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(0));
     
-    nextTrigger.Reset();
+    AliAnalysisMuMuJpsiResult* resInt =  static_cast<AliAnalysisMuMuJpsiResult*>(sInt->GetResultForBin(*r));
+    if ( !resInt )
+        {
+        AliError(Form("No integrated result found in spectra %s at %s",sObsInt.Data(),intPath.Data()));
+        return;
+        }
+    TObjArray* sresIntArray = resInt->SubResults();
     
-    while ( ( trigger = static_cast<TObjString*>(nextTrigger())) )
-    {
-      AliDebug(1,Form("TRIGGER %s",trigger->String().Data()));
-      
-      nextEventType.Reset();
-      
-      while ( ( eventType = static_cast<TObjString*>(nextEventType())) )
-      {
-        AliDebug(1,Form("--EVENTTYPE %s",eventType->String().Data()));
-        
-        nextPairCut.Reset();
-        
-        while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) )
-        {
-          AliDebug(1,Form("----PAIRCUT %s",pairCut->String().Data()));
-          
-          nextCentrality.Reset();
-          
-          while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) )
-          {
-            AliDebug(1,"----Fitting...");
-            
-            TObject* o;
-            
-            TString id(Form("/%s/%s/%s/%s",eventType->String().Data(),
-                            trigger->String().Data(),
-                            centrality->String().Data(),
-                            pairCut->String().Data()));
-
-            AliAnalysisMuMuSpectra* spectra(0x0);
-            if ( !onlyCorrected )
+    delete bin;
+    //_________________________
+    
+    
+    bin = BIN()->CreateBinObjArray("psi",squantity.Data(),sflavour.Data());
+    if ( !bin )
+        {
+        AliError(Form("%s-%s-%s binning does not exist","psi",squantity.Data(),sflavour.Data()));
+        return;
+        }
+    
+    //_______ Exclude desired bins
+    TIter nextBinTest(bin);
+    
+    TString sbinListToExclude(binListToExclude);
+    TObjArray* abinListToExclude = sbinListToExclude.Tokenize(",");
+    TIter nextBinToExclude(abinListToExclude);
+    Int_t excl(0);
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBinTest()) ) ) //Bin loop
+        {
+        nextBinToExclude.Reset();
+        TObjString* s(0x0);
+        while ( (s = static_cast<TObjString*>(nextBinToExclude())) )
             {
-              
-              spectra = FitParticle("psi",
-                                    trigger->String().Data(),
-                                    eventType->String().Data(),
-                                    pairCut->String().Data(),
-                                    centrality->String().Data(),
-                                    *binning);
-              
-              AliDebug(1,Form("----fitting done spectra = %p",spectra));
-              
-              if ( spectra )
-              {
-                ++nfits;
-
-                o = fMergeableCollection->GetObject(id.Data(),spectra->GetName());
-
-                AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
-
-                if (o)
+            if ( !r->AsString().CompareTo(s->GetString().Data()) )
                 {
-                  AliWarning(Form("Replacing %s/%s",id.Data(),spectra->GetName()));
-                  fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectra->GetName()));
+                std::cout << "Removing bin " << s->GetString().Data() << std::endl;
+                bin->RemoveAt(excl);
                 }
-
-                Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectra);
-
-                if ( adoptOK ) std::cout << "+++Spectra " << spectra->GetName() << " adopted" << std::endl;
-                else AliError(Form("Could not adopt spectra %s",spectra->GetName()));
-
-                StdoutToAliDebug(1,spectra->Print(););
-              }
-              else AliError("Error creating spectra");
             }
+        excl++;
+        }
+    std::cout <<  std::endl;
+    bin->Compress();
+    //_________________
+    
+    
+    //______Create arrays to store values inside
+    Int_t nbin = bin->GetEntries();
+    Int_t nsres = sresIntArray->GetEntries();
+    TObjArray* sResultNameArray= new TObjArray();
+    sResultNameArray->SetOwner();
+    std::vector<std::vector<double> > valuesArr;
+    valuesArr.resize(nbin+1, std::vector<double>(nsres,0));
+    std::vector<std::vector<double> > valuesErrorArr;
+    valuesErrorArr.resize(nbin+1, std::vector<double>(nsres,0));
+    //_________________________
+    
+    
+    //________Get the integrated values from results
+    TIter nextIntSubResult(sresIntArray);
+    AliAnalysisMuMuResult* sresInt(0x0);
+    
+    TString testSig(""); //Strings for testing the name of the subresult to extract the number of tests for the systematics
+    TString testSPsip("");
+    TString testSresIntNameSig("");
+    TString testSresIntNameSPsip("");
+    
+    Int_t nFitsSameSignal(0);
+    Int_t j(0);
+    while ( ( sresInt = static_cast<AliAnalysisMuMuResult*>(nextIntSubResult()) ) ) //Integrated SubResult loop
+        {
+        TString sresIntName(sresInt->GetName());
+        
+        valuesArr[0][j] = sresInt->GetValue(svalue2Test.Data());
+        valuesErrorArr[0][j] = sresInt->GetErrorStat(svalue2Test.Data());
+        sResultNameArray->Add(new TObjString(sresIntName.Data()));
+        
+        if ( j ==0 ) // Get the first and last part of name of the first subresult
+            {
+            testSresIntNameSig = sresIntName.Data();
+            testSresIntNameSPsip = sresIntName.Data();
             
-            AliDebug(1,"----Fitting corrected spectra...");
-            
-            AliAnalysisMuMuSpectra* spectraCorr = FitParticle("psi",
-                                                              trigger->String().Data(),
-                                                              eventType->String().Data(),
-                                                              pairCut->String().Data(),
-                                                              centrality->String().Data(),
-                                                              *binning,"minv",kTRUE);
-            
-            AliDebug(1,Form("----fitting done corrected spectra = %p",spectraCorr));
-            
-            o = 0x0;
-            if ( spectraCorr )
+            testSresIntNameSig.Remove(3,testSresIntNameSig.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
+            testSresIntNameSPsip.Remove(0,testSresIntNameSPsip.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
+            }
+        
+        if ( sresIntName.Contains(testSresIntNameSig.Data()) && sresIntName.Contains(testSresIntNameSPsip.Data()) ) //This counts the number of times a fit with the same signal and same SigmaPsiP is repeated. This will be the number of tests for a given signal.
+            {
+            nFitsSameSignal++;
+            }
+        j++;
+        }
+    
+    std::cout << "Number of tests per signal/SigmaPsi' combination = " << nFitsSameSignal << std::endl;
+    std::cout <<  std::endl;
+    //____________________________________
+    
+    //__________Get the bin per bin results and the values
+    AliAnalysisMuMuSpectra* sBin = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),sObsBin.Data())));
+    if ( !sBin )
+        {
+        AliError(Form("No integrated spectra %s found in %s",sObsBin.Data(),diffPath.Data()));
+        delete bin;
+        delete sResultNameArray;
+        return;
+        }
+    
+    TIter nextBin(bin);
+    AliAnalysisMuMuJpsiResult* sresBin(0x0);
+    Int_t i(1);
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
+        {
+        sresBin =  static_cast<AliAnalysisMuMuJpsiResult*>(sBin->GetResultForBin(*r));
+        if ( !sresBin )
+            {
+            AliError(Form("No result found in spectra %s at %s for bin %s",sObsInt.Data(),diffPath.Data(),r->AsString().Data()));
+            delete bin;
+            delete sResultNameArray;
+            return;
+            }
+        
+        TObjArray* sresBinArray = sresBin->SubResults();
+        
+        if ( nsres != sresBinArray->GetEntries() )
             {
-              ++nfits;
-              
-              o = fMergeableCollection->GetObject(id.Data(),spectraCorr->GetName());
-              
-              AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
-              
-              if (o)
-              {
-                AliWarning(Form("Replacing %s/%s",id.Data(),spectraCorr->GetName()));
-                fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraCorr->GetName()));
-              }
-              
-              Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraCorr);
-              
-              if ( adoptOK ) std::cout << "+++Spectra " << spectraCorr->GetName() << " adopted" << std::endl;
-              else AliError(Form("Could not adopt spectra %s",spectraCorr->GetName()));
-              
-              StdoutToAliDebug(1,spectraCorr->Print(););
+            AliError("Integrated and bins spectra have different number of subresults");
+            delete bin;
+            delete sResultNameArray;
+            return;
             }
-            else AliError("Error creating spectra");
+        
+        TIter nextSubResult(sresBinArray);
+        j = 0;
+        while ( (sresBin = static_cast<AliAnalysisMuMuJpsiResult*>(nextSubResult())) ) // Subresults loop
+            {
+            valuesArr[i][j] = sresBin->GetValue(svalue2Test.Data());
+            valuesErrorArr[i][j] = sresBin->GetErrorStat(svalue2Test.Data());
             
+            j++;
             
-            if (fitmPt)
+            } //End Subresults loop
+        i++;
+        
+        } //End bin loop
+    //___________________________
+    
+    
+    //____________Compute the value ratios and systematic uncertainties on the ratios bin by bin
+    
+    //______ Create histos to store signal extraction systematic uncertainties
+    TH1* hsyst = new TH1F(Form("%s_Systematics",value2Test),Form("%s Systematics results",value2Test),nbin,0,nbin);
+    //_________________________________
+    
+    //______ Create histos to store relative Jpsi yield or <p_T> vs bins
+    Int_t size = bin->GetEntriesFast();
+    Double_t* axis = new Double_t[size+1];
+    TIter next(bin);
+    AliAnalysisMuMuBinning::Range* b;
+    TH1* hy(0x0);
+    i = 0;
+    while ( ( b = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+        {
+        axis[i] = b->Xmin();
+        ++i;
+        }
+    
+    b = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(size-1));
+    
+    axis[i] = b->Xmax();
+    
+    if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
+        {
+        hy = new TH1D(Form("hMeanJPsiYieldVS%sRelative",quantity),Form("Relative J/#psi yield vs %s;%s;Y^{J/#psi}/Y^{J/#psi}_{int}",quantity,quantity)
+                      ,size,axis);
+        }
+    else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
+        {
+        hy = new TH1D(Form("hMeanJPsiMPtVS%sRelative",quantity),Form("Relative J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}/<p_{T}>^{J/#psi}_{int}",quantity,quantity)
+                      ,size,axis);
+        }
+    
+    if ( !hy )
+        {
+        AliError("No histogram created to store the results");
+        return;
+        }
+    delete axis;
+    //_________________________________
+    
+    TString binName("");
+    for ( Int_t b = 1 ; b <= size ; b++ ) //Bin loop
+        {
+        
+        binName = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(b-1))->AsString().Data();
+        //    TString savePath(Form("%s/%s",id.Data(),binName.Data()));
+        
+        Int_t binUCTotal(1);
+        
+        TH1* hratiosBin = new TH1D(Form("SystTests_%s_Bkg_%s",sObsBin.Data(),binName.Data()),
+                                   Form("%s Systematics tests for %s",binName.Data(),shName.Data()),j*nFitsSameSignal,0,
+                                   j*nFitsSameSignal);
+        
+        for ( Int_t k = 0 ; k < j ; k++ ) // Subresults loop for integrated values
             {
-              AliDebug(1,"----Fitting mean pt...");
-              
-              std::cout << "" << std::endl;
-              std::cout << "" << std::endl;
-              
-              if ( !onlyCorrected )
-              {
-                std::cout << "++++++++++++ Fitting mean Pt for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
-                if ( spectra )
+            //__Get the name of the signal and the Psi' sigma for the integrated result
+            TString signalNameInt(sResultNameArray->At(k)->GetName());
+            TString sPsiPNameInt(signalNameInt.Data());
+            
+            signalNameInt.Remove(3,signalNameInt.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
+            sPsiPNameInt.Remove(0,sPsiPNameInt.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
+            //__
+            
+            //      Int_t sizeName = signalName.Sizeof();
+            //      signalName.Remove(2,sizeName-3);
+            //      Int_t binUC(1);
+            
+            for ( Int_t l = 0; l < j ; l++) //Subresults loop for bins values
                 {
-                  AliAnalysisMuMuSpectra* spectraMeanPt = FitParticle("psi",
-                                                                      trigger->String().Data(),
-                                                                      eventType->String().Data(),
-                                                                      pairCut->String().Data(),
-                                                                      centrality->String().Data(),
-                                                                      *binning,"mpt"/*,*spectra*/);
-                  
-                  
-                  
-                  AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPt));
-                  o = 0x0;
-
-                  if ( spectraMeanPt )
-                  {
-                    ++nfits; //Review this
-
-                    o = fMergeableCollection->GetObject(id.Data(),spectraMeanPt->GetName());
-
-                    AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
-
-                    if (o)
-                    {
-                      AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPt->GetName()));
-                      fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPt->GetName()));
-                    }
-
-                    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPt);
-
-                    if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPt->GetName() << " adopted" << std::endl;
-                    else AliError(Form("Could not adopt spectra %s",spectraMeanPt->GetName()));
-                  }
-                  else AliError("Error creating spectra");
-                  
-                }
-                else std::cout << "Mean pt fit failed: No inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
-              }
-
-              std::cout << "++++++++++++ Fitting corrected mean Pt for" << " " << swhat->String().Data() << " " << "slices" << std::endl;
-              
-              if ( spectraCorr )
-              {
-                AliAnalysisMuMuSpectra* spectraMeanPtCorr  = FitParticle("psi",
-                                                                       trigger->String().Data(),
-                                                                       eventType->String().Data(),
-                                                                       pairCut->String().Data(),
-                                                                       centrality->String().Data(),
-                                                                       *binning,"mpt"/*,*spectraCorr*/,kTRUE);
+                TString binSignalName(sResultNameArray->At(l)->GetName());
                 
+                Double_t ratio,ratioError(0.);
                 
+                ratio = valuesArr[b][l] / valuesArr[0][k];
+                //          ratioError = TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[0][k],2.) + TMath::Power(valuesArr[b][l]*valuesErrorArr[0][k] / TMath::Power(valuesArr[0][k],2.),2.) );
                 
-                AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPtCorr));
+                if ( (valuesErrorArr[b][l] != 0) && (valuesErrorArr[0][k] != 0) ) // We only give an error!=0 if the errors of the int and bin values are both !=0 (Otherwise it means that there was a problem with the fit so we fix the error to 0 to skip the test later on)
+                    {
+                    ratioError = ratio*TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[b][l],2.) + TMath::Power(valuesErrorArr[0][k] / valuesArr[0][k],2.) );
+                    }
                 
-                o = 0x0;
+                if ( binSignalName.Contains(signalNameInt.Data()) && binSignalName.Contains(sPsiPNameInt.Data()) ) // In this case the integrated and bin values have the same signal shape and Psi' sigma, so the result is stored
+                    {
+                    hratiosBin->GetXaxis()->SetBinLabel(binUCTotal,Form("%s/%s",sResultNameArray->At(l)->GetName(),sResultNameArray->At(k)->GetName()));
+                    
+                    hratiosBin->SetBinContent(binUCTotal,ratio);
+                    hratiosBin->SetBinError(binUCTotal,ratioError);
+                    
+                    binUCTotal++;
+                    }
                 
-                if ( spectraMeanPtCorr )
-                {
-                  ++nfits; //Review this
-                  
-                  o = fMergeableCollection->GetObject(id.Data(),spectraMeanPtCorr->GetName());
-                  
-                  AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
-                  
-                  if (o)
-                  {
-                    AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPtCorr->GetName()));
-                    fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPtCorr->GetName()));
-                  }
-                  
-                  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPtCorr);
-
-                  if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPtCorr->GetName() << " adopted" << std::endl;
-                  else AliError(Form("Could not adopt spectra %s",spectraMeanPtCorr->GetName()));
-                  
                 }
-                else AliError("Error creating spectra");
+            
+            }
+        //____ Take the Eq Nof MB events from the histos
+        Double_t nMBRatio(1.),nMBRatioError(0.);
+        if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
+            {
+            for (Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
+                {
                 
-              }
-              
-              else std::cout << "Corrected mean pt fit failed: No corrected inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl;
-              
+                if ( !binName.CompareTo(hMB->GetXaxis()->GetBinLabel(i)) )
+                    {
+                    Double_t eqMBBin = hMB->GetBinContent(i);
+                    
+                    nMBRatio = nEqMBTot/eqMBBin;
+                    nMBRatioError = nMBRatio*TMath::Sqrt( TMath::Power(nEqMBTotError/nEqMBTot,2.) + TMath::Power(hMB->GetBinError(i)/eqMBBin,2.) );
+                    }
+                
+                }
             }
-          }
+        //_____________________
+        
+        //________Mean, error on the mean and systematic uncertainty(signal extraction) computation for bin
+        //__Mean computation
+        Double_t num(0.),deno(0.);
+        for ( Int_t m = 1 ; m <= hratiosBin->GetNbinsX() ; m++ )
+            {
+            Double_t value = hratiosBin->GetBinContent(m); // Bin/Int value
+            Double_t error = hratiosBin->GetBinError(m); // Before this was divided by TMath::Sqrt(value);
+            
+            if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
+            
+            num += value; // We do not weight the values anymore with TMath::Power(weight,2.);
+            deno += 1.; // We do not weight the values anymore with 1./TMath::Power(weight,2.);
+            }
+        
+        Double_t mean = num/deno;
+        Double_t jpsiMean = mean*nMBRatio ; //Compute relative Jpsi yield
+        //__
+        
+        //__Error on the mean
+        Int_t nofvalidResults(0),nofTests(0);
+        Double_t w2err2(0.),sumw(0.);
+        for ( Int_t n = 1 ; n <= hratiosBin->GetNbinsX() ; n++ )
+            {
+            Double_t value = hratiosBin->GetBinContent(n);
+            Double_t error = hratiosBin->GetBinError(n);
+            Double_t weight = 1.; // We do not weight the values anymore with (error*error)/value;
+            
+            nofTests++;
+            
+            if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
+            
+            w2err2 += weight*weight*error*error;
+            sumw += 1./weight;
+            
+            nofvalidResults++;
+            }
+        
+        std::cout << std::endl;
+        std::cout << "Bin " << b << " number of valid tests = " << nofvalidResults << "(" << nofvalidResults*100./nofTests << "%)" << std::endl;
+        std::cout << std::endl;
+        
+        Double_t errorMean = TMath::Sqrt(w2err2*nofvalidResults)/sumw;
+        Double_t jpsiErrorMean = jpsiMean*TMath::Sqrt( TMath::Power(errorMean/mean,2.) + TMath::Power(nMBRatioError/nMBRatio,2.) ); //Compute relative Jpsi yield error
+        //__
+        
+        Double_t val(0.),err(0.);
+        if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
+            {
+            val = jpsiMean;
+            err = jpsiErrorMean;
+            }
+        else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
+            {
+            val = mean;
+            err = errorMean;
+            }
+        
+        hy->SetBinContent(b,val);
+        hy->SetBinError(b,err);
+        hy->GetXaxis()->SetBinLabel(b,binName.Data());
+        
+        //__Systematic uncertainty
+        Double_t v1(0.),v2(0.),sum(0.);
+        for ( Int_t l = 1 ; l <= hratiosBin->GetNbinsX() ; l++ )
+            {
+            Double_t value = hratiosBin->GetBinContent(l);
+            Double_t error = hratiosBin->GetBinError(l); // Before this was divided by TMath::Sqrt(value);
+            
+            if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
+            
+            Double_t wi = 1.; // We do not wight anymore with 1./TMath::Power(error,2.);
+            v1 += wi;
+            v2 += wi*wi;
+            Double_t diff = value - mean;
+            sum += wi*diff*diff;
+            
+            }
+        
+        Double_t syst = TMath::Sqrt( (v1/(v1*v1-v2)) * sum);
+        //__
+        
+        hsyst->GetXaxis()->SetBinLabel(b,binName.Data());
+        hsyst->SetBinContent(b,(syst*100.)/mean);
+        //________
+        
+        //___
+        TF1* meanF = new TF1("mean","[0]",0,j*nFitsSameSignal);
+        meanF->SetParameter(0,mean);
+        
+        TF1* meanFPS = new TF1("meanPS","[0]",0,j*nFitsSameSignal);
+        meanFPS->SetParameter(0,mean+syst);
+        meanFPS->SetLineStyle(2);
+        
+        TF1* meanFMS = new TF1("meanMS","[0]",0,j*nFitsSameSignal);
+        meanFMS->SetParameter(0,mean-syst);
+        meanFMS->SetLineStyle(2);
+        
+        hratiosBin->GetListOfFunctions()->Add(meanF);
+        hratiosBin->GetListOfFunctions()->Add(meanFPS);
+        hratiosBin->GetListOfFunctions()->Add(meanFMS);
+        
+        //___ Save the signal extraction systematic uncertainty histo for each bin
+        TH1* o = OC()->Histo(Form("%s",id.Data()),hratiosBin->GetName());
+        
+        if (o)
+            {
+            AliWarning(Form("Replacing %s/%s",id.Data(),hratiosBin->GetName()));
+            OC()->Remove(Form("%s/%s",id.Data(),hratiosBin->GetName()));
+            }
+        
+        Bool_t adoptOK = OC()->Adopt(id.Data(),hratiosBin);
+        
+        if ( adoptOK ) std::cout << "+++syst histo " << hratiosBin->GetName() << " adopted" << std::endl;
+        else AliError(Form("Could not adopt syst histo %s",hratiosBin->GetName()));
+        //__________________
         }
-      }
-    }
-  }
-  
-  delete whatArray;
-  delete triggerArray;
-  delete eventTypeArray;
-  delete pairCutArray;
-  delete centralityArray;
-  
-  StdoutToAliDebug(1,timer.Print(););
-
-  if (nfits)
-  {
-    Update();
-//    ReOpen(fFilename,"UPDATE");
-//    fMergeableCollection->Write("MC",TObjArray::kOverwrite);// | TObjArray::kSingleKey);
-//    ReOpen(fFilename,"READ");
-  }
-  
-  
-  return nfits;
-  
-}
-
-//_____________________________________________________________________________
-TGraph* AliAnalysisMuMu::PlotEventSelectionEvolution(const char* trigger1, const char* event1,
-                                                     const char* trigger2, const char* event2,
-                                                     Bool_t drawFills,
-                                                     Bool_t asRejection) const
-{
-  if (!CC()) return 0x0;
-  
-  const std::set<int>& runnumbers = RunNumbers();
-  
-  TGraphErrors* g = new TGraphErrors(runnumbers.size());
-  
-  std::set<int>::const_iterator it;
-  Int_t i(0);
-
-  Double_t ymin(TMath::Limits<double>::Max());
-  Double_t ymax(TMath::Limits<double>::Min());
-
-  for ( it = runnumbers.begin(); it != runnumbers.end(); ++it )
-  {
-    Int_t runNumber = *it;
-    Double_t n = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger1,event1,runNumber));
-    Double_t d = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger2,event2,runNumber));
-    if (n>0 && d>0)
-    {
-      Double_t y = n/d;
-      
-      if ( fCorrectionPerRun )
-      {
-        Double_t xcorr,ycorr;
-        fCorrectionPerRun->GetPoint(i,xcorr,ycorr); // note that the fact that xcorr==runNumber has been checked by the SetCorrectionPerRun method
-        y *= ycorr;
-        // FIXME: should get the correction error here
-      }
-      
-      if ( asRejection ) y = 100*(1.0 - y);
-      ymin = TMath::Min(ymin,y);
-      ymax = TMath::Max(ymax,y);
-      Double_t yerr = y*AliAnalysisMuMuResult::ErrorAB(n,TMath::Sqrt(n),d,TMath::Sqrt(d));
-      g->SetPoint(i,runNumber,y);
-      g->SetPointError(i,0.5,yerr);
-      
-      ++i;
-    }
+    //_____________________________________________________________________________
     
-  }
-
-  TH2* hframe = new TH2F(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
-                         Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
-                         runnumbers.size()+50,
-                         *(runnumbers.begin())-25,
-                         *(runnumbers.rbegin())+25,100,0,ymax*1.3);
-  
-  gStyle->SetOptStat(0);
-  
-  hframe->Draw();
-  
-  hframe->GetXaxis()->SetNoExponent();
-           
-  hframe->GetYaxis()->SetTitle(asRejection ? "Rejection (%)" : "Ratio");
-  
-  g->Set(i);
-  g->SetTitle(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2));
-  g->GetXaxis()->SetNoExponent();
-  g->Draw("lp");
-
-  AliAnalysisTriggerScalers ts(RunNumbers(),Config()->OCDBPath());
-
-  if ( drawFills )
-  {
-    ts.DrawFills(ymin,ymax);
-    g->Draw("lp");
-  }
-  
-  
-  std::map<std::string, std::pair<int,int> > periods;
-  
-  ts.GetLHCPeriodBoundaries(periods);
-  
-  TLegend* legend = new TLegend(0.15,0.82,0.90,0.92);
-  legend->SetFillColor(0);
-  Int_t n(0);
-  
-
-  for ( std::map<std::string, std::pair<int,int> >::const_iterator pit = periods.begin(); pit != periods.end(); ++pit )
-  {
-    std::string period = pit->first;
-    int run1 = (pit->second).first;
-    int run2 = (pit->second).second;
-    int nruns(0);
-    for ( std::set<int>::const_iterator rit = RunNumbers().begin(); rit != RunNumbers().end(); ++ rit )
-    {
-      if ( (*rit) >= run1 && (*rit) <= run2 )
-      {
-        ++nruns;
-      }
-    }
-    AliInfo(Form("Period %s runs %6d-%6d ; %d actual runs",period.c_str(),run1,run2,nruns));
     
-    g->Fit("pol0","+Q","",run1,run2);
-    TF1* func = static_cast<TF1*>(g->GetListOfFunctions()->Last());
-    if (func)
-    {
-      func->SetLineColor(2+n);
-      legend->AddEntry(func,Form("%s %5.2f #pm %5.2f %s (rel. error %5.2f %%)",period.c_str(),func->GetParameter(0),func->GetParError(0),
-                                 (asRejection ? "%":""),100*func->GetParError(0)/func->GetParameter(0)));
-      ++n;
-    }
-  }
-
-  legend->SetNColumns(3);
-
-  Double_t mean = TMath::Mean(g->GetN(),g->GetY());
-  Double_t rms = TMath::RMS(g->GetN(),g->GetY());
-  
-  legend->AddEntry("",Form("Mean %5.2f RMS %5.2f (%5.2f %%)",mean,rms,(mean) ? 100.0*rms/mean : 0.0),"");
-  
-  legend->Draw();
-  
-  return g;
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::ShowList(const char* title, const TString& list, const char separator) const
-{
-  /// Show a list of strings
-  TObjArray* parts = list.Tokenize(separator);
-  
-  std::cout << title << " (" << parts->GetEntries() << ") : " << std::endl;
-  
-  TIter next(parts);
-  TObjString* str;
-  
-  while ( ( str = static_cast<TObjString*>(next()) ) )
-  {
-    std::cout << "    " << str->String().Data() << std::endl;
-  }
-  
-  if ( parts->GetEntries()==0) std::cout << endl;
-  
-  delete parts;
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::Print(Option_t* opt) const
-{
-    /// printout
-  std::cout << "Reading from file : " << fFilename.Data() << std::endl;
-  
-  TString copt(opt);
-  
-  if (IsSimulation() || SIM() )
-  {
-    copt += "SIM";
-  }
-
-  if ( !IsSimulation() )
-  {
-    copt += "REAL";
-  }
-  
-  Config()->Print(copt.Data());
-
-  if ( RunNumbers().size() > 1 )
-  {
-    std::cout << RunNumbers().size() << " runs";
-  }
-  else
-  {
-    std::cout << RunNumbers().size() << " run";
-  }
-  
-  if ( fCorrectionPerRun )
-  {
-    std::cout << " with correction factors";
-  }
-  std::cout << std::endl;
-  Int_t i(0);
-  for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
-  {
-    std::cout << (*it);
-    if ( fCorrectionPerRun )
-    {
-      std::cout << Form("(%e)",fCorrectionPerRun->GetY()[i]);
-    }
-    std::cout << ",";
-    ++i;
-  }
-  std::cout << std::endl;
-  
-  TString sopt(opt);
-  sopt.ToUpper();
-  
-  if ( sopt.Contains("BIN") && BIN() )
-  {
-    std::cout << "Binning : " << std::endl;
-    TString topt(sopt);
-    topt.ReplaceAll("BIN","");
-    BIN()->Print(topt.Data());
-  }
-  if ( sopt.Contains("MC") && OC() )
-  {
-    TString topt(sopt);
-    topt.ReplaceAll("MC","");
-    OC()->Print(topt.Data());
-  }
-  if ( sopt.Contains("CC") && CC() )
-  {
-    CC()->Print("trigger/event");
-  }
-  
-  if ( sopt.Contains("SIZE") )
-  {
-    TFile* f = ReOpen(fFilename,"READ");
-    TIter next(f->GetListOfKeys());
-    TKey* key;
+    //___ Save the signal extraction systematic uncertainty histo for all the bins
+    TH1* o = OC()->Histo(Form("%s",id.Data()),hsyst->GetName());
+    
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s",id.Data(),hsyst->GetName()));
+        OC()->Remove(Form("%s/%s",id.Data(),hsyst->GetName()));
+        }
+    
+    Bool_t adoptOK = OC()->Adopt(id.Data(),hsyst);
+    
+    if ( adoptOK ) std::cout << "+++syst histo " << hsyst->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt syst histo %s",hsyst->GetName()));
+    //__________________
+    
+    
+    //___ Save the Jpsi relative yield or <pT> histo
+    o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy->GetName());
+    
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s","/RESULTS-%s/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/V0A",hy->GetName()));
+        OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),diffPath.Data(),hy->GetName()));
+        }
+    
+    adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy);
+    
+    if ( adoptOK ) std::cout << "+++Yield histo " << hy->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt Yield histo %s",hy->GetName()));
+    //__________________
+    
+    
+    delete bin;
+    delete sResultNameArray;
+    
+    return;
     
-    while ( ( key = static_cast<TKey*>(next()) ) )
-    {
-      std::cout << key->GetName() << " " << key->GetNbytes() << " " << key->GetObjlen() << std::endl;
-    }
-  }
-}
-
-//_____________________________________________________________________________
-TFile* AliAnalysisMuMu::ReOpen(const char* filename, const char* mode) const
-{
-  /// Tries to reopen the file with a new mode
-  
-  TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(filename));
-  
-  if (f)
-  {
-    delete f;
-  }
-  
-  f = TFile::Open(filename,mode);
-  
-  if ( !f || !f->IsOpen() )
-  {
-    AliError(Form("Cannot open file %s in mode %s",filename,mode));
-    return 0x0;
-  }
-  
-  return f;
 }
 
-//_____________________________________________________________________________
-void AliAnalysisMuMu::SetCentralitySelectionList(const char* centralitySelectionList)
-{
-  /// Set centralities to be used during fitting
-  /// centralitySelectionList is a regular expression.
-
-  TObjArray* centralities = BIN()->CreateBinObjArray("centrality");
-  TIter next(centralities);
-  AliAnalysisMuMuBinning::Range* r;
-
-  TString csl;
-
-  TPRegexp re(centralitySelectionList);
-  
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    AliDebug(1,Form("r=%s",r->AsString().Data()));
-    if ( re.MatchB(r->AsString()) )
-    {
-      csl += r->AsString();
-      csl += ",";
-    }
-  }
-  
-  if ( IsSimulation() )  csl += " sim";
-  
-  Config()->Add(Config()->CentralitySelectionKey(),csl);
-  
-  delete centralities;
-}
 
 //_____________________________________________________________________________
-Bool_t AliAnalysisMuMu::SetCorrectionPerRun(const TGraph& corr, const char* formula)
+TH1* AliAnalysisMuMu::PlotJpsiYield(const char* whatever)
 {
-    /// Sets the graph used to correct values per run
-  delete fCorrectionPerRun;
-  fCorrectionPerRun=0x0;
-  
-  // check that corr has the same runs as we do
-  
-  Int_t i(0);
-  
-  for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
-  {
-    Int_t corrRun = TMath::Nint(corr.GetX()[i]);
-    if (corrRun != *it)
-    {
-      AliError(Form("%d-th run mistmatch %d vs %d",i,corrRun,*it));
-      
-      return kFALSE;
-    }
-    ++i;
-  }
-  
-  fCorrectionPerRun = new TGraphErrors(corr.GetN());
-
-  TFormula* tformula(0x0);
-  if ( strlen(formula) > 0 )
-  {
-    tformula = new TFormula("SetCorrectionPerRunFormula",formula);
-  }
-
-  i = 0;
-  
-  for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
-  {
-    Double_t y = corr.GetY()[i];
     
-    if ( tformula )
-    {
-      y = tformula->Eval(y);
-    }
-    fCorrectionPerRun->SetPoint(i,corr.GetX()[i],y);
-    ++i;
-  }
-
-  delete formula;
-  
-  return kTRUE;
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::SetNofInputParticles(AliAnalysisMuMuJpsiResult& r)
-{
-  /// Set the "NofInput" variable(s) of one result
-  
-  TString hname(Form("MinvUS%s",r.Bin().AsString().Data()));
-
-  TH1* hinput = fMergeableCollection->Histo(Form("/%s/ALL/ANY/V0A/INYRANGE",AliAnalysisMuMuBase::MCInputPrefix()),hname.Data());
-
-  if (!hinput)
-  {
-    AliError(Form("Got a simulation file where I did not find histogram /%s/ALL/EVERYTHING/ANY/INYRANGE/%s",AliAnalysisMuMuBase::MCInputPrefix(),hname.Data()));
-
-  }
-  else
-  {
-    r.SetNofInputParticles(*hinput);
-  }
+    //FIXME::Make it general
+    if ( IsSimulation() )
+        {
+        AliError("Cannot compute J/Psi yield: Is a simulation file");
+        return 0x0;
+        }
+    
+    TString path(Form("/%s/%s/%s/%s",
+                      Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
+                      Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
+    
+    AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/PSI-%s",path.Data(),whatever)));
+    if ( !s )
+        {
+        AliError(Form("No spectra %s found in %s",whatever,path.Data()));
+        return 0x0;
+        }
+    
+    std::cout << "Number of J/Psi:" << std::endl;
+    TH1* hry = s->Plot("NofJPsi","PSIPSIPRIMECB2VWGINDEPTAILS",kFALSE); //Number of Jpsi
+    std::cout << "" << std::endl;
+    
+    std::cout << "Equivalent number of MB events:" << std::endl;
+    TH1* hN = ComputeEquNofMB();
+    std::cout << "" << std::endl;
+    
+    TH1* hy = static_cast<TH1*>(hry->Clone("CorrJPsiYields"));
+    Double_t bR = 0.0593; // BR(JPsi->mu+mu-)
+    Double_t bRerror = 0.0006 ;
+    
+    for (Int_t i = 1 ; i <= hy->GetNbinsX() ; i++)
+        {
+        Double_t yield = hry->GetBinContent(i)/(hN->GetBinContent(i)*bR);
+        Double_t yieldError = TMath::Sqrt(TMath::Power(hry->GetBinError(i)/(hN->GetBinContent(i)*bR),2.) +
+                                          TMath::Power(hN->GetBinError(i)*bR/TMath::Power(hN->GetBinContent(i)*bR,2.),2.) +
+                                          TMath::Power(hry->GetBinContent(i)*hN->GetBinContent(i)*bRerror/TMath::Power(hN->GetBinContent(i)*bR,2.),2.));
+        
+        std::cout << yield << " +- " << yieldError << std::endl;
+        
+        hy->SetBinContent(i,yield);
+        hy->SetBinError(i,yieldError);
+        }
+    
+    delete hry;
+    delete hN;
+    
+    return hy;
 }
 
-//_____________________________________________________________________________
-AliAnalysisMuMuSpectra* AliAnalysisMuMu::SPECTRA(const char* fullpath) const
-{
-  /// Shortcut method to get to a spectra
-  if (!OC()) return 0x0;
-  
-  return static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(fullpath));
-}
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::SelectRunByTrigger(const char* triggerList)
+UInt_t AliAnalysisMuMu::GetSum(AliCounterCollection& cc, const char* triggerList,
+                               const char* eventSelection, Int_t runNumber)
 {
-  if (!fMergeableCollection || !fCounterCollection) return;
-  
-  TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
-  TIter nextRun(runs);
-  
-  TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
-  TIter nextTrigger(triggers);
-  
-  TObjString* srun;
-  TObjString* strigger;
-  
-  TString striggerList(triggerList);
-  
-  TList* runList = new TList();
-  
-  while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
-  {
+    TObjArray* ktrigger = cc.GetKeyWords("trigger").Tokenize(",");
+    TObjArray* kevent = cc.GetKeyWords("event").Tokenize(",");
+    TObjArray* a = TString(triggerList).Tokenize(" ");
+    TIter next(a);
+    TObjString* str;
     
-    nextTrigger.Reset();
+    UInt_t n(0);
     
-    while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
-    {
-      if ( !striggerList.Contains(strigger->String().Data()) )
-      {
-        continue;
-      }
-      
-      ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d",
-                                                                strigger->String().Data(),"PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",srun->String().Atoi())));
-      if ( n > 0 ) runList->Add(srun);
-  
-    }
-  }
-    runList->Sort();
-    TIter nextRunOK(runList);
-    while ( ( srun = static_cast<TObjString*>(nextRunOK()) ) )
-    {
-      std::cout << srun->String().Atoi() << std::endl;
-    }
-    delete runList;
-
-    delete triggers;
-    delete runs;
-}
-//_____________________________________________________________________________
-void AliAnalysisMuMu::TriggerCountCoverage(const char* triggerList,
-                                           Bool_t compact,
-                                           Bool_t orderByTriggerCount)
-{
-  // Give the fraction of triggers (in triggerList) relative 
-  // to what is expected in the scalers
-  
-  TGrid::Connect("alien://"); // to insure the "Trying to connect to server... message does not pollute our output later on...
-  
-  AliLog::EType_t oldLevel = static_cast<AliLog::EType_t>(AliLog::GetGlobalLogLevel());
-  
-  AliLog::SetGlobalLogLevel(AliLog::kFatal);
-  
-  if (!fMergeableCollection || !fCounterCollection) return;
-  
-  TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
-  TIter nextRun(runs);
-  
-  TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
-  TIter nextTrigger(triggers);
-  
-  TObjString* srun;
-  TObjString* strigger;
-  
-  TString striggerList(triggerList);
-  
-  ULong64_t total(0);
-  ULong64_t totalExpected(0);
-  TString msg;
-  std::multimap<ULong64_t,std::string> messages;
-  
-  while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
-  {
-    msg.Form("RUN %09d ",srun->String().Atoi());
+    TString sEventSelection(eventSelection);
+    sEventSelection.ToUpper();
     
-    if (!compact)
-    {
-        msg += "\n";
-    }
-
-    ULong64_t nmax(0);
-
-    nextTrigger.Reset();
+    if ( kevent->FindObject(sEventSelection.Data()) )
+        {
+        while ( ( str = static_cast<TObjString*>(next()) ) )
+            {
+            if ( ktrigger->FindObject(str->String().Data()) )
+                {
+                if ( runNumber < 0 )
+                    {
+                    n +=  static_cast<UInt_t>(cc.GetSum(Form("trigger:%s/event:%s",str->String().Data(),eventSelection)));
+                    }
+                else
+                    {
+                    n +=  static_cast<UInt_t>(cc.GetSum(Form("trigger:%s/event:%s/run:%d",str->String().Data(),eventSelection,runNumber)));
+                    }
+                }
+            }
+        }
     
-    while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
-    {
-      if ( !striggerList.Contains(strigger->String().Data()) ) 
-      {
-        continue;
-      }
-  
-      ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d",
-                                                            strigger->String().Data(),"ALL",srun->String().Atoi())));
-    
-      ULong64_t expected = GetTriggerScalerCount(strigger->String().Data(),srun->String().Atoi());
-    
-      
-      nmax = TMath::Max(n,nmax);
-      
-      total += n;
-      totalExpected += expected;
-      
-      msg += TString::Format("%30s %9lld expected %9lld [%s] ",strigger->String().Data(),n,expected,
-                             (n>expected ? "!" : " "));
-      
-      if ( expected > 0 ) {
-        msg += TString::Format("fraction %5.1f %%",n*100.0/expected);
-      }
-
-      if (!compact)
-      {
-        msg += "\n";
-      }
-    }
-    if (nmax>0)
-    {
-      if (!orderByTriggerCount)
-      {
-        std::cout << msg.Data() << std::endl;
-      }
-      else
-      {
-        messages.insert(std::make_pair(nmax,static_cast<std::string>(msg.Data())));
-      }
-    }
-  }
-  
-  std::multimap<ULong64_t,std::string>::const_reverse_iterator it;
-  
-  ULong64_t current(0);
-  Int_t n(0);
-  
-  for ( it = messages.rbegin(); it != messages.rend(); ++it )
-  {
-    ++n;
-    current += it->first;
-    Double_t percent = ( total > 0.0 ? current*100.0/total : 0.0);
-    std::cout << Form("%10lld",it->first) << " " << it->second << " percentage of total = " << Form("%7.2f %% %3d",percent,n ) << std::endl;
-  }
-
-  std::cout << Form("--- TOTAL %lld expected %lld fraction %5.1f %%",
-                    total,totalExpected,totalExpected ? total*100.0/totalExpected : 0.0) << std::endl;
-  
-
-   
-  AliLog::SetGlobalLogLevel(oldLevel);
-  delete triggers;
-  delete runs;
+    delete a;
+    delete ktrigger;
+    delete kevent;
+    return n;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::UnsetCorrectionPerRun()
-{
-    // drop the correction factors
-  delete fCorrectionPerRun;
-  fCorrectionPerRun=0x0;
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::Update()
+Bool_t
+AliAnalysisMuMu::GetCollections(const char* rootfile,
+                                AliMergeableCollection*& oc,
+                                AliCounterCollection*& cc,
+                                AliAnalysisMuMuBinning*& bin,
+                                std::set<int>& runnumbers)
 {
-  /// update the current file with memory
- 
-  if (!CC() || !OC()) return;
-  
-  std::cout << "fDirectory=" << fDirectory.Data() << std::endl;
-  
-  ReOpen(fFilename,"UPDATE");
-
-  if (OC())
-  {
-    if (fDirectory.Length())
-    {
-      gDirectory->cd(fDirectory.Data());
-    }
-    OC()->Write("OC",TObject::kSingleKey|TObject::kOverwrite);
-  }
-
-  ReOpen(fFilename,"READ");
-  
-  GetCollections(fFilename,fDirectory,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
+    oc = 0x0;
+    cc = 0x0;
+    bin = 0x0;
+    //Get the rootfile
+    TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(rootfile));
+    if (!f)
+        {
+        f = TFile::Open(rootfile);
+        }
+    
+    if ( !f || f->IsZombie() )
+        {
+        return kFALSE;
+        }
+    // oc points on the histogramme collection
+    f->GetObject("OC",oc);
+    if (!oc)
+        {
+        f->GetObject("MC",oc);
+        }
+    // cc point on mergeable collection
+    f->GetObject("CC",cc);
+    // Iterator on bin type
+    TIter next(f->GetListOfKeys());
+    TKey* key;
+    // bin points on each bin type
+    while ( ( key = static_cast<TKey*>(next())) && !bin )
+        {
+        if ( strcmp(key->GetClassName(),"AliAnalysisMuMuBinning")==0 )
+            {
+            bin = dynamic_cast<AliAnalysisMuMuBinning*>(key->ReadObj());
+            }
+        }
+    
+    if (!oc || !cc)
+        {
+        AliErrorClass("Old file. Please upgrade it!");
+        
+        return kFALSE;
+        }
+    
+    // get run list
+    TObjArray* runs = cc->GetKeyWords("run").Tokenize(",");
+    runs->Sort();
+    TIter nextRun(runs);
+    TObjString* srun;
+    
+    runnumbers.clear();
+    
+    while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
+        {
+        runnumbers.insert(srun->String().Atoi());
+        }
+    
+    delete runs;
+    
+    return kTRUE;
 }
 
 //_____________________________________________________________________________
-Bool_t AliAnalysisMuMu::Upgrade(const char* filename)
+Bool_t AliAnalysisMuMu::IsSimulation() const
 {
-  /// Upgrade a file
-  AliAnalysisMuMu m(filename);
-  
-  return m.Upgrade();
+    // whether or not we have MC information
+    
+    //  return kFALSE;
+    
+    if (!fMergeableCollection) return kFALSE;
+    
+    TList* list = fMergeableCollection->CreateListOfKeys(0);
+    TIter next(list);
+    TObjString* str;
+    Bool_t ok(kFALSE);
+    
+    while ( ( str = static_cast<TObjString*>(next()) ) )
+        {
+        if ( str->String().Contains(AliAnalysisMuMuBase::MCInputPrefix()) ) ok = kTRUE;
+        }
+    delete list;
+    
+    return ok;
 }
 
 //_____________________________________________________________________________
-Bool_t AliAnalysisMuMu::Upgrade()
+Int_t
+AliAnalysisMuMu::Jpsi(const char* what, const char* binningFlavour, Bool_t fitmPt, Bool_t onlyCorrected)
 {
-  /// Upgrade the current file
-  /// - from single list to one key per object, if needed
-  /// - from histogramCollection to mergeableCollection, if needed
-
-  
-  AliWarning("Out of date method");
-  
-  TFile* f = ReOpen(fFilename,"UPDATE");
-  
-  TList* list = static_cast<TList*>(f->Get("chist"));
-  
-  if (list)
-  {
-    // really old file where everything was in a single list
-  
-    AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(list->At(0));
-    AliCounterCollection* cc = static_cast<AliCounterCollection*>(list->At(1));
+    /// Fit the J/psi (and psiprime) peaks for the triggers in fDimuonTriggers list
+    /// what="integrated" => fit only fully integrated MinvUS
+    /// what="pt" => fit MinvUS in pt bins
+    /// what="y" => fit MinvUS in y bins
+    /// what="pt,y" => fit MinvUS in (pt,y) bins
+    
+    TStopwatch timer;
+    
+    if (!fMergeableCollection)
+        {
+        AliError("No mergeable collection. Consider Upgrade()");
+        return 0;
+        }
+    
+    Int_t nfits(0);
+    
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray          = TString(what).Tokenize(",");
+    
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextCentrality(centralityArray);
     
-    AliMergeableCollection* mc = hc->Convert();
+    TObjString* trigger;
+    TObjString* eventType;
+    TObjString* pairCut;
+    TObjString* swhat;
+    TObjString* centrality;
     
-    f->cd();
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
+        {
+        AliAnalysisMuMuBinning* binning(0x0);
+        
+        if ( fBinning && swhat->String().Length() > 0 )
+            {
+            binning = fBinning->Project("psi",swhat->String().Data(),binningFlavour);
+            }
+        else
+            {
+            binning = new AliAnalysisMuMuBinning;
+            binning->AddBin("psi",swhat->String().Data());
+            }
+        
+        StdoutToAliDebug(1,std::cout << "++++++++++++ swhat=" << swhat->String().Data() << std::endl;);
+        
+        std::cout << "" << std::endl;
+        std::cout << "++++++++++++++++++" << "NEW BIN TYPE" << "+++++++++++++++++++" << std::endl;
+        std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
+        std::cout << "++++++++++++ swhat=" << swhat->String().Data() << "++++++++++++++++++++" << std::endl;
+        std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
+        std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
+        std::cout << "" << std::endl;
+        std::cout << "" << std::endl;
+        
+        if (!binning)
+            {
+            AliError("oups. binning is NULL");
+            continue;
+            }
+        
+        StdoutToAliDebug(1,binning->Print(););
+        
+        nextTrigger.Reset();
+        
+        while ( ( trigger = static_cast<TObjString*>(nextTrigger())) )
+            {
+            AliDebug(1,Form("TRIGGER %s",trigger->String().Data()));
+            
+            nextEventType.Reset();
+            
+            while ( ( eventType = static_cast<TObjString*>(nextEventType())) )
+                {
+                AliDebug(1,Form("--EVENTTYPE %s",eventType->String().Data()));
+                
+                nextPairCut.Reset();
+                
+                while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("----PAIRCUT %s",pairCut->String().Data()));
+                    
+                    nextCentrality.Reset();
+                    
+                    while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) )
+                        {
+                        AliDebug(1,"----Fitting...");
+                        
+                        TObject* o;
+                        
+                        TString id(Form("/%s/%s/%s/%s",eventType->String().Data(),
+                                        trigger->String().Data(),
+                                        centrality->String().Data(),
+                                        pairCut->String().Data()));
+                        
+                        AliAnalysisMuMuSpectra* spectra(0x0);
+                        if ( !onlyCorrected )
+                            {
+                            
+                            spectra = FitParticle("psi",
+                                                  trigger->String().Data(),
+                                                  eventType->String().Data(),
+                                                  pairCut->String().Data(),
+                                                  centrality->String().Data(),
+                                                  *binning);
+                            
+                            AliDebug(1,Form("----fitting done spectra = %p",spectra));
+                            
+                            if ( spectra )
+                                {
+                                ++nfits;
+                                
+                                o = fMergeableCollection->GetObject(id.Data(),spectra->GetName());
+                                
+                                AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
+                                
+                                if (o)
+                                    {
+                                    AliWarning(Form("Replacing %s/%s",id.Data(),spectra->GetName()));
+                                    fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectra->GetName()));
+                                    }
+                                
+                                Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectra);
+                                
+                                if ( adoptOK ) std::cout << "+++Spectra " << spectra->GetName() << " adopted" << std::endl;
+                                else AliError(Form("Could not adopt spectra %s",spectra->GetName()));
+                                
+                                StdoutToAliDebug(1,spectra->Print(););
+                                }
+                            else AliError("Error creating spectra");
+                            }
+                        
+                        AliDebug(1,"----Fitting corrected spectra...");
+                        
+                        AliAnalysisMuMuSpectra* spectraCorr = FitParticle("psi",
+                                                                          trigger->String().Data(),
+                                                                          eventType->String().Data(),
+                                                                          pairCut->String().Data(),
+                                                                          centrality->String().Data(),
+                                                                          *binning,"minv",kTRUE);
+                        
+                        AliDebug(1,Form("----fitting done corrected spectra = %p",spectraCorr));
+                        
+                        o = 0x0;
+                        if ( spectraCorr )
+                            {
+                            ++nfits;
+                            
+                            o = fMergeableCollection->GetObject(id.Data(),spectraCorr->GetName());
+                            
+                            AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
+                            
+                            if (o)
+                                {
+                                AliWarning(Form("Replacing %s/%s",id.Data(),spectraCorr->GetName()));
+                                fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraCorr->GetName()));
+                                }
+                            
+                            Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraCorr);
+                            
+                            if ( adoptOK ) std::cout << "+++Spectra " << spectraCorr->GetName() << " adopted" << std::endl;
+                            else AliError(Form("Could not adopt spectra %s",spectraCorr->GetName()));
+                            
+                            StdoutToAliDebug(1,spectraCorr->Print(););
+                            }
+                        else AliError("Error creating spectra");
+                        
+                        
+                        if (fitmPt)
+                            {
+                            AliDebug(1,"----Fitting mean pt...");
+                            
+                            std::cout << "" << std::endl;
+                            std::cout << "" << std::endl;
+                            
+                            if ( !onlyCorrected )
+                                {
+                                std::cout << "++++++++++++ Fitting mean Pt for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
+                                if ( spectra )
+                                    {
+                                    AliAnalysisMuMuSpectra* spectraMeanPt = FitParticle("psi",
+                                                                                        trigger->String().Data(),
+                                                                                        eventType->String().Data(),
+                                                                                        pairCut->String().Data(),
+                                                                                        centrality->String().Data(),
+                                                                                        *binning,"mpt"/*,*spectra*/);
+                                    
+                                    
+                                    
+                                    AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPt));
+                                    o = 0x0;
+                                    
+                                    if ( spectraMeanPt )
+                                        {
+                                        ++nfits; //Review this
+                                        
+                                        o = fMergeableCollection->GetObject(id.Data(),spectraMeanPt->GetName());
+                                        
+                                        AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
+                                        
+                                        if (o)
+                                            {
+                                            AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPt->GetName()));
+                                            fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPt->GetName()));
+                                            }
+                                        
+                                        Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPt);
+                                        
+                                        if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPt->GetName() << " adopted" << std::endl;
+                                        else AliError(Form("Could not adopt spectra %s",spectraMeanPt->GetName()));
+                                        }
+                                    else AliError("Error creating spectra");
+                                    
+                                    }
+                                else std::cout << "Mean pt fit failed: No inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
+                                }
+                            
+                            std::cout << "++++++++++++ Fitting corrected mean Pt for" << " " << swhat->String().Data() << " " << "slices" << std::endl;
+                            
+                            if ( spectraCorr )
+                                {
+                                AliAnalysisMuMuSpectra* spectraMeanPtCorr  = FitParticle("psi",
+                                                                                         trigger->String().Data(),
+                                                                                         eventType->String().Data(),
+                                                                                         pairCut->String().Data(),
+                                                                                         centrality->String().Data(),
+                                                                                         *binning,"mpt"/*,*spectraCorr*/,kTRUE);
+                                
+                                
+                                
+                                AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPtCorr));
+                                
+                                o = 0x0;
+                                
+                                if ( spectraMeanPtCorr )
+                                    {
+                                    ++nfits; //Review this
+                                    
+                                    o = fMergeableCollection->GetObject(id.Data(),spectraMeanPtCorr->GetName());
+                                    
+                                    AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
+                                    
+                                    if (o)
+                                        {
+                                        AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPtCorr->GetName()));
+                                        fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPtCorr->GetName()));
+                                        }
+                                    
+                                    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPtCorr);
+                                    
+                                    if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPtCorr->GetName() << " adopted" << std::endl;
+                                    else AliError(Form("Could not adopt spectra %s",spectraMeanPtCorr->GetName()));
+                                    
+                                    }
+                                else AliError("Error creating spectra");
+                                
+                                }
+                            
+                            else std::cout << "Corrected mean pt fit failed: No corrected inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl;
+                            
+                            }
+                        }
+                    }
+                }
+            }
+        }
     
-    mc->Write("MC",TObject::kSingleKey);
-    cc->Write("CC",TObject::kSingleKey);
+    delete whatArray;
+    delete triggerArray;
+    delete eventTypeArray;
+    delete pairCutArray;
+    delete centralityArray;
     
-    f->Delete("chist;*");
+    StdoutToAliDebug(1,timer.Print(););
     
-    f->Write();
+    if (nfits)
+        {
+        Update();
+        //    ReOpen(fFilename,"UPDATE");
+        //    fMergeableCollection->Write("MC",TObjArray::kOverwrite);// | TObjArray::kSingleKey);
+        //    ReOpen(fFilename,"READ");
+        }
+    
+    
+    return nfits;
     
-  }
-  else
-  {
-    AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(f->Get("HC"));
-
-    if ( hc )
-    {
-      // old file with histogram collection instead of mergeable collection
-      
-      AliMergeableCollection* mc = hc->Convert();
-
-      f->cd();
-
-      mc->Write("MC",TObject::kSingleKey);
-
-      f->Delete("HC;*");
-      
-      f->Write();
-    }
-  }
-
-  delete f;
-  
-  return kTRUE;
 }
 
 //_____________________________________________________________________________
-TH2* AliAnalysisMuMu::ComputeSPDCorrection(const char* type, const char* eventSel, const char* triggerSel, Bool_t bkgReject)
+TGraph* AliAnalysisMuMu::PlotEventSelectionEvolution(const char* trigger1, const char* event1,
+                                                     const char* trigger2, const char* event2,
+                                                     Bool_t drawFills,
+                                                     Bool_t asRejection) const
 {
-  TString stype(type);
-  TString evtype(eventSel);
-  TString trigtype(triggerSel);
-  
-  TH2* hNch = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NchVsZVertexVsEta",evtype.Data(),
-                                                 trigtype.Data()))); // Input Nch // //"/INPUT/QASPDZPSALL/NchVSEtaVSZVertMC"
-  if ( !hNch )
-  {
-    AliError("No Nch histo found");
-    return 0x0;
-  }
-  TH2* hNtr = static_cast<TH2*>(OC()->Histo(Form("/%s/%s/V0A/TrackletsVsZVertexVsEta",evtype.Data(),
-                                                trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
-  if ( !hNtr )
-  {
-    AliError("No tracklets histo found");
-    return 0x0;
-  }
-  
-  TH2* hNtrBkg = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NBkgTrackletsVsZVertexVsEta",evtype.Data(),
-                                                 trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
-  if ( !hNtrBkg )
-  {
-    AliError("No background tracklets histo found");
-    return 0x0;
-  }
-
-  
-  TH2D* hSPDCorr = static_cast<TH2D*>(hNtr->Clone("SPDCorr"));
-  TString title("");\
-  if ( stype.Contains("oneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction");
-  else if ( stype.Contains("AccEffOnly")) hSPDCorr->SetTitle("SPD AccxEff correction");
-  else if ( stype.Contains("statOneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction stat. unc.");
-  
-  for (Int_t i = 1 ; i < hNch->GetNbinsX() ; i++)
-  {
-    for (Int_t j = 1 ; j < hNch->GetNbinsY() ; j++)
-    {
-      Int_t n = hNch->GetBin(i,j);
-      Double_t nch = hNch->GetBinContent(n);
-      Double_t ntr = hNtr->GetBinContent(n);
-      Double_t nBkgtr(0.);
-      if ( bkgReject ) nBkgtr = hNtrBkg->GetBinContent(n);
-      
-      Double_t corr(0.),corrErr(0.);
-      if ( nch != 0. )
-      {
-        corr = (ntr - nBkgtr)/nch;
-        corrErr = TMath::Max( 1./nch,TMath::Sqrt( corr*(1.-corr)/nch ) );
-      }
-      
-      if ( stype.Contains("oneOverAccEff"))
-      {
-        if ( corr > 0. )
-        {
-          hSPDCorr->SetBinContent(n,1./corr);
-          hSPDCorr->SetBinError(n,corrErr/TMath::Power(corr,2.));
-        }
-        else
+    if (!CC()) return 0x0;
+    
+    const std::set<int>& runnumbers = RunNumbers();
+    
+    TGraphErrors* g = new TGraphErrors(runnumbers.size());
+    
+    std::set<int>::const_iterator it;
+    Int_t i(0);
+    
+    Double_t ymin(TMath::Limits<double>::Max());
+    Double_t ymax(TMath::Limits<double>::Min());
+    
+    for ( it = runnumbers.begin(); it != runnumbers.end(); ++it )
         {
-          hSPDCorr->SetBinContent(n,0.);
-          hSPDCorr->SetBinError(n,1.);
-        }
+        Int_t runNumber = *it;
+        Double_t n = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger1,event1,runNumber));
+        Double_t d = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger2,event2,runNumber));
+        if (n>0 && d>0)
+            {
+            Double_t y = n/d;
+            
+            if ( fCorrectionPerRun )
+                {
+                Double_t xcorr,ycorr;
+                fCorrectionPerRun->GetPoint(i,xcorr,ycorr); // note that the fact that xcorr==runNumber has been checked by the SetCorrectionPerRun method
+                y *= ycorr;
+                // FIXME: should get the correction error here
+                }
+            
+            if ( asRejection ) y = 100*(1.0 - y);
+            ymin = TMath::Min(ymin,y);
+            ymax = TMath::Max(ymax,y);
+            Double_t yerr = y*AliAnalysisMuMuResult::ErrorAB(n,TMath::Sqrt(n),d,TMath::Sqrt(d));
+            g->SetPoint(i,runNumber,y);
+            g->SetPointError(i,0.5,yerr);
+            
+            ++i;
+            }
         
-      }
-      else if ( stype.Contains("AccEffOnly"))
-      {
-        hSPDCorr->SetBinContent(n,corr);
-        hSPDCorr->SetBinError(n,corrErr);
-      }
-      else if ( stype.Contains("statOneOverAccEff"))
-      {
-        if ( corr != 0. )
+        }
+    
+    TH2* hframe = new TH2F(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
+                           Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
+                           runnumbers.size()+50,
+                           *(runnumbers.begin())-25,
+                           *(runnumbers.rbegin())+25,100,0,ymax*1.3);
+    
+    gStyle->SetOptStat(0);
+    
+    hframe->Draw();
+    
+    hframe->GetXaxis()->SetNoExponent();
+    
+    hframe->GetYaxis()->SetTitle(asRejection ? "Rejection (%)" : "Ratio");
+    
+    g->Set(i);
+    g->SetTitle(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2));
+    g->GetXaxis()->SetNoExponent();
+    g->Draw("lp");
+    
+    AliAnalysisTriggerScalers ts(RunNumbers(),Config()->OCDBPath());
+    
+    if ( drawFills )
         {
-          hSPDCorr->SetBinContent(n,(corrErr/TMath::Power(corr,2.)*100)/(1./corr));
+        ts.DrawFills(ymin,ymax);
+        g->Draw("lp");
         }
-        else
+    
+    
+    std::map<std::string, std::pair<int,int> > periods;
+    
+    ts.GetLHCPeriodBoundaries(periods);
+    
+    TLegend* legend = new TLegend(0.15,0.82,0.90,0.92);
+    legend->SetFillColor(0);
+    Int_t n(0);
+    
+    
+    for ( std::map<std::string, std::pair<int,int> >::const_iterator pit = periods.begin(); pit != periods.end(); ++pit )
         {
-          hSPDCorr->SetBinContent(n,-1);
+        std::string period = pit->first;
+        int run1 = (pit->second).first;
+        int run2 = (pit->second).second;
+        int nruns(0);
+        for ( std::set<int>::const_iterator rit = RunNumbers().begin(); rit != RunNumbers().end(); ++ rit )
+            {
+            if ( (*rit) >= run1 && (*rit) <= run2 )
+                {
+                ++nruns;
+                }
+            }
+        AliInfo(Form("Period %s runs %6d-%6d ; %d actual runs",period.c_str(),run1,run2,nruns));
+        
+        g->Fit("pol0","+Q","",run1,run2);
+        TF1* func = static_cast<TF1*>(g->GetListOfFunctions()->Last());
+        if (func)
+            {
+            func->SetLineColor(2+n);
+            legend->AddEntry(func,Form("%s %5.2f #pm %5.2f %s (rel. error %5.2f %%)",period.c_str(),func->GetParameter(0),func->GetParError(0),
+                                       (asRejection ? "%":""),100*func->GetParError(0)/func->GetParameter(0)));
+            ++n;
+            }
         }
-
-      }
-    }
-  }
-  
-  return hSPDCorr;
+    
+    legend->SetNColumns(3);
+    
+    Double_t mean = TMath::Mean(g->GetN(),g->GetY());
+    Double_t rms = TMath::RMS(g->GetN(),g->GetY());
+    
+    legend->AddEntry("",Form("Mean %5.2f RMS %5.2f (%5.2f %%)",mean,rms,(mean) ? 100.0*rms/mean : 0.0),"");
+    
+    legend->Draw();
+    
+    return g;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeFnorm()
+void AliAnalysisMuMu::ShowList(const char* title, const TString& list, const char separator) const
 {
-  /// Compute the CMUL to CINT ratio(s)
-  
-  if (!CC()) return;
-  
-  OC()->Prune("/FNORM");
-  
-  AliAnalysisMuMuFnorm computer(*(CC()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());
-  
-  computer.ComputeFnorm();
-
-  AliMergeableCollection* fnorm = computer.DetachMC();
-  
-  OC()->Attach(fnorm,"/FNORM/");
-  
-  Update();
+    /// Show a list of strings
+    TObjArray* parts = list.Tokenize(separator);
+    
+    std::cout << title << " (" << parts->GetEntries() << ") : " << std::endl;
+    
+    TIter next(parts);
+    TObjString* str;
+    
+    while ( ( str = static_cast<TObjString*>(next()) ) )
+        {
+        std::cout << "    " << str->String().Data() << std::endl;
+        }
+    
+    if ( parts->GetEntries()==0) std::cout << endl;
+    
+    delete parts;
 }
 
 //_____________________________________________________________________________
-TH1* AliAnalysisMuMu::ComputeDiffFnormFromHistos(const char* what,const char* quantity,const char* flavour,Bool_t printout)
+void AliAnalysisMuMu::Print(Option_t* opt) const
 {
-  /// OUTDATED METHOD: Compute the CMUL to CINT ratio(s) from the histos stored in the OC(). Now the Counter Collection is used for this (AliAnalysisMuMu::ComputeDiffFnormFromCounters)
-    
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,quantity,flavour));
-    return 0x0;
-  }
-  TObjArray* dNchdEtas = binning->CreateBinObjArray();
-  
-  Double_t* binArray = binning->CreateBinArray();
-  
-  TIter next(dNchdEtas);
-  AliAnalysisMuMuBinning::Range* r;
-  
-  Double_t FNorm(0.);
-  Double_t FNormError(0.);
-  
-  TH1* hFNorm = new TH1F("hFNorm","'Global' normalization factor vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
-  
-  Int_t bin(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
+    /// printout
+    std::cout << "Reading from file : " << fFilename.Data() << std::endl;
     
-    TH1* hCMSL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMSL7-B-NOPF-MUON/V0A/%s",
-                             Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMSL )
-    {
-      AliError(Form("No event histo in bin %s found for CMSL7-B-NOPF-MUON",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
-    }
+    TString copt(opt);
     
-    TH1* hCMSLandOMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMSL7-B-NOPF-MUON&0MUL/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMSLandOMUL )
-    {
-      AliError(Form("No event histo in bin %s found for CMSL7-B-NOPF-MUON & 0MUL",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
-    }
+    if (IsSimulation() || SIM() )
+        {
+        copt += "SIM";
+        }
     
-    TH1* hCINT = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CINT7-B-NOPF-ALLNOTRD/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCINT )
-    {
-      AliError(Form("No event histo in bin %s found for CINT7-B-NOPF-ALLNOTRD",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
-    }
+    if ( !IsSimulation() )
+        {
+        copt += "REAL";
+        }
     
-    TH1* hCINTandOMSL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CINT7-B-NOPF-ALLNOTRD&0MSL/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCINTandOMSL )
-    {
-      AliError(Form("No event histo in bin %s found for CINT7-B-NOPF-ALLNOTRD & 0MSL",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
-    }
-  
-    FNorm = (hCMSL->GetBinContent(1)/hCMSLandOMUL->GetBinContent(1))*(hCINT->GetBinContent(1)/hCINTandOMSL->GetBinContent(1));
-    FNormError = ErrorPropagationAxBoverCxD(hCMSL->GetBinContent(1),hCINT->GetBinContent(1),hCMSLandOMUL->GetBinContent(1),hCINTandOMSL->GetBinContent(1));
+    Config()->Print(copt.Data());
     
-    if ( printout ) std::cout << r->AsString().Data() << " : " << FNorm << " +- " << FNormError << std::endl;
+    if ( RunNumbers().size() > 1 )
+        {
+        std::cout << RunNumbers().size() << " runs";
+        }
+    else
+        {
+        std::cout << RunNumbers().size() << " run";
+        }
     
-    hFNorm->SetBinContent(++bin,FNorm);
-    hFNorm->SetBinError(bin,FNormError);
-  }
-  
-  delete binning;
-  delete dNchdEtas;
-  delete[] binArray;
-  
-  return hFNorm;
+    if ( fCorrectionPerRun )
+        {
+        std::cout << " with correction factors";
+        }
+    std::cout << std::endl;
+    Int_t i(0);
+    for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
+        {
+        std::cout << (*it);
+        if ( fCorrectionPerRun )
+            {
+            std::cout << Form("(%e)",fCorrectionPerRun->GetY()[i]);
+            }
+        std::cout << ",";
+        ++i;
+        }
+    std::cout << std::endl;
+    
+    TString sopt(opt);
+    sopt.ToUpper();
+    
+    if ( sopt.Contains("BIN") && BIN() )
+        {
+        std::cout << "Binning : " << std::endl;
+        TString topt(sopt);
+        topt.ReplaceAll("BIN","");
+        BIN()->Print(topt.Data());
+        }
+    if ( sopt.Contains("MC") && OC() )
+        {
+        TString topt(sopt);
+        topt.ReplaceAll("MC","");
+        OC()->Print(topt.Data());
+        }
+    if ( sopt.Contains("CC") && CC() )
+        {
+        CC()->Print("trigger/event");
+        }
+    
+    if ( sopt.Contains("SIZE") )
+        {
+        TFile* f = ReOpen(fFilename,"READ");
+        TIter next(f->GetListOfKeys());
+        TKey* key;
+        
+        while ( ( key = static_cast<TKey*>(next()) ) )
+            {
+            std::cout << key->GetName() << " " << key->GetNbytes() << " " << key->GetObjlen() << std::endl;
+            }
+        }
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromInt(const char* triggerCluster, const char* eventSelection, AliMergeableCollection* mc, const char* what,const char* quantity,const char* flavour,Bool_t printout)
+void AliAnalysisMuMu::PrintNofParticle(const char* particle, const char* what, const char* binType, Bool_t AccEffCorr) const
 {
-  /// OUTDATED METHOD:Compute the CMUL to CINT ratio(s) form the ratio of "quantity" distributions, in bins. Now the Counter Collection is used for this (AliAnalysisMuMu::ComputeDiffFnormFromGlobal)
-
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-
-  TString seventSelection(eventSelection);
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelection.Data()));
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,quantity,flavour));
-    return;
-  }
-  
-  TString path(Form("%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data()));
-  if ( !mc )
-  {
-    AliError("Error: No mergeable collection to get Nch histo");
-    delete binning;
-    return;
-  }
-  TH1* hNtr = static_cast<TH1*>(mc->Histo(Form("/%s/Nch",path.Data())));
-  if ( !hNtr )
-  {
-    AliError(Form("Error: No /%s/Nch histo in mergeable collection",path.Data()));
-    delete binning;
-    return;
-  }
-  Int_t nTrackletsCorrTot = hNtr->Integral();
-  
-  TObjArray* bin = binning->CreateBinObjArray(what,quantity,flavour);
-  Int_t nEntries = bin->GetEntries();
-  Double_t* binArray = binning->CreateBinArray();
-  Double_t FNormTot(0.);
-  Double_t FNormTotError(0.);
-  
-  TH1* hNorm = OC()->Histo(Form("%s/hFNormInt",id.Data()));
-  
-  TH1* hFNormTot = new TH1F("hFNormVSdNchdEtaFromInt","Normalization factor vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",nEntries,binArray);
-  
-  Double_t FNormGlobal = hNorm->GetBinContent(1);
-  Double_t FNormGlobalError = hNorm->GetBinError(1);
-  
-  if ( printout ) std::cout << "Global FNorm = " << FNormGlobal << " + - " << FNormGlobalError << std::endl;
-  
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    Double_t nTrklsCorrBin = hNtr->Integral(r->Xmin(),r->Xmax());
-    Double_t nTrklsCorrBinFrac = nTrklsCorrBin / nTrackletsCorrTot;
-    Double_t nTrklsCorrBinFracError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nTrklsCorrBin) / nTrackletsCorrTot,2.) +
-                                                  TMath::Power(TMath::Sqrt(nTrackletsCorrTot)*nTrklsCorrBin / TMath::Power(nTrackletsCorrTot,2.) ,2.) );
-    
-    FNormTot = FNormGlobal*nTrklsCorrBinFrac;
-    FNormTotError = TMath::Sqrt( TMath::Power(FNormGlobalError*nTrklsCorrBinFrac,2.) + TMath::Power(FNormGlobal*nTrklsCorrBinFracError,2.) );
-
-    hFNormTot->SetBinContent(i,FNormTot);
-    hFNormTot->SetBinError(i,FNormTotError);
-    i++;
+    ///
+    /// Function to use after JPsi(). It loops over all combination of centrality/enventype/ trigger (etc.) and
+    /// print RAA on terminal accordingly. Fnorm / <T_AA> / other constants are written in AliAnalysisMuMuSpectraCapsulePbPb.
+    /// <binType> can be either "PT" or "Y" for the moment. This method reads sigma_pp value
+    /// from extern file who's line must be written as :
+    ///
+    /// intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff;
+    ///
+    /// WATCH OUT FOR UNITS !! Function is written for cross-section in microbarn in externFile
+    ///
+    /// note : For now, this method is set for a single centrality bin 0-90
+    /// TODO : Make it work with different centrality, i.e  need to read also an extra externfile with value who are function of centrality (<T_AA> for instance...)
+    ///
+    ///
+    
+    
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       Number of "<< particle << endl;
+        cout <<      " ================================================================ " << endl;
+        }
+    
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+    
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+    
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+    
+    //Loop on particle type
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextCentrality.Reset();
+                // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                    AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+                    nextPairCut.Reset();
+                    // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                        {
+                        AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+                        nextbinType.Reset();
+                        // Loop on each type (pt or y)
+                        //==============================================================================
+                        while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                            {
+                            AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
+                            
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                continue;
+                                }
+                            //________
+                            
+                            // Create pointer on fitted spectra
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,"","");
+                            if(!capsule)
+                                {
+                                AliError("Could not find spetra !");
+                                continue;
+                                }
+                            if(!capsule) continue;
+                            AliDebug(1,Form("Spectra = %p",capsule));
+                            // Print RAA on terminal
+                            capsule->PrintNofWhat(what);
+                            delete capsule;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+    
+    return ;
     
-    if ( printout ) std::cout << "Bin: " << r->AsString().Data() << " ; " << " FNorm = " << FNormTot << " +- " << FNormTotError << std::endl;
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  
-  delete binning;
-  delete bin;
-  delete[] binArray;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromCounters(const char* filePileUpCorr, const char* what,const char* quantity, const char* flavour, const char* triggerCluster, const char* eventSelectionFnorm, const char* eventSelectionYield,Bool_t printout)
+TFile* AliAnalysisMuMu::ReOpen(const char* filename, const char* mode) const
 {
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), in bins.
-  ///
-  /// Important considerations:
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection to compute Fnorm and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly (Usually the event selection should be the same for the Fnorm and the analysis but the option to use 2 different ev. sel. is included). (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
-  /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
-
-
-  //_______ Definitions for the triggers used to extract the counts from the counter collection:
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-  
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  //_______
-  
-
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
-    
-    while ( in.getline(line,1024,'\n'))
-    {
-      TString lrun(line);
-      TString lvalue(line);
-      
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
-      
-      lvalue.Remove(0,lvalue.First("=")+1);
-      
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
-      
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
-    }
-    corrPU = kTRUE;
-  }
-  //________
-
-
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sQuantity(quantity);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
-  Double_t NofRuns = runs->GetEntries();
-  
-  TIter nextRun(runs);
-  TObjString* s;
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-    return;
-  }
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Double_t* binArray = binning->CreateBinArray();
-  Int_t nEntries = bin->GetEntries();
-  
-  TH1* h;
-  TH1* hNofEqMB = new TH1F(Form("hNofEqMBVS%s",sQuantity.Data()),Form("Equivalent MB events per CMUL vs %s",sQuantity.Data()),
-                           nEntries,binArray);
-  TH1* hFNormTot = new TH1F(Form("hFNormVS%s",sQuantity.Data()),Form("Normalization factor vs %s;%s;FNorm",sQuantity.Data(),
-                                                                     sQuantity.Data()),nEntries,binArray);
-
-  Double_t* FNormTot = new Double_t[nEntries];
-  Double_t* FNormTotError = new Double_t[nEntries];
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data()));
-
-  TList* lRun2Reject = new TList();
-  lRun2Reject->SetOwner(kTRUE);
-  
-  Int_t i(0); // Bin number
-  TObjArray* aCluster = striggerCluster.Tokenize("-");
-  TIter nextCluster(aCluster);
-  TObjString* striggerClusterS;
-  
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    FNormTot[i] = 0;
-    FNormTotError[i] = 0;
-    if ( printout )
-    {
-      std::cout << "______________________________" << std::endl;
-      std::cout << "Bin: " << r->AsString().Data() << std::endl;
-    }
+    /// Tries to reopen the file with a new mode
     
-    hFNormTot->GetXaxis()->SetBinLabel(i+1,r->AsString().Data());
-    hNofEqMB->GetXaxis()->SetBinLabel(i+1,r->AsString().Data());
-
-    h = new TH1F(Form("hFNormVSrun_%s",r->AsString().Data()),Form("Normalization factor vs run for %s ;run;FNorm",r->AsString().Data()),NofRuns,1,NofRuns);
-    //Set the run labels
+    TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(filename));
+    
+    if (f)
+        {
+        delete f;
+        }
     
-    Double_t nCMULBin = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                          seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data())); //Nof CMUL7/8 events in Bin summed over runs
+    f = TFile::Open(filename,mode);
     
-    Int_t j(1); //Run label index
-    nextRun.Reset();
-    while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
-    {
-      Double_t nCMSL(0.),nCMSLandOMUL(0.);
-      nextCluster.Reset();
-      while ( (striggerClusterS = static_cast<TObjString*>(nextCluster())) && nCMSL == 0. )
-      {
-        nCMSL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s/centrality:V0A/run:%s/bin:%s",
-                                  seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),
-                                  s->GetName(),r->AsString().Data()));
-        
-        nCMSLandOMUL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s&0MUL/centrality:V0A/run:%s/bin:%s",
-                                         seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),
-                                         s->GetName(),r->AsString().Data()));
-      }
-      Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s/bin:%s",
-                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
-      
-      Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/run:%s/bin:%s",
-                                         seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
-      
-      Double_t nCINTandOMSL = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD&0MSL/centrality:V0A/run:%s/bin:%s",
-                                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
-      
-      Double_t FNorm(0.);
-      Double_t FNormError(0.);
-      Double_t FNormError2(0.);
-      Double_t pUfactor = 1.;
-      if ( nCMSLandOMUL != 0. && nCINTandOMSL !=0. && nCMSL != 0. && nCINT !=0. )
-      {
-        if (corrPU)
-        {
-          TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-          if ( p ) pUfactor = p->GetVal();
-          else
-          {
-            AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
-          }
+    if ( !f || !f->IsOpen() )
+        {
+        AliError(Form("Cannot open file %s in mode %s",filename,mode));
+        return 0x0;
         }
-        
-        FNorm = (nCMSL*nCINT)*pUfactor/(nCMSLandOMUL*nCINTandOMSL);
-        FNormError = ErrorPropagationAxBoverCxD(nCMSL,nCINT,nCMSLandOMUL,nCINTandOMSL)*pUfactor;
-        FNormError2 = AliAnalysisMuMuResult::ErrorABCD(nCMSL, TMath::Sqrt(nCMSL), nCINT, TMath::Sqrt(nCINT), nCMSLandOMUL,
-                                                       TMath::Sqrt(nCMSLandOMUL), nCINTandOMSL, TMath::Sqrt(nCINTandOMSL));
-      }
-      else
-      {
-        if ( nCINT == 0 ) std::cout << " Warning: Run " << s->GetName() << " has no MB trigger in this bin" << std::endl;
-        
-        lRun2Reject->Add(new TObjString(s->GetName()));
-        if ( printout ) std::cout << "Run " << s->GetName() << " not used for FNorm cause lack of stats" << std::endl;
-        continue;
-      }
-      FNormTot[i] += FNorm*nCMUL; // This is the sum of equivalent Nof MB per CMUL run by run. NOTE: This sum is NOT always the total equivalent Nof MB per CMUL because in pp 2012 if just one cluster is used at a time this sum is not the sum for all runs
-      FNormTotError[i] += TMath::Power(nCMUL*FNormError,2.) + TMath::Power(FNorm*TMath::Sqrt(nCMUL),2.);
-      
-      if ( printout ) std::cout << "Run " << s->GetName() << " FNorm = " << FNorm << " +- " << FNormError << " (" << FNormError2 << ")" << " ; PUFactor =" << pUfactor << " ; " << "Nof CMUL = " << nCMUL << std::endl;
-      
-      h->GetXaxis()->SetBinLabel(j,s->GetName());
-      h->SetBinContent(j,FNorm);
-      h->SetBinError(j++,FNormError);
+    
+    return f;
+}
+
+////_____________________________________________________________________________
+//void AliAnalysisMuMu::SetCentralitySelectionList(const char* centralitySelectionList)
+//{
+//  /// Set centralities to be used during fitting
+//  /// centralitySelectionList is a regular expression.
+//
+//  TObjArray* centralities = BIN()->CreateBinObjArray("centrality");
+//  TIter next(centralities);
+//  AliAnalysisMuMuBinning::Range* r;
+//
+//  TString csl;
+//
+//  TPRegexp re(centralitySelectionList);
+//
+//  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+//  {
+//    AliDebug(1,Form("r=%s",r->AsString().Data()));
+//    if ( re.MatchB(r->AsString()) )
+//    {
+//      csl += r->AsString();
+//      csl += ",";
+//    }
+//  }
+//
+//  Config()->SetList(AliAnalysisMuMuConfig::kCentralitySelectionList,IsSimulation(),csl);
+//
+//  delete centralities;
+//}
 
-    }
-    
-    TIter nextRejectRun(lRun2Reject);
-    TObjString* run2Rej;
-    Double_t nCMULBinRej(0.);
-    while ( (run2Rej = static_cast<TObjString*>(nextRejectRun())) )
-    {
-      nCMULBinRej += CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data(),
-                                       run2Rej->GetName())); //Sum of CMUL7 events from rejected runs
-    }
-    
-    nCMULBin = nCMULBin - nCMULBinRej;
-    lRun2Reject->Clear();
-    
-    FNormTotError[i] =  TMath::Sqrt(TMath::Power(TMath::Sqrt(FNormTotError[i])/nCMULBin,2.) + TMath::Power(FNormTot[i]*TMath::Sqrt(nCMULBin)/TMath::Power(nCMULBin,2.),2.));
-    FNormTot[i] = FNormTot[i]/nCMULBin;
-    
-    std::cout << "Mean FNorm in Bin = " << FNormTot[i]  << " +- " << FNormTotError[i] <<std::endl;
-    
-    hFNormTot->SetBinContent(i+1,FNormTot[i]);
-    hFNormTot->SetBinError(i+1,FNormTotError[i]);
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMu::SetCorrectionPerRun(const TGraph& corr, const char* formula)
+{
+    /// Sets the graph used to correct values per run
+    delete fCorrectionPerRun;
+    fCorrectionPerRun=0x0;
     
-    //____
-    Double_t nCMULBinYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                 seventSelectionYield.Data(),triggerType.Data(),colType.Data(),r->AsString().Data())); //Nof CMUL7/8 events in Bin summed over runs (for yield event selection)
+    // check that corr has the same runs as we do
     
-    Double_t nofEqMB = FNormTot[i]*nCMULBinYield;
-    Double_t nofEqMBError = TMath::Sqrt( TMath::Power(FNormTotError[i]*nCMULBinYield,2.) + TMath::Power(FNormTot[i]*TMath::Sqrt(nCMULBinYield),2.) );
+    Int_t i(0);
     
-    std::cout << "EqMB in Bin  = " << nofEqMB << " +- " << nofEqMBError << " ; nCMUL (used for the yield) = " << nCMULBinYield << std::endl;
+    for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
+        {
+        Int_t corrRun = TMath::Nint(corr.GetX()[i]);
+        if (corrRun != *it)
+            {
+            AliError(Form("%d-th run mistmatch %d vs %d",i,corrRun,*it));
+            
+            return kFALSE;
+            }
+        ++i;
+        }
     
-    hNofEqMB->SetBinContent(i+1,nofEqMB);
-    hNofEqMB->SetBinError(i+1,nofEqMBError);
-    //____
+    fCorrectionPerRun = new TGraphErrors(corr.GetN());
     
-    TH1* o = fMergeableCollection->Histo(id.Data(),h->GetName());
+    TFormula* tformula(0x0);
+    if ( strlen(formula) > 0 )
+        {
+        tformula = new TFormula("SetCorrectionPerRunFormula",formula);
+        }
     
-    if (o)
-    {
-      AliWarning(Form("Replacing %s/%s",id.Data(),h->GetName()));
-      fMergeableCollection->Remove(Form("%s/%s",id.Data(),h->GetName()));
-    }
+    i = 0;
     
-    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),h);
+    for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
+        {
+        Double_t y = corr.GetY()[i];
+        
+        if ( tformula )
+            {
+            y = tformula->Eval(y);
+            }
+        fCorrectionPerRun->SetPoint(i,corr.GetX()[i],y);
+        ++i;
+        }
     
-    if ( adoptOK ) std::cout << "+++FNorm histo " << h->GetName() << " adopted" << std::endl;
-    else AliError(Form("Could not adopt FNorm histo %s",h->GetName()));
+    delete formula;
     
-    i++;
-    lRun2Reject->Clear();
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  
-  
-  o = fMergeableCollection->Histo(id.Data(),hNofEqMB->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNofEqMB->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNofEqMB->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNofEqMB);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNofEqMB->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNofEqMB->GetName()));
-  
-  delete binning;
-  delete runs;
-  delete aCluster;
-  delete bin;
-  delete[] binArray;
-  delete[] FNormTot;
-  delete[] FNormTotError;
-  delete lRun2Reject;
-  
-  return;
- 
+    return kTRUE;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromGlobal(const char* what, const char* quantity, const char* flavour,const char* triggerCluster,
-                                                 const char* eventSelectionFnorm, const char* eventSelectionYield,  Bool_t printout)
+void AliAnalysisMuMu::SetNofInputParticles(AliAnalysisMuMuJpsiResult& r)
 {
-  /// Compute the CMUL to CINT ratio(s) from the itegrated FNorm, in bins.
-  /// The FNorm bin by bin is computed as follows:
-  ///   FNorm^{i} = FNorm*( (N_{MB}^{i}/N_{MB}) / (N_{CMUL}^{i}/N_{CMUL}) )
-  ///
-  /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection)(because the integrated Fnorm has to be computed in PSALL).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00" (Used for charged particle multiplicity analysis).
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
-
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-  
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sQuantity(quantity);
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data()));
-  
-  TH1* hFnormGlobalInt = OC()->Histo(id.Data(),"hFNormInt");
-  if( !hFnormGlobalInt)
-  {
-    AliError("hFNormInt not found");
-    return;
-  }
-  Double_t FNormGlobal = hFnormGlobalInt->GetBinContent(1);
-  Double_t FNormGlobalError = hFnormGlobalInt->GetBinError(1);
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-    return;
-  }
-  
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Double_t* binArray = binning->CreateBinArray();
-  Int_t nEntries = bin->GetEntries();
-
-  TH1* hNMBVSBin = new TH1F(Form("hNofEqMBVS%sFromGlobal",sQuantity.Data()),Form("Equivalent MB events per CMUL vs %s",sQuantity.Data())
-                            ,nEntries,binArray);
-  TH1* hFNormVSBin = new TH1F(Form("hFNormVS%sFromGlobal",sQuantity.Data()),Form("Normalization factor vs %s;%s;FNorm",sQuantity.Data(),sQuantity.Data()),
-                              nEntries,binArray);
-  
-  Double_t nCMULTot = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                                        seventSelectionFNorm.Data(),triggerType.Data(),colType.Data()));
-  
-  Double_t nCINTTot = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A",
-                                     seventSelectionFNorm.Data(),triggerType.Data(),colType.Data()));
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
-    
-    Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/bin:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
-    
-    Double_t f = nCMUL/nCMULTot;
-    Double_t fError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nCMUL)/nCMULTot,2.) + TMath::Power(nCMUL*TMath::Sqrt(nCMULTot)/TMath::Power(nCMULTot,2.),2.) );
-    
-    Double_t g = nCINT/nCINTTot;
-    Double_t gError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nCINT)/nCINTTot,2.) + TMath::Power(nCINT*TMath::Sqrt(nCINTTot)/TMath::Power(nCINTTot,2.),2.) );
-    
-    Double_t value = FNormGlobal*(g/f);
-    Double_t error = TMath::Sqrt( TMath::Power(FNormGlobalError*(g/f),2.) + TMath::Power(FNormGlobal*(gError/f),2.) + TMath::Power(FNormGlobal*g*fError/TMath::Power(f,2.),2.) );
-    
-    hFNormVSBin->SetBinContent(i,value);
-    hFNormVSBin->SetBinError(i,error);
-    hFNormVSBin->GetXaxis()->SetBinLabel(i,r->AsString().Data());
-
-    if (printout)
-    {
-      std::cout << "Bin " << r->AsString().Data() << " : " << std::endl;
-      std::cout << " FNorm = " << value << " +- " << error << " ; nCMUL = " << nCMUL << std::endl;
-    }
-
-    Double_t nCMULYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                       seventSelectionYield.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
-
-    Double_t nMB = value*nCMULYield;
-    Double_t nMBerror = nMB*TMath::Sqrt( TMath::Power(error/value,2.) + TMath::Power(TMath::Sqrt(nCMULYield)/nCMULYield,2.) );
+    /// Set the "NofInput" variable(s) of one result
     
-    if (printout) std::cout << " NEqMB = " << nMB << " +- " << nMBerror << " ; nCMUL (for yield) = " << nCMULYield << std::endl;
+    TString hname(Form("MinvUS%s",r.Bin().AsString().Data()));
     
-    hNMBVSBin->SetBinContent(i,nMB);
-    hNMBVSBin->SetBinError(i,nMBerror);
-    hNMBVSBin->GetXaxis()->SetBinLabel(i,r->AsString().Data());
+    TH1* hinput = fMergeableCollection->Histo(Form("/%s/ALL/ANY/V0A/INYRANGE",AliAnalysisMuMuBase::MCInputPrefix()),hname.Data());
     
-    i++;
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormVSBin->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormVSBin->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormVSBin->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormVSBin);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormVSBin->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormVSBin->GetName()));
-  
-  o = fMergeableCollection->Histo(id.Data(),hNMBVSBin->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNMBVSBin->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNMBVSBin->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNMBVSBin);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNMBVSBin->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNMBVSBin->GetName()));
-
-  
+    if (!hinput)
+        {
+        AliError(Form("Got a simulation file where I did not find histogram /%s/ALL/EVERYTHING/ANY/INYRANGE/%s",AliAnalysisMuMuBase::MCInputPrefix(),hname.Data()));
+        
+        }
+    else
+        {
+        r.SetNofInputParticles(*hinput);
+        }
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeMeanFnorm(const char* triggerCluster, const char* eventSelection, const char* what,const char* quantity,const char* flavour)
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::SPECTRA(const char* fullpath) const
 {
-  /// Compute the mean Fnorm and mean NMB from the "offline" and "rescaled global" methods.
-  ///
-  /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  
-  TString seventSelection(eventSelection);
-  TString striggerCluster(triggerCluster);
-  TString sQuantity(quantity);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-  
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-
-  TH1* hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMB )
-  {
-    AliError(Form("Histo hNofEqMBVS%s not found",sQuantity.Data()));
-    return;
-  }
-  
-  TH1* hMBG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMBG )
-  {
-    AliError(Form("Histo hNofEqMBVS%sFromGlobal not found",sQuantity.Data()));
-    return;
-  }
-
-  TH1* hFnorm = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMB )
-  {
-    AliError(Form("Histo hFNormVS%s not found",sQuantity.Data()));
-    return;
-  }
-  
-  TH1* hFnormG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMBG )
-  {
-    AliError(Form("Histo hFNormVS%sFromGlobal not found",sQuantity.Data()));
-    return;
-  }
-
-
-//  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-//  if ( !binning )
-//  {
-//    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-//    return;
-//  }
-//  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelection.Data()));
-  
-  TH1* hMBMean = static_cast<TH1*>(hMBG->Clone());
-  hMBMean->SetName(Form("hNofEqMBVS%sFromMean",sQuantity.Data()));
-  
-  TH1* hFnormMean = static_cast<TH1*>(hFnorm->Clone());
-  hFnormMean->SetName(Form("hFNormVS%sFromMean",sQuantity.Data()));
-  
-  for ( Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
-  {
-    //______Mean NofMB computation
-    Double_t Fn = hMB->GetBinContent(i);
-    Double_t Fng = hMBG->GetBinContent(i);
-    
-    Double_t FnE = hMB->GetBinError(i);
-    Double_t FngE = hMBG->GetBinError(i);
-//
-//    Double_t meanBin = (Fn + Fng) / 2.;
-//    Double_t meanBinError = TMath::Sqrt( TMath::Power(FnE/2.,2.) + TMath::Power(FngE/2.,2.) );
-//    Double_t meanBinSys = TMath::Abs( meanBin - Fn );
-
-    Double_t meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
-    Double_t meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
-    Double_t meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
+    /// Shortcut method to get to a spectra
+    if (!OC()) return 0x0;
+    
+    return static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(fullpath));
+}
 
-    std::cout << "Bin : " << hMB->GetXaxis()->GetBinLabel(i) << std::endl;
+//_____________________________________________________________________________
+void AliAnalysisMuMu::SelectRunByTrigger(const char* triggerList)
+{
+    // Print sum of event in each run according to trigger
+    //
+    // FIX ME : make it general with MuMuConfig
     
-    std::cout << " Mean NMB = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
-    << "%))" << std::endl;
+    if (!fMergeableCollection || !fCounterCollection) return;
     
-    hMBMean->SetBinContent(i,meanBin);
-    hMBMean->SetBinError(i,meanBinError);
-    //______
+    TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
+    TIter nextRun(runs);
     
+    TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
+    TIter nextTrigger(triggers);
     
-    //______Mean FNorm computation
-    Fn = hFnorm->GetBinContent(i);
-    Fng = hFnormG->GetBinContent(i);
+    TObjString* srun;
+    TObjString* strigger;
     
-    FnE = hFnorm->GetBinError(i);
-    FngE = hFnormG->GetBinError(i);
+    TString striggerList(triggerList);
     
-    meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
-    meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
-    meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
+    TList* runList = new TList();
     
-//    Double_t nCMULBin = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-//                                          seventSelection.Data(),triggerType.Data(),colType.Data(),
-//                                          static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(i-1))->AsString().Data()));
-//
-//    if (printout) std::cout << meanBinSys/nCMULBin << std::endl;
-//
-//    Double_t meanFnBin = meanBin/nCMULBin;
-//    Double_t meanFnBinError = TMath::Sqrt( TMath::Power(meanBinError/nCMULBin,2) + TMath::Power(meanBin/TMath::Power(nCMULBin,2.),2) );
-//
-//    if (printout) std::cout << meanBinSys/nCMULBin/meanFnBin << std::endl;
-//
-//    if (printout) std::cout << meanFnBin << " +- " << meanFnBinError << std::endl;
-
-    std::cout << " Mean FNorm = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
-    << "%)" << std::endl;
-    std::cout << std::endl;
-
-    hFnormMean->SetBinContent(i,meanBin);
-    hFnormMean->SetBinError(i,meanBinError);
-    //______
-  }
-
-  TH1* o = fMergeableCollection->Histo(id.Data(),hMBMean->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hMBMean->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hMBMean->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hMBMean);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hMBMean->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hMBMean->GetName()));
-  
-  
-  o = fMergeableCollection->Histo(id.Data(),hFnormMean->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFnormMean->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFnormMean->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hFnormMean);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFnormMean->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFnormMean->GetName()));
-
-
+    while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
+        {
+        
+        nextTrigger.Reset();
+        
+        while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
+            {
+            if ( !striggerList.Contains(strigger->String().Data()) )
+                {
+                continue;
+                }
+            
+            ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d",
+                                                                      strigger->String().Data(),"PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",srun->String().Atoi())));
+            if ( n > 0 ) runList->Add(srun);
+            
+            }
+        }
+    runList->Sort();
+    TIter nextRunOK(runList);
+    while ( ( srun = static_cast<TObjString*>(nextRunOK()) ) )
+        {
+        std::cout << srun->String().Atoi() << std::endl;
+        }
+    delete runList;
+    
+    delete triggers;
+    delete runs;
 }
-
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeIntFnormFromCounters(const char* filePileUpCorr, const char* triggerCluster, const char* eventSelectionFnorm, const char* eventSelectionYield, Bool_t printout)
+void AliAnalysisMuMu::TriggerCountCoverage(const char* triggerList,
+                                           Bool_t compact,
+                                           Bool_t orderByTriggerCount)
 {
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), integrated.
-  ///
-  /// Important considerations:
-  ///   - If the analysed file has a binning, we must be sure that all events are included in the bins to get the correct integrated Fnorm.
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00, but by default is also PSALL (it can be different in case the aditional event cuts do not affect the J/psi yield, like for example a cut on |Z_vtx| < x cm)) to work correctly. (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
-  /// Parameters:
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFNorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
-
-
-  //_______ Definitions for the triggers used to extract the counts from the counter collection:
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data()); // Let the method know if the collision is beam-beam of satellite.
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data()); // Let the method know the MB trigger type (V0 or T0).
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-
-  TString striggerCluster(triggerCluster); // Let the method know in which cluster the CMUL trigger is included.
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  //________
-
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
-  Double_t NofRuns = runs->GetEntries();
-  
-
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
-    
-    while ( in.getline(line,1024,'\n'))
-    {
-      TString lrun(line);
-      TString lvalue(line);
-      
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
-      
-      lvalue.Remove(0,lvalue.First("=")+1);
-      
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
-      
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
-    }
-    corrPU = kTRUE;
-  }
-  //________
-
-  
-  TIter nextRun(runs);
-  TObjString* s;
-  
-  TH1* h;
-  
-  Double_t FNormTot(0.);
-  Double_t FNormTotError(0.);
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data())); // Path to save the Fnorm and EqNofMB histos in the mergeable collection
-  
-  h = new TH1F("hFNormIntVSrun","Integrated Normalization factor vs run;run;FNorm",NofRuns,1.,NofRuns);
-  
-  Double_t nCMULTot = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                                        seventSelectionFNorm.Data(),triggerType.Data(),colType.Data())); //Total Nof CMUL7 events in the event selection for the Fnorm
-  
-  TObjArray* aCluster = striggerCluster.Tokenize("-");
-  TIter nextCluster(aCluster);
-  TObjString* striggerClusterS;
-  
-  TList* lRun2Reject = new TList();
-  lRun2Reject->SetOwner(kTRUE);
-  
-  nextRun.Reset();
-  Int_t i(0);//Run label index
-  std::cout << std::endl;
-  std::cout << std::endl;
-  std::cout << std::endl;
-  std::cout << "Computing FNorm" << std::endl;
-  while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
-  {
-    Double_t nCMSL(0.),nCMSLandOMUL(0.);
-    nextCluster.Reset();
-    while ( (striggerClusterS = static_cast<TObjString*>(nextCluster())) && nCMSL == 0. ) // Loop on clusters (in case the single muon trigger is in different clusters depending on the run). We need to explicitly ask for using more than one cluster by setting "triggercluster" parameter
-    {
-      nCMSL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s/centrality:V0A/run:%s",
-                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),s->GetName()));
-      
-      nCMSLandOMUL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s&0MUL/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),s->GetName()));
-    }
+    // Give the fraction of triggers (in triggerList) relative
+    // to what is expected in the scalers
+    //
+    // FIX ME : make it general with MuMuConfig
     
-    Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
+    TGrid::Connect("alien://"); // to insure the "Trying to connect to server... message does not pollute our output later on...
     
-    Double_t nCINTandOMSL = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD&0MSL/centrality:V0A/run:%s",
-                                              seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
+    AliLog::EType_t oldLevel = static_cast<AliLog::EType_t>(AliLog::GetGlobalLogLevel());
     
-    Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
+    AliLog::SetGlobalLogLevel(AliLog::kFatal);
     
-    Double_t FNorm(0.),FNormError(0.);
-    Double_t pUfactor = 1.;
-    if ( nCMSLandOMUL != 0. && nCINTandOMSL !=0. && nCMSL != 0. && nCINT !=0. )
-    {
-      if (corrPU) // Pile up correction
-      {
-        TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-        if ( p ) pUfactor = p->GetVal();
-        else
+    if (!fMergeableCollection || !fCounterCollection) return;
+    
+    TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
+    TIter nextRun(runs);
+    
+    TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
+    TIter nextTrigger(triggers);
+    
+    TObjString* srun;
+    TObjString* strigger;
+    
+    TString striggerList(triggerList);
+    
+    ULong64_t total(0);
+    ULong64_t totalExpected(0);
+    TString msg;
+    std::multimap<ULong64_t,std::string> messages;
+    
+    while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
+        {
+        msg.Form("RUN %09d ",srun->String().Atoi());
+        
+        if (!compact)
+            {
+            msg += "\n";
+            }
+        
+        ULong64_t nmax(0);
+        
+        nextTrigger.Reset();
+        
+        while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
+            {
+            if ( !striggerList.Contains(strigger->String().Data()) )
+                {
+                continue;
+                }
+            
+            ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d",
+                                                                      strigger->String().Data(),"ALL",srun->String().Atoi())));
+            
+            ULong64_t expected = GetTriggerScalerCount(strigger->String().Data(),srun->String().Atoi());
+            
+            
+            nmax = TMath::Max(n,nmax);
+            
+            total += n;
+            totalExpected += expected;
+            
+            msg += TString::Format("%30s %9lld expected %9lld [%s] ",strigger->String().Data(),n,expected,
+                                   (n>expected ? "!" : " "));
+            
+            if ( expected > 0 ) {
+                msg += TString::Format("fraction %5.1f %%",n*100.0/expected);
+            }
+            
+            if (!compact)
+                {
+                msg += "\n";
+                }
+            }
+        if (nmax>0)
+            {
+            if (!orderByTriggerCount)
+                {
+                std::cout << msg.Data() << std::endl;
+                }
+            else
+                {
+                messages.insert(std::make_pair(nmax,static_cast<std::string>(msg.Data())));
+                }
+            }
+        }
+    
+    std::multimap<ULong64_t,std::string>::const_reverse_iterator it;
+    
+    ULong64_t current(0);
+    Int_t n(0);
+    
+    for ( it = messages.rbegin(); it != messages.rend(); ++it )
         {
-          AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
+        ++n;
+        current += it->first;
+        Double_t percent = ( total > 0.0 ? current*100.0/total : 0.0);
+        std::cout << Form("%10lld",it->first) << " " << it->second << " percentage of total = " << Form("%7.2f %% %3d",percent,n ) << std::endl;
         }
-      }
-      FNorm = (nCMSL*nCINT)*pUfactor/(nCMSLandOMUL*nCINTandOMSL); //Fnorm computation
-      FNormError = ErrorPropagationAxBoverCxD(nCMSL,nCINT,nCMSLandOMUL,nCINTandOMSL)*pUfactor;
-    }
-    else // If a run has no enough stats to compute FNorm it will be skipped to compute the run average
-    {
-      if ( nCINT == 0 ) std::cout << " Warning: Bad run " << s->GetName() << " has no MB trigger in this bin. Remove from analysis" << std::endl;
-      
-      lRun2Reject->Add(new TObjString(s->GetName()));
-      if ( printout ) std::cout << "Run " << s->GetName() << " not used for FNorm cause lack of stats" << std::endl;
-      continue;
-    }
     
-    FNormTot += FNorm*nCMUL; // This is the sum of equivalent Nof MB per CMUL run by run (for the ev. selection used for the FNorm, not the yield one). NOTE: This sum is NOT always the total equivalent Nof MB per CMUL because in pp 2012 if just one cluster is set as input parameter "triggercluster", this sum is not the sum for all runs
-    FNormTotError += TMath::Power(nCMUL*FNormError,2.) + TMath::Power(FNorm*TMath::Sqrt(nCMUL),2.);
+    std::cout << Form("--- TOTAL %lld expected %lld fraction %5.1f %%",
+                      total,totalExpected,totalExpected ? total*100.0/totalExpected : 0.0) << std::endl;
     
-    if ( printout ) std::cout << "Run " << s->GetName() << " FNorm = " << FNorm << " +- " << FNormError << " ; PUFactor =" << pUfactor << " ; " << "Nof CMUL = " << nCMUL << std::endl;
     
-    h->GetXaxis()->SetBinLabel(++i,s->GetName());
-    h->SetBinContent(i,FNorm);
-    h->SetBinError(i,FNormError);
     
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),h->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),h->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),h->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),h);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << h->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",h->GetName()));
-  
-  
-  //______ Computation of the total Nof CMUL used to compute the FNorm
-  TIter nextRejectRun(lRun2Reject);
-  TObjString* run2Rej;
-  Double_t nCMULTotRej(0.);
-  while ( (run2Rej = static_cast<TObjString*>(nextRejectRun())) )
-  {
-    nCMULTotRej += CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s",
-                                     seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),
-                                     run2Rej->GetName())); //Sum of CMUL7 events (for Fnorm event selection) from rejected runs
-  }
-
-  nCMULTot = nCMULTot - nCMULTotRej;
-  //_______
-
-
-  //_______ Integrated Fnorm computation
-  FNormTotError =  TMath::Sqrt(TMath::Power(TMath::Sqrt(FNormTotError)/nCMULTot,2.) + TMath::Power(FNormTot*TMath::Sqrt(nCMULTot)/TMath::Power(nCMULTot,2.),2.));
-  
-  FNormTot = FNormTot/nCMULTot; // nCMULTot is here nCMULTot - nCMULTotRej
-  
-  std::cout << "FNorm = " << FNormTot << " +- " << FNormTotError << std::endl;
-  
-  TH1* hFNormTot = new TH1F("hFNormInt","Global Normalization factor",1,0.,1.);
-  hFNormTot->SetBinContent(1,FNormTot);
-  hFNormTot->SetBinError(1,FNormTotError);
-  
-  o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  //________
+    AliLog::SetGlobalLogLevel(oldLevel);
+    delete triggers;
+    delete runs;
+}
 
-  
-  //_______ Integrated Equivalent number of minimum bias events (for the yield computation event selection)
-  TH1* hNEqMB = new TH1F("hNEqMB","Equivalent number of MB events per CMUL",1,0.,1.);
-  
-  Double_t nCMULTotYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                               seventSelectionYield.Data(),triggerType.Data(),colType.Data())); //Total Nof CMUL7 events for the event selection used to compute the yield
-  
-  Double_t nofEqMB = FNormTot*nCMULTotYield;
-  Double_t nofEqMBError = TMath::Sqrt( TMath::Power(FNormTotError*nCMULTotYield,2.) + TMath::Power(FNormTot*TMath::Sqrt(nCMULTotYield),2.) );
-  
-  std::cout << "Nof CMUL tot (used for yield) = " << nCMULTotYield << " ; " << "EqMB = " << nofEqMB << " +- " << TMath::Sqrt(nofEqMBError) << std::endl;
-  
-  hNEqMB->SetBinContent(1,nofEqMB);
-  hNEqMB->SetBinError(1,nofEqMBError);
-  
-  o = fMergeableCollection->Histo(id.Data(),hNEqMB->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNEqMB->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNEqMB->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNEqMB);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNEqMB->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNEqMB->GetName()));
-  //_______
-  
-  delete runs;
-  delete lRun2Reject;
-  delete aCluster;
-  
-  return;
-  
+//_____________________________________________________________________________
+void AliAnalysisMuMu::UnsetCorrectionPerRun()
+{
+    // drop the correction factors
+    delete fCorrectionPerRun;
+    fCorrectionPerRun=0x0;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::PlotYiedWSyst(const char* triggerCluster)
+void AliAnalysisMuMu::Update()
 {
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  
-  TString path(Form("%s/%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
-  
-  TH1* hY = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),path.Data()),"hJPsiYieldVSdNchdEtaRelative");
-  if ( !hY )
-  {
-    AliError("No yield found");
-    return;
-  }
-
-  TString id(Form("/TESTSYST/%s",path.Data()));
-  
-  TH1* hYSyst = static_cast<TH1*>(hY->Clone("RelYieldSyst"));
-  if ( !hYSyst )
-  {
-    AliError("No systematic found");
-    return;
-  }
-
-  TH1* hS = OC()->Histo(id.Data(),"yield_Systematics");
-  
-  for ( Int_t i = 1 ; i <= hY->GetNbinsX() ; i++ )
-  {
-    hYSyst->SetBinError(i,hS->GetBinContent(i)*hY->GetBinContent(i)/100.);
-  }
+    /// update the current file with memory
+    
+    if (!CC() || !OC()) return;
+    
+    ReOpen(fFilename,"UPDATE");
     
-  hY->Draw();
-  hYSyst->Draw("same");
+    if (OC())
+        {
+        OC()->Write("OC",TObject::kSingleKey|TObject::kOverwrite);
+        }
+    
+    ReOpen(fFilename,"READ");
+    
+    GetCollections(fFilename,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeJpsiYield( Bool_t relative, const char* fNormType, const char* evSelInt, const char* evSelDiff, const char* triggerCluster, const char* spectra, const char* sResName)
+Bool_t AliAnalysisMuMu::Upgrade(const char* filename)
 {
-  /// Compute the Jpsi yield integrated and in bins, absolute or relative (Y_bin/Y_int). It can be calculated for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
-  ///
-  /// Important considerations:
-  ///   - No corrections can be applied to the yields or x-axis with this method
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL (fot integrated signal extraction) and the one used in the bin by bin yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly.
-  ///
-  /// Parameters:
-  ///   -relative: kTRUE if relative yield (y/y_int) is to be computed. Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
-  ///   -fNormType: Desired FNorm to use: "offline", "global" or "mean"
-  ///   -evSelInt: Event selection to compute integrated NofJpsi
-  ///   -evSelDiff: Event selection to compute diferential NofJpsi
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -spectra: spectra (AliAnalysisMuMuSpectra) to be used to get the differential NofJpsi
-  ///   -sResName: subresult name to get the yield from. By default is "" (mean of all subresults)
-
-  TString sfNormType(fNormType);
-  TString swhat("");
-  TString sres(sResName);
-  TString sspectra(spectra);
-  TString sevSelInt(evSelInt);
-  TString sevSelDiff(evSelDiff);
-
-  if ( sspectra.Contains("DNCHDETA")) swhat = "dnchdeta";   //FIXME::Make it general for any bin quantity (pt,centrality...)
-  else if ( sspectra.Contains("NTRCORR") ) swhat = "ntrcorr";
-  else if ( sspectra.Contains("V0ACORR") ) swhat = "v0acorr";
-  else if ( sspectra.Contains("V0CCORR") ) swhat = "v0ccorr";
-  else if ( sspectra.Contains("V0MCORR") ) swhat = "v0mcorr";
-
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi yield: Is a simulation file");
-    return;
-  }
-
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-
-  TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
-  TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
-  TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
-  
-  //Path to get/store integrated results from Mergeable Collection
-  TString intPath(Form("%s/%s/%s/%s",
-                       sevSelInt.Data(),
-                       dimuonTriggerClassName.Data(),
-                       centralitySelection.Data(),
-                       pairSelection.Data()));
-  
-  //Path to get/store differential results from Mergeable Collection
-  TString diffPath(Form("%s/%s/%s/%s",
-                        sevSelDiff.Data(),
-                        dimuonTriggerClassName.Data(),
-                        centralitySelection.Data(),
-                        pairSelection.Data()));
-
-
-  Double_t bR = 0.0593; // BR(JPsi->mu+mu-)
-  Double_t bRerror = 0.0006 ;
-
-  if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
-
-  //_________Integrated yield
-  AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),"PSI-INTEGRATED-AccEffCorr"))); //FIXME::Make it general
-
-  if ( !sInt )
-  {
-    AliError(Form("No spectra %s found in %s","PSI-INTEGRATED-AccEffCorr",intPath.Data()));
-    return;
-  }
-
-  AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
-  b->AddBin("psi","INTEGRATED");
-
-  AliAnalysisMuMuBinning::Range* bin = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
-
-  AliAnalysisMuMuResult* result = sInt->GetResultForBin(*bin);
-  if ( !result )
-  {
-    AliError(Form("No result for bin %s found in %s",bin->AsString().Data(),"PSI-INTEGRATED-AccEffCorr"));
-    return;
-  }
-
-  Double_t NofJPsiTot = result->GetValue("NofJPsi",sres.Data());
-  Double_t NofJPsiTotError = result->GetErrorStat("NofJPsi",sres.Data());
-
-  TH1* hMBTot = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data()));
-  if ( !hMBTot )
-  {
-    AliError(Form("No eq Nof MB events found in %s",Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data())));
-    return;
-  }
-
-  Double_t nEqMBTot = hMBTot->GetBinContent(1);
-  Double_t nEqMBTotError = hMBTot->GetBinError(1);
-
-  Double_t yieldInt = NofJPsiTot/(nEqMBTot*bR);
-  Double_t yieldIntError = yieldInt*TMath::Sqrt(TMath::Power(NofJPsiTotError/NofJPsiTot,2.) +
-                                       TMath::Power(nEqMBTotError/nEqMBTot,2.) +
-                                       TMath::Power(bRerror/bR,2.));
-
-  std::cout << "Integrated yield = " << yieldInt << " +- " << yieldIntError << std::endl;
-
-  TH1* hYint = new TH1F("hJPsiYieldInt","Integrated J/#psi yield",1,0.,1.);
-  hYint->SetBinContent(1,yieldInt);
-  hYint->SetBinError(1,yieldIntError);
-
-  TH1* o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),intPath.Data()),hYint->GetName());
-
-  if (o)
-  {
-    AliWarning(Form("Replacing /RESULTS-%s/%s/%s",striggerCluster.Data(),intPath.Data(),hYint->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),intPath.Data(),hYint->GetName()));
-  }
-
-  Bool_t adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),intPath.Data()),hYint);
-
-  if ( adoptOK ) std::cout << "+++Yield histo " << hYint->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hYint->GetName()));
-
-  std::cout << std::endl;
-
-  delete b;
-  //_________
-
+    /// Upgrade a file
+    AliAnalysisMuMu m(filename);
+    
+    return m.Upgrade();
+}
 
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMu::Upgrade()
+{
+    /// Upgrade the current file
+    /// - from single list to one key per object, if needed
+    /// - from histogramCollection to mergeableCollection, if needed
+    
+    
+    AliWarning("Out of date method");
+    
+    TFile* f = ReOpen(fFilename,"UPDATE");
+    
+    TList* list = static_cast<TList*>(f->Get("chist"));
+    
+    if (list)
+        {
+        // really old file where everything was in a single list
+        
+        AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(list->At(0));
+        AliCounterCollection* cc = static_cast<AliCounterCollection*>(list->At(1));
+        
+        AliMergeableCollection* mc = hc->Convert();
+        
+        f->cd();
+        
+        mc->Write("MC",TObject::kSingleKey);
+        cc->Write("CC",TObject::kSingleKey);
+        
+        f->Delete("chist;*");
+        
+        f->Write();
+        
+        }
+    else
+        {
+        AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(f->Get("HC"));
+        
+        if ( hc )
+            {
+            // old file with histogram collection instead of mergeable collection
+            
+            AliMergeableCollection* mc = hc->Convert();
+            
+            f->cd();
+            
+            mc->Write("MC",TObject::kSingleKey);
+            
+            f->Delete("HC;*");
+            
+            f->Write();
+            }
+        }
+    
+    delete f;
+    
+    return kTRUE;
+}
 
-  //_____Differential yield
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),sspectra.Data())));
-  if ( !s )
-  {
-    AliError(Form("No spectra %s found in %s",sspectra.Data(),diffPath.Data()));
+//_____________________________________________________________________________
+void AliAnalysisMuMu::PrintDistribution(const char* binType, const char* what, const char* sResName, const char* ColSys, Bool_t divideByBinWidth, Bool_t AccEffCorr)
+{
+    /// Compute what distribution vs binType. Delegate procedure to AliAnalysisSpectra object. It can be compute for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
+    ///
+    /// Parameters:
+    ///   -binType    : INTEGRATED, PT, Y (for now)
+    ///   -what       : The quantity (NofJPsi by default, but could be something else...)
+    ///   -AccEffCorr : Just a tag to select right histograms.
+    ///   -sResName   : subresult name to get the yield from. By default is "" (mean of all subresults)
+    
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       PrintDistribution                          " << endl;
+        cout <<      " ================================================================ " << endl;
+        }
+    
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+    
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+    
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* swhat;
+    TObjString* sbinType;
+    TObjString* scentrality;
+    
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+    const TString syear(ColSys);
+    
+    // Pointers
+    TH1* h= 0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+    
+    //Loop on what type
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
+        {
+        AliDebug(1,Form("what %s",swhat->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                        
+                        // //canvas
+                        // TCanvas *c1 = new TCanvas;
+                        // c1->Draw();
+                        // gStyle->SetOptStat(0);
+                        
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                            {
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+                            
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),"PSI",sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+                            
+                            h= spectra->Plot(swhat->String().Data(),sResName,divideByBinWidth);
+                            TCanvas *c = new TCanvas;
+                            c->SetLogy();
+                            h->Draw();
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    
     return;
-  }
-
-  std::cout << "Number of J/Psi:" << std::endl;
-  TH1* hry = s->Plot("NofJPsi",sres.Data(),kFALSE); //Number of Jpsi
-  
-  std::cout << "" << std::endl;
-  
-  //  std::cout << "Equivalent number of MB events:" << std::endl;
-  TH1* hMB(0x0);
-  if ( sfNormType.Contains("offline") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
-    {
-      AliError(Form("Histo hNofEqMBVS%s not found",swhat.Data()));
-      return;
-    }
+}
 
-    std::cout << " Using Fnorm from offline method " << std::endl;
-  }
-  else if ( sfNormType.Contains("global") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
+void AliAnalysisMuMu::ComputeDimuonRawCount(const Double_t rlow, const Double_t rhight, const char* binType, const char* flavour, Bool_t corrected)
+{
+    /// Compute the raw count of dimuon pair
+    /// Parameters:
+    ///   - rlow,rhight  : intervall in bin for the raw count
+    ///   -binType       : integrated,pt,y ...see your AddTaskMuMu
+    ///   -flavour       : Default is BENJ
+    ///   -corrected     : For nomenclature
+
+    if(!OC())
     {
-      AliError(Form("Histo hNofEqMBVS%sFromGlobal not found",swhat.Data()));
-      return;
+        AliError("No mergeable. Consider Upgrade()");
+        return;
     }
-
-    std::cout << " Using Fnorm from global method " << std::endl;
-  }
-  else if ( sfNormType.Contains("mean") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromMean",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
+    else
     {
-      AliError(Form("Histo hNofEqMBVS%sFromMean not found",swhat.Data()));
-      return;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputeDimuonRawCount                          " << endl;
+        cout <<      " ================================================================ " << endl;
     }
 
-    std::cout << " Using mean Fnorm " << std::endl;
-  }
-  else
-  {
-    AliError("Dont know what Fnorm use");
-    return;
-  }
-  
-  std::cout << std::endl;
-
-  TH1* hy;
-  const TArrayD* binArray = hry->GetXaxis()->GetXbins();
-  Int_t size = binArray->GetSize();
-  const Double_t* axis = binArray->GetArray();
-
-  if (sres.IsNull()) sres += "mean"; // To indicate that the result is computed from the mean yield of all the subresults
-
-  if ( relative )
-  {
-    hy = new TH1D(Form("hJPsiYieldVS%sRelative",swhat.Data()),Form("Relative J/#psi yield vs %s (%s);%s;Y^{J/#psi}/Y^{J/#psi}_{int}",swhat.Data(),sres.Data(),swhat.Data()),size-1,axis);
-  }
-  else
-  {
-    hy = new TH1D(Form("hJPsiYieldVS%s",swhat.Data()),Form("J/#psi yield vs %s (%s);%s;Y^{J/#psi}",swhat.Data(),sres.Data(),swhat.Data())
-                  ,size-1,axis);
-  }
-
-  delete axis;
-
-  // AccxEff(from rel diff or paper)  // Signal extraction
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.01,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.022,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.009,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.016 ,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.033,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.003,0.001,0.002,0.003,0.002,0.004,0.011,0.012,0.071};
-  //  Double_t systPU[9] = {0.00,0.01,0.012,0.014,0.014,0.019,0.020,0.021,0.040}; //_______pPb
-  // AccxEff(from paper)
-  //  Double_t systNofJpsiTot = 0.015;
-
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.028,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.016,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.024,2.) + TMath::Power(0.005 ,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.016,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.005,0.004,0.004,0.004,0.003,0.002,0.002,0.04,0.04};
-  //  Double_t systPU[9] = {0.00,0.007,0.015,0.011,0.014,0.018,0.014,0.011,0.020}; //______Pbp
-  //  Double_t systNofJpsiTot = 0.015;
-
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.034,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.042,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.063,2.) + TMath::Power(0.014,2.) ),TMath::Sqrt( TMath::Power(0.094,2.) + TMath::Power(0.009,2.) ),TMath::Sqrt( TMath::Power(0.00,2.) + TMath::Power(0.00 ,2.) ),TMath::Sqrt( TMath::Power(0.00,2.) + TMath::Power(0.00,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.004,0.019,0.002,0.012,0.048,0.063,0.082,0.000,0.000};
-  //  Double_t systPU[9] = {0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00}; //______pp |eta|<0.5
-  //  Double_t systNofJpsiTot = 0.017;
-
-//  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.037,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.021,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.022,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.019,2.) + TMath::Power(0.001,2.) ),TMath::Sqrt( TMath::Power(0.036,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.042,2.) + TMath::Power(0.001,2.) ),TMath::Sqrt( TMath::Power(0.039,2.) + TMath::Power(0.012 ,2.) ),TMath::Sqrt( TMath::Power(0.000,2.) + TMath::Power(0.000,2.) )}; //FIXME: find a way to give this as input
-//  Double_t systFNorm[9] = {0.026,0.002,0.015,0.019,0.012,0.030,0.015,0.119,0.000};
-//  Double_t systPU[9] = {0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00}; //______pp |eta|<1
-//  Double_t systNofJpsiTot = 0.017;
-  
-  Double_t systRNofJpsi[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  Double_t systFNormInt[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  Double_t systFNormBin[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  
-  TString* nameMB = new TString();
-  TString* nameY = new TString();
-  Int_t deltai(0);
-  for ( Int_t i = 1 ; i <= hy->GetNbinsX() ; i++ )
-  {
-    Int_t iMB = i + deltai;
-    nameMB->Replace(0,nameMB->Sizeof(),hMB->GetXaxis()->GetBinLabel(iMB));
-    nameY->Replace(0,nameY->Sizeof(),hry->GetXaxis()->GetBinLabel(i));
-    
-    // If the spectra had some results wich could not be fitted the corresponding bins are not in hry, producing a missmatchig between the bins in hMB and hry (Because hMB contains all the bins, even if for one bin the Fnorm could not be calculated). So we skip the hMB bin until matches with the hry one:
-
-    while ( nameMB->CompareTo(*nameY) )
+     // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+    
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+    
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sbinType;
+    TObjString* scentrality;
+    
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+    
+    // Pointers
+    TH1* h= 0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+    
+
+    // Loop on each envenType (see MuMuConfig)
+    //==============================================================================
+    while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
     {
-      deltai++;
-      iMB++;
-      nameMB->Replace(0,nameMB->Sizeof(),hMB->GetXaxis()->GetBinLabel(iMB));
-    }
-
-    std::cout << " Computing yield in bin(" << iMB << "): " << nameMB->Data() << " with yield from bin (" << i << "): " << nameY->Data() << std::endl; //Just to check that the bin matching is ok
+        AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+        nextTrigger.Reset();
+        // Loop on each trigger (see MuMuConfig)
+        //==============================================================================
+        while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+        {
+            AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+            nextPairCut.Reset();
+            // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+            //==============================================================================
+            while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+            {
+                AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                nextbinType.Reset();
+                // Loop on each type (pt or y)
+                //==============================================================================
+                while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                {
+                    AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                    nextCentrality.Reset();
 
 
-    Double_t yield = hry->GetBinContent(i)/(hMB->GetBinContent(iMB)*bR);
-    Double_t yieldError = yield*TMath::Sqrt(TMath::Power(hry->GetBinError(i)/hry->GetBinContent(i),2.) +
-                                            TMath::Power(hMB->GetBinError(iMB)/hMB->GetBinContent(iMB),2.) +
-                                            TMath::Power(bRerror/bR,2.));
+                     AliAnalysisMuMuBinning* binning(0x0);
+        
+                    if ( fBinning && sbinType->String().Length() > 0 )
+                    {
+                        binning = fBinning->Project("psi",sbinType->String().Data(),flavour);
+                    }
+                    else
+                    {
+                        binning = new AliAnalysisMuMuBinning;
+                        binning->AddBin("psi",sbinType->String().Data());
+                    }
 
-    std::cout << "Yield = " << yield << " +- " << yieldError << " (stat) " << std::endl;
-    std::cout << std::endl;
-    
-    if ( relative )
-    {
-      yieldError = (yield/yieldInt)*TMath::Sqrt(TMath::Power(yieldError/yield,2.) + TMath::Power(yieldIntError/yieldInt,2.));
-      yield /= yieldInt;
-      
-      Double_t syst = yield*TMath::Sqrt( TMath::Power(systRNofJpsi[i-1],2.) + TMath::Power(systFNormInt[i-1],2.) +
-                                             TMath::Power(systFNormBin[iMB-1],2.) );
-      
-      std::cout << "Relative yield = " << yield << " +- " << yieldError << " (stat) " << " +- " << syst << " (sys) "  << std::endl;
-      std::cout << std::endl;
+                    //Check Binning list
+                    TObjArray* bins = binning->CreateBinObjArray("psi");
+                    if (!bins)
+                    {
+                        AliError(Form("Did not get any bin for particle psi"));
+                        return;
+                    }
+                    // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {  
+                        AliDebug(1,Form("----CENTRALITY %s",scentrality->String().Data()));
+                        // The binning pointer, which point at Pt binning, Y binning etc.
+                        AliAnalysisMuMuBinning::Range* sbin;
+                        TIter next(bins);
+                        next.Reset();
+
+                        // Create ID for the fit which will be used to name results
+                        TString id(Form("/%s/%s/%s/%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data()));
+
+                        // Histo where we put the count
+                        const Double_t * binArrayX = binning->CreateBinArrayX();
+                        Int_t nBinX = binning->GetNBinsX();
+
+                        TH1* hraw = new TH1D(Form("hRawCountVS%s",sbinType->String().Data()),Form("raw count of dimuon pairs for %s",id.Data()),nBinX,binArrayX);
+                        hraw->GetYaxis()->SetTitle(Form("raw count of dimuon pairs in [%0.2f;%0.2f] GeV/c",rlow,rhight));
+                        hraw->GetXaxis()->SetTitle(sbinType->String().Data());
+
+                        //Bin counter
+                        int j = 0;
+                        // Loop on each range in bin 
+                        //==============================================================================
+                        while ( ( sbin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
+                        {
+                            AliDebug(1,Form("-----Bin range %s",sbin->AsString().Data()));
+                            // Create ID for the fit which will be used to name results
+                            TString id(Form("/%s/%s/%s/%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data()));
+                            TString hname = corrected ? Form("MinvUS+%s_AccEffCorr",sbin->AsString().Data()) : Form("MinvUS+%s",sbin->AsString().Data());
+                            
+                            // Pointer to the histo from histo collection
+                            h = OC()->Histo(id.Data(),hname.Data());
+                            if (!h)
+                            {
+                                AliError(Form("Could not find histo %s",hname.Data()));
+                                continue;
+                            }
+
+                            // Get X
+                            Double_t xmin = sbin->Xmin();
+                            Double_t xmax = sbin->Xmax();
+                            Double_t x = xmin + (xmax-xmin)/2;
+                            printf("x = %f \n", x);
+
+                            //find bin
+                            Int_t binLow   = h->FindBin(rlow); 
+                            Int_t binHight = h->FindBin(rhight);
+
+                            if(binLow==0 || binHight ==0)continue; 
+                            // Fill
+                            Double_t rawCount =0.;
+                            for (Int_t i = binLow; i < binHight; ++i)
+                            {
+                                rawCount = rawCount + h->GetBinContent(i);
+                                printf("rawCount for %s in bin [%d]= %f \n",h->GetTitle(),i,rawCount);
+                            }
+                            if(rawCount!=0.)hraw->Fill(x,rawCount);
+
+                            // j++;
+                        }
+                        TH1* o = OC()->Histo(id.Data(),hraw->GetName());
+    
+                        if (o)
+                        {
+                            AliWarning(Form("Replacing %s/%s",id.Data(),hraw->GetName()));
+                            OC()->Remove(Form("%s/%s",id.Data(),hraw->GetName()));
+                        }
+
+                        //Adopt
+                        Bool_t adoptOK = OC()->Adopt(Form("%s",id.Data()),hraw);
+
+                        if ( adoptOK ) std::cout << "+++raw histo " << hraw->GetName() << " adopted" << std::endl;
+                        else AliError(Form("Could not adopt Yield histo %s",hraw->GetName()));
+                        new TCanvas;
+                        hraw->DrawCopy("e0");
+
+                    } 
+                    delete binning;
 
+                }
+            }
+        }
     }
-
-    hy->SetBinContent(i,yield);
-    hy->SetBinError(i,yieldError);
-  }
-
-  delete nameMB;
-  delete nameY;
-
-  o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy->GetName());
-
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s","/RESULTS-%s/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/V0A",hy->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),diffPath.Data(),hy->GetName()));
-  }
-
-  adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy);
-
-  if ( adoptOK ) std::cout << "+++Yield histo " << hy->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hy->GetName()));
-  
-  
-
-//  delete hry;
-
-  
-  return;
+        
+    return;
 }
 
+
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeJpsiMPt(Bool_t relative, const char* evSelInt, const char* evSelDiff,const char* spectra, const char* sResName)
+TH2* AliAnalysisMuMu::ComputeSPDCorrection(const char* type, const char* eventSel, const char* triggerSel, Bool_t bkgReject)
 {
-  // ocMBTrigger is the mergeableCollection with the MB trigger dNchdEta plot (migth be the same as oc, in which case we set ocMBTrigger=0x0)
-  //FIXME::Make it general
-  // Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
-
-
-  TString swhat("");
-  TString sres("");
-  TString sspectra(spectra);
-  TString sevSelInt(evSelInt);
-  TString sevSelDiff(evSelDiff);
-
-  if ( sspectra.Contains("DNCHDETA")) swhat = "dnchdeta";   //FIXME::Make it general for any bin quantity (pt,centrality...)
-  else if ( sspectra.Contains("NTRCORR") ) swhat = "ntrcorr";
-
-  if ( strlen(sResName) > 0 ) sres = sResName; //sres = "MPTPSIPSIPRIMECB2VWG_BKGMPTPOL2";
-
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi <pT>: Is a simulation file");
-    return;
-  }
-  
-  TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
-  TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
-  TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
-  
-  //Path to get/store integrated results from Mergeable Collection
-  TString intPath(Form("%s/%s/%s/%s",
-                       sevSelInt.Data(),
-                       dimuonTriggerClassName.Data(),
-                       centralitySelection.Data(),
-                       pairSelection.Data()));
-  
-  //Path to get/store differential results from Mergeable Collection
-  TString diffPath(Form("%s/%s/%s/%s",
-                        sevSelDiff.Data(),
-                        dimuonTriggerClassName.Data(),
-                        centralitySelection.Data(),
-                        pairSelection.Data()));
-  
-  
-  if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
-
-  //_________Integrated mean pt
-  AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),"PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS")));
-  if ( !sInt )
-  {
-    AliError(Form("No spectra %s found in %s","PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS",intPath.Data()));
-    return;
-  }
-  
-  AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
-  b->AddBin("psi","INTEGRATED");
-  
-  AliAnalysisMuMuBinning::Range* bin = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
-  
-  AliAnalysisMuMuResult* result = sInt->GetResultForBin(*bin);
-  if ( !result )
-  {
-    AliError(Form("No result for bin %s found in spectra %s",bin->AsString().Data(),sInt->GetName()));
-    return;
-  }
-  
-  
-  Double_t JPsiMPtTot = result->GetValue("MeanPtJPsi");
-  Double_t JPsiMPtTotError = result->GetErrorStat("MeanPtJPsi");
-
-  std::cout << "Integrated J/Psi <pT> = " << JPsiMPtTot << " +- " << JPsiMPtTotError << std::endl;
-  std::cout << std::endl;
-
-  TH1* hMPtint = new TH1F("hJPsiMPtInt","Integrated J/#psi mean p_{T}",1,0.,1.);
-  hMPtint->SetBinContent(1,JPsiMPtTot);
-  hMPtint->SetBinError(1,JPsiMPtTotError);
-  
-  TH1* o = OC()->Histo(Form("/RESULTS/%s",intPath.Data()),hMPtint->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing /RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
-    OC()->Remove(Form("/RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
-  }
-  
-  Bool_t adoptOK = OC()->Adopt(Form("/RESULTS/%s",intPath.Data()),hMPtint);
-  
-  if ( adoptOK ) std::cout << "+++Mean Pt histo " << hMPtint->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Mean Pt histo %s",hMPtint->GetName()));
-  
-  delete b;
-
-  //_____Differential mean pt
-
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),spectra)));
-  if ( !s )
-  {
-    AliError(Form("No spectra %s found in %s",spectra,diffPath.Data()));
-    return;
-  }
-
-  std::cout << "Mean pt of J/Psi:" << std::endl;
-  TH1* hrmPt = s->Plot("MeanPtJPsi",sres.Data(),kFALSE); //MPT2CB2VWGPOL2INDEPTAILS//mean pt of Jpsi
-  std::cout << "" << std::endl;
-
-
-  const TArrayD* binArray = hrmPt->GetXaxis()->GetXbins();
-  Int_t size = binArray->GetSize();
-  Double_t* axis = new Double_t[size];
-  
-//  Double_t ptInt,ptIntError;
-  TH1* hmPt;
-  if ( relative )
-  {
-    
-    hmPt = new TH1D(Form("hJPsiMeanPtVS%sRelative",swhat.Data()),Form("Relative J/#psi mean p_{T} vs %s;%s;<p_{T}^{J/#psi}>/<p_{T}^{J/#psi}_{int}>",swhat.Data(),swhat.Data())
-                    ,size-1,axis);
-    
-  }
-  else
-  {
-    hmPt = new TH1D(Form("hJPsiMeanPtVS%s",swhat.Data()),Form("J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}",swhat.Data(),swhat.Data())
-                    ,size-1,axis);
-
-  }
-  
-  delete axis;
-
-  Double_t systMptInt[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //FIXME: find a way to give this as input
-  Double_t systMptBin[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
-  
-  Double_t systMptRel[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //signal extraction pPb
-
-//  Double_t systMptInt[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014}; //FIXME: find a way to give this as input
-//  Double_t systMptBin[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014};
-//
-//  Double_t systMptRel[9] = {0.002,0.001,0.001,0.002,0.002,0.002,0.002,0.004,0.004}; //signal extraction pPb
-  
-  //  Double_t systMptRel[9] = {0.002,0.001,0.012,0.001,0.002,0.002,0.001,0.004,0.003}; //signal extraction Pbp
-  
-  //  Double_t systMptRel[9] = {0.001,0.002,0.001,0.002,0.002,0.003,0.005,0.000,0.000}; //signal extraction pp|eta|<05
-  
-  //  Double_t systMptRel[9] = {0.002,0.002,0.002,0.002,0.001,0.002,0.001,0.012,0.000}; //signal extraction pp|eta|<1
-  
-  for ( Int_t i = 1 ; i <= hrmPt->GetNbinsX() ; i++ )
-  {
-    Double_t pt = hrmPt->GetBinContent(i);
-    Double_t ptError = hrmPt->GetBinError(i);
+    //FIX ME : make it general
+    //
+    //
+    TString stype(type);
+    TString evtype(eventSel);
+    TString trigtype(triggerSel);
+    // >Add centrality and title in the path<
+    TH2* hNch = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NchVsZVertexVsEta",evtype.Data(),
+                                                   trigtype.Data()))); // Input Nch // //"/INPUT/QASPDZPSALL/NchVSEtaVSZVertMC"
+    if ( !hNch )
+        {
+        AliError("No Nch histo found");
+        return 0x0;
+        }
+    // >Add centrality and title in the path<
+    TH2* hNtr = static_cast<TH2*>(OC()->Histo(Form("/%s/%s/V0A/TrackletsVsZVertexVsEta",evtype.Data(),
+                                                   trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
+    if ( !hNtr )
+        {
+        AliError("No tracklets histo found");
+        return 0x0;
+        }
+    // >Add centrality and title in the path<
+    TH2* hNtrBkg = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NBkgTrackletsVsZVertexVsEta",evtype.Data(),
+                                                      trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
+    if ( !hNtrBkg )
+        {
+        AliError("No background tracklets histo found");
+        return 0x0;
+        }
     
-    std::cout << " Computing <pT> in bin " << hrmPt->GetXaxis()->GetBinLabel(i) << std::endl;
-
-    if ( relative )
-    {
-      ptError = TMath::Sqrt(TMath::Power(ptError/JPsiMPtTot,2.) + TMath::Power((pt*JPsiMPtTotError)/TMath::Power(JPsiMPtTot,2.),2.));
-      
-      Double_t sMptInt = JPsiMPtTot*systMptInt[i-1];
-      Double_t sMptBin = pt*systMptBin[i-1];
-      Double_t sysMptRel = TMath::Sqrt( TMath::Power(sMptBin/JPsiMPtTot,2) + TMath::Power(pt*sMptInt/TMath::Power(JPsiMPtTot,2.),2.) );
-      
-      pt /= JPsiMPtTot;
-      
-//      std::cout << TMath::Sqrt( TMath::Power(sysMptRel/pt,2.) +TMath::Power(systMptRel[i-1],2.) ) << std::endl;
-      
-      std::cout << pt << " +- " << ptError << std::endl;
-
-    }
     
-    hmPt->SetBinContent(i,pt);
-    hmPt->SetBinError(i,ptError);
-  }
-  
-  o = fMergeableCollection->Histo(Form("/RESULTS/%s",diffPath.Data()),hmPt->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing /RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
-    fMergeableCollection->Remove(Form("/RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(Form("/RESULTS/%s",diffPath.Data()),hmPt);
-  
-  if ( adoptOK ) std::cout << "+++Mean Pt histo " << hmPt->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt mean pt histo %s",hmPt->GetName()));
-  
-  
-  
-  delete hrmPt;
-  
-  
-  return;
-
+    TH2D* hSPDCorr = static_cast<TH2D*>(hNtr->Clone("SPDCorr"));
+    TString title("");\
+    if ( stype.Contains("oneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction");
+    else if ( stype.Contains("AccEffOnly")) hSPDCorr->SetTitle("SPD AccxEff correction");
+    else if ( stype.Contains("statOneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction stat. unc.");
+    
+    for (Int_t i = 1 ; i < hNch->GetNbinsX() ; i++)
+        {
+        for (Int_t j = 1 ; j < hNch->GetNbinsY() ; j++)
+            {
+            Int_t n = hNch->GetBin(i,j);
+            Double_t nch = hNch->GetBinContent(n);
+            Double_t ntr = hNtr->GetBinContent(n);
+            Double_t nBkgtr(0.);
+            if ( bkgReject ) nBkgtr = hNtrBkg->GetBinContent(n);
+            
+            Double_t corr(0.),corrErr(0.);
+            if ( nch != 0. )
+                {
+                corr = (ntr - nBkgtr)/nch;
+                corrErr = TMath::Max( 1./nch,TMath::Sqrt( corr*(1.-corr)/nch ) );
+                }
+            
+            if ( stype.Contains("oneOverAccEff"))
+                {
+                if ( corr > 0. )
+                    {
+                    hSPDCorr->SetBinContent(n,1./corr);
+                    hSPDCorr->SetBinError(n,corrErr/TMath::Power(corr,2.));
+                    }
+                else
+                    {
+                    hSPDCorr->SetBinContent(n,0.);
+                    hSPDCorr->SetBinError(n,1.);
+                    }
+                
+                }
+            else if ( stype.Contains("AccEffOnly"))
+                {
+                hSPDCorr->SetBinContent(n,corr);
+                hSPDCorr->SetBinError(n,corrErr);
+                }
+            else if ( stype.Contains("statOneOverAccEff"))
+                {
+                if ( corr != 0. )
+                    {
+                    hSPDCorr->SetBinContent(n,(corrErr/TMath::Power(corr,2.)*100)/(1./corr));
+                    }
+                else
+                    {
+                    hSPDCorr->SetBinContent(n,-1);
+                    }
+                
+                }
+            }
+        }
+    
+    return hSPDCorr;
+}
 
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnorm()
+{
+    /// Compute the CMUL to CINT ratio(s)
+    
+    if (!CC()) return;
+    
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM");
+    //Create the object
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());
+    //Compute Fnorm
+    computer.ComputeFnorm();
+    //Let go the ownership
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/");
+    //Update
+    Update();
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeMBXSectionFractionInBins(const char* filePileUpCorr, const char* eventSelection, const char* what,const char* quantity
-                                                      ,const char* flavour)
+void AliAnalysisMuMu::ComputeNumberOfEvent()
 {
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), in bins.
-  ///
-  /// Important considerations:
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly. (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
-  /// Parameters:
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -eventSelection: desired event selection. By default is "PSALL" (no event cuts but physics selection).
+    /// Compute the CMUL to CINT ratio(s)
+    
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeNumberOfEvent                 " << endl;
+        cout <<      " ================================================================ " << endl;
+    }
+    
+    const AliAnalysisMuMuFnorm::ETriggerType triggerTypes[] = { AliAnalysisMuMuFnorm::kMB, AliAnalysisMuMuFnorm::kMUL, AliAnalysisMuMuFnorm::kMSL, AliAnalysisMuMuFnorm::kMSH };
+    const Bool_t trueFalse[] = { kTRUE, kFALSE };
 
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Nevent");
 
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());// here trigger type doesn't count
 
-    while ( in.getline(line,1024,'\n'))
+    for ( Int_t i = 0; i < 4; ++i )
     {
-      TString lrun(line);
-      TString lvalue(line);
-
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
+        for ( Int_t pileup = 0; pileup < 2; ++pileup )
+        {
+          for ( Int_t ps = 0; ps < 2; ++ps )
+          {
+            computer.ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+          }
+        }
+    }
 
-      lvalue.Remove(0,lvalue.First("=")+1);
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Nevent");
+    //Update
+    Update();
+}
 
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnormWeightedMeanGraphs(AliAnalysisMuMuFnorm::ETriggerType refTrigger,const char* patternOrList, const char* graphName )
+{
 
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeFnormWeightedMeanGraphs                 " << endl;
+        cout <<      " ================================================================ " << endl;
     }
-    corrPU = kTRUE;
-  }
-  //________
 
+    // Create array 
+    // TObjArray* pattArray        = TString(patternOrList).Tokenize(",");
+    // TObjArray* graphNameArray     = TString(graphName).Tokenize(",");
+    // TIter nextWhat(pattArray);
+    // TIter nextgraphName(graphNameArray);
+    // TObjString* spatt;
+    // TObjString* sgraphName;
 
-  TString seventSelection(eventSelection);
-  TString sQuantity(quantity);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/WeightedMeanGraphs");
 
-  TIter nextRun(runs);
-  TObjString* s;
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
 
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-    return;
-  }
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Int_t nEntries = bin->GetEntries();
+    computer.WeightedMeanGraphs(patternOrList,graphName,OC());
 
-  Double_t* nCINTBin = new Double_t[nEntries];
-  Double_t nCINTTot = 0. ;
+    // while ( ( spatt = static_cast<TObjString*>(nextWhat()) ) ){
+        
+    //     AliDebug(1,Form("patternOrList %s",spatt->String().Data()));
+    //     nextgraphName.Reset();
 
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(0); // Bin number
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    nCINTBin[i] = 0;
+    //     while ( ( sgraphName = static_cast<TObjString*>(nextgraphName()) ) ){
 
-    std::cout << "______________________________" << std::endl;
-    std::cout << "Bin: " << r->AsString().Data() << std::endl;
+    //         AliDebug(1,Form("graphName %s",sgraphName->String().Data()));
+    //         computer.WeightedMeanGraphs(spatt->String().Data(),sgraphName->String().Data(),OC());
+    //     }
+    // }   
+    
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/WeightedMeanGraphs");
+    //Update
+    Update();
+}
 
-    nextRun.Reset();
-    while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
-    {
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnormScalers(AliAnalysisMuMuFnorm::ETriggerType refTrigger, Bool_t PileUpCorr)
+{
+  /// Compute the MB to REF ratio using the scalers method (from OCDB)
+  ///
+  /// i.e. Fnorm = L0B(MB) x PS(MB) x Fpile-up / ( L0B(REF) x PS(REF) )
+  ///
+  /// where MB is the minbias trigger
+  /// REF is the fReferenceTrigger
+  /// and PS is the fraction of events selected by the physics selection
+  ///
+  /// The correction factor (the two PS and one Fpile-up) are
+  /// taken from graphs computed in other methods
+  ///
 
-      Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT7-B-NOPF-ALLNOTRD/centrality:V0A/run:%s/bin:%s",
-                                         seventSelection.Data(),s->GetName(),r->AsString().Data()));
 
-      Double_t pUfactor = 1.;
-      if ( nCINT !=0. )
-      {
-        if (corrPU)
-        {
-          TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-          if ( p ) pUfactor = p->GetVal();
-          else
-          {
-            AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
-          }
-        }
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeFnormScalers                 " << endl;
+        cout <<      " ================================================================ " << endl;
+    }
 
-        nCINT = nCINT*pUfactor;
-      }
-      else
-      {
-        std::cout << " Warning: Run " << s->GetName() << " has no MB trigger in this bin" << std::endl;
-        continue;
-      }
-      nCINTBin[i] += nCINT;
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Scaler");
 
-      std::cout << "Run " << s->GetName() <<  " ; " << "Nof CINT = " << nCINT << std::endl;
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
 
+    computer.ComputeFnormScalers(kFALSE,0);
+    if(PileUpCorr){
+        computer.ComputeFnormScalers(kTRUE,0);
+        computer.ComputeFnormScalers(kTRUE,1);
     }
 
-    nCINTTot += nCINTBin[i];
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Scaler");
+    //Update
+    Update();
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeIntFnormFromCounters(AliAnalysisMuMuFnorm::ETriggerType refTrigger, Bool_t PileUpCorr)
+{
+ /// Compute the CMUL to CINT ratio(s) in 1 or 2 steps (Offline method) from the CC(), in bins.
+ ///
+ /// Important considerations:
+ ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
+ ///   FIX ME : quantity not define in CC() for "pt" and "y".
 
-    std::cout << std::endl;
 
-    std::cout << "Nof CINT in bin = " << nCINTBin[i]  << std::endl;
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeIntFnormFromCounters                 " << endl;
+        cout <<      " ================================================================ " << endl;
+    }
 
-    i++;
-  }
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Offline");
 
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
 
-  nextBin.Reset();
-  i=0;
-  Double_t totXSectFract(0.);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
-  {
-    Double_t xSecFract = (nCINTBin[i] / nCINTTot)*100.;
+    computer.ComputeFnormOffline(1,kFALSE,0); // CINT/CINT&0MUL
+    computer.ComputeFnormOffline(1,kFALSE,1); // CINT/CINT&0MUL + Event selection corrected
+    if(PileUpCorr) computer.ComputeFnormOffline(1,kTRUE,1); // CINT/CINT&0MUL + Event selection corrected + pileup correction
+  
+    computer.ComputeFnormOffline(2,kFALSE,0); // CMSL/CMSL&0MUL x CINT/CINT&0MSL
+    computer.ComputeFnormOffline(2,kFALSE,1); // CMSL/CMSL&0MUL x CINT/CINT&0MSL + Event selection corrected
+    if(PileUpCorr) computer.ComputeFnormOffline(2,kTRUE,1); // CMSL/CMSL&0MUL x CINT/CINT&0MSL+ Event selection corrected + pileup correction
 
-    totXSectFract += xSecFract;
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Offline/");
+    //Update
+    Update();
+}
 
-    std::cout << "Cross section Fraction in bin " << r->AsString().Data() << " = " << xSecFract  << std::endl;
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeMeanFnorm(const char* triggerCluster, const char* eventSelection, const char* what,const char* quantity,const char* flavour)
+{
+    /// Compute the mean Fnorm and mean NMB from the "offline" and "rescaled global" methods.
+    ///
+    /// Parameters:
+    ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
+    ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
+    ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
+    ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
+    ///   -quantity: binning type. By default "ntrcorr"
+    ///   -flavour: binning flavour. By default "D2H"
+    
+    TString seventSelection(eventSelection);
+    TString striggerCluster(triggerCluster);
+    TString sQuantity(quantity);
+    if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
+    else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
+    else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
+    else
+        {
+        AliError("Unknown trigger cluster");
+        return;
+        }
+    
+    TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
+    if ( triggerType.Contains("7-") ) triggerType = "7";
+    else if ( triggerType.Contains("8-") ) triggerType = "8";
+    else
+        {
+        AliError("Unknown trigger type");
+        return;
+        }
+    
+    TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
+    if ( colType.Contains("-B-") ) colType = "B";
+    else if ( colType.Contains("-S-") ) colType = "S";
+    else
+        {
+        AliError("Unknown collision type");
+        return;
+        }
+    
+    TH1* hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMB )
+        {
+        AliError(Form("Histo hNofEqMBVS%s not found",sQuantity.Data()));
+        return;
+        }
+    
+    TH1* hMBG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMBG )
+        {
+        AliError(Form("Histo hNofEqMBVS%sFromGlobal not found",sQuantity.Data()));
+        return;
+        }
+    
+    TH1* hFnorm = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMB )
+        {
+        AliError(Form("Histo hFNormVS%s not found",sQuantity.Data()));
+        return;
+        }
+    
+    TH1* hFnormG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMBG )
+        {
+        AliError(Form("Histo hFNormVS%sFromGlobal not found",sQuantity.Data()));
+        return;
+        }
+    
+    
+    //  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
+    //  if ( !binning )
+    //  {
+    //    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
+    //    return;
+    //  }
+    //  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
+    
+    
+    TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelection.Data()));
+    
+    TH1* hMBMean = static_cast<TH1*>(hMBG->Clone());
+    hMBMean->SetName(Form("hNofEqMBVS%sFromMean",sQuantity.Data()));
+    
+    TH1* hFnormMean = static_cast<TH1*>(hFnorm->Clone());
+    hFnormMean->SetName(Form("hFNormVS%sFromMean",sQuantity.Data()));
+    
+    for ( Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
+        {
+        //______Mean NofMB computation
+        Double_t Fn = hMB->GetBinContent(i);
+        Double_t Fng = hMBG->GetBinContent(i);
+        
+        Double_t FnE = hMB->GetBinError(i);
+        Double_t FngE = hMBG->GetBinError(i);
+        //
+        //    Double_t meanBin = (Fn + Fng) / 2.;
+        //    Double_t meanBinError = TMath::Sqrt( TMath::Power(FnE/2.,2.) + TMath::Power(FngE/2.,2.) );
+        //    Double_t meanBinSys = TMath::Abs( meanBin - Fn );
+        
+        Double_t meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
+        Double_t meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
+        Double_t meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
+        
+        std::cout << "Bin : " << hMB->GetXaxis()->GetBinLabel(i) << std::endl;
+        
+        std::cout << " Mean NMB = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
+        << "%))" << std::endl;
+        
+        hMBMean->SetBinContent(i,meanBin);
+        hMBMean->SetBinError(i,meanBinError);
+        //______
+        
+        
+        //______Mean FNorm computation
+        Fn = hFnorm->GetBinContent(i);
+        Fng = hFnormG->GetBinContent(i);
+        
+        FnE = hFnorm->GetBinError(i);
+        FngE = hFnormG->GetBinError(i);
+        
+        meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
+        meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
+        meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
+        
+        //    Double_t nCMULBin = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
+        //                                          seventSelection.Data(),triggerType.Data(),colType.Data(),
+        //                                          static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(i-1))->AsString().Data()));
+        //
+        //    if (printout) std::cout << meanBinSys/nCMULBin << std::endl;
+        //
+        //    Double_t meanFnBin = meanBin/nCMULBin;
+        //    Double_t meanFnBinError = TMath::Sqrt( TMath::Power(meanBinError/nCMULBin,2) + TMath::Power(meanBin/TMath::Power(nCMULBin,2.),2) );
+        //
+        //    if (printout) std::cout << meanBinSys/nCMULBin/meanFnBin << std::endl;
+        //
+        //    if (printout) std::cout << meanFnBin << " +- " << meanFnBinError << std::endl;
+        
+        std::cout << " Mean FNorm = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
+        << "%)" << std::endl;
+        std::cout << std::endl;
+        
+        hFnormMean->SetBinContent(i,meanBin);
+        hFnormMean->SetBinError(i,meanBinError);
+        //______
+        }
+    
+    TH1* o = fMergeableCollection->Histo(id.Data(),hMBMean->GetName());
+    
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s",id.Data(),hMBMean->GetName()));
+        fMergeableCollection->Remove(Form("%s/%s",id.Data(),hMBMean->GetName()));
+        }
+    
+    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hMBMean);
+    
+    if ( adoptOK ) std::cout << "+++FNorm histo " << hMBMean->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt FNorm histo %s",hMBMean->GetName()));
+    
+    
+    o = fMergeableCollection->Histo(id.Data(),hFnormMean->GetName());
+    
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s",id.Data(),hFnormMean->GetName()));
+        fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFnormMean->GetName()));
+        }
+    
+    adoptOK = fMergeableCollection->Adopt(id.Data(),hFnormMean);
+    
+    if ( adoptOK ) std::cout << "+++FNorm histo " << hFnormMean->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt FNorm histo %s",hFnormMean->GetName()));
+    
+    
+}
 
-    i++;
-  }
 
-  std::cout << std::endl;
-  std::cout << "Total xSection in bins = " << totXSectFract  << std::endl;
+//_____________________________________________________________________________
+void AliAnalysisMuMu::PlotYiedWSyst(const char* triggerCluster)
+{
+    // Add syst. to yield and plot it
+    //
+    // FIX ME : make me more general
+    TString striggerCluster(triggerCluster);
+    if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
+    else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
+    else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
+    else
+        {
+        AliError("Unknown trigger cluster");
+        return;
+        }
+    
+    
+    TString path(Form("%s/%s/%s/%s",
+                      Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
+                      Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
+    
+    TH1* hY = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),path.Data()),"hJPsiYieldVSdNchdEtaRelative");
+    if ( !hY )
+        {
+        AliError("No yield found");
+        return;
+        }
+    
+    TString id(Form("/TESTSYST/%s",path.Data()));
+    
+    TH1* hYSyst = static_cast<TH1*>(hY->Clone("RelYieldSyst"));
+    if ( !hYSyst )
+        {
+        AliError("No systematic found");
+        return;
+        }
+    
+    TH1* hS = OC()->Histo(id.Data(),"yield_Systematics");
+    
+    for ( Int_t i = 1 ; i <= hY->GetNbinsX() ; i++ )
+        {
+        hYSyst->SetBinError(i,hS->GetBinContent(i)*hY->GetBinContent(i)/100.);
+        }
+    
+    hY->Draw();
+    hYSyst->Draw("same");
+}
 
-  delete binning;
-  delete runs;
-  delete bin;
-  delete[] nCINTBin;
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeJpsiYield(const char* binType, const char* what, const char* externfile, const char* externfile2, const char* sResName, const char* beamYear, Bool_t AccEffCorr)
+{
+    /// Compute the Jpsi yield, i.e NofJPsi/Fnorm. Delegate procedure to the right capsule object. It can be compute for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
+    ///
+    /// Parameters:
+    ///   -binType    : INTEGRATED, PT, Y (for now)
+    ///   -what       : The quantity divided by FNorm (NofJPsi by default, but could be something else...)
+    ///   -externfile : For the capsule
+    ///   -externfile2: For the capsule
+    ///   -AccEffCorr : Just a tag to select right histograms.
+    ///   -sResName   : subresult name to get the yield from. By default is "" (mean of all subresults)
+    
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputeJpsiYield                           " << endl;
+        cout <<      " ================================================================ " << endl;
+        }
+    
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+    
+    
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+    
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* swhat;
+    TObjString* sbinType;
+    TObjString* scentrality;
+    
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+    const TString syear(beamYear);
+    
+    
+    
+    // Pointers
+    TH1* h= 0x0;
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphCent=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+    
+    //Loop on what type
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
+        {
+        AliDebug(1,Form("what %s",swhat->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                        
+                        //canvas
+                        TCanvas *c1 = new TCanvas;
+                        c1->Draw();
+                        gStyle->SetOptStat(0);
+                        
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                            {
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+                            
+                            //________Get Fnorm Histo
+                            TString id(Form("/FNORM-%s/%s/%s/%s",striggerDimuon->String().Data(),seventType->String().Data(),scentrality->String().Data(),syear.Data())); // Path to save the Fnorm and EqNofMB histos in the mergeable collection
+                            
+                            TString idHisto="";
+                            if (!sbinType->String().Contains("INTEGRATED")) idHisto= Form("hNofEqMBVS%s",sbinType->String().Data());
+                            else if (sbinType->String().Contains("INTEGRATED")) idHisto= Form("hFNormInt_%s",striggerMB.Data());
+                            
+                            h = OC()->Histo(Form("%s/%s",id.Data(),idHisto.Data()));
+                            if (!h)
+                                {
+                                AliError(Form("Could not find histo in %s/%s",id.Data(),idHisto.Data()));
+                                return;
+                                }
+                            //________
+                            
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),"PSI",sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+                            
+                            //________Select methods
+                            if(syear.Contains("PbPb"))
+                                {
+                                
+                                
+                                    AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,externfile,externfile2);
+                                    AliDebug(1,Form("Spectra = %p",capsule));
+                                
+                                    // Get Graph with Yield results
+                                    graph = capsule->ComputeYield(swhat->String().Data(),h,sResName);
+                                
+                                    TLegend * leg = new TLegend(0.4,0.7,0.90,0.9);
+                                    leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=2.76 TeV, L_{int}=70 #mub^{-1}, %s",scentrality->String().Data()));
+                                    leg->AddEntry(graph,"Inclusive J/#psi Yield","pe");
+                                    graph->Draw("ap");
+                                    leg->Draw();
+                                
+                                    delete capsule;
+                                }
+                            else if(syear.Contains("pPb") || syear.Contains("Pbp"))
+                                {
+                                AliAnalysisMuMuSpectraCapsulePbP * capsule = new AliAnalysisMuMuSpectraCapsulePbP(spectra,spectraPath,externfile,externfile2);
+                                AliDebug(1,Form("Spectra = %p",capsule));
+                                
+                                // Get Graph with Yield results
+                                graph = capsule->ComputeYield(swhat->String().Data(),h,sResName);
+                                
+                                TLegend * leg = new TLegend(0.4,0.7,0.90,0.9);
+                                leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=2.76 TeV, L_{int}=70 #mub^{-1}, %s",scentrality->String().Data()));
+                                leg->AddEntry(graph,"Inclusive J/#psi Yield","pe");
+                                graph->Draw("ap");
+                                leg->Draw();
+                                
+                                delete capsule;
+                                }
+                            else if(syear.Contains("pp"))
+                                {
+                                AliError("No method implemented for this beam yet, but you're welcome to do it !");
+                                return;
+                                }
+                            
+                            //________ Update resultes in Mergeable collection
+                            TString id2(Form("/JpsiYield-%s/%s/%s/%s/%s",striggerDimuon->String().Data(),seventType->String().Data(),spairCut->String().Data(),sbinType->String().Data(),swhat->String().Data()));
+                            
+                            TObject* o = 0x0;
+                            
+                            if (graph)// first graph
+                                {
+                                o = fMergeableCollection->GetObject(Form("%s/%s",id2.Data(),graph->GetName()));
+                                
+                                if (o)
+                                    {
+                                    AliWarning(Form("Replacing %s/%s",id2.Data(),graph->GetName()));
+                                    fMergeableCollection->Remove(Form("%s/%s",id2.Data(),graph->GetName()));
+                                    }
+                                
+                                Bool_t adoptOK = fMergeableCollection->Adopt(id2.Data(),graph);
+                                
+                                if ( adoptOK ) std::cout << "+++JpsiYield graph " << graph->GetName() << " adopted" << std::endl;
+                                else AliError(Form("Could not adopt JpsiYield grap %s",graph->GetName()));
+                                }
+                            //________
+                            
+                            
+                            
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    
+    return;
+}
 
-  return;
-  
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeJpsiMPt(Bool_t relative, const char* evSelInt, const char* evSelDiff,const char* spectra, const char* sResName)
+{
+    // ocMBTrigger is the mergeableCollection with the MB trigger dNchdEta plot (migth be the same as oc, in which case we set ocMBTrigger=0x0)
+    //FIXME::Make it general
+    // Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
+    
+    
+    TString swhat("");
+    TString sres("");
+    TString sspectra(spectra);
+    TString sevSelInt(evSelInt);
+    TString sevSelDiff(evSelDiff);
+    
+    if ( sspectra.Contains("DNCHDETA")) swhat = "dnchdeta";   //FIXME::Make it general for any bin quantity (pt,centrality...)
+    else if ( sspectra.Contains("NTRCORR") ) swhat = "ntrcorr";
+    
+    if ( strlen(sResName) > 0 ) sres = sResName; //sres = "MPTPSIPSIPRIMECB2VWG_BKGMPTPOL2";
+    
+    if ( IsSimulation() )
+        {
+        AliError("Cannot compute J/Psi <pT>: Is a simulation file");
+        return;
+        }
+    TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
+    TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
+    TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
+    
+    TString intPath(Form("%s/%s/%s/%s",
+                         sevSelInt.Data(),
+                         dimuonTriggerClassName.Data(),
+                         centralitySelection.Data(),
+                         pairSelection.Data())); //Path to store integrated result in Mergeable Collection
+    
+    TString diffPath(Form("%s/%s/%s/%s",
+                          sevSelDiff.Data(),
+                          dimuonTriggerClassName.Data(),
+                          centralitySelection.Data(),
+                          pairSelection.Data())); //Path to store differential result in Mergeable Collection
+    
+    if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
+    
+    //_________Integrated mean pt
+    AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),"PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS")));
+    if ( !sInt )
+        {
+        AliError(Form("No spectra %s found in %s","PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS",intPath.Data()));
+        return;
+        }
+    
+    AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
+    b->AddBin("psi","INTEGRATED");
+    
+    AliAnalysisMuMuBinning::Range* bin = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
+    
+    AliAnalysisMuMuResult* result = sInt->GetResultForBin(*bin);
+    if ( !result )
+        {
+        AliError(Form("No result for bin %s found in spectra %s",bin->AsString().Data(),sInt->GetName()));
+        return;
+        }
+    
+    
+    Double_t JPsiMPtTot = result->GetValue("MeanPtJPsi");
+    Double_t JPsiMPtTotError = result->GetErrorStat("MeanPtJPsi");
+    
+    std::cout << "Integrated J/Psi <pT> = " << JPsiMPtTot << " +- " << JPsiMPtTotError << std::endl;
+    std::cout << std::endl;
+    
+    TH1* hMPtint = new TH1F("hJPsiMPtInt","Integrated J/#psi mean p_{T}",1,0.,1.);
+    hMPtint->SetBinContent(1,JPsiMPtTot);
+    hMPtint->SetBinError(1,JPsiMPtTotError);
+    
+    TH1* o = OC()->Histo(Form("/RESULTS/%s",intPath.Data()),hMPtint->GetName());
+    
+    if (o)
+        {
+        AliWarning(Form("Replacing /RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
+        OC()->Remove(Form("/RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
+        }
+    
+    Bool_t adoptOK = OC()->Adopt(Form("/RESULTS/%s",intPath.Data()),hMPtint);
+    
+    if ( adoptOK ) std::cout << "+++Mean Pt histo " << hMPtint->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt Mean Pt histo %s",hMPtint->GetName()));
+    
+    delete b;
+    
+    //_____Differential mean pt
+    
+    AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),spectra)));
+    if ( !s )
+        {
+        AliError(Form("No spectra %s found in %s",spectra,diffPath.Data()));
+        return;
+        }
+    
+    std::cout << "Mean pt of J/Psi:" << std::endl;
+    TH1* hrmPt = s->Plot("MeanPtJPsi",sres.Data(),kFALSE); //MPT2CB2VWGPOL2INDEPTAILS//mean pt of Jpsi
+    std::cout << "" << std::endl;
+    
+    
+    const TArrayD* binArray = hrmPt->GetXaxis()->GetXbins();
+    Int_t size = binArray->GetSize();
+    Double_t* axis = new Double_t[size];
+    
+    //  Double_t ptInt,ptIntError;
+    TH1* hmPt;
+    if ( relative )
+        {
+        //    TString path2(Form("/%s/%s/%s",
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kEventSelectionList,kFALSE)).Data(),
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kMinbiasTriggerList,kFALSE)).Data(),
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kCentralitySelectionList,kFALSE)).Data()));
+        //
+        //    TH1* hdNch = OC()->Histo(path2.Data(),swhat.Data());
+        
+        
+        
+        hmPt = new TH1D(Form("hJPsiMeanPtVS%sRelative",swhat.Data()),Form("Relative J/#psi mean p_{T} vs %s;%s;<p_{T}^{J/#psi}>/<p_{T}^{J/#psi}_{int}>",swhat.Data(),swhat.Data())
+                        ,size-1,axis);
+        
+        //
+        //    ptInt = result->GetValue("MeanPtJPsi",sres.Data());
+        //    ptIntError = result->GetErrorStat("MeanPtJPsi",sres.Data());
+        
+        }
+    else
+        {
+        hmPt = new TH1D(Form("hJPsiMeanPtVS%s",swhat.Data()),Form("J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}",swhat.Data(),swhat.Data())
+                        ,size-1,axis);
+        
+        //    hmPt = static_cast<TH1D*>(hrmPt->Clone("hJPsiMeanPtVSdNchdEta"));
+        //    hmPt->SetTitle("J/#psi mean p_{T} vs dN_{ch}/d#eta");
+        //    hmPt->GetXaxis()->SetTitle("dN_{ch}/d#eta");
+        //    hmPt->GetYaxis()->SetTitle("<p_{T}^{J/#psi}>");
+        }
+    
+    delete axis;
+    
+    Double_t systMptInt[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //FIXME: find a way to give this as input
+    Double_t systMptBin[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
+    
+    Double_t systMptRel[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //signal extraction pPb
+    
+    //  Double_t systMptInt[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014}; //FIXME: find a way to give this as input
+    //  Double_t systMptBin[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014};
+    //
+    //  Double_t systMptRel[9] = {0.002,0.001,0.001,0.002,0.002,0.002,0.002,0.004,0.004}; //signal extraction pPb
+    
+    //  Double_t systMptRel[9] = {0.002,0.001,0.012,0.001,0.002,0.002,0.001,0.004,0.003}; //signal extraction Pbp
+    
+    //  Double_t systMptRel[9] = {0.001,0.002,0.001,0.002,0.002,0.003,0.005,0.000,0.000}; //signal extraction pp|eta|<05
+    
+    //  Double_t systMptRel[9] = {0.002,0.002,0.002,0.002,0.001,0.002,0.001,0.012,0.000}; //signal extraction pp|eta|<1
+    
+    for ( Int_t i = 1 ; i <= hrmPt->GetNbinsX() ; i++ )
+        {
+        Double_t pt = hrmPt->GetBinContent(i);
+        Double_t ptError = hrmPt->GetBinError(i);
+        
+        std::cout << " Computing <pT> in bin " << hrmPt->GetXaxis()->GetBinLabel(i) << std::endl;
+        
+        if ( relative )
+            {
+            ptError = TMath::Sqrt(TMath::Power(ptError/JPsiMPtTot,2.) + TMath::Power((pt*JPsiMPtTotError)/TMath::Power(JPsiMPtTot,2.),2.));
+            
+            Double_t sMptInt = JPsiMPtTot*systMptInt[i-1];
+            Double_t sMptBin = pt*systMptBin[i-1];
+            Double_t sysMptRel = TMath::Sqrt( TMath::Power(sMptBin/JPsiMPtTot,2) + TMath::Power(pt*sMptInt/TMath::Power(JPsiMPtTot,2.),2.) );
+            
+            pt /= JPsiMPtTot;
+            
+            //      std::cout << TMath::Sqrt( TMath::Power(sysMptRel/pt,2.) +TMath::Power(systMptRel[i-1],2.) ) << std::endl;
+            
+            std::cout << pt << " +- " << ptError << std::endl;
+            
+            }
+        
+        hmPt->SetBinContent(i,pt);
+        hmPt->SetBinError(i,ptError);
+        }
+    
+    o = fMergeableCollection->Histo(Form("/RESULTS/%s",diffPath.Data()),hmPt->GetName());
+    
+    if (o)
+        {
+        AliWarning(Form("Replacing /RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
+        fMergeableCollection->Remove(Form("/RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
+        }
+    
+    adoptOK = fMergeableCollection->Adopt(Form("/RESULTS/%s",diffPath.Data()),hmPt);
+    
+    if ( adoptOK ) std::cout << "+++Mean Pt histo " << hmPt->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt mean pt histo %s",hmPt->GetName()));
+    
+    
+    
+    delete hrmPt;
+    
+    
+    return;
+    
+    
 }
 
 //_____________________________________________________________________________
-Double_t AliAnalysisMuMu::ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d)
+void AliAnalysisMuMu::ComputeMBXSectionFractionInBins(const char* filePileUpCorr, const char* eventSelection, const char* what,const char* quantity
+                                                      ,const char* flavour)
 {
-  //Just valid for counts
-  Double_t error2 = TMath::Power(b/(c*d),2.)*a + TMath::Power(a/(c*d),2.)*b + TMath::Power(a*b*d,2.)*(c/TMath::Power(c*d,4.)) + TMath::Power(a*b*c,2.)*(d/TMath::Power(c*d,4.));
-  
-  return TMath::Sqrt(error2);
+    /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), in bins.
+    ///
+    /// Important considerations:
+    ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
+    ///
+    ///   - The analysed file must contain the event selection PSALL and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly. (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
+    ///
+    /// Parameters:
+    ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
+    ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
+    ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
+    ///   -quantity: binning type. By default "ntrcorr"
+    ///   -flavour: binning flavour. By default "D2H"
+    ///   -eventSelection: desired event selection. By default is "PSALL" (no event cuts but physics selection).
+    
+    
+    //________Decoding of the pileup correction file
+    Bool_t corrPU(kFALSE);
+    TObjArray* pUCorr = new TObjArray();
+    if ( strlen(filePileUpCorr) > 0 )
+        {
+        std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
+        char line[1024];
+        ifstream in(filePileUpCorr);
+        
+        while ( in.getline(line,1024,'\n'))
+            {
+            TString lrun(line);
+            TString lvalue(line);
+            
+            lrun.Remove(0,4);
+            lrun.Remove(6,67);
+            
+            lvalue.Remove(0,lvalue.First("=")+1);
+            
+            std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
+            
+            pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
+            }
+        corrPU = kTRUE;
+        }
+    //________
+    
+    
+    TString seventSelection(eventSelection);
+    TString sQuantity(quantity);
+    TString sruns = CC()->GetKeyWords("run");
+    TObjArray* runs = sruns.Tokenize(",");
+    
+    TIter nextRun(runs);
+    TObjString* s;
+    
+    AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
+    if ( !binning )
+        {
+        AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
+        return;
+        }
+    TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
+    Int_t nEntries = bin->GetEntries();
+    
+    Double_t* nCINTBin = new Double_t[nEntries];
+    Double_t nCINTTot = 0. ;
+    
+    TIter nextBin(bin);
+    AliAnalysisMuMuBinning::Range* r;
+    Int_t i(0); // Bin number
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
+        {
+        nCINTBin[i] = 0;
+        
+        std::cout << "______________________________" << std::endl;
+        std::cout << "Bin: " << r->AsString().Data() << std::endl;
+        
+        nextRun.Reset();
+        while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
+            {
+            
+            Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT7-B-NOPF-ALLNOTRD/centrality:V0A/run:%s/bin:%s",
+                                               seventSelection.Data(),s->GetName(),r->AsString().Data()));
+            
+            Double_t pUfactor = 1.;
+            if ( nCINT !=0. )
+                {
+                if (corrPU)
+                    {
+                    TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
+                    if ( p ) pUfactor = p->GetVal();
+                    else
+                        {
+                        AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
+                        }
+                    }
+                
+                nCINT = nCINT*pUfactor;
+                }
+            else
+                {
+                std::cout << " Warning: Run " << s->GetName() << " has no MB trigger in this bin" << std::endl;
+                continue;
+                }
+            nCINTBin[i] += nCINT;
+            
+            std::cout << "Run " << s->GetName() <<  " ; " << "Nof CINT = " << nCINT << std::endl;
+            
+            }
+        
+        nCINTTot += nCINTBin[i];
+        
+        std::cout << std::endl;
+        
+        std::cout << "Nof CINT in bin = " << nCINTBin[i]  << std::endl;
+        
+        i++;
+        }
+    
+    
+    nextBin.Reset();
+    i=0;
+    Double_t totXSectFract(0.);
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
+        {
+        Double_t xSecFract = (nCINTBin[i] / nCINTTot)*100.;
+        
+        totXSectFract += xSecFract;
+        
+        std::cout << "Cross section Fraction in bin " << r->AsString().Data() << " = " << xSecFract  << std::endl;
+        
+        i++;
+        }
+    
+    std::cout << std::endl;
+    std::cout << "Total xSection in bins = " << totXSectFract  << std::endl;
+    
+    delete binning;
+    delete runs;
+    delete bin;
+    delete[] nCINTBin;
+    
+    return;
+    
 }
 
 //_____________________________________________________________________________
-TH1* AliAnalysisMuMu::ComputeEquNofMB(const char* what,const char* quantity,const char* flavour,Bool_t printout)
+Double_t AliAnalysisMuMu::ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d)
 {
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  TObjArray* dNchdEtas = binning->CreateBinObjArray();
-  
-  Double_t* binArray = binning->CreateBinArray();
-  
-  TIter next(dNchdEtas);
-  AliAnalysisMuMuBinning::Range* r;
-  
-  TH1* hFNorm = ComputeDiffFnormFromHistos(what,quantity,flavour,kFALSE);
-  
-  TH1* hNMB = new TH1F("hNofEqMB","Equivalent number of MB triggers vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
-  
-  Int_t bin(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    
-    TH1* hCMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMUL7-B-NOPF-MUON/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMUL )
-    {
-      AliError(Form("No event histo in bin %s found for CMUL7-B-NOPF-MUON",r->AsString().Data()));
-      return 0x0;
-    }
+    //Just valid for counts
+    Double_t error2 = TMath::Power(b/(c*d),2.)*a + TMath::Power(a/(c*d),2.)*b + TMath::Power(a*b*d,2.)*(c/TMath::Power(c*d,4.)) + TMath::Power(a*b*c,2.)*(d/TMath::Power(c*d,4.));
     
-    Double_t NMB = hCMUL->GetBinContent(1)*hFNorm->GetBinContent(++bin);
-    Double_t NMBError = TMath::Sqrt(TMath::Power(hCMUL->GetBinContent(1)*hFNorm->GetBinError(bin),2.) + TMath::Power(TMath::Sqrt(hCMUL->GetBinContent(1))*hFNorm->GetBinContent(bin),2));
-    
-    if ( printout ) std::cout << r->AsString().Data() << " : " << NMB << " +- " << NMBError << std::endl;
-    
-    hNMB->SetBinContent(bin,NMB);
-    hNMB->SetBinError(bin,NMBError);
-  }
-  
-  delete dNchdEtas;
-  delete[] binArray;
-  
-  return hNMB;
+    return TMath::Sqrt(error2);
 }
 
+// //_____________________________________________________________________________
+// TH1* AliAnalysisMuMu::ComputeEquNofMB(const char* what,const char* quantity,const char* flavour,Bool_t printout)
+// {
+//   //Compute Equivalent Numbre of MB bin by bin 
+//  
+//   // Get binning
+//   AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
+//  
+//   // Copy binning array
+//   TObjArray* dNchdEtas = binning->CreateBinObjArray();
+//   Double_t* binArray = binning->CreateBinArray();
+//  
+//   TIter next(dNchdEtas);
+//   AliAnalysisMuMuBinning::Range* r;
+//  
+//   TH1* hFNorm = ComputeDiffFnormFromHistos(what,quantity,flavour,kFALSE);
+//  
+//   TH1* hNMB = new TH1F("hNofEqMB","Equivalent number of MB triggers vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
+//  
+//   Int_t bin(0);
+//   while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+//   {
+//    
+//     TH1* hCMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMUL7-B-NOPF-MUON/V0A/%s",
+//                                   Form("EventsIn%s",r->AsString().Data())));
+//     if ( !hCMUL )
+//     {
+//       AliError(Form("No event histo in bin %s found for CMUL7-B-NOPF-MUON",r->AsString().Data()));
+//       return 0x0;
+//     }
+//    
+//     Double_t NMB = hCMUL->GetBinContent(1)*hFNorm->GetBinContent(++bin);
+//     Double_t NMBError = TMath::Sqrt(TMath::Power(hCMUL->GetBinContent(1)*hFNorm->GetBinError(bin),2.) + TMath::Power(TMath::Sqrt(hCMUL->GetBinContent(1))*hFNorm->GetBinContent(bin),2));
+//    
+//     if ( printout ) std::cout << r->AsString().Data() << " : " << NMB << " +- " << NMBError << std::endl;
+//    
+//     hNMB->SetBinContent(bin,NMB);
+//     hNMB->SetBinError(bin,NMBError);
+//   }
+//  
+//   delete dNchdEtas;
+//   delete[] binArray;
+//  
+//   return hNMB;
+// }
+
 
 //_____________________________________________________________________________
 AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const char* flavour)
 {
-  /// Correct one spectra
-  
-  if (!SIM())
-  {
-    AliError("Cannot compute corrected yield without associated MC file !");
-    return 0x0;
-  }
-
-  const char* accEffSubResultName="PSICOUNT:1";
-  
-  AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
-  AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
-  
-  if ( !realSpectra )
-  {
-    AliError("could not get real spectra");
-    return 0x0;
-  }
-  
-  if ( !simSpectra)
-  {
-    AliError("could not get sim spectra");
-    return 0x0;
-  }
-  
-  realSpectra->Correct(*simSpectra,"Jpsi",accEffSubResultName);
-
-  Update();
-  
-  return realSpectra;
+    /// Correct one spectra
+    
+    if (!SIM())
+        {
+        AliError("Cannot compute corrected yield without associated MC file !");
+        return 0x0;
+        }
+    
+    const char* accEffSubResultName="PSICOUNT:1";
+    
+    AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
+    AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
+    
+    if ( !realSpectra )
+        {
+        AliError("could not get real spectra");
+        return 0x0;
+        }
+    
+    if ( !simSpectra)
+        {
+        AliError("could not get sim spectra");
+        return 0x0;
+        }
+    
+    realSpectra->Correct(*simSpectra,"Jpsi",accEffSubResultName);
+    
+    Update();
+    
+    return realSpectra;
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const char* flavour)
 {
-  if (!SIM())
-  {
-    AliError("Cannot compute corrected yield without associated MC file !");
-    return 0x0;
-  }
-  
-  const char* accEffSubResultName="PSICOUNT:1";
-  
-  AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
-  
-  if ( !realSpectra )
-  {
-    AliError("could not get real spectra");
-    return 0x0;
-  }
-  
-  if (!realSpectra->HasValue("CoffNofJpsi"))
-  {
-    if (!CorrectSpectra(type,flavour))
-    {
-      AliError("Could not get corrected spectra");
-      return 0x0;
-    }
-  }
-  
-  AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
-  
-  if ( !simSpectra)
-  {
-    AliErrorClass("could not get sim spectra");
-    return 0x0;
-  }
-  
-  Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
-  Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
-  Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
-  
-  AliAnalysisMuMuBinning* binning = realSpectra->Binning();
-  TObjArray* bins = binning->CreateBinObjArray();
-  TIter nextBin(bins);
-  AliAnalysisMuMuBinning::Range* bin;
-  Int_t i(0);
-  AliAnalysisMuMuJpsiResult* r;
-  
-  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
-  {
-    r = static_cast<AliAnalysisMuMuJpsiResult*>(realSpectra->BinContentArray()->At(i));
-   
-    StdoutToAliDebug(1,std::cout << "bin=";r->Print(););
+    // Compute yield from simulation file
+    // 
+    // FIX ME: make it general
+    
+    if (!SIM())
+        {
+        AliError("Cannot compute corrected yield without associated MC file !");
+        return 0x0;
+        }
     
-    AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
+    const char* accEffSubResultName="PSICOUNT:1";
     
-    Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
-    Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                                                nofCINT7,TMath::Sqrt(nofCINT7),
-                                                                nofCMUL7,TMath::Sqrt(nofCMUL7));
+    AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
+    
+    if ( !realSpectra )
+        {
+        AliError("could not get real spectra");
+        return 0x0;
+        }
     
-    r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                                                                                nofCINT7,TMath::Sqrt(nofCINT7)));
+    if (!realSpectra->HasValue("CoffNofJpsi"))
+        {
+        if (!CorrectSpectra(type,flavour))
+            {
+            AliError("Could not get corrected spectra");
+            return 0x0;
+            }
+        }
     
-    Double_t yield =  r->GetValue("CorrNofJpsi") * mbeq;
+    AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
     
-    Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJpsi"), r->GetErrorStat("CorrNofJpsi"),
-                                                                 mbeq,mbeqError);
+    if ( !simSpectra)
+        {
+        AliErrorClass("could not get sim spectra");
+        return 0x0;
+        }
     
-    r->Set("YJpsi",yield,yieldError);
+    Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
+    Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
+    Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
     
-    r->Set("NofInputJpsi",rsim->GetValue("NofInputJpsi",accEffSubResultName),rsim->GetErrorStat("NofInputJpsi",accEffSubResultName));
-    r->Set("AccEffJpsi",rsim->GetValue("AccEffJpsi",accEffSubResultName),rsim->GetErrorStat("AccEffJpsi",accEffSubResultName));
+    AliAnalysisMuMuBinning* binning = realSpectra->Binning();
+    TObjArray* bins = binning->CreateBinObjArray();
+    TIter nextBin(bins);
+    AliAnalysisMuMuBinning::Range* bin;
+    Int_t i(0);
+    AliAnalysisMuMuJpsiResult* r;
     
-    ++i;
-  }
-  
-  delete bins;
-  
-  Update();
-  
-  return realSpectra;
+    while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
+        {
+        r = static_cast<AliAnalysisMuMuJpsiResult*>(realSpectra->BinContentArray()->At(i));
+        
+        StdoutToAliDebug(1,std::cout << "bin=";r->Print(););
+        
+        AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
+        
+        Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
+        Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+                                                                    nofCINT7,TMath::Sqrt(nofCINT7),
+                                                                    nofCMUL7,TMath::Sqrt(nofCMUL7));
+        
+        r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+                                                                                                      nofCINT7,TMath::Sqrt(nofCINT7)));
+        
+        Double_t yield =  r->GetValue("CorrNofJpsi") * mbeq;
+        
+        Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJpsi"), r->GetErrorStat("CorrNofJpsi"),
+                                                                     mbeq,mbeqError);
+        
+        r->Set("YJpsi",yield,yieldError);
+        
+        r->Set("NofInputJpsi",rsim->GetValue("NofInputJpsi",accEffSubResultName),rsim->GetErrorStat("NofInputJpsi",accEffSubResultName));
+        r->Set("AccEffJpsi",rsim->GetValue("AccEffJpsi",accEffSubResultName),rsim->GetErrorStat("AccEffJpsi",accEffSubResultName));
+        
+        ++i;
+        }
+    
+    delete bins;
+    
+    Update();
+    
+    return realSpectra;
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* direction)
 {
-  /// Compute the RAB...
-  
-  if (!SIM()) return 0x0;
-  
-  Double_t rapidityShift = 0.465;// 0.5*TMath::Log(208.0/82.0);
-  const Double_t sqrts=5.023;
-  const Double_t ymax=TMath::Log(sqrts*1000.0/3.096916);
-  const Double_t tab = 0.093e-6; // nb^-1
-  const Double_t tabError = 0.0035E-6; // nb^-1
-  const char* accEffSubResultName="PSICOUNT:1";
-  
-  TF1 ydist("ydist","[0]*TMath::Exp(-(x*x)/(2.0*0.39*0.39))",0.,0.5);
-  ydist.SetParameter(0,1.);
-
-  //Normalization to the values presented by Zaida and Rosana on January 11th 2013 https://indico.cern.ch/conferenceDisplay.py?confId=224985 slide 22
-  // Normalization is done in the rapidity range 2.75<y<3.25 where Rosanas values is 230.8+212.1
-  Double_t y1_norma= 2.75/ymax;
-  Double_t y2_norma= 3.25/ymax;
-  Double_t normalization = 0.25*(230.8+212.1)/ydist.Integral(y1_norma, y2_norma);
-  ydist.SetParameter(0,normalization);
-//  AliInfoClass(Form("ymax=%e normalization=%f",ymax,ydist.Integral(y1_norma, y2_norma)));
-  
-  AliAnalysisMuMuSpectra* realSpectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/PSALL/CMUL7-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
-  AliAnalysisMuMuSpectra* simSpectra = static_cast<AliAnalysisMuMuSpectra*>(SIM()->OC()->GetObject(Form("/ALL/CMULLO-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
-  
-  if ( !realSpectra )
-  {
-    AliErrorClass("could not get real spectra");
-    return 0x0;
-  }
-  
-  if ( !simSpectra)
-  {
-    AliErrorClass("could not get sim spectra");
-    return 0x0;
-  }
-  
-  AliAnalysisMuMuSpectra* corrSpectra = static_cast<AliAnalysisMuMuSpectra*>(realSpectra->Clone());
-  corrSpectra->Correct(*simSpectra,"Jpsi",accEffSubResultName);
-  
-  Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
-  Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
-  Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
-  
-  AliAnalysisMuMuBinning* binning = realSpectra->Binning();
-  TObjArray* bins = binning->CreateBinObjArray();
-  TIter nextBin(bins);
-  AliAnalysisMuMuBinning::Range* bin;
-  Int_t i(0);
-  AliAnalysisMuMuJpsiResult* r;
-  
-  Int_t n = bins->GetLast();
-  
-  TObjArray finalBins(n+1);
-  finalBins.SetOwner(kTRUE);
-  
-  TObjArray finalResults(n+1);
-  finalResults.SetOwner(kFALSE);
-  
-  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
-  {
-    Double_t ylowlab = bin->Xmin();
-    Double_t yhighlab = bin->Xmax();
-
-    Double_t ylowcms, yhighcms;
-    Double_t ylownorm, yhighnorm;
+    /// Compute the RAB...
+    /// Not used anymore
     
-    if ( bin->IsIntegrated() )
-    {
-      ylowlab = -4;
-      yhighlab = -2.5;
-    }
+    if (!SIM()) return 0x0;
     
-    if ( strcmp(direction,"pPb")==0 )
-    {
-      ylowcms = TMath::Abs(yhighlab) -  rapidityShift;
-      yhighcms = TMath::Abs(ylowlab) - rapidityShift;
-      ylownorm = ylowcms/ymax;
-      yhighnorm = yhighcms/ymax;
-    }
-    else
-    {
-      ylowcms = ylowlab - rapidityShift;
-      yhighcms = yhighlab - rapidityShift;
-      ylownorm = -yhighcms/ymax;
-      yhighnorm = -ylowcms/ymax;
-    }
+    Double_t rapidityShift = 0.465;// 0.5*TMath::Log(208.0/82.0);
+    const Double_t sqrts=5.023;
+    const Double_t ymax=TMath::Log(sqrts*1000.0/3.096916);
+    const Double_t tab = 0.093e-6; // nb^-1
+    const Double_t tabError = 0.0035E-6; // nb^-1
+    const char* accEffSubResultName="PSICOUNT:1";
     
+    TF1 ydist("ydist","[0]*TMath::Exp(-(x*x)/(2.0*0.39*0.39))",0.,0.5);
+    ydist.SetParameter(0,1.);
     
-    Double_t brsigmapp = ydist.Integral(ylownorm,yhighnorm);
-    Double_t brsigmappError = 0.0; // FIXME
+    //Normalization to the values presented by Zaida and Rosana on January 11th 2013 https://indico.cern.ch/conferenceDisplay.py?confId=224985 slide 22
+    // Normalization is done in the rapidity range 2.75<y<3.25 where Rosanas values is 230.8+212.1
+    Double_t y1_norma= 2.75/ymax;
+    Double_t y2_norma= 3.25/ymax;
+    Double_t normalization = 0.25*(230.8+212.1)/ydist.Integral(y1_norma, y2_norma);
+    ydist.SetParameter(0,normalization);
+    //  AliInfoClass(Form("ymax=%e normalization=%f",ymax,ydist.Integral(y1_norma, y2_norma)));
     
-    AliInfoClass(Form("y range : LAB %f ; %f CMS %f ; %f -> ynorm : %f ; %f -> BR x sigmapp = %f",
-                      ylowlab,yhighlab,ylowcms,yhighcms,ylownorm,yhighnorm,brsigmapp));
+    AliAnalysisMuMuSpectra* realSpectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/PSALL/CMUL7-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
+    AliAnalysisMuMuSpectra* simSpectra = static_cast<AliAnalysisMuMuSpectra*>(SIM()->OC()->GetObject(Form("/ALL/CMULLO-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
     
-    r = static_cast<AliAnalysisMuMuJpsiResult*>(corrSpectra->BinContentArray()->At(i)->Clone());
-
-    AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
+    if ( !realSpectra )
+        {
+        AliErrorClass("could not get real spectra");
+        return 0x0;
+        }
+    
+    if ( !simSpectra)
+        {
+        AliErrorClass("could not get sim spectra");
+        return 0x0;
+        }
     
-    Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
-    Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                         nofCINT7,TMath::Sqrt(nofCINT7),
-                                         nofCMUL7,TMath::Sqrt(nofCMUL7));
+    AliAnalysisMuMuSpectra* corrSpectra = static_cast<AliAnalysisMuMuSpectra*>(realSpectra->Clone());
+    corrSpectra->Correct(*simSpectra,"Jpsi",accEffSubResultName);
     
-    r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                                                      nofCINT7,TMath::Sqrt(nofCINT7)));
+    Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
+    Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
+    Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
     
-    Double_t yield =  r->GetValue("CorrNofJpsi") * mbeq;
-
-    Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJpsi"), r->GetErrorStat("CorrNofJpsi"),
-                                          mbeq,mbeqError);
+    AliAnalysisMuMuBinning* binning = realSpectra->Binning();
+    TObjArray* bins = binning->CreateBinObjArray();
+    TIter nextBin(bins);
+    AliAnalysisMuMuBinning::Range* bin;
+    Int_t i(0);
+    AliAnalysisMuMuJpsiResult* r;
     
-    r->Set(Form("Y%sJpsi",direction),yield,yieldError);
-
-    Double_t raa = yield/(tab*brsigmapp);
-    Double_t raaError = AliAnalysisMuMuResult::ErrorABC(yield,yieldError,
-                                                        tab,tabError,
-                                                        brsigmapp,brsigmappError);
-    r->Set(Form("R%sJpsi",direction),raa,raaError);
-
-    r->Set("NofInputJpsi",rsim->GetValue("NofInputJpsi",accEffSubResultName),rsim->GetErrorStat("NofInputJpsi",accEffSubResultName));
-    r->Set("AccEffJpsi",rsim->GetValue("AccEffJpsi",accEffSubResultName),rsim->GetErrorStat("AccEffJpsi",accEffSubResultName));
+    Int_t n = bins->GetLast();
+    
+    TObjArray finalBins(n+1);
+    finalBins.SetOwner(kTRUE);
+    
+    TObjArray finalResults(n+1);
+    finalResults.SetOwner(kFALSE);
+    
+    while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
+        {
+        Double_t ylowlab = bin->Xmin();
+        Double_t yhighlab = bin->Xmax();
+        
+        Double_t ylowcms, yhighcms;
+        Double_t ylownorm, yhighnorm;
+        
+        if ( bin->IsIntegrated() )
+            {
+            ylowlab = -4;
+            yhighlab = -2.5;
+            }
+        
+        if ( strcmp(direction,"pPb")==0 )
+            {
+            ylowcms = TMath::Abs(yhighlab) -  rapidityShift;
+            yhighcms = TMath::Abs(ylowlab) - rapidityShift;
+            ylownorm = ylowcms/ymax;
+            yhighnorm = yhighcms/ymax;
+            }
+        else
+            {
+            ylowcms = ylowlab - rapidityShift;
+            yhighcms = yhighlab - rapidityShift;
+            ylownorm = -yhighcms/ymax;
+            yhighnorm = -ylowcms/ymax;
+            }
+        
+        
+        Double_t brsigmapp = ydist.Integral(ylownorm,yhighnorm);
+        Double_t brsigmappError = 0.0; // FIXME
+        
+        AliInfoClass(Form("y range : LAB %f ; %f CMS %f ; %f -> ynorm : %f ; %f -> BR x sigmapp = %f",
+                          ylowlab,yhighlab,ylowcms,yhighcms,ylownorm,yhighnorm,brsigmapp));
+        
+        r = static_cast<AliAnalysisMuMuJpsiResult*>(corrSpectra->BinContentArray()->At(i)->Clone());
+        
+        AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
+        
+        Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
+        Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+                                                                    nofCINT7,TMath::Sqrt(nofCINT7),
+                                                                    nofCMUL7,TMath::Sqrt(nofCMUL7));
+        
+        r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+                                                                                                      nofCINT7,TMath::Sqrt(nofCINT7)));
+        
+        Double_t yield =  r->GetValue("CorrNofJpsi") * mbeq;
+        
+        Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJpsi"), r->GetErrorStat("CorrNofJpsi"),
+                                                                     mbeq,mbeqError);
+        
+        r->Set(Form("Y%sJpsi",direction),yield,yieldError);
+        
+        Double_t raa = yield/(tab*brsigmapp);
+        Double_t raaError = AliAnalysisMuMuResult::ErrorABC(yield,yieldError,
+                                                            tab,tabError,
+                                                            brsigmapp,brsigmappError);
+        r->Set(Form("R%sJpsi",direction),raa,raaError);
+        
+        r->Set("NofInputJpsi",rsim->GetValue("NofInputJpsi",accEffSubResultName),rsim->GetErrorStat("NofInputJpsi",accEffSubResultName));
+        r->Set("AccEffJpsi",rsim->GetValue("AccEffJpsi",accEffSubResultName),rsim->GetErrorStat("AccEffJpsi",accEffSubResultName));
+        
+        AliAnalysisMuMuBinning::Range* bincm = new AliAnalysisMuMuBinning::Range(bin->What(),bin->Quantity(),ylowcms,yhighcms);
+        
+        r->SetBin(*bincm);
+        
+        finalBins.Add(bincm);
+        finalResults.Add(r);
+        
+        ++i;
+        }
     
-    AliAnalysisMuMuBinning::Range* bincm = new AliAnalysisMuMuBinning::Range(bin->What(),bin->Quantity(),ylowcms,yhighcms);
+    delete bins;
+    
+    AliAnalysisMuMuSpectra* spectra = new AliAnalysisMuMuSpectra(type,direction);
     
-    r->SetBin(*bincm);
+    for ( i = 0; i <= n; ++i )
+        {
+        Int_t j(i);
+        if ( strcmp(direction,"pPb")==0 )
+            {
+            j = n-i;
+            }
+        
+        r = static_cast<AliAnalysisMuMuJpsiResult*>(finalResults.At(j));
         
-    finalBins.Add(bincm);
-    finalResults.Add(r);
+        bin = static_cast<AliAnalysisMuMuBinning::Range*>(finalBins.At(j));
+        
+        spectra->AdoptResult(*bin,r);
+        }
     
-    ++i;
-  }
-  
-  delete bins;
-  
-  AliAnalysisMuMuSpectra* spectra = new AliAnalysisMuMuSpectra(type,direction);
-  
-  for ( i = 0; i <= n; ++i )
-  {
-    Int_t j(i);
-    if ( strcmp(direction,"pPb")==0 )
-    {
-      j = n-i;
-    }
     
-    r = static_cast<AliAnalysisMuMuJpsiResult*>(finalResults.At(j));
-
-    bin = static_cast<AliAnalysisMuMuBinning::Range*>(finalBins.At(j));
+    delete corrSpectra;
     
-    spectra->AdoptResult(*bin,r);
-  }
-  
-
-  delete corrSpectra;
-  
-  return spectra;
+    return spectra;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::SetConfig(const AliAnalysisMuMuConfig& config)
 {
-  /// (re)set the config
-  delete fConfig;
-  fConfig = new AliAnalysisMuMuConfig(config);
+    /// (re)set the config
+    delete fConfig;
+    fConfig = new AliAnalysisMuMuConfig(config);
 }
-
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMu::SetParticleNameFromFileName(const char* filename)
 {
-  /// Try to get the simulated particle name from the filename
-  
-  TString sFilename(filename);
-  
-  if ( sFilename.Contains("JPSI",TString::kIgnoreCase) )
-  {
-    SetParticleName("JPsi");
-  }
-  else if ( sFilename.Contains("PSIP",TString::kIgnoreCase) )
-  {
-    SetParticleName("PsiP");
-  }
-  else
-  {
-    AliError("Unknown Particle Name in simulation");
-    return kFALSE;
-  }
-  return kTRUE;
-}
-
-//_____________________________________________________________________________
-void AliAnalysisMuMu::GetFileNameAndDirectory(const char* filename)
-{
-  /// Split the filename[:subdir] into a file name and a subdir
-  
-  fFilename = gSystem->ExpandPathName(filename);
-  
-  fDirectory = "";
-  
-  if ( fFilename.CountChar(':') )
-  {
-    fDirectory = filename;
-    Int_t colon = fFilename.Index(':');
-    fFilename = fFilename(0,colon);
-    fDirectory = fDirectory(colon+1,strlen(filename)-colon);
-  }
+    /// Try to get the simulated particle name from the filename
+    TString sFilename(filename);
+    if ( sFilename.Contains("JPSI",TString::kIgnoreCase) )
+        {
+        SetParticleName("JPsi");
+        }
+    else if ( sFilename.Contains("PSIP",TString::kIgnoreCase) )
+        {
+        SetParticleName("PsiP");
+        }
+    else
+        {
+        AliError("Unknown Particle Name in simulation");
+        return kFALSE;
+        }
+    return kTRUE;
 }
-
-
diff --git a/PWG/muondep/AliAnalysisMuMu.h b/PWG/muondep/AliAnalysisMuMu.h
index 7e85570..89c2ded 100644
--- a/PWG/muondep/AliAnalysisMuMu.h
+++ b/PWG/muondep/AliAnalysisMuMu.h
@@ -7,12 +7,13 @@
 // $Id$
 
 ///
-/// AliAnalysisMuMu : helper class to digest/plot/massage results from
+/// AliAnalysisMuMu : Facade class of all subclass called to digest/plot/massage results from
 /// AliAnalysisTaskMuMu
 ///
 /// author : Laurent Aphecetche (Subatech) and Javier Martin Blanco
 
 #include "AliAnalysisMuMuBinning.h"
+#include "AliAnalysisMuMuFnorm.h"
 #include "TNamed.h"
 #include <map>
 #include <set>
@@ -38,234 +39,268 @@ class TMap;
 
 class AliAnalysisMuMu : public TObject, public TQObject
 {
-
+    
 public:
-
-  AliAnalysisMuMu(const char* filename, AliAnalysisMuMuConfig& config);
-
-  AliAnalysisMuMu(const char* filename,
-                  const char* associatedSimFileName="",
-                  const char* associatedSimFileName2="",
-                  const char* configurationFile="");
-  
-  virtual ~AliAnalysisMuMu();
-  
-  /* Basic checks */
-  void BasicCounts(Bool_t detailTrigger=kFALSE,
-                   ULong64_t* totalNmb=0x0,
-                   ULong64_t* totalNmsl=0x0,
-                   ULong64_t* totalNmul=0x0);
-  
-  void TriggerCountCoverage(const char* triggerList, Bool_t compact=kTRUE,
-                            Bool_t orderByTriggerCount=kTRUE);
-  
-  void SelectRunByTrigger(const char* triggerList);
-  
-  AliAnalysisMuMuSpectra* FitParticle(const char* particle,
-                                      const char* trigger,
-                                      const char* eventType,
-                                      const char* pairCut,
-                                      const char* centrality,
-                                      const AliAnalysisMuMuBinning& binning,
-                                      const char* spectraType="minv",
-                                      Bool_t corrected=kFALSE);
-
-  AliAnalysisMuMuSpectra* CorrectSpectra(const char* type, const char* flavour="");
-  
-  TH2* ComputeSPDCorrection(const char* type="oneOverAccEff", const char* eventSel="PSALL", const char* triggerSel="ANY", Bool_t bkgReject=kTRUE);
-  
-  void ComputeFnorm();
-  
-  TH1* ComputeDiffFnormFromHistos(const char* what="psi",const char* quantity="ntrcorr",const char* flavour="JAVI",Bool_t printout=kFALSE);
-  
-  void ComputeDiffFnormFromInt(const char* triggerCluster="MUON", const char* eventSelection="PSALL", AliMergeableCollection* mc=0x0, const char* what="psi",const char* quantity="ntrcorr",const char* flavour="JAVI",Bool_t printout=kTRUE);
-  
-  void ComputeDiffFnormFromCounters(const char* filePileUpCorr="", const char* what="psi", const char* quantity="ntrcorr",
-                                    const char* flavour="D2H",const char* triggerCluster="MUON",
-                                    const char* eventSelectionFNorm="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
+    
+    AliAnalysisMuMu(const char* filename, AliAnalysisMuMuConfig& config);
+    
+    AliAnalysisMuMu(const char* filename="",
+                    const char* associatedSimFileName="",
+                    const char* associatedSimFileName2="",
+                    const char* configurationFile="");
+    
+    virtual ~AliAnalysisMuMu();
+    
+    /* Basic checks */
+    void BasicCounts(Bool_t detailTrigger=kFALSE,
+                     ULong64_t* totalNmb=0x0,
+                     ULong64_t* totalNmsl=0x0,
+                     ULong64_t* totalNmul=0x0);
+    
+    void TriggerCountCoverage(const char* triggerList, Bool_t compact=kTRUE,
+                              Bool_t orderByTriggerCount=kTRUE);
+    
+    void SelectRunByTrigger(const char* triggerList);
+    
+    AliAnalysisMuMuSpectra* FitParticle(const char* particle,
+                                        const char* trigger,
+                                        const char* eventType,
+                                        const char* pairCut,
+                                        const char* centrality,
+                                        const AliAnalysisMuMuBinning& binning,
+                                        const char* spectraType="minv",
+                                        Bool_t corrected=kFALSE);
+    
+    AliAnalysisMuMuSpectra* CorrectSpectra(const char* type, const char* flavour="");
+    
+    void PrintDistribution(
+                           const char              * binType="Y",
+                           const char              * what="NofJPsi",
+                           const char              * sResName="",
+                           const char              * ColSys="PbPb",
+                           Bool_t divideByBinWidth =kTRUE,
+                           Bool_t AccEffCorr       =kFALSE);
+
+    void ComputeDimuonRawCount(
+                            const Double_t rlow   = 2.8, 
+                            const Double_t rhight = 3.4, 
+                            const char            * binType="pt", 
+                            const char            * flavour="BENJ", 
+                            Bool_t corrected      =kFALSE );
+    
+    TH2* ComputeSPDCorrection(const char* type="oneOverAccEff", const char* eventSel="PSALL", const char* triggerSel="ANY", Bool_t bkgReject=kTRUE);
+    
+    void ComputeFnorm();
+
+    void ComputeNumberOfEvent();
+
+    void ComputeDiffFnormFromCounters(const char* filePileUpCorr="", const char* what ="psi",const char* quantity="pt", const char* flavour="BENJ", Bool_t printout=kTRUE);
+    
+    void ComputeDiffFnormFromGlobal(const char* what="psi",const char* quantity="ntrcorr",const char* flavour="D2H",const char* triggerCluster="MUON",
+                                    const char* eventSelectionFnorm="PSALL",
                                     const char* eventSelectionYield="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00", Bool_t printout=kTRUE);
-
-  void ComputeDiffFnormFromGlobal(const char* what="psi",const char* quantity="ntrcorr",const char* flavour="D2H",const char* triggerCluster="MUON",
-                                  const char* eventSelectionFnorm="PSALL",
-                                  const char* eventSelectionYield="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00", Bool_t printout=kTRUE);
-  
-  void ComputeMeanFnorm(const char* triggerCluster="MUON", const char* eventSelection="PSALL", const char* what="psi",const char* quantity="ntrcorr",
-                        const char* flavour="D2H");
-
-  void ComputeIntFnormFromCounters(const char* filePileUpCorr="", const char* triggerCluster="MUON", const char* eventSelectionFNorm="PSALL",
-                                   const char* eventSelectionYield="PSALL", Bool_t printout=kTRUE);
-
-  void PlotYiedWSyst(const char* triggerCluster="MUON");
-
-  void ComputeRelativeValueAndSESystematics(const char* quantity,const char* flavour,const char* value2Test, const char* binListToExclude,
-                                            const char* fNormType="mean", const char* evSelInt="PSALL",
-                                            const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                                            const char* triggerCluster="MUON");
-
-  void ComputeJpsiYield( Bool_t relative=kTRUE, const char* fNormType="mean", const char* evSelInt="PSALL",
-                        const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                        const char* triggerCluster="MUON", const char* whatever="PSI-NTRCORR-AccEffCorr", const char* sResName="");
-
-  void ComputeJpsiMPt(Bool_t relative=kTRUE, const char* evSelInt="PSALL", const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00"
-                      ,const char* spectra="PSI-NTRCORR-AccEffCorr-MeanPtVsMinvUS",const char* sResName="");
-
-  void ComputeMBXSectionFractionInBins(const char* filePileUpCorr="", const char* eventSelection="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                                       const char* what="psi",const char* quantity="ntrcorr", const char* flavour="D2H");
-
-  TH1* ComputeEquNofMB(const char* what="psi",const char* quantity="dnchdeta",const char* flavour="JAVI",Bool_t printout=kFALSE);
-
-  Double_t ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d);
-
-  void TwikiOutputFnorm(const char* series="FnormOffline2PUPS,FnormScalersPUPS,FnormBest2,RelDifFnormScalersPUPSvsFnormOffline2PUPS,FnormScalersPUVDM,RelDifFnormScalersPUPSvsFnormScalersPUVDM") const;
-
-  AliAnalysisMuMuSpectra* ComputeYield(const char* type, const char* flavour="");
-
-  void CleanAllSpectra();
-  
-  ///------
-  
-//  static AliAnalysisMuMuSpectra* ComputeYield(const char* realFile="ds.list.saf.root",
-//                                              const char* simFile="ds.sim.list.saf.root",
-//                                              const  char* type="PSI-Y VS PT");
-
-   AliAnalysisMuMuSpectra* RABy(const char* type="", const char* direction="pPb");
-
-  ///-------
-  
-  TGraph* PlotEventSelectionEvolution(const char* trigger1="CINT7-B-NOPF-MUON", const char* event1="PSALL",
-                                   const char* trigger2="CINT7-B-NOPF-MUON", const char* event2="PSALL",
-                                      Bool_t drawFills=kFALSE,
-                                      Bool_t asRejection=kTRUE) const;
-
-  Bool_t Upgrade();
-  
-   Bool_t Upgrade(const char* filename);
-  
-   TObjArray* CompareJpsiPerCMUUWithBackground(const char* jpsiresults="results.root",
-                                                     const char* backgroundresults="background.lhc11d.root");
-  
-   TGraph* CompareJpsiPerCMUUWithSimu(const char* realjpsiresults="results.root",
-                                      const char* simjpsiresults="results.sim.root");
-  
-  
-  static TFile* FileOpen(const char* file);
-  
-  static TString ExpandPathName(const char* file);
-  
-  
-  Bool_t GetCollections(const char* rootfile, const char* subdir,
-                        AliMergeableCollection*& oc,
-                        AliCounterCollection*& cc,
-                        AliAnalysisMuMuBinning*& bin,
-                        std::set<int>& runnumbers);
-  
-  AliAnalysisMuMuSpectra* GetSpectra(const char* what, const char* flavour="") const;
-  
-  TH1* PlotAccEfficiency(const char* whatever="PSI-INTEGRATED");
-  
-  TH1* PlotJpsiYield(const char* whatever="PSI-DNCHDETA-AccEffCorr");
-  
-  UInt_t GetSum(AliCounterCollection& cc, const char* triggerList, const char* eventSelection, Int_t runNumber=-1);
-  
-  ULong64_t GetTriggerScalerCount(const char* triggerList, Int_t runNumber);
-  
-  Int_t Jpsi(const char* what="integrated", const char* binningFlavour="", Bool_t fitmPt=kTRUE, Bool_t onlyCorrected=kTRUE);
-  
-  Bool_t IsSimulation() const;
-  
-  AliMergeableCollection* OC() const { return fMergeableCollection; }
-  AliCounterCollection* CC() const { return fCounterCollection; }
-  AliAnalysisMuMuBinning* BIN() const { return fBinning; }
-
-  void Print(Option_t* opt="") const;
-  
-  const std::set<int>& RunNumbers() const { return fRunNumbers; }
-  
-  void DrawMinv(const char* type,
-                const char* particle,
-                const char* trigger,
-                const char* eventType,
-                const char* pairCut,
-                const char* centrality,
-                const char* subresultname="",
-                const char* flavour="") const;
-
-  void DrawMinv(const char* type="PT", const char* particle="PSI", const char* flavour="", const char* subresultname="") const;
-  
-  Bool_t SetCorrectionPerRun(const TGraph& corr, const char* formula="");
-  
-  void UnsetCorrectionPerRun();
-  
-  void ExecuteCanvasEvent(Int_t event, Int_t px, Int_t py, TObject *sel);
-
-  std::vector<Double_t> GetMCCB2Tails(const AliAnalysisMuMuBinning::Range& bin) const;
-  
-  AliAnalysisMuMu* SIM() const { return fAssociatedSimulation; }
-  
-  AliAnalysisMuMu* SIM2() const { return fAssociatedSimulation2; }
-  
-  AliAnalysisMuMuSpectra* SPECTRA(const char* fullpath) const;
-  
-  void SetParticleName(const char* particleName) { fParticleName = particleName; }
-  
-  const char* GetParticleName() { return fParticleName; }
-  
-  void Update();
-
-  AliAnalysisMuMuConfig* Config();
-
-  AliAnalysisMuMuConfig* Config() const { return fConfig; }
-  
-  void SetConfig(const AliAnalysisMuMuConfig& config);
-
-  void SetCentralitySelectionList(const char* centralitySelectionList);
-  
+    
+    void ComputeMeanFnorm(const char* triggerCluster="MUON", const char* eventSelection="PSALL", const char* what="psi",const char* quantity="ntrcorr",
+                          const char* flavour="D2H");
+
+    void ComputeFnormWeightedMeanGraphs(AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, const char* patternOrList= "", const char* graphName= "");
+        
+    void ComputeFnormScalers(AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, Bool_t PileUpCorr =kFALSE);
+    
+    void ComputeIntFnormFromCounters(AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, Bool_t PileUpCorr =kFALSE);
+    
+    void PlotYiedWSyst(const char* triggerCluster="MUON");
+    
+    void ComputeRelativeValueAndSESystematics(const char* quantity,const char* flavour,const char* value2Test, const char* binListToExclude,
+                                              const char* fNormType="mean", const char* evSelInt="PSALL",
+                                              const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
+                                              const char* triggerCluster="MUON");
+    
+    void ComputeJpsiYield(
+                          const char        * binType="INTEGRATED",
+                          const char        * what="NofJPsi",
+                          const char        * externfile1="externFile_PT.txt",
+                          const char        * externfile2="externFile_CENT.txt",
+                          const char        * sResName="",
+                          const char        * beamYear="",
+                          Bool_t AccEffCorr =kFALSE);
+    
+    void ComputeJpsiMPt(Bool_t relative=kTRUE, const char* evSelInt="PSALL", const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00"
+                        ,const char* spectra="PSI-NTRCORR-AccEffCorr-MeanPtVsMinvUS",const char* sResName="");
+    
+    void ComputeMBXSectionFractionInBins(const char* filePileUpCorr="", const char* eventSelection="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
+                                         const char* what="psi",const char* quantity="ntrcorr", const char* flavour="D2H");
+    
+    TH1* ComputeEquNofMB(const char* what="psi",const char* quantity="dnchdeta",const char* flavour="JAVI",Bool_t printout=kFALSE);
+    
+    Double_t ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d);
+    
+    void TwikiOutputFnorm(const char* series="FnormOffline2PUPS,FnormScalersPUPS,FnormBest2,RelDifFnormScalersPUPSvsFnormOffline2PUPS,FnormScalersPUVDM,RelDifFnormScalersPUPSvsFnormScalersPUVDM") const;
+    
+    AliAnalysisMuMuSpectra* ComputeYield(const char* type, const char* flavour="");
+    
+    void CleanAllSpectra();
+
+    void CleanFNorm();
+    
+    ///------
+    
+    void RAAasGraphic(
+                      const char                                           * particle="PSI",
+                      const char                                           * binType="PT",
+                      const char                                           * externfile1="externFile_PT.txt",
+                      const char                                           * externfile2="externFile_CENT.txt",
+                      const char                                           * RefCent ="V0M_00.00_90.00",
+                      Bool_t AccEffCorr                                    =kFALSE)const;
+    
+    void DrawFitResults(
+                        const char                                           * particle="PSI",
+                        const char                                           * binType="INTEGRATED",
+                        const char                                           * printDirectoryPath="histo",
+                        Bool_t Print                                         =kFALSE,
+                        Bool_t AccEffCorr                                    =kFALSE)const;
+    
+    void PrintNofParticle(
+                          const char                                           * particle="PSI",
+                          const char                                           * what="NofJPsi",
+                          const char                                           * binType="PT",
+                          Bool_t AccEffCorr                                    =kFALSE) const;
+    
+    //  static AliAnalysisMuMuSpectra* ComputeYield(const char* realFile="ds.list.saf.root",
+    //                                              const char* simFile="ds.sim.list.saf.root",
+    //                                              const  char* type="PSI-Y VS PT");
+    
+    AliAnalysisMuMuSpectra* RABy(const char* type="", const char* direction="pPb");
+    
+    ///-------
+    
+    TGraph* PlotEventSelectionEvolution(const char* trigger1="CINT7-B-NOPF-MUON", const char* event1="PSALL",
+                                        const char* trigger2="CINT7-B-NOPF-MUON", const char* event2="PSALL",
+                                        Bool_t drawFills=kFALSE,
+                                        Bool_t asRejection=kTRUE) const;
+    
+    Bool_t Upgrade();
+    
+    Bool_t Upgrade(const char* filename);
+    
+    TObjArray* CompareJpsiPerCMUUWithBackground(const char* jpsiresults="results.root",
+                                                const char* backgroundresults="background.lhc11d.root");
+    
+    TGraph* CompareJpsiPerCMUUWithSimu(const char* realjpsiresults="results.root",
+                                       const char* simjpsiresults="results.sim.root");
+    
+    
+    static TFile* FileOpen(const char* file);
+    
+    static TString ExpandPathName(const char* file);
+    
+    
+    Bool_t GetCollections(const char* rootfile,
+                          AliMergeableCollection*& oc,
+                          AliCounterCollection*& cc,
+                          AliAnalysisMuMuBinning*& bin,
+                          std::set<int>& runnumbers);
+    
+    AliAnalysisMuMuSpectra* GetSpectra(const char* what, const char* flavour="") const;
+    
+    TH1* PlotAccEfficiency(const char* whatever="PSI-INTEGRATED");
+    
+    TH1* PlotJpsiYield(const char* whatever="PSI-DNCHDETA-AccEffCorr");
+    
+    UInt_t GetSum(AliCounterCollection& cc, const char* triggerList, const char* eventSelection, Int_t runNumber=-1);
+    
+    ULong64_t GetTriggerScalerCount(const char* triggerList, Int_t runNumber);
+    
+    Int_t Jpsi(const char* what="integrated", const char* binningFlavour="", Bool_t fitmPt=kTRUE, Bool_t onlyCorrected=kTRUE);
+    
+    Bool_t IsSimulation() const;
+    
+    AliMergeableCollection* OC() const { return fMergeableCollection; }
+    AliCounterCollection  * CC() const { return fCounterCollection; }
+    AliAnalysisMuMuBinning* BIN() const { return fBinning; }
+    
+    void Print(Option_t* opt="") const;
+    
+    const std::set<int>& RunNumbers() const { return fRunNumbers; }
+    
+    void DrawMinv(const char* type,
+                  const char* particle,
+                  const char* trigger,
+                  const char* eventType,
+                  const char* pairCut,
+                  const char* centrality,
+                  const char* subresultname="",
+                  const char* flavour="") const;
+    
+    void DrawMinv(const char* type="PT", const char* particle="PSI", const char* flavour="", const char* subresultname="") const;
+    
+    Bool_t SetCorrectionPerRun(const TGraph& corr, const char* formula="");
+    
+    void UnsetCorrectionPerRun();
+    
+    void ExecuteCanvasEvent(Int_t event, Int_t px, Int_t py, TObject *sel);
+    
+    std::vector<Double_t> GetMCCB2Tails(const AliAnalysisMuMuBinning::Range& bin) const;
+    
+    AliAnalysisMuMu* SIM() const { return fAssociatedSimulation; }
+    
+    AliAnalysisMuMu* SIM2() const { return fAssociatedSimulation2; }
+    
+    AliAnalysisMuMuSpectra* SPECTRA(const char* fullpath) const;
+    
+    void SetParticleName(const char* particleName) { fParticleName = particleName; }
+    
+    const char* GetParticleName() { return fParticleName; }
+    
+    void Update();
+    
+    // AliAnalysisMuMuConfig* Config();
+    
+    AliAnalysisMuMuConfig* Config() const { return fConfig; }
+    
+    void SetConfig(const AliAnalysisMuMuConfig& config);
+    
+    void SetCentralitySelectionList(const char* centralitySelectionList);
+    
 private:
-  AliAnalysisMuMu(const AliAnalysisMuMu& rhs); // not implemented on purpose
-  AliAnalysisMuMu& operator=(const AliAnalysisMuMu& rhs); // not implemented on purpose
-
-  Bool_t SetParticleNameFromFileName(const char* filename);
-
-  void ShowList(const char* title, const TString& list, const char separator=',') const;
-
-  TFile* ReOpen(const char* filename, const char* mode) const;
-
-  void GetParametersFromMC(TString& fitType, const char* pathCentrPairCut, const char* spectraName, AliAnalysisMuMuBinning::Range* bin) const;
-  void GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const;
-
-  void GetCollectionsFromAnySubdir(TDirectory& dir,
-                                   AliMergeableCollection*& oc,
-                                   AliCounterCollection*& cc,
-                                   AliAnalysisMuMuBinning*& bin);
-
-  void GetFileNameAndDirectory(const char* filename);
-
+    AliAnalysisMuMu(const AliAnalysisMuMu& rhs); // not implemented on purpose
+    AliAnalysisMuMu& operator=(const AliAnalysisMuMu& rhs); // not implemented on purpose
+    
+    Bool_t SetParticleNameFromFileName(const char* filename);
+    
+    void ShowList(const char* title, const TString& list, const char separator=',') const;
+    
+    TFile* ReOpen(const char* filename, const char* mode) const;
+    
+    TString First(const TString& list) const;
+    
+    void GetParametersFromMC(TString& fitType, const char* pathCentrPairCut, const char* spectraName, AliAnalysisMuMuBinning::Range* bin) const;
+    void GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const;
+    
 private:
-
-  void SetNofInputParticles(AliAnalysisMuMuJpsiResult& r);
-
-  
-  TString fFilename; // file containing the result collections (of objects and counters) from AliAnalysisTaskMuMu
-  TString fDirectory; // directory, within fFilename, containing the actual objects
-  
-  AliCounterCollection* fCounterCollection; // collection of counters in file
-
-  AliAnalysisMuMuBinning* fBinning; // binning
-  
-  AliMergeableCollection* fMergeableCollection; // collection of objects in file
-
-  std::set<int> fRunNumbers; // run numbers
-  
-  TGraph* fCorrectionPerRun; // correction factor per run
-  
-  AliAnalysisMuMu* fAssociatedSimulation; // associated simulations (if any)
-  AliAnalysisMuMu* fAssociatedSimulation2; // second associated simulations (if any)
-  
-  TString fParticleName; // Name of the simulated particle in the associated simulations
-
-  AliAnalysisMuMuConfig* fConfig; // configuration
-  
-  ClassDef(AliAnalysisMuMu,13) // class to analysis results from AliAnalysisTaskMuMuXXX tasks
+    
+    void SetNofInputParticles(AliAnalysisMuMuJpsiResult& r);
+    
+    
+    TString fFilename; // file containing the result collections (of objects and counters) from AliAnalysisTaskMuMu
+    AliCounterCollection* fCounterCollection; // collection of counters in file
+    
+    AliAnalysisMuMuBinning* fBinning; // binning
+    
+    AliMergeableCollection* fMergeableCollection; // collection of objects in file
+    
+    std::set<int> fRunNumbers; // run numbers
+    
+    TGraph* fCorrectionPerRun; // correction factor per run
+    
+    AliAnalysisMuMu* fAssociatedSimulation; // associated simulations (if any)
+    AliAnalysisMuMu* fAssociatedSimulation2; // second associated simulations (if any)
+    
+    TString fParticleName; // Name of the simulated particle in the associated simulations
+    
+    AliAnalysisMuMuConfig* fConfig; // configuration
+    
+    ClassDef(AliAnalysisMuMu,12) // class to analysis results from AliAnalysisTaskMuMuXXX tasks
 };
 
 #endif
diff --git a/PWG/muondep/AliAnalysisMuMuConfig.cxx b/PWG/muondep/AliAnalysisMuMuConfig.cxx
index 739038b..dffa4d0 100644
--- a/PWG/muondep/AliAnalysisMuMuConfig.cxx
+++ b/PWG/muondep/AliAnalysisMuMuConfig.cxx
@@ -44,9 +44,9 @@
 ClassImp(AliAnalysisMuMuConfig)
 
 namespace {
-
-  Bool_t GetKeyValue(const TString& str, const char separator, TString& key, TString& value)
-  {
+    
+    Bool_t GetKeyValue(const TString& str, const char separator, TString& key, TString& value)
+    {
     /// Get a key value pair, separated by separator character
     key=value="";
     if ( !str.CountChar(separator) ) return kFALSE;
@@ -55,10 +55,10 @@ namespace {
     key.Remove(TString::kBoth,' ');
     value = str(index+1,str.Length()-index-1);
     return kTRUE;
-  }
-  
-  void DecodeRunRanges(const TString& runranges, std::set<int>& runs)
-  {
+    }
+    
+    void DecodeRunRanges(const TString& runranges, std::set<int>& runs)
+    {
     /// From a string of form A-D,F,H,W-Y,Z return a set containing
     /// A,B,C,D,F,H,W,X,Y,Z
     TObjArray* ranges = runranges.Tokenize(",");
@@ -66,50 +66,50 @@ namespace {
     TIter next(ranges);
     
     while ( ( s = static_cast<TObjString*>(next())))
-    {
-      int first = s->String().Atoi();
-      int last = first;
-      
-      if ( s->String().Contains("-") )
-      {
-        TString sfirst,slast;
-        GetKeyValue(s->String(),'-',sfirst,slast);
-        last = slast.Atoi();
-        assert(first==sfirst.Atoi());
-      }
-      for (int i = first; i <= last; ++i )
-      {
-        runs.insert(i);
-      }
-    }
+        {
+        int first = s->String().Atoi();
+        int last = first;
+        
+        if ( s->String().Contains("-") )
+            {
+            TString sfirst,slast;
+            GetKeyValue(s->String(),'-',sfirst,slast);
+            last = slast.Atoi();
+            assert(first==sfirst.Atoi());
+            }
+        for (int i = first; i <= last; ++i )
+            {
+            runs.insert(i);
+            }
+        }
     delete ranges;
-  }
-  
-  void PrintRunInfo(const std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string>& map)
-  {
-    if ( map.count(AliAnalysisMuMuConfig::kMBTriggerClassName) )
-    {
-      std::cout << "MB=" << map.find(AliAnalysisMuMuConfig::kMBTriggerClassName)->second << " ";
     }
-    if ( map.count(AliAnalysisMuMuConfig::kMULTriggerClassName) )
+    
+    void PrintRunInfo(const std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string>& map)
     {
-      std::cout << "MUL=" << map.find(AliAnalysisMuMuConfig::kMULTriggerClassName)->second << " ";
-    }
+    if ( map.count(AliAnalysisMuMuConfig::kMBTriggerClassName) )
+        {
+        std::cout << "MB=" << map.find(AliAnalysisMuMuConfig::kMBTriggerClassName)->second << " ";
+        }
+    if ( map.count(AliAnalysisMuMuConfig::kMULTriggerClassName) )
+        {
+        std::cout << "MUL=" << map.find(AliAnalysisMuMuConfig::kMULTriggerClassName)->second << " ";
+        }
     if ( map.count(AliAnalysisMuMuConfig::kMSLTriggerClassName) )
-    {
-      std::cout << "MSL=" << map.find(AliAnalysisMuMuConfig::kMSLTriggerClassName)->second << " ";
-    }
+        {
+        std::cout << "MSL=" << map.find(AliAnalysisMuMuConfig::kMSLTriggerClassName)->second << " ";
+        }
     if ( map.count(AliAnalysisMuMuConfig::kMSHTriggerClassName) )
-    {
-      std::cout << "MSH=" << map.find(AliAnalysisMuMuConfig::kMSHTriggerClassName)->second << " ";
-    }
+        {
+        std::cout << "MSH=" << map.find(AliAnalysisMuMuConfig::kMSHTriggerClassName)->second << " ";
+        }
     if ( map.count(AliAnalysisMuMuConfig::kCentralityName) )
-    {
-      std::cout << "CENT=" << map.find(AliAnalysisMuMuConfig::kCentralityName)->second << " ";
-    }
+        {
+        std::cout << "CENT=" << map.find(AliAnalysisMuMuConfig::kCentralityName)->second << " ";
+        }
     std::cout << std::endl;
-  }
-  
+    }
+    
 }
 
 const char* AliAnalysisMuMuConfig::DimuonTriggerKey() const { return "DimuonTrigger"; }
@@ -129,547 +129,547 @@ fOCDBPath("raw://"),
 fIsCompactGraphs(kFALSE),
 fPerRunInfo()
 {
-  // ctor
+    // ctor
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuConfig::~AliAnalysisMuMuConfig()
 {
-  // dtor
-  delete fMap;
+    // dtor
+    delete fMap;
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuConfig::AliAnalysisMuMuConfig(const AliAnalysisMuMuConfig& other)
 {
-  if ( &other != this )
-  {
+    if ( &other != this )
+    {
     fOCDBPath = other.fOCDBPath;
     fIsCompactGraphs = other.fIsCompactGraphs;
     if (other.fMap)
-    {
-      fMap = static_cast<TMap*>(other.fMap->Clone());
-    }
+        {
+        fMap = static_cast<TMap*>(other.fMap->Clone());
+        }
     fPerRunInfo = other.fPerRunInfo;
-  }
+    }
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuConfig& AliAnalysisMuMuConfig::operator=(const AliAnalysisMuMuConfig& other)
 {
-  if ( &other != this )
-  {
+    if ( &other != this )
+    {
     fOCDBPath = other.fOCDBPath;
     fIsCompactGraphs = other.fIsCompactGraphs;
     delete fMap;
     fMap = 0x0;
     if (other.fMap)
-    {
-      fMap = static_cast<TMap*>(other.fMap->Clone());
-    }
+        {
+        fMap = static_cast<TMap*>(other.fMap->Clone());
+        }
     fPerRunInfo = other.fPerRunInfo;
-  }
-  return *this;
+    }
+    return *this;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::Add(const char* key, const TString& line)
 {
-  /// Add a configuration element, in the form :
-  /// key : line
-  /// where line is "actual_value [sim] [real]
-  
-  UInt_t dataType(0);
-  
-  if ( !line.Contains("SIM",TString::kIgnoreCase) &&
-      !line.Contains("REAL",TString::kIgnoreCase) )
-  {
+    /// Add a configuration element, in the form :
+    /// key : line
+    /// where line is "actual_value [sim] [real]
+    
+    UInt_t dataType(0);
+    
+    if ( !line.Contains("SIM",TString::kIgnoreCase) &&
+        !line.Contains("REAL",TString::kIgnoreCase) )
+    {
     // no REAL or SIM keyword = REAL
     dataType |= kReal;
-  }
-  else if ( line.Contains("SIM",TString::kIgnoreCase) )
-  {
+    }
+    else if ( line.Contains("SIM",TString::kIgnoreCase) )
+    {
     dataType |= kSim;
     if ( line.Contains("REAL",TString::kIgnoreCase) )
-    {
-      dataType |= kReal;
+        {
+        dataType |= kReal;
+        }
     }
-  }
-  else if ( line.Contains("REAL",TString::kIgnoreCase) )
-  {
+    else if ( line.Contains("REAL",TString::kIgnoreCase) )
+    {
     dataType |= kReal;
-  }
-  
-  TObjArray* a = line.Tokenize(" ");
-  TString es = static_cast<TObjString*>(a->First())->String();
-  delete a;
-  
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  if (!list)
-  {
+    }
+    
+    TObjArray* a = line.Tokenize(" ");
+    TString es = static_cast<TObjString*>(a->First())->String();
+    delete a;
+    
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+    if (!list)
+    {
     list = new THashList;
     list->SetOwner(kTRUE);
     Map()->Add(new TObjString(key),list);
     
-  }
-  
-  TObjString* s = static_cast<TObjString*>(list->FindObject(es));
-  if ( !s )
-  {
+    }
+    
+    TObjString* s = static_cast<TObjString*>(list->FindObject(es));
+    if ( !s )
+    {
     s = new TObjString(es);
     s->SetUniqueID(dataType);
     list->Add(s);
-  }
-  else
-  {
+    }
+    else
+    {
     s->SetUniqueID(dataType);
     s->String() = es;
-  }
+    }
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::Clear(Option_t*)
 {
-  /// Clear the internal map
-  if (fMap) fMap->DeleteAll();
+    /// Clear the internal map
+    if (fMap) fMap->DeleteAll();
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::First(const char* key, Bool_t simulation) const
 {
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  TIter next(list);
-  TObjString* s;
-  
-  UInt_t test(kReal);
-  
-  if ( simulation )
-  {
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+    TIter next(list);
+    TObjString* s;
+    
+    UInt_t test(kReal);
+    
+    if ( simulation )
+    {
     test = kSim;
-  }
-
-  while ( ( s = static_cast<TObjString*>(next())) )
-  {
-    if ( s->GetUniqueID() & test )
+    }
+    
+    while ( ( s = static_cast<TObjString*>(next())) )
     {
-      return s->String();
+    if ( s->GetUniqueID() & test )
+        {
+        return s->String();
+        }
     }
-  }
-  return "";
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMBTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMBTriggerClassName)->second;
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMULTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMULTriggerClassName)->second;
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMSLTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMSLTriggerClassName)->second;
-  }
-  return "";
- 
+    }
+    return "";
+    
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMSHTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMSHTriggerClassName)->second;
-  }
-  return "";
-  
+    }
+    return "";
+    
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetCentralityName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kCentralityName)->second;
-  }
-  return "";
-  
+    }
+    return "";
+    
 }
 
 #if 0
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::GetDimuonPaths(TObjArray& paths, Bool_t simulation) const
 {
-  /// Fill the paths array with the paths /event/trigger/paircut/centrality
-  
-  paths.Clear();
-  
-  TObjArray* triggerArray = GetListElements(DimuonTriggerKey(),simulation);
-  TObjArray* eventTypeArray = GetListElements(EventSelectionKey(),simulation);
-  TObjArray* pairCutArray = GetListElements(PairSelectionKey(),simulation);
-  TObjArray* centralityArray = GetListElements(CentralitySelectionKey(),simulation);
-  
-  TIter nextTrigger(triggerArray);
-  TIter nextEventType(eventTypeArray);
-  TIter nextPairCut(pairCutArray);
-  TIter nextCentrality(centralityArray);
-  
-  TObjString* trigger;
-  TObjString* eventType;
-  TObjString* pairCut;
-  TObjString* centrality;
-  
-  while ( ( trigger = static_cast<TObjString*>(nextTrigger())) )
-  {
+    /// Fill the paths array with the paths /event/trigger/paircut/centrality
+    
+    paths.Clear();
+    
+    TObjArray* triggerArray = GetListElements(DimuonTriggerKey(),simulation);
+    TObjArray* eventTypeArray = GetListElements(EventSelectionKey(),simulation);
+    TObjArray* pairCutArray = GetListElements(PairSelectionKey(),simulation);
+    TObjArray* centralityArray = GetListElements(CentralitySelectionKey(),simulation);
+    
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextCentrality(centralityArray);
+    
+    TObjString* trigger;
+    TObjString* eventType;
+    TObjString* pairCut;
+    TObjString* centrality;
+    
+    while ( ( trigger = static_cast<TObjString*>(nextTrigger())) )
+    {
     nextEventType.Reset();
     while ( ( eventType = static_cast<TObjString*>(nextEventType())) )
-    {
-      nextPairCut.Reset();
-      while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) )
-      {
-        nextCentrality.Reset();
-        while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) )
         {
-          paths.Add(new TObjString(Form("/%s/%s/%s/%s/",eventType->String().Data(),
-                                        trigger->String().Data(),
-                                        centrality->String().Data(),
-                                        pairCut->String().Data())));
+        nextPairCut.Reset();
+        while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) )
+            {
+            nextCentrality.Reset();
+            while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) )
+                {
+                paths.Add(new TObjString(Form("/%s/%s/%s/%s/",eventType->String().Data(),
+                                              trigger->String().Data(),
+                                              centrality->String().Data(),
+                                              pairCut->String().Data())));
+                }
+            }
         }
-      }
-    }
-  }
-  
-  delete triggerArray;
-  delete eventTypeArray;
-  delete pairCutArray;
-  delete centralityArray;
+    }
+    
+    delete triggerArray;
+    delete eventTypeArray;
+    delete pairCutArray;
+    delete centralityArray;
 }
 #endif
 
 //_____________________________________________________________________________
 TObjArray* AliAnalysisMuMuConfig::GetListElements(const char* key, Bool_t simulation) const
 {
-  /// Get list as an array (to be deleted by the user)
-  
-  TObjArray* a = new TObjArray;
-  a->SetOwner(kTRUE);
-  
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  
-  TIter next(list);
-  TObjString* s;
-  TString rv;
-  UInt_t test(kReal);
-  
-  if ( simulation )
-  {
+    /// Get list as an array (to be deleted by the user)
+    
+    TObjArray* a = new TObjArray;
+    a->SetOwner(kTRUE);
+    
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+    
+    TIter next(list);
+    TObjString* s;
+    TString rv;
+    UInt_t test(kReal);
+    
+    if ( simulation )
+    {
     test = kSim;
-  }
-  
-  while ( ( s = static_cast<TObjString*>(next()) ) )
-  {
-    if ( s->GetUniqueID() & test )
+    }
+    
+    while ( ( s = static_cast<TObjString*>(next()) ) )
     {
-      a->Add(new TObjString(*s));
+    if ( s->GetUniqueID() & test )
+        {
+        a->Add(new TObjString(*s));
+        }
     }
-  }
-  return a;
+    return a;
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetTriggerClassName(ETriggerType tt, Int_t runNumber) const
 {
-  // get the triggerclass to for a given trigger type and run number
-  
-  if ( tt == kMB )
-  {
+    // get the triggerclass to for a given trigger type and run number
+    
+    if ( tt == kMB )
+    {
     return GetMBTriggerClassName(runNumber);
-  }
-  else if ( tt == kMUL )
-  {
+    }
+    else if ( tt == kMUL )
+    {
     return GetMULTriggerClassName(runNumber);
-  }
-  else if ( tt == kMSL)
-  {
+    }
+    else if ( tt == kMSL)
+    {
     return GetMSLTriggerClassName(runNumber);
-  }
-  else if ( tt == kMSH)
-  {
+    }
+    else if ( tt == kMSH)
+    {
     return GetMSHTriggerClassName(runNumber);
-  }
-  else
-  {
+    }
+    else
+    {
     AliError(Form("Unknown trigger type %d ???",tt));
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetTriggerTypeName(ETriggerType tt)
 {
-  // get the name of the trigger type
-  if ( tt == kMB )
-  {
+    // get the name of the trigger type
+    if ( tt == kMB )
+    {
     return "MB";
-  }
-  else if ( tt == kMUL )
-  {
+    }
+    else if ( tt == kMUL )
+    {
     return "MUL";
-  }
-  else if ( tt == kMSL)
-  {
+    }
+    else if ( tt == kMSL)
+    {
     return "MSL";
-  }
-  else if ( tt == kMSH)
-  {
+    }
+    else if ( tt == kMSH)
+    {
     return "MSH";
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMuConfig::Has(const char* key, const char* value, Bool_t simulation) const
 {
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  TIter next(list);
-  TObjString* s;
-  
-  UInt_t test(kReal);
-  
-  if ( simulation )
-  {
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+    TIter next(list);
+    TObjString* s;
+    
+    UInt_t test(kReal);
+    
+    if ( simulation )
+    {
     test = kSim;
-  }
-  
-  while ( ( s = static_cast<TObjString*>(next())) )
-  {
-    if ( ( s->GetUniqueID() & test ) && ( s->String() == value ) )
+    }
+    
+    while ( ( s = static_cast<TObjString*>(next())) )
     {
-      return kTRUE;
+    if ( ( s->GetUniqueID() & test ) && ( s->String() == value ) )
+        {
+        return kTRUE;
+        }
     }
-  }
-  return kFALSE;
+    return kFALSE;
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMuConfig::HasRunInformation(std::set<int>& runs, Bool_t show) const
 {
-  /// Return true if we have run information for all the runs in the set.
-  /// if show=true, show that information for all those runs
-  
-  std::set<int>::size_type n(0);
-  
-  std::set<int>::const_iterator it;
-  std::map<int,std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> >::const_iterator mit;
-
-  for ( it = runs.begin(); it != runs.end(); ++it )
-  {
+    /// Return true if we have run information for all the runs in the set.
+    /// if show=true, show that information for all those runs
+    
+    std::set<int>::size_type n(0);
+    
+    std::set<int>::const_iterator it;
+    std::map<int,std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> >::const_iterator mit;
+    
+    for ( it = runs.begin(); it != runs.end(); ++it )
+    {
     int runNumber = *it;
     
     mit = fPerRunInfo.find(runNumber);
     
     if ( mit != fPerRunInfo.end() )
-    {
-      ++n;
-      if ( show )
-      {
-        std::cout << Form("RUN %09d ",runNumber);
-        PrintRunInfo(mit->second);
-      }
-    }
+        {
+        ++n;
+        if ( show )
+            {
+            std::cout << Form("RUN %09d ",runNumber);
+            PrintRunInfo(mit->second);
+            }
+        }
     else
-    {
-      if ( show )
-      {
-        std::cout << "Missing information for run " << runNumber << std::endl;
-      }
+        {
+        if ( show )
+            {
+            std::cout << "Missing information for run " << runNumber << std::endl;
+            }
+        }
     }
-  }
-  
-  return n == runs.size();
+    
+    return n == runs.size();
 }
 
 //_____________________________________________________________________________
 TMap* AliAnalysisMuMuConfig::Map() const
 {
-  /// Return (and initialize, if needed) the internal map
-  if (!fMap)
-  {
+    /// Return (and initialize, if needed) the internal map
+    if (!fMap)
+    {
     fMap = new TMap;
     fMap->SetOwnerKeyValue(kTRUE,kTRUE);
-  }
-  return fMap;
+    }
+    return fMap;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::ShowList(const char* key, Bool_t simulation) const
 {
-  /// Show the list for a given key
-
-  TObjArray* a = GetListElements(key,simulation);
-  TObjString* s;
-  
-  TIter next(a);
-  
-  while ( ( s = static_cast<TObjString*>(next()) ) )
-  {
+    /// Show the list for a given key
+    
+    TObjArray* a = GetListElements(key,simulation);
+    TObjString* s;
+    
+    TIter next(a);
+    
+    while ( ( s = static_cast<TObjString*>(next()) ) )
+    {
     std::cout << "    " << s->String() << std::endl;
-  }
-  
-  delete a;
+    }
+    
+    delete a;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::Print(Option_t* opt) const
 {
-  /// printout
-  /// Use opt = "REAL" to show only things relevant to real data
-  /// Use opt = "SIM" to show only things relevant to simulation
-  /// Use opt = "REAL SIM" or "" to show everything
-  
-  std::cout << "OCDBPath : " << fOCDBPath << std::endl;
-  std::cout << "Use compact graphs : " << fIsCompactGraphs << std::endl;
-  TString sopt(opt);
-  sopt.ToUpper();
-  
-  if ( sopt == "RAW")
-  {
+    /// printout
+    /// Use opt = "REAL" to show only things relevant to real data
+    /// Use opt = "SIM" to show only things relevant to simulation
+    /// Use opt = "REAL SIM" or "" to show everything
+    
+    std::cout << "OCDBPath : " << fOCDBPath << std::endl;
+    std::cout << "Use compact graphs : " << fIsCompactGraphs << std::endl;
+    TString sopt(opt);
+    sopt.ToUpper();
+    
+    if ( sopt == "RAW")
+    {
     TIter nextKey(Map());
     TObjString* key;
-
+    
     while ( ( key = static_cast<TObjString*>(nextKey()) ) )
-    {
-      THashList* list = static_cast<THashList*>(Map()->GetValue(key->String()));
-      TIter next(list);
-      TObjString* s;
-      while ( ( s = static_cast<TObjString*>(next())))
-      {
-        std::cout << Form("%s [%u]",s->String().Data(),s->GetUniqueID()) << std::endl;
-      }
-    }
+        {
+        THashList* list = static_cast<THashList*>(Map()->GetValue(key->String()));
+        TIter next(list);
+        TObjString* s;
+        while ( ( s = static_cast<TObjString*>(next())))
+            {
+            std::cout << Form("%s [%u]",s->String().Data(),s->GetUniqueID()) << std::endl;
+            }
+        }
     return;
-  }
+    }
     
-  if (sopt.Length()==0)
-  {
+    if (sopt.Length()==0)
+    {
     sopt = "REAL SIM";
-  }
-  
-  TIter next(Map());
-  TObjString* key;
-  
-  while ( ( key = static_cast<TObjString*>(next()) ) )
-  {
+    }
+    
+    TIter next(Map());
+    TObjString* key;
+    
+    while ( ( key = static_cast<TObjString*>(next()) ) )
+    {
     std::cout << key->String() << ":" << std::endl;
     
     if ( sopt.Contains("REAL",TString::kIgnoreCase) )
-    {
-      std::cout << "  Real:" << std::endl;
-      ShowList(key->String(),kFALSE);
-    }
+        {
+        std::cout << "  Real:" << std::endl;
+        ShowList(key->String(),kFALSE);
+        }
     if ( sopt.Contains("SIM",TString::kIgnoreCase) )
-    {
-      std::cout << "  Sim:" << std::endl;
-      ShowList(key->String(),kTRUE);
+        {
+        std::cout << "  Sim:" << std::endl;
+        ShowList(key->String(),kTRUE);
+        }
     }
-  }
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::SetRunInfo(const TString& runranges, const TString& runinfo)
 {
-  /// Associate the run info (specified in string runinfo) to each of the runs
-  /// defined by the string runranges
-  
-  std::set<int> runs;
-  
-  DecodeRunRanges(runranges,runs);
-  
-  std::set<int>::const_iterator it;
-  
-  std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> mapForOneRun;
-  
-  TObjArray* info = runinfo.Tokenize(" ");
-  TIter next(info);
-  TObjString*s ;
-  while ( ( s = static_cast<TObjString*>(next())))
-  {
+    /// Associate the run info (specified in string runinfo) to each of the runs
+    /// defined by the string runranges
+    
+    std::set<int> runs;
+    
+    DecodeRunRanges(runranges,runs);
+    
+    std::set<int>::const_iterator it;
+    
+    std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> mapForOneRun;
+    
+    TObjArray* info = runinfo.Tokenize(" ");
+    TIter next(info);
+    TObjString*s ;
+    while ( ( s = static_cast<TObjString*>(next())))
+    {
     TString key,value;
     GetKeyValue(s->String(),'=',key,value);
     if (!key.CompareTo("MB",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMBTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMBTriggerClassName]=value;
+        }
     if (!key.CompareTo("MUL",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMULTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMULTriggerClassName]=value;
+        }
     if (!key.CompareTo("MSL",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMSLTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMSLTriggerClassName]=value;
+        }
     if (!key.CompareTo("MSH",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMSHTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMSHTriggerClassName]=value;
+        }
     if (!key.CompareTo("CENT",TString::kIgnoreCase))
-    {
-      mapForOneRun[kCentralityName]=value;
+        {
+        mapForOneRun[kCentralityName]=value;
+        }
     }
-  }
-  
-  for ( it = runs.begin(); it != runs.end(); ++it )
-  {
+    
+    for ( it = runs.begin(); it != runs.end(); ++it )
+    {
     int runNumber = *it;
     fPerRunInfo[runNumber] = mapForOneRun;
-  }
-  
-  delete info;
+    }
+    
+    delete info;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::ReadFromFile(const char* inputfile)
 {
-  /// Read configuration from external file.
-  
-  TString filename = gSystem->ExpandPathName(inputfile);
-  std::ifstream in(filename.Data());
-  if (in.bad())
-  {
+    /// Read configuration from external file.
+    
+    TString filename = gSystem->ExpandPathName(inputfile);
+    std::ifstream in(filename.Data());
+    if (in.bad())
+    {
     AliError(Form("Cannot read input file %s",filename.Data()));
     return;
-  }
-  
-  std::string line;
-  
-  std::vector<TString> selectionKeys;
-  
-  selectionKeys.push_back(DimuonTriggerKey());
-  selectionKeys.push_back(MuonTriggerKey());
-  selectionKeys.push_back(MinbiasTriggerKey());
-  selectionKeys.push_back(EventSelectionKey());
-  selectionKeys.push_back(PairSelectionKey());
-  selectionKeys.push_back(CentralitySelectionKey());
-  selectionKeys.push_back(FitTypeKey());
-  
-  // read per run info
-  while (std::getline(in,line))
-  {
+    }
+    
+    std::string line;
+    
+    std::vector<TString> selectionKeys;
+    
+    selectionKeys.push_back(DimuonTriggerKey());
+    selectionKeys.push_back(MuonTriggerKey());
+    selectionKeys.push_back(MinbiasTriggerKey());
+    selectionKeys.push_back(EventSelectionKey());
+    selectionKeys.push_back(PairSelectionKey());
+    selectionKeys.push_back(CentralitySelectionKey());
+    selectionKeys.push_back(FitTypeKey());
+    
+    // read per run info
+    while (std::getline(in,line))
+    {
     TString sline(line.c_str());
     if ( sline.BeginsWith("#") ) continue;
     if ( sline.BeginsWith("//") ) continue;
@@ -680,73 +680,73 @@ void AliAnalysisMuMuConfig::ReadFromFile(const char* inputfile)
     if (!GetKeyValue(sline, ':',left,right)) continue;
     
     if ( left.Atoi() )
-    {
-      // we assume left is a run range, so we define runinfo
-      SetRunInfo(left,right);
-    }
+        {
+        // we assume left is a run range, so we define runinfo
+        SetRunInfo(left,right);
+        }
     else if ( !left.CompareTo(OCDBPathKey(),TString::kIgnoreCase) )
-    {
-      fOCDBPath = right;
-      fOCDBPath.Remove(TString::kBoth,' ');
-    }
+        {
+        fOCDBPath = right;
+        fOCDBPath.Remove(TString::kBoth,' ');
+        }
     else if ( !left.CompareTo(CompactGraphKey(),TString::kIgnoreCase) )
-    {
-      right.Remove(TString::kBoth,' ');
-      if ( !right.CompareTo("yes",TString::kIgnoreCase) ||
-          !right.CompareTo("on",TString::kIgnoreCase) ||
-          !right.CompareTo("1",TString::kIgnoreCase) )
-      {
-        fIsCompactGraphs = kTRUE;
-      }
-      else
-      {
-        fIsCompactGraphs = kFALSE;
-      }
-    }
+        {
+        right.Remove(TString::kBoth,' ');
+        if ( !right.CompareTo("yes",TString::kIgnoreCase) ||
+            !right.CompareTo("on",TString::kIgnoreCase) ||
+            !right.CompareTo("1",TString::kIgnoreCase) )
+            {
+            fIsCompactGraphs = kTRUE;
+            }
+        else
+            {
+            fIsCompactGraphs = kFALSE;
+            }
+        }
     else {
-      
-      Bool_t found(kFALSE);
-      
-      for ( std::vector<TString>::size_type i = 0; i < selectionKeys.size(); ++i )
-      {
-        if ( ! left.CompareTo(selectionKeys[i],TString::kIgnoreCase) )
+        
+        Bool_t found(kFALSE);
+        
+        for ( std::vector<TString>::size_type i = 0; i < selectionKeys.size(); ++i )
         {
-          Add(selectionKeys[i],right);
-          found = kTRUE;
+        if ( ! left.CompareTo(selectionKeys[i],TString::kIgnoreCase) )
+            {
+            Add(selectionKeys[i],right);
+            found = kTRUE;
+            }
         }
-      }
-
-      if (!found)
-      {
+        
+        if (!found)
+        {
         std::cerr << "Unable to decode line : " << std::endl;
         std::cerr << line << std::endl;
-      }
+        }
+    }
     }
-  }
 }
 
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::SetColorScheme()
 {
-  /// Set a few custom colors
-  
-  new TColor(AliAnalysisMuMuConfig::kBlue,4/255.0,44/255.0,87/255.0,"my blue");
-  new TColor(AliAnalysisMuMuConfig::kOrange,255/255.0,83/255.0,8/255.0,"my orange");
-  new TColor(AliAnalysisMuMuConfig::kGreen,152/255.0,202/255.0,52/255.0,"my green");
-  
-  gStyle->SetGridColor(AliAnalysisMuMuConfig::kBlue);
-  
-  gStyle->SetFrameLineColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetAxisColor(AliAnalysisMuMuConfig::kBlue,"xyz");
-  gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue,"xyz");
-  
-  gStyle->SetTitleColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetTitleTextColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetStatTextColor(AliAnalysisMuMuConfig::kBlue);
-  
-  gStyle->SetOptStat(0);
+    /// Set a few custom colors
+    
+    new TColor(AliAnalysisMuMuConfig::kBlue,4/255.0,44/255.0,87/255.0,"my blue");
+    new TColor(AliAnalysisMuMuConfig::kOrange,255/255.0,83/255.0,8/255.0,"my orange");
+    new TColor(AliAnalysisMuMuConfig::kGreen,152/255.0,202/255.0,52/255.0,"my green");
+    
+    gStyle->SetGridColor(AliAnalysisMuMuConfig::kBlue);
+    
+    gStyle->SetFrameLineColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetAxisColor(AliAnalysisMuMuConfig::kBlue,"xyz");
+    gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue,"xyz");
+    
+    gStyle->SetTitleColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetTitleTextColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetStatTextColor(AliAnalysisMuMuConfig::kBlue);
+    
+    gStyle->SetOptStat(0);
 }
 
 
diff --git a/PWG/muondep/AliAnalysisMuMuConfig.h b/PWG/muondep/AliAnalysisMuMuConfig.h
index cc4da2b..d5512ab 100644
--- a/PWG/muondep/AliAnalysisMuMuConfig.h
+++ b/PWG/muondep/AliAnalysisMuMuConfig.h
@@ -130,6 +130,8 @@ public:
   
   TObjArray* GetListElements(const char* type, Bool_t simulation) const;
 
+  void DefineDefaultsFromFile(const char* configfile);
+
 private:
   
   enum EDataType { kSim = 1<<0, kReal = 1<<1 };
diff --git a/PWG/muondep/AliAnalysisMuMuFnorm.cxx b/PWG/muondep/AliAnalysisMuMuFnorm.cxx
index 59f44d8..3195ca4 100644
--- a/PWG/muondep/AliAnalysisMuMuFnorm.cxx
+++ b/PWG/muondep/AliAnalysisMuMuFnorm.cxx
@@ -35,6 +35,7 @@
 #include "AliCounterCollection.h"
 #include "AliLog.h"
 #include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuConfig.h"
 #include "Riostream.h"
 #include "TAxis.h"
 #include "TCanvas.h"
@@ -53,12 +54,13 @@
 ClassImp(AliAnalysisMuMuFnorm)
 
 //_____________________________________________________________________________
-AliAnalysisMuMuFnorm::AliAnalysisMuMuFnorm(AliCounterCollection& cc,
+AliAnalysisMuMuFnorm::AliAnalysisMuMuFnorm(AliCounterCollection& cc,AliAnalysisMuMuConfig& cf,
                                            AliAnalysisMuMuFnorm::ETriggerType refTriggerType,
                                            const char* ocdbpath,
                                            Bool_t compactGraphs) :
 TObject(),
 fCounterCollection(cc),
+fConfig(cf),
 fMergeableCollection(0x0),
 fIsOwner(kTRUE),
 fOCDBPath(ocdbpath),
@@ -67,8 +69,6 @@ fIsCompactGraphs(compactGraphs),
 fReferenceTriggerType(refTriggerType)
 {
   // ctor
-  
-  
 }
 
 //_____________________________________________________________________________
@@ -95,73 +95,72 @@ void AliAnalysisMuMuFnorm::ComputeFnorm()
   ///   - scaler values corrected for pile-up
   ///   - scaler values corrected for pile-up and physics selection
 
-  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
-  const Bool_t trueFalse[] = { kTRUE, kFALSE };
+//   const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+//   const Bool_t trueFalse[] = { kTRUE, kFALSE };
+//   // Call ComputeNofEvent for every combination possible
+//   for ( Int_t i = 0; i < 4; ++i )
+//   {
+//     for ( Int_t pileup = 0; pileup < 2; ++pileup )
+//     {
+//       for ( Int_t ps = 0; ps < 2; ++ps )
+//       {
+//         ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+//       }
+//     }
+//   }
+//   ComputeFnormOffline(1,kFALSE,0);
+//   ComputeFnormOffline(1,kFALSE,1);
+//   ComputeFnormOffline(1,kTRUE,1);
   
-  for ( Int_t i = 0; i < 4; ++i )
-  {
-    for ( Int_t pileup = 0; pileup < 2; ++pileup )
-    {
-      for ( Int_t ps = 0; ps < 2; ++ps )
-      {
-        ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
-      }
-    }
-  }
-
-  ComputeFnormOffline(1,kFALSE,0);
-  ComputeFnormOffline(1,kFALSE,1);
-  ComputeFnormOffline(1,kTRUE,1);
-  
-  ComputeFnormOffline(2,kFALSE,0);
-  ComputeFnormOffline(2,kFALSE,1);
-  ComputeFnormOffline(2,kTRUE,1);
+//   ComputeFnormOffline(2,kFALSE,0);
+//   ComputeFnormOffline(2,kFALSE,1);
+//   ComputeFnormOffline(2,kTRUE,1);
 
-//  ComputeFnormOffline(2,kFALSE,2);
-//  ComputeFnormOffline(2,kTRUE,2);
+// //  ComputeFnormOffline(2,kFALSE,2);
+// //  ComputeFnormOffline(2,kTRUE,2);
 
-  ComputeFnormScalers(kFALSE,0);
-  ComputeFnormScalers(kTRUE,0);
-  ComputeFnormScalers(kTRUE,1);
-//  ComputeFnormScalers(kTRUE,2);
+//   ComputeFnormScalers(kFALSE,0);
+//   ComputeFnormScalers(kTRUE,0);
+//   ComputeFnormScalers(kTRUE,1);
+// //  ComputeFnormScalers(kTRUE,2);
 
-  WeightedMeanGraphs("Offline");
-  WeightedMeanGraphs("Scalers");
-  WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
+//   WeightedMeanGraphs("Offline");
+//   WeightedMeanGraphs("Scalers");
+//   WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
   
-  WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
+//   WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
   
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
 
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
   
-  ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
+//   ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
 
-//  for ( Int_t i = 0; i < 4; ++i )
-///  {
-    TString triggerEvents;
+// //  for ( Int_t i = 0; i < 4; ++i )
+// ///  {
+//     TString triggerEvents;
     
-//  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
-  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
+// //  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
+//   triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
   
-  MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
+//   MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
   
-    MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
-  MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
-//  }
+//     MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
+//   MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
+// //  }
 
-//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
-//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
+// //  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
+// //  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
 
-  ComputeResultsFromGraphs();
+//   ComputeResultsFromGraphs();
   
-  AliAnalysisMuMuResult* result = GetResult("Fnorm");
-  if (result)
-  {
-    result->Exclude("*");
-    result->Include("FnormBest2");
-  }
+//   AliAnalysisMuMuResult* result = GetResult("Fnorm");
+//   if (result)
+//   {
+//     result->Exclude("*");
+//     result->Include("FnormBest2");
+//   }
 }
 
 //_____________________________________________________________________________
@@ -179,7 +178,7 @@ void AliAnalysisMuMuFnorm::ComputeCorrectionFactors(Int_t eventSelectionCorrecte
     return;
   }
   
-  AliDebug(2,"");
+  AliDebug(2,"");// ??
   
   std::vector<double> vx;
   std::vector<double> vxerr;
@@ -193,7 +192,7 @@ void AliAnalysisMuMuFnorm::ComputeCorrectionFactors(Int_t eventSelectionCorrecte
   
   for ( Int_t i = 0; i < 4; ++i )
   {
-    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);
+    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);// Problem from here
     ComputePileUpGraph(triggerTypes[i],eventSelectionCorrected);
   }
   
@@ -259,6 +258,7 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
   TString name("FnormOffline");
   TString title("Computed using offline information");
   TString refInput = Form("0%s",GetTriggerTypeName(fReferenceTriggerType).Data());
+  printf("refInput = %s\n",refInput.Data() );
   
   if (nstep==1)
   {
@@ -309,7 +309,8 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     TString mbTrigger = GetTriggerClassName(kMB,runNumber);
     TString muonTrigger = GetTriggerClassName(kMSL,runNumber);
 //    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
-    
+    printf("mb trigger : %s\n", mbTrigger.Data() );
+
     if (!mbTrigger.Length())
     {
       AliError(Form("Cannot get MB trigger for run %d",runNumber));
@@ -819,7 +820,7 @@ void AliAnalysisMuMuFnorm::ComputeNofEvents(ETriggerType triggerType,
   TString graphName(Form("NofEvent%s%s%s",GetTriggerTypeName(triggerType).Data(),
                          pileUpCorrected ? "PU" : "",
                          GetEventSelectionName(eventSelectionCorrected).Data()));
-  
+  // Check if Compute has already been done
   if ( GetGraph(graphName) )
   {
     // compute it only once
@@ -1387,6 +1388,8 @@ Double_t AliAnalysisMuMuFnorm::GetSum(const char* triggerClassName,
   }
   
   Double_t n = fCounterCollection.GetSum(condition.Data());
+
+  printf("Sum of %s for %s = %f \n",triggerClassName,condition.Data(),n );
   
   if (n<=0)
   {
@@ -1488,13 +1491,21 @@ TString AliAnalysisMuMuFnorm::MBTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
-  {
-    return "CINT7-B-NOPF-ALLNOTRD";
-  }
-  return "";
+  // if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CINT7-B-NOPF-ALLNOTRD";
+  // }
+  // else if ( TriggerClassnameTest("CPBI2_B1-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CPBI2_B1-B-NOPF-ALLNOTRD";
+  // }
+  // return "";
+  
+  TString triggerType(fConfig.First(fConfig.MinbiasTriggerKey(),kFALSE).Data());
+  return triggerType.Data();
 }
 
+
 //_____________________________________________________________________________
 TString AliAnalysisMuMuFnorm::MSHTriggerClassName(Int_t runNumber) const
 {
@@ -1516,18 +1527,22 @@ TString AliAnalysisMuMuFnorm::MSLTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
-  {
-      return "CMSL7-B-NOPF-MUON";
-  }
-//  else
-//    if ( TriggerClassnameTest("CMSL7-B-NOPF-ALLNOTRD",runNumber) )
-//  {
-//    return "CMSL7-B-NOPF-ALLNOTRD";
-//  }
-  return "";
+ //  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
+ //  {
+ //      return "CMSL7-B-NOPF-MUON";
+ //  }
+ // else
+ //   if ( TriggerClassnameTest("CPBI1MSL-B-NOPF-MUON",runNumber) )
+ // {
+ //   return "CPBI1MSL-B-NOPF-MUON";
+ // }
+ //  return "";
+ 
+ TString triggerType(fConfig.First(fConfig.MuonTriggerKey(),kFALSE).Data());
+  return triggerType.Data();
 }
 
+
 //_____________________________________________________________________________
 void AliAnalysisMuMuFnorm::MultiplyGraphs(const char* g1name, const char* g2name, const char* name)
 {
@@ -1596,16 +1611,24 @@ TString AliAnalysisMuMuFnorm::MULTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
-  {
-    return "CMUL7-B-NOPF-ALLNOTRD";
-  }
-  else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
-  {
-    return "CMUL7-B-NOPF-MUON";
-  }
-  return "";
+  // if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CMUL7-B-NOPF-ALLNOTRD";
+  // }
+  // else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
+  // {
+  //   return "CMUL7-B-NOPF-MUON";
+  // }
+  // else if ( TriggerClassnameTest("CPBI1MUL-B-NOPF-MUON",runNumber) )
+  // {
+  //   return "CPBI1MUL-B-NOPF-MUON";
+  // }
+  // return "";
   
+  TString triggerType(fConfig.First(fConfig.DimuonTriggerKey(),kFALSE).Data());
+    return triggerType.Data();
+
+
 }
 
 //_____________________________________________________________________________
@@ -1725,7 +1748,7 @@ Bool_t AliAnalysisMuMuFnorm::TriggerClassnameTest(const char* triggerClassName,
 
 //_____________________________________________________________________________
 void
-AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char* graphName)
+AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char* graphName, AliMergeableCollection* mc)
 {
   /// Sum the graphs which name matches pattern
   /// Sum is made using a weighted mean (each element is weighted by the inverse
@@ -1740,34 +1763,52 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     slist = spattern.Tokenize(",");
     spattern = "";
   }
+
+  TList* objectList = 0x0;
+  if(mc) {
+    printf("Adding %s to the list...\n", "/FNORM/Offline/GRAPHS/");
+    objectList = mc->CreateListOfObjectNames("/FNORM/Offline/GRAPHS/");
+    printf("Adding %s to the list...\n", "/FNORM/Scaler/GRAPHS/");
+    objectList->Add(static_cast<TObject*>(mc->CreateListOfObjectNames("/FNORM/Scaler/GRAPHS/")));
+  }
+  else return;
+
+  if (!objectList){
+    printf("Cannot add list\n");
+    return;
+  } 
+  objectList->Print();
   
-  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
   TIter next(objectList);
   TObjString* str(0x0);
   TObjArray selected;
   selected.SetOwner(kFALSE);
-  
+
+  printf("Selecting graphs ...\n");
   while ( ( str = static_cast<TObjString*>(next()) ) )
   {
-    TGraphErrors* g = GetGraph(str->String());
-    
+    TGraphErrors* g = static_cast<TGraphErrors*>(objectList->FindObject(str->String()));
+
     if (!g) continue;
-    
+
     TString name(g->GetName());
-    
+
     if ( spattern.Length() >0 && !name.Contains(spattern.Data()) ) continue;
-    
+    AliDebug(2,Form("name : %s !\n",name.Data() ));
+
     if ( slist && !slist->FindObject(name)) continue;
-    
+
     AliDebug(2,Form("Selected for sum : %s",name.Data()));
     
-    selected.Add(g);
+    selected.Add(g->Clone());
   }
   
   delete slist;
   delete objectList;
   
   if (selected.GetLast()<0) return;
+
+  selected.Print();
   
   std::vector<double> vx;
   std::vector<double> vy;
@@ -1775,16 +1816,24 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
   std::vector<double> vyerr;
   
   Int_t npts = static_cast<TGraphErrors*>(selected.First())->GetN();
+  if(npts==0 || npts==1) return;
+
+  printf("npts = %d \n", npts);
   
+  printf("Computing mean ...\n");
+
   for ( Int_t ipoint = 0; ipoint < npts; ++ipoint )
   {
     Double_t x(0.0),xref(0.0),xerr(0.0);
     Double_t sum(0.0);
     Double_t sume2(0.0);
     
+    printf("Loop on graphs ...\n");
     for ( Int_t igraph = 0; igraph <= selected.GetLast(); ++igraph )
     {
       TGraphErrors* g = static_cast<TGraphErrors*>(selected.At(igraph));
+      printf("g = %p\n", g);
+      g->Print();      
       
       if ( g->GetN() != npts )
       {
@@ -1792,16 +1841,23 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
         continue;
       }
       Double_t runNumber;
-      
+      new TCanvas;
+      g->DrawClone("");
+
       if ( fIsCompactGraphs )
       {
+        printf("toto\n");
+        cout << g->GetXaxis()->GetBinLabel(ipoint+1)<< endl;
         runNumber = TString(g->GetXaxis()->GetBinLabel(ipoint+1)).Atoi()*1.0;
+        
+        printf("runNumber %f\n", runNumber);
       }
       else
       {
         runNumber = g->GetX()[ipoint];
+        printf("runNumber 2 %f\n", runNumber);
       }
-      
+      printf("totoo !\n");
       if ( igraph == 0 )
       {
         xref = g->GetX()[ipoint];
@@ -1816,6 +1872,7 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
           return;
         }
       }
+      printf("totooo !\n");
       
       Double_t e2 = g->GetEY()[ipoint]*g->GetEY()[ipoint];
       
@@ -1835,6 +1892,7 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     }
   }
   
+  printf("Changing titles ...\n");
   Int_t n = selected.GetEntries();
   
   TString name(graphName);
@@ -1847,6 +1905,7 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     title = TString::Format("WeightMeanFnorm%s from %d individual graphs",patternOrList,n);
   }
   
+  printf("Creating graph ...\n");
   CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
 }
 
diff --git a/PWG/muondep/AliAnalysisMuMuFnorm.h b/PWG/muondep/AliAnalysisMuMuFnorm.h
index d132c0b..444b6ca 100644
--- a/PWG/muondep/AliAnalysisMuMuFnorm.h
+++ b/PWG/muondep/AliAnalysisMuMuFnorm.h
@@ -21,6 +21,7 @@ class TGraph;
 class AliAnalysisMuMuResult;
 class AliCounterCollection;
 class AliMergeableCollection;
+class AliAnalysisMuMuConfig;
 
 class AliAnalysisMuMuFnorm : public TObject
 {
@@ -35,7 +36,7 @@ public:
     kMSH=4
   };
   
-  AliAnalysisMuMuFnorm(AliCounterCollection& cc,
+  AliAnalysisMuMuFnorm(AliCounterCollection& cc, AliAnalysisMuMuConfig& cf,
                        AliAnalysisMuMuFnorm::ETriggerType triggerType=AliAnalysisMuMuFnorm::kMUL,
                        const char* ocdbpath="raw://",
                        Bool_t compactGraphs=kFALSE);
@@ -105,7 +106,7 @@ public:
 
   Bool_t TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const;
 
-  void WeightedMeanGraphs(const char* pattern, const char* name="");
+  void WeightedMeanGraphs(const char* pattern="", const char* name="", AliMergeableCollection* mc =0x0);
   
 private:
   
@@ -135,6 +136,7 @@ private:
 private:
   
   /*const*/ AliCounterCollection& fCounterCollection; // collection of trigger counters (not owner)
+  /*const*/ AliAnalysisMuMuConfig& fConfig; // collection of trigger counters (not owner)
   mutable AliMergeableCollection* fMergeableCollection; // collection of results, histograms, graphs (ownership is in fIsOwner)
   Bool_t fIsOwner; // whether we are the owner of the mergeable collection
   TString fOCDBPath; // OCDB to be used (raw:// by default)
diff --git a/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx b/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
new file mode 100644
index 0000000..c121343
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
@@ -0,0 +1,1859 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// AliAnalysisMuMuFnormBeta : class to encapsulate computation(s)
+/// of the normalisation factor used to get the equivalent
+/// number of MB events from the number of REF triggers
+///
+/// The computed objects are stored within a AliMergeableCollection
+/// with 3 subdirectories, dependinf on their type
+///
+/// /GRAPHS/
+/// /RESULTS/
+/// /HISTOS/
+///
+/// author: Laurent Aphecetche (Subatech) and Benjamin Audurier
+
+#include "AliAnalysisMuMuFnormBeta.h"
+
+#include "AliAnalysisMuMuGraphUtil.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisTriggerScalers.h"
+#include "AliCounterCollection.h"
+#include "AliLog.h"
+#include "AliMergeableCollection.h"
+#include "Riostream.h"
+#include "TAxis.h"
+#include "TCanvas.h"
+#include "TGraphErrors.h"
+#include "TH1F.h"
+#include "TList.h"
+#include "TMap.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "TObjString.h"
+#include "TPaveText.h"
+#include "TStyle.h"
+#include <cassert>
+#include <numeric>
+
+ClassImp(AliAnalysisMuMuFnormBeta)
+
+//_____________________________________________________________________________
+AliAnalysisMuMuFnormBeta::AliAnalysisMuMuFnormBeta(AliCounterCollection& cc,
+                                           AliAnalysisMuMuFnormBeta::ETriggerType refTriggerType,
+                                           const char* ocdbpath,
+                                           Bool_t compactGraphs) :
+TObject(),
+fCounterCollection(cc),
+fMergeableCollection(0x0),
+fIsOwner(kTRUE),
+fOCDBPath(ocdbpath),
+fResult(0x0),
+fIsCompactGraphs(compactGraphs),
+fReferenceTriggerType(refTriggerType)
+{
+  // ctor
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuFnormBeta::~AliAnalysisMuMuFnormBeta()
+{
+  // dtor
+  if ( fIsOwner )
+  {
+    delete fMergeableCollection;
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnorm()
+{
+  /// Compute the REF to CINT ratio(s)
+  ///
+  /// Using offline method
+  ///   - in one go CINT/REF
+  ///   - in two steps CINT/CMSL and CMSL/REF
+  ///
+  /// Using scaler method
+  ///   - bare scaler values
+  ///   - scaler values corrected for pile-up
+  ///   - scaler values corrected for pile-up and physics selection
+
+  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+  const Bool_t trueFalse[] = { kTRUE, kFALSE };
+  // Call ComputeNofEvent for every combination possible
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    for ( Int_t pileup = 0; pileup < 2; ++pileup )
+    {
+      for ( Int_t ps = 0; ps < 2; ++ps )
+      {
+        ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+      }
+    }
+  }
+ cout << "Here ! "<< endl;
+  ComputeFnormOffline(1,kFALSE,0);
+  ComputeFnormOffline(1,kFALSE,1);
+  ComputeFnormOffline(1,kTRUE,1);
+  
+  ComputeFnormOffline(2,kFALSE,0);
+  ComputeFnormOffline(2,kFALSE,1);
+  ComputeFnormOffline(2,kTRUE,1);
+
+//  ComputeFnormOffline(2,kFALSE,2);
+//  ComputeFnormOffline(2,kTRUE,2);
+
+  ComputeFnormScalers(kFALSE,0);
+  ComputeFnormScalers(kTRUE,0);
+  ComputeFnormScalers(kTRUE,1);
+//  ComputeFnormScalers(kTRUE,2);
+
+  WeightedMeanGraphs("Offline");
+  WeightedMeanGraphs("Scalers");
+  WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
+  
+  WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
+  
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
+
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
+  
+  ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
+
+//  for ( Int_t i = 0; i < 4; ++i )
+///  {
+    TString triggerEvents;
+    
+//  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
+  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
+  
+  MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
+  
+    MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
+  MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
+//  }
+
+//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
+//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
+
+  ComputeResultsFromGraphs();
+  
+  AliAnalysisMuMuResult* result = GetResult("Fnorm");
+  if (result)
+  {
+    result->Exclude("*");
+    result->Include("FnormBest2");
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeCorrectionFactors(Int_t eventSelectionCorrected)
+{
+  /// Compute individual graphs for the correction factors (PS_REF, PS_CINT,
+  /// F_pile-up,PS_CINT/PS_REF) used in the computation of (some) Fnorm factors
+  ///
+
+  TString graphName(Form("CorrectionGlobal%s",GetEventSelectionName(eventSelectionCorrected).Data()));;
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we compute it only once
+    return;
+  }
+  
+  AliDebug(2,"");// ??
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  std::vector<double> vyGlobal;
+  std::vector<double> vyGlobalErr;
+
+  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+  
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);// Problem from here
+    ComputePileUpGraph(triggerTypes[i],eventSelectionCorrected);
+  }
+  
+  TGraphErrors* gPSCINT = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(AliAnalysisMuMuFnormBeta::kMB).Data()));
+                                   
+  TGraphErrors* gPSREF = GetGraph(Form("Correction%s%s", GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(fReferenceTriggerType).Data()));
+                                   
+  TGraphErrors* gPU = GetGraph(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(AliAnalysisMuMuFnormBeta::kMB).Data()));
+  
+  if ( !gPSCINT || !gPSREF || !gPU )
+  {
+    AliError("Did not get the relevant graphs. Cannot work");
+    return;
+  }
+  
+  for ( Int_t i = 0; i < gPSCINT->GetN(); ++i )
+  {
+    Double_t x,y,yerr,yGlobal,yGlobalErr;
+    
+    gPSCINT->GetPoint(i,x,y);
+    
+    if ( fIsCompactGraphs )
+    {
+      x = TString(gPSCINT->GetXaxis()->GetBinLabel(i)).Atoi();
+    }
+    
+    yGlobal = gPSCINT->GetY()[i] * gPU->GetY()[i] / gPSREF->GetY()[i];
+    
+    yGlobalErr = yGlobal*AliAnalysisMuMuResult::ErrorABC(gPSCINT->GetY()[i],gPSCINT->GetEY()[i],
+                                                         gPSREF->GetY()[i],gPSREF->GetEY()[i],
+                                                         gPU->GetY()[i],gPU->GetEY()[i]);
+    
+    y = gPSCINT->GetY()[i] / gPSREF->GetY()[i];
+    yerr = y * AliAnalysisMuMuResult::ErrorAB(gPSCINT->GetY()[i],gPSCINT->GetEY()[i],
+                                              gPSREF->GetY()[i],gPSREF->GetEY()[i]);
+
+    vx.push_back(x);
+    vxerr.push_back(gPSCINT->GetEX()[i]);
+
+    vyGlobal.push_back(yGlobal);
+    vyGlobalErr.push_back(yGlobalErr);
+    
+    vy.push_back(y);
+    vyerr.push_back(yerr);
+  }
+  
+  TString name(Form("Correction%sRatio",GetEventSelectionName(eventSelectionCorrected).Data()));
+  TString title(Form("%s_MB/%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data(),
+                     GetEventSelectionName(eventSelectionCorrected).Data()));
+  
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+  
+  title = TString::Format("%s_MB x Fpile-up / %s_%s ",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data(),GetEventSelectionName(eventSelectionCorrected).Data());
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vyGlobal,vyGlobalErr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrected, Int_t eventSelectionCorrected)
+{
+  /// Compute MB to REF ratio using offline method, either in 1 or 2 steps
+  
+  TString name("FnormOffline");
+  TString title("Computed using offline information");
+  TString refInput = Form("0%s",GetTriggerTypeName(fReferenceTriggerType).Data());
+  
+  if (nstep==1)
+  {
+    name += "1";
+    title += Form(" in one step (CINT/CINT&%s)",refInput.Data());
+  }
+  else
+  {
+    name += "2";
+    title += Form(" in two steps (CMSL/CMSL&%s x CINT/CINT&0MSL)",refInput.Data());
+  }
+  
+  if (pileUpCorrected)
+  {
+    name += "PU";
+    title += " with pile-up correction";
+  }
+  if (eventSelectionCorrected==1)
+  {
+    name += "PS";
+    title += " with (ps) purity corrections";
+  }
+  else if ( eventSelectionCorrected==2 )
+  {
+    name += "TS";
+    title += " with (ts) purity corrections";
+  }
+
+  if ( GetGraph(name) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+  
+  AliDebug(2,name);
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    TString mbTrigger = GetTriggerClassName(kMB,runNumber);
+    TString muonTrigger = GetTriggerClassName(kMUL,runNumber);
+//    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
+    
+    if (!mbTrigger.Length())
+    {
+      AliError(Form("Cannot get MB trigger for run %d",runNumber));
+      continue;
+    }
+    
+    Double_t nofMB = GetSum(mbTrigger.Data(),runNumber,eventSelectionCorrected);
+    Double_t nofMSL(0.0);
+    Double_t nofMSLw0REF(0.0);
+    
+    if ( nstep==2 )
+    {
+      nofMSL = GetSum(muonTrigger.Data(),runNumber,eventSelectionCorrected);
+      TString counterName = muonTrigger;
+      if ( fReferenceTriggerType != kMSL ) counterName += Form("&%s",refInput.Data());
+      nofMSLw0REF = GetSum(counterName,runNumber,eventSelectionCorrected);
+    }
+    
+    Double_t nofMBw0REF = GetSum(Form("%s&%s",mbTrigger.Data(),refInput.Data()),runNumber,eventSelectionCorrected);
+    Double_t nofMBw0MSL = GetSum(Form("%s&0MSL",mbTrigger.Data()),runNumber,eventSelectionCorrected);
+    
+    if ( !nofMBw0REF ) continue;
+    if ( !nofMBw0MSL && nstep == 2 ) continue;
+    
+    Double_t purityMB(1.0);
+    Double_t purityMBerror(0.0);
+
+    if ( eventSelectionCorrected > 0 )
+    {
+      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
+      
+      TGraphErrors* gps = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      
+      GetValueAndErrorFromGraph(gps,runNumber,purityMB,purityMBerror);
+    }
+    
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+    
+    if (pileUpCorrected)
+    {      
+      ComputePileUpGraph(kMB,eventSelectionCorrected);
+      
+      TGraphErrors* gpu = GetGraph(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      
+      GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
+
+      nofMB *= pileUpFactor;
+    }
+        
+    double value = nofMBw0REF > 0.0 ? nofMB/nofMBw0REF : 0.0;
+    double error = value*AliAnalysisMuMuResult::ErrorABC(nofMB,TMath::Sqrt(nofMB),
+                                                              nofMBw0REF,TMath::Sqrt(nofMBw0REF),
+                                                              pileUpFactor,pileUpFactorError);
+    
+    if ( nstep == 2 )
+    {
+      value = (nofMB/nofMSLw0REF)*(nofMSL/nofMBw0MSL);
+      
+      if ( runNumber == 196310 )
+      {
+        AliDebug(1,Form("RUN %09d %d-%d-%d value=%e nofMB %e nofMSLw%s %e nofMSL %e nofMBw0MSL %e",
+                        runNumber,nstep,pileUpCorrected,eventSelectionCorrected,
+                        value,nofMB,refInput.Data(),nofMSLw0REF,nofMSL,nofMBw0MSL));
+      }
+      
+      error = value*AliAnalysisMuMuResult::ErrorABCD(nofMB,TMath::Sqrt(nofMB),
+                                                          nofMSLw0REF,TMath::Sqrt(nofMSLw0REF),
+                                                          nofMSL,TMath::Sqrt(nofMSL),
+                                                          nofMBw0MSL,TMath::Sqrt(nofMBw0MSL));
+    }
+    
+    if ( value > 0.0 )
+    {
+      vx.push_back(1.0*runNumber);
+      vxerr.push_back(0.5);
+      vy.push_back(value);
+      vyerr.push_back(error);
+    }
+  }
+  
+    
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnormScalers(Bool_t pileUpCorrected,
+                                               Int_t eventSelectionCorrected)
+{
+  /// Compute the MB to REF ratio using the scalers method (from OCDB)
+  ///
+  /// i.e. Fnorm = L0B(MB) x PS(MB) x Fpile-up / ( L0B(REF) x PS(REF) )
+  ///
+  /// where MB is the minbias trigger
+  /// REF is the fReferenceTrigger
+  /// and PS is the fraction of events selected by the physics selection
+  ///
+  /// The correction factor (the two PS and one Fpile-up) are
+  /// taken from graphs computed in other methods
+  ///
+  
+  TString name("FnormScalers");
+  TString title("Computed using OCDB scalers");
+  
+  if (pileUpCorrected)
+  {
+    name += "PU";
+    title += " with pile-up correction";
+  }
+  if (eventSelectionCorrected==1)
+  {
+    name += "PS";
+    title += " with (ps) purity corrections";
+  }
+  if (eventSelectionCorrected==2)
+  {
+    name += "TS";
+    title += " with (ts) purity corrections";
+  }
+  
+  if ( GetGraph(name) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+  
+  AliDebug(2,name);
+  
+  // insure we have all the graphs we need to work
+  ComputeTriggerL0B(kMB);
+  ComputeTriggerL0B(fReferenceTriggerType);
+  
+  const std::set<int>& runs = RunNumbers();
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  Double_t purityREF(1.0);
+  Double_t purityMB(1.0);
+  Double_t purityREFerror(00);
+  Double_t purityMBerror(0.0);
+  
+  // compute the per run values
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    TString mbTrigger = GetTriggerClassName(kMB,runNumber);
+//    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
+    
+    purityMB=purityREF=1.0;
+    purityMBerror=purityREFerror=0.0;
+    
+    if (eventSelectionCorrected>0)
+    {
+      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
+      ComputeEventSelectionGraph(fReferenceTriggerType,eventSelectionCorrected);
+      
+      TGraphErrors* gpsMB  = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      TGraphErrors* gpsREF = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data()));
+      
+      GetValueAndErrorFromGraph(gpsMB,runNumber,purityMB,purityMBerror);
+      GetValueAndErrorFromGraph(gpsREF,runNumber,purityREF,purityREFerror);
+    }
+    
+    if (purityMB<=0.0)
+    {
+      AliError(Form("Got purity=%e for MB for run %9d",purityMB,runNumber));
+      continue;
+    }
+    
+    TGraphErrors* gl0bMB = GetGraph(Form("L0B%s",GetTriggerTypeName(kMB).Data()));
+    TGraphErrors* gl0bREF = GetGraph(Form("L0B%s",GetTriggerTypeName(fReferenceTriggerType).Data()));
+    
+    Double_t L0bMB,L0bMBError;
+    Double_t L0bREF,L0bREFError;
+    
+    GetValueAndErrorFromGraph(gl0bMB,runNumber,L0bMB,L0bMBError);
+    GetValueAndErrorFromGraph(gl0bREF,runNumber,L0bREF,L0bREFError);
+    
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+    
+    if (pileUpCorrected)
+    {
+      TGraphErrors* gpu = GetGraph((Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data())));
+      
+      GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
+    }
+    
+    Double_t value;
+    Double_t error;
+    
+    ScalerFnorm(value,error,
+                L0bREF,purityREF,purityREFerror,
+                L0bMB,purityMB,purityMBerror,
+                pileUpFactor,pileUpFactorError);
+    
+    if ( value > 0.0 )
+    {
+      vx.push_back(1.0*runNumber);
+      vxerr.push_back(0.5);
+      vy.push_back(value);
+      vyerr.push_back(error);
+    }
+  }
+  
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeGraphRelDif(const char* a, const char* b) const
+{
+  // compute dispersion of b versus a
+  //
+  // computed differences graphs are put into the GRAPHS/ directory
+  // computed differences results are put into the HISTOS/ directory
+  
+  TString name(Form("RelDif%svs%s",b,a));
+  
+  if ( GetGraph(name) )
+  {
+    // insure we compute it only once
+    return;
+  }
+  
+  AliDebug(2,name);
+  
+  TGraphErrors* ga = static_cast<TGraphErrors*>(MC()->GetObject(Form("/GRAPHS/%s",a)));
+  TGraphErrors* gb = static_cast<TGraphErrors*>(MC()->GetObject(Form("/GRAPHS/%s",b)));
+  
+  if (!ga)
+  {
+    AliError(Form("Cannot get graph for %s",a));
+    return;
+  }
+  
+  if (!gb)
+  {
+    AliError(Form("Cannot get graph for %s",b));
+    return;
+  }
+  
+  if ( ga->GetN() != gb->GetN() )
+  {
+    AliError(Form("Cannot work with different number of points in the graphs : %d vs %d",
+                  ga->GetN(),gb->GetN()));
+    return;
+  }
+  
+  TString title(Form("%s-%s (RelDif,%%)",b,a));
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  for ( Int_t i = 0; i < ga->GetN(); ++i )
+  {
+    Double_t xa,xb,ya,yb;
+    
+    ga->GetPoint(i,xa,ya);
+    gb->GetPoint(i,xb,yb);
+    
+    if ( xa != xb )
+    {
+      AliError(Form("Incompatible graphs : got xa=%e and xb=%e",xa,xb));
+      return;
+    }
+  
+    Double_t newvalue = 0.0;
+    
+    if ( TMath::Abs(xa) > 1E-12 )
+    {
+      newvalue = 100.0*( yb - ya ) / ya;
+    }
+
+    Double_t yerr = newvalue*AliAnalysisMuMuResult::ErrorAB(ya,ga->GetEY()[i],
+                                                            yb,gb->GetEY()[i]);
+
+    if ( fIsCompactGraphs )
+    {
+      xa = TString(ga->GetXaxis()->GetBinLabel(i+1)).Atoi()*1.0;
+    }
+
+    vx.push_back(xa);
+    vxerr.push_back(0.5);
+    vy.push_back(newvalue);
+    vyerr.push_back(yerr);
+    
+  }
+  
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+
+  // FIXME : fill here an histogram from the graph to get the
+  // weight of 1/e2 ?
+  //  h->Fill(newvalue,1.0/(yerr*yerr));
+  //  MC()->Adopt("/HISTOS/",h);
+  
+  //  AliAnalysisMuMuResult* r = GetRunIntegratedResult(*g,"FnormDispersion");
+  //  if (r)
+  //  {
+  //    if (!dispersion)
+  //    {
+  //      dispersion = new AliAnalysisMuMuResult("FnormDispersion");
+  //    }
+  //    dispersion->AdoptSubResult(r);
+  //    if ( !TString(g->GetName()).BeginsWith("Fnorm") )
+  //    {
+  //      dispersion->Exclude(r->Alias());
+  //    }
+  //  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputePileUpGraph(ETriggerType tt, Int_t eventSelectionCorrected)
+{
+  /// Compute the per-run graph of pile-up factor
+  
+  TString graphName(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(tt).Data()));
+  
+  if ( GetGraph(graphName) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+  
+  AliDebug(2,graphName);
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  const std::set<int>& runs = RunNumbers();
+  
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+    Double_t purity(1.0);
+    Double_t purityError(0.0);
+    
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+    
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+    
+    if (eventSelectionCorrected)
+    {
+      GetPurity(triggerClassName.Data(),runNumber,purity,purityError,eventSelectionCorrected);
+    }
+    ts.GetPileUpFactor(runNumber,triggerClassName.Data(),purity,pileUpFactor,pileUpFactorError);
+   
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(pileUpFactor);
+    vyerr.push_back(pileUpFactorError);
+  }
+  
+  TString title(Form("Pile-up correction factor for trigger %s",GetTriggerTypeName(tt).Data()));
+  
+  if (eventSelectionCorrected)
+  {
+    title += "( L0BRate corrected by event selection";
+    title += GetEventSelectionName(eventSelectionCorrected);
+    title += " accept fraction)";
+  }
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected)
+{
+  /// Compute the per-run graph of physics selection accept fraction
+  /// for the given trigger
+  
+  TString graphName(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(tt).Data()));
+  
+  if (GetGraph(graphName))
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  const std::set<int>& runs = RunNumbers();
+  
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    Double_t purity, purityError;
+    
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+    
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+
+    GetPurity(triggerClassName.Data(),runNumber,purity,purityError,eventSelectionCorrected);
+    
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(purity);
+    vyerr.push_back(purityError);
+  }
+  
+  TString title(Form("Fraction of events accepted by the event selection %s for trigger %s",GetTriggerTypeName(tt).Data(),
+                     GetEventSelectionName(eventSelectionCorrected).Data()));
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeResultsFromGraphs()
+{
+  // Compute one single value for each graph, by weighting by the fraction
+  // of events in each run
+  // do this for certain groups of graphs
+  
+  TObjArray groups;
+  groups.SetOwner(kTRUE);
+  
+  groups.Add(new TObjString("Fnorm"));
+  groups.Add(new TObjString("NMBeq"));
+  groups.Add(new TObjString("Correction"));
+  groups.Add(new TObjString("RelDif"));
+  
+  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+  
+  TIter nextGroup(&groups);
+  TObjString* grp;
+  
+  TIter next(objectList);
+  TObjString* str(0x0);
+
+  while ( ( grp = static_cast<TObjString*>(nextGroup()) ) )
+  {
+    TString oname(Form("/RESULTS/%s",grp->String().Data()));
+    
+    if ( MC()->GetObject(oname) )
+    {
+      // delete if we have it already so we can replace it
+      MC()->Remove(oname);
+    }
+    
+    AliAnalysisMuMuResult* result = new AliAnalysisMuMuResult(grp->String());
+    
+    MC()->Adopt("/RESULTS/",result);
+    
+    next.Reset();
+    
+    while ( ( str = static_cast<TObjString*>(next()) ) )
+    {
+      if ( ! ( str->String().BeginsWith(grp->String() ) ) ) continue;
+
+      TGraphErrors* g = GetGraph(str->String());
+
+      if (!g) continue;
+    
+      AliAnalysisMuMuResult* sub = GetRunIntegratedResult(*g);
+
+      if ( !sub )
+      {
+        AliError(Form("Could not get result for graph %s",g->GetName()));
+      }
+      if ( sub )
+      {
+        result->AdoptSubResult(sub);
+      }
+    }
+  }
+  
+  delete objectList;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeNofEvents(ETriggerType triggerType,
+                                            Bool_t pileUpCorrected,
+                                            Int_t eventSelectionCorrected)
+{
+  /// Compute trigger fractions
+  
+  TString graphName(Form("NofEvent%s%s%s",GetTriggerTypeName(triggerType).Data(),
+                         pileUpCorrected ? "PU" : "",
+                         GetEventSelectionName(eventSelectionCorrected).Data()));
+  // Check if Compute has already been done
+  if ( GetGraph(graphName) )
+  {
+    // compute it only once
+    return;
+  }
+  
+  ComputeCorrectionFactors(eventSelectionCorrected);
+  
+  TString gpsname(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(triggerType).Data()));
+  TString gpuname(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(triggerType).Data()));
+  
+  TGraphErrors* gPS = GetGraph(gpsname);
+  
+  if (!gPS)
+  {
+    AliError(Form("Could not find %s",gpsname.Data()));
+    return;
+  }
+  
+  TGraphErrors* gPU = GetGraph(gpuname);
+
+  if (!gPU)
+  {
+    AliError(Form("Could not find %s",gpuname.Data()));
+    return;
+  }
+
+  AliDebug(2,graphName);
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  const std::set<int>& runs = RunNumbers();
+  
+  Int_t i(0);
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+    
+    if ( triggerClassName.Length() )
+    {
+      Double_t n = GetSum(triggerClassName,runNumber,0);
+      
+      vx.push_back(runNumber);
+      vxerr.push_back(0.5);
+
+      assert(runNumber==TMath::Nint(gPU->GetX()[i]));
+      
+      Double_t y(n);
+      Double_t y1(1.0);
+      Double_t y2(1.0);
+      Double_t e1(0);
+      Double_t e2(0);
+      
+      if ( pileUpCorrected )
+      {
+        y1 = gPU->GetY()[i];
+        e1 = gPU->GetEY()[i];
+      }
+
+      if ( eventSelectionCorrected > 0 )
+      {
+        y2 = gPS->GetY()[i];
+        e2 = gPS->GetEY()[i];
+      }
+      
+      y *= y1*y2;
+
+      AliDebug(2,Form("RUN %09d n %e y1 %e y2 %e y% e",runNumber,n,y1,y2,y));
+      
+      Double_t yerr = y*AliAnalysisMuMuResult::ErrorABC( n, TMath::Sqrt(n),
+                                                        y1, e1,
+                                                        y2, e2);
+
+      vy.push_back(y);
+      vyerr.push_back(yerr);
+      
+      ++i;
+    }
+  }
+    
+  TString title(Form("Number of event of trigger %s",GetTriggerTypeName(triggerType).Data()));
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeTriggerFractions(ETriggerType triggerType,
+                                                   Bool_t physicsSelectionCorrected)
+{
+  /// Compute trigger fractions
+  
+  TString graphName(Form("Fractions%s%s",GetTriggerTypeName(triggerType).Data(),physicsSelectionCorrected ? "PS" : ""));
+
+  if ( GetGraph(graphName) )
+  {
+    // compute it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  const std::set<int>& runs = RunNumbers();
+
+  Double_t n(0.0);
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+    
+    if ( triggerClassName.Length() )
+    {
+      n += GetSum(triggerClassName,runNumber,physicsSelectionCorrected);
+    }
+  }
+
+  if ( n <= 0.0 )
+  {
+    AliWarning(Form("Got zero trigger for %s",GetTriggerTypeName(triggerType).Data()));
+    return;
+  }
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+    
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    Double_t y = GetSum(triggerClassName,runNumber,physicsSelectionCorrected);
+    vy.push_back(y/n);
+    vyerr.push_back( (y/n) * AliAnalysisMuMuResult::ErrorAB( y,TMath::Sqrt(y),
+                                                        n, TMath::Sqrt(n)));
+  }
+  
+
+  TString title(Form("Fraction of event of trigger %s",GetTriggerTypeName(triggerType).Data()));
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeTriggerL0B(ETriggerType triggerType)
+{
+  /// Compute trigger L0B
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  TString graphName(Form("L0B%s",GetTriggerTypeName(triggerType).Data()));
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+  
+  AliDebug(2,graphName);
+  
+  const std::set<int>& runs = RunNumbers();
+  
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+    
+    AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L0B",triggerClassName);
+    if (!item) continue;
+    
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+
+    Double_t y = item->Value();
+
+    vy.push_back(y);
+    
+    vyerr.push_back( TMath::Sqrt(y) );
+  }
+  
+  TString title(Form("L0B of trigger %s",GetTriggerTypeName(triggerType).Data()));
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+////_____________________________________________________________________________
+//void AliAnalysisMuMuFnormBeta::ComputeTSGraph(ETriggerType tt)
+//{
+//  /// Compute the per-run graph of physics selection accept fraction x track
+//  /// accept fraction for the given trigger
+//  
+//  TString graphName(Form("CorrectionTS%s",GetTriggerTypeName(tt).Data()));
+//  
+//  if (GetGraph(graphName))
+//  {
+//    // insure we're computing it only once
+//    return;
+//  }
+//  
+//  AliDebug(1,graphName);
+//  
+//  std::vector<double> vx;
+//  std::vector<double> vxerr;
+//  std::vector<double> vy;
+//  std::vector<double> vyerr;
+//  
+//  const std::set<int>& runs = RunNumbers();
+//  
+//  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+//  
+//  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+//  {
+//    Int_t runNumber = *it;
+//    
+//    Double_t purity, purityError;
+//    
+//    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+//    
+//    if ( triggerClassName.Length()==0 )
+//    {
+//      AliError(Form("Unknown trigger type %d",tt));
+//      return;
+//    }
+//    
+//    GetPurity(triggerClassName.Data(),runNumber,purity,purityError,"OFFLINE1");
+//    
+//    vx.push_back(runNumber);
+//    vxerr.push_back(0.5);
+//    vy.push_back(purity);
+//    vyerr.push_back(purityError);
+//  }
+//  
+//  TString title(Form("Fraction of events accepted by the physics selection x track selection for trigger %s",GetTriggerTypeName(tt).Data()));
+//  
+//  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+//}
+//
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuFnormBeta::CreateAndAddGraph(const TString& name,
+                                                      const TString& title,
+                                                      const std::vector<double>& vx,
+                                                      const std::vector<double>& vxerr,
+                                                      const std::vector<double>& vy,
+                                                      const std::vector<double>& vyerr) const
+{
+  /// Creates a graph and adds it to our mergeable collection
+  
+  TGraphErrors* g = new TGraphErrors(vx.size(),&vx[0],&vy[0],&vxerr[0],&vyerr[0]);
+  g->SetName(name.Data());
+  g->SetTitle(title.Data());
+  
+  if  (fIsCompactGraphs)
+  {
+    AliAnalysisMuMuGraphUtil::Compact(*g);
+  }
+
+  g->GetXaxis()->SetNoExponent();
+//  g->GetXaxis()->SetTitle("Run number");
+
+  TPaveText* text = new TPaveText(0.70,0.70,0.89,0.89,"NDC");
+  text->SetBorderSize(0);
+  text->SetFillColor(0);
+  text->AddText(Form("Mean %e",g->GetMean(2)));
+  text->AddText(Form("RMS  %e",g->GetRMS(2)));
+  g->GetListOfFunctions()->Add(text);
+  
+  MC()->Adopt("/GRAPHS/",g);
+  return g;
+}
+
+//_____________________________________________________________________________
+AliMergeableCollection* AliAnalysisMuMuFnormBeta::DetachMC()
+{
+  // let go the ownership of our mergeable collection
+  fIsOwner = kFALSE;
+  return fMergeableCollection;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::DrawWith2Scales(const char* graphName1, const char* graphName2)
+{
+  TGraphErrors* g1 = static_cast<TGraphErrors*>(GetGraph(graphName1)->Clone());
+  TGraphErrors* g2 = static_cast<TGraphErrors*>(GetGraph(graphName2)->Clone());
+  
+  if ( g1 && g2 )
+  {
+    gStyle->SetOptTitle(0);
+    
+    AliAnalysisMuMuGraphUtil gu;
+    
+    TCanvas* c = gu.DrawWith2Scales(*g1,*g2);
+    c->Draw();
+    
+    for ( Int_t i = 0; i < 2; ++i )
+    {
+      c->cd(i);
+      gPad->SetLeftMargin(0.15);
+      gPad->SetRightMargin(0.15);
+    }
+    
+    c->Update();
+    
+    //    TGraphErrors* g = new TGraphErrors(g1->GetN());
+    //
+    //    Double_t check(0.0);
+    //
+    //    for ( Int_t i = 0; i < g->GetN(); ++i )
+    //    {
+    //      Double_t y = g1->GetY()[i]*g2->GetY()[i];
+    //
+    //      check += g2->GetY()[i];
+    //
+    //      g->SetPoint(i,g2->GetX()[i],y);
+    //      g->SetPointError(i,g2->GetEX()[i],
+    //                       y*AliAnalysisMuMuResult::ErrorAB(g1->GetY()[i],g1->GetEY()[i],
+    //                                                        g2->GetY()[i],g2->GetEY()[i]));
+    //    }
+    //
+    //    new TCanvas;
+    //
+    //    g->Draw("ap");
+    //
+    //    AliInfo(Form("check: %e g mean %e rms %e",check,g->GetMean(2),g->GetRMS(2)));
+
+    /*
+     
+    // g1 vs g2 
+     
+    TGraphErrors* g = new TGraphErrors(g1->GetN());
+    
+    for ( Int_t i = 0; i < g->GetN(); ++i )
+    {
+      g->SetPoint(i,g2->GetY()[i],g1->GetY()[i]);
+      g->SetPointError(i,g2->GetEY()[i],g1->GetEY()[i]);
+    }
+    
+    new TCanvas;
+    
+    g->Draw("ap");
+    
+    AliInfo(Form("g mean %e rms %e",g->GetMean(2),g->GetRMS(2)));
+     
+     */
+    
+  }
+  
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetEventSelectionName(Int_t eventSelectionCorrected) const
+{
+  if ( eventSelectionCorrected == 1 )
+  {
+    return "PS";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    return "TS";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuFnormBeta::GetGraph(const char* name) const
+{
+  // shortcut method to give access to one graph
+  
+  TObject* o = MC()->GetObject(Form("/GRAPHS/%s",name));
+  
+  if (!o) return 0x0;
+  
+  if ( o->IsA() != TGraphErrors::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+  
+  return static_cast<TGraphErrors*>(o);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::GetPurity(const char* triggerClassName, Int_t runNumber,
+                                     Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const
+{
+  /// Get the physics selection accept fraction for a given trigger
+  
+  value=error=0.0;
+
+  TString runCondition;
+  
+  if (runNumber>0)
+  {
+    runCondition.Form("/run:%d",runNumber);
+  }
+  
+  Double_t nall = fCounterCollection.GetSum(Form("trigger:%s/event:ALL%s",triggerClassName,runCondition.Data()));
+  
+  TString ename;
+  
+  if ( eventSelectionCorrected == 1 )
+  {
+    ename = "PSALL";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    ename = "OFFLINE1";
+  }
+  else
+  {
+    value = 1.0;
+    return;
+    
+  }
+  Double_t nps = fCounterCollection.GetSum(Form("trigger:%s/event:%s%s",
+                                                triggerClassName,ename.Data(),runCondition.Data()));
+  
+  if ( nall <= 0.0 ) return;
+  
+  value = nps/nall;
+  
+  error = AliAnalysisMuMuResult::ErrorAB(nall,TMath::Sqrt(nall),nps,TMath::Sqrt(nps));
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuResult* AliAnalysisMuMuFnormBeta::GetResult(const char* name) const
+{
+  // shortcut method to give access to one result
+  
+  TObject* o = MC()->GetObject(Form("/RESULTS/%s",name));
+  
+  if (!o) return 0x0;
+  
+  if ( o->IsA() != AliAnalysisMuMuResult::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+  
+  return static_cast<AliAnalysisMuMuResult*>(o);
+}
+
+//______________________________________________________________________________
+AliAnalysisMuMuResult* AliAnalysisMuMuFnormBeta::GetRunIntegratedResult(const TGraphErrors& g, const char* basename)
+{
+  /// get one value +- error for this graph (weighting the run-by-run values
+  /// by the fraction of the number of triggers in that run)
+  /// also the rms is computed.
+  
+  Bool_t physicsSelectionCorrected(kFALSE);
+  
+  if ( TString(g.GetName()).Contains("PS") )
+  {
+    physicsSelectionCorrected=kTRUE;
+  }
+
+  ComputeTriggerFractions(fReferenceTriggerType,physicsSelectionCorrected);
+
+  TString fname(Form("Fractions%s%s",GetTriggerTypeName(fReferenceTriggerType).Data(),physicsSelectionCorrected ? "PS" : ""));
+  
+  TGraphErrors* gTriggerFractions = GetGraph(fname);
+  
+  StdoutToAliDebug(2,std::cout << g.GetName() << std::endl; g.Print(););
+  
+  if (!gTriggerFractions)
+  {
+    AliError(Form("Did not find graph for %s",fname.Data()));
+    return 0x0;
+  }
+  
+  Double_t mean = g.GetY()[0];
+  Int_t n = g.GetN();
+  
+  Double_t errorOnMean = g.GetEY()[0];
+  Double_t rms = 0.0;
+  
+  if ( n > 1 )
+  {
+    mean = errorOnMean = 0.0;
+    Double_t d(0.0);
+    Double_t v1(0.0);
+    Double_t v2(0.0);
+    
+    for ( Int_t i = 0; i < n; ++i )
+    {
+      Double_t y = g.GetY()[i];
+      
+      Double_t weight = gTriggerFractions->GetY()[i]; // sum of weight should be 1.0
+      
+      AliDebug(2,Form("%s i %3d y %e weight %e",g.GetName(),i,y,weight));
+      
+      mean += y * weight;
+      
+      v1 += weight;
+      v2 += weight*weight;
+    }
+    
+    mean /= v1;
+    
+    for ( Int_t i = 0; i < n; ++i )
+    {
+      Double_t weight = gTriggerFractions->GetY()[i]; // sum of weight should be 1.0
+      Double_t y = g.GetY()[i];
+      
+      d += (y-mean)*(y-mean)*weight;
+    }
+    
+    AliDebug(2,Form("v1=%e v2=%e d=%e",v1,v2,d));
+    
+    if ( v1 <= 0) return 0x0;
+    
+    errorOnMean = TMath::Sqrt((1.0/v1)*(1.0/(n-1))*d);
+    
+    rms = TMath::Sqrt( (v1/(v1*v1-v2))*d );    
+  }
+  
+  AliAnalysisMuMuResult* result = new AliAnalysisMuMuResult(g.GetName(),g.GetTitle());  
+
+  result->Set(basename,mean,errorOnMean,rms);
+  
+  if ( TString(g.GetName()) == "FnormScalersPUPS" )
+  {
+    AliDebug(1,Form("mean %e errorOnMean %e rms %e",mean,errorOnMean,rms));
+    StdoutToAliDebug(1,result->Print("full"));
+  }
+
+  return result;
+}
+
+//_____________________________________________________________________________
+Double_t AliAnalysisMuMuFnormBeta::GetSum(const char* triggerClassName,
+                                      Int_t runNumber,
+                                      Int_t eventSelectionCorrected) const
+{
+  TString condition(Form("trigger:%s/run:%d",triggerClassName,runNumber));
+  
+  if (eventSelectionCorrected==1)
+  {
+    condition += "/event:PSALL";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    condition += "/event:OFFLINE1";
+  }
+  else
+  {
+    condition += "/event:ALL";
+  }
+  
+  Double_t n = fCounterCollection.GetSum(condition.Data());
+  
+  if (n<=0)
+  {
+    AliError(Form("Got no count for %s for run %d (physicsSelected:%d)",triggerClassName,runNumber,eventSelectionCorrected));
+    return 0;
+  }
+  
+  return n;
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetTriggerClassName(ETriggerType tt, Int_t runNumber) const
+{
+  // get the triggerclass to for a given trigger type and run number
+  
+  if ( tt == kMB )
+  {
+    return MBTriggerClassName(runNumber);
+  }
+  else if ( tt == kMUL )
+  {
+    return MULTriggerClassName(runNumber);
+  }
+  else if ( tt == kMSL)
+  {
+    return MSLTriggerClassName(runNumber);
+  }
+  else if ( tt == kMSH)
+  {
+    return MSHTriggerClassName(runNumber);
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetTriggerTypeName(ETriggerType tt) const
+{
+  // get the name of the trigger type
+  if ( tt == kMB )
+  {
+    return "MB";
+  }
+  else if ( tt == kMUL )
+  {
+    return "MUL";
+  }
+  else if ( tt == kMSL)
+  {
+    return "MSL";
+  }
+  else if ( tt == kMSH)
+  {
+    return "MSH";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::GetValueAndErrorFromGraph(TGraphErrors* graph,
+                                                     Int_t runNumber,
+                                                     Double_t& value,
+                                                     Double_t& error) const
+{
+  /// get (value,error) corresponding to run=runNumber.
+  /// Works both for compact and non-compact graphs
+  
+  value = TMath::Limits<Double_t>::Max();
+  error = 0.0;
+  
+  if (!graph) return;
+  
+  TAxis* axis = graph->GetXaxis();
+  
+  for ( Int_t i = 0; i < graph->GetN(); ++i )
+  {
+    Int_t rbin = TMath::Nint(graph->GetX()[i]);
+    Int_t rlabel = TString(axis->GetBinLabel(i+1)).Atoi();
+    if ( rbin == runNumber || rlabel == runNumber )
+    {
+      value = graph->GetY()[i];
+      error = graph->GetEY()[i];
+    }
+  }
+}
+
+//_____________________________________________________________________________
+AliMergeableCollection* AliAnalysisMuMuFnormBeta::MC() const
+{
+  // get our mergeable collection
+  if (!fMergeableCollection)
+  {
+    fMergeableCollection = new AliMergeableCollection("Fnorm",Form("MB to %s trigger normalization results",GetTriggerTypeName(fReferenceTriggerType).Data()));
+  }
+  return fMergeableCollection;
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MBTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+  
+  if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CINT7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CPBI2_B1-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CPBI2_B1-B-NOPF-ALLNOTRD";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MSHTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+  
+  if ( TriggerClassnameTest("CMSH7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CMSH7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CMSH7-B-NOPF-MUON",runNumber) )
+  {
+    return "CMSH7-B-NOPF-MUON";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MSLTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+  
+  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
+  {
+      return "CMSL7-B-NOPF-MUON";
+  }
+ else
+   if ( TriggerClassnameTest("CPBI1MSL-B-NOPF-MUON",runNumber) )
+ {
+   return "CPBI1MSL-B-NOPF-MUON";
+ }
+  return "";
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::MultiplyGraphs(const char* g1name, const char* g2name, const char* name)
+{
+  /// Make a new graph = g1*g2
+  std::vector<double> vx;
+  std::vector<double> vy;
+  std::vector<double> vxerr;
+  std::vector<double> vyerr;
+  
+  TGraphErrors* g1 = GetGraph(g1name);
+  TGraphErrors* g2 = GetGraph(g2name);
+  
+  if (!g1)
+  {
+    AliError(Form("Could not get graph %s",g1name));
+    return;
+  }
+
+  if (!g2)
+  {
+    AliError(Form("Could not get graph %s",g2name));
+    return;
+  }
+
+  if ( g1->GetN() != g2->GetN() )
+  {
+    AliError(Form("Could not multiply incompatible graphs %d pts vs %d pts",g1->GetN(),g2->GetN()));
+    return;
+  }
+  
+  for ( Int_t i = 0; i < g1->GetN(); ++i )
+  {
+    if ( g1->GetX()[i] != g2->GetX()[i] )
+    {
+      AliError(Form("Incompatible bin %d : %e vs %e",i,g1->GetX()[i],g2->GetX()[i]));
+      return;
+    }
+    
+    vx.push_back(g1->GetX()[i]);
+    vxerr.push_back(g1->GetEX()[i]);
+    
+    Double_t y = g1->GetY()[i]*g2->GetY()[i];
+    Double_t yerr = y*AliAnalysisMuMuResult::ErrorAB( g1->GetY()[i], g1->GetEY()[i],
+                                                     g2->GetY()[i], g2->GetEY()[i]);
+    
+    vy.push_back(y);
+    vyerr.push_back(yerr);
+  }
+  
+  TString gname(name);
+  
+  if ( gname.Length() == 0 )
+  {
+    gname = g1->GetName();
+    gname += "x";
+    gname += g2->GetName();
+  }
+  
+  TString title(Form("Product of %s by %s",g1->GetName(),g2->GetName()));
+  
+  CreateAndAddGraph(gname,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MULTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+  
+  if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CMUL7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
+  {
+    return "CMUL7-B-NOPF-MUON";
+  }
+  else if ( TriggerClassnameTest("CPBI1MUL-B-NOPF-MUON",runNumber) )
+  {
+    return "CPBI1MUL-B-NOPF-MUON";
+  }
+  return "";
+  
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::Print(Option_t* opt) const
+{
+  if ( fMergeableCollection )
+  {
+    fMergeableCollection->Print(opt);
+  }
+}
+
+//_____________________________________________________________________________
+std::set<int> AliAnalysisMuMuFnormBeta::RunNumbers() const
+{
+  // Extract the run numbers from our counter collection
+  
+  std::set<int> runset;
+  
+  TString sruns = fCounterCollection.GetKeyWords("run");
+  TObjArray* runs = sruns.Tokenize(",");
+  
+  TIter next(runs);
+  TObjString* s;
+  
+  while ( ( s = static_cast<TObjString*>(next())) )
+  {
+    runset.insert(s->String().Atoi());
+  }
+  delete runs;
+  
+  return runset;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ScalerFnorm(Double_t& value, Double_t& error,
+                                       Double_t L0bREF, Double_t purityREF, Double_t purityREFerror,
+                                       Double_t L0bMB, Double_t purityMB, Double_t purityMBerror,
+                                       Double_t pileUpFactor, Double_t pileUpFactorError)
+{
+  /// Compute the MB to REF ratio and its associated error
+  
+  value = error = 0.0;
+  
+  value = L0bREF*purityREF;
+  
+  if (!value) return;
+  
+  value = L0bMB*purityMB*pileUpFactor/value;
+  
+  error = value*AliAnalysisMuMuResult::ErrorABCDE(L0bREF,TMath::Sqrt(L0bREF),
+                                                  purityREF,purityREFerror,
+                                                  L0bMB,TMath::Sqrt(L0bMB),
+                                                  purityMB,purityMBerror,
+                                                  pileUpFactor,pileUpFactorError);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ShowFnorm(const TObjArray& a) const
+{
+  /// Print and plot Fnorm values
+  TIter next(&a);
+  TGraphErrors* g;
+  
+  while ( ( g = static_cast<TGraphErrors*>(next()) ) )
+  {
+    g->SetTitle(Form("Fnorm %s",g->GetTitle()));
+
+    new TCanvas(Form("c%s",g->GetName()));
+
+    if (fIsCompactGraphs)
+    {
+      AliAnalysisMuMuGraphUtil::Compact(*g);
+    }
+    else
+    {
+      g->GetXaxis()->SetNoExponent();
+    }
+    g->Draw("lpa");
+    
+    Double_t y(0.0);
+    Double_t yerr(0.0);
+    
+    for ( Int_t i = 0; i < g->GetN(); ++i )
+    {
+      y += g->GetY()[i];
+      Double_t e = ( y != 0.0  ? g->GetEY()[i]/y : 0.0);
+      
+      yerr += e*e;
+    }
+    
+    y /= (g->GetN());
+    yerr = TMath::Sqrt(yerr)*y;
+    
+    AliInfo(Form("%30s graph %e +- %e (%5.2f %%) RMS %e",g->GetName(),
+                 y,yerr,yerr*100/y,g->GetRMS(2)));
+
+  }
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuFnormBeta::TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const
+{
+  /// Check if we have counts for that trigger,run combination
+  
+  TString runs = fCounterCollection.GetKeyWords("run");
+  
+  if ( !runs.Contains(Form("%d",runNumber)) ) return kFALSE;
+  
+  TString triggers = fCounterCollection.GetKeyWords("trigger");
+  
+  if (!triggers.Contains(triggerClassName)) return kFALSE;
+  
+  Double_t n = fCounterCollection.GetSum(Form("trigger:%s/run:%d",triggerClassName,runNumber));
+  
+  return ( n > 0.0 );
+}
+
+//_____________________________________________________________________________
+void
+AliAnalysisMuMuFnormBeta::WeightedMeanGraphs(const char* patternOrList, const char* graphName)
+{
+  /// Sum the graphs which name matches pattern
+  /// Sum is made using a weighted mean (each element is weighted by the inverse
+  /// of its error squared)
+  
+  TString spattern(patternOrList);
+  TObjArray* slist(0x0);
+  
+  if ( spattern.CountChar(',') )
+  {
+    // it's not a pattern but a list...
+    slist = spattern.Tokenize(",");
+    spattern = "";
+  }
+  
+  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+  TIter next(objectList);
+  TObjString* str(0x0);
+  TObjArray selected;
+  selected.SetOwner(kFALSE);
+  
+  while ( ( str = static_cast<TObjString*>(next()) ) )
+  {
+    TGraphErrors* g = GetGraph(str->String());
+    
+    if (!g) continue;
+    
+    TString name(g->GetName());
+    
+    if ( spattern.Length() >0 && !name.Contains(spattern.Data()) ) continue;
+    
+    if ( slist && !slist->FindObject(name)) continue;
+    
+    AliDebug(2,Form("Selected for sum : %s",name.Data()));
+    
+    selected.Add(g);
+  }
+  
+  delete slist;
+  delete objectList;
+  
+  if (selected.GetLast()<0) return;
+  
+  std::vector<double> vx;
+  std::vector<double> vy;
+  std::vector<double> vxerr;
+  std::vector<double> vyerr;
+  
+  Int_t npts = static_cast<TGraphErrors*>(selected.First())->GetN();
+  
+  for ( Int_t ipoint = 0; ipoint < npts; ++ipoint )
+  {
+    Double_t x(0.0),xref(0.0),xerr(0.0);
+    Double_t sum(0.0);
+    Double_t sume2(0.0);
+    
+    for ( Int_t igraph = 0; igraph <= selected.GetLast(); ++igraph )
+    {
+      TGraphErrors* g = static_cast<TGraphErrors*>(selected.At(igraph));
+      
+      if ( g->GetN() != npts )
+      {
+        AliError(Form("Graph %s does not have the expected %d points",g->GetName(),npts));
+        continue;
+      }
+      Double_t runNumber;
+      
+      if ( fIsCompactGraphs )
+      {
+        runNumber = TString(g->GetXaxis()->GetBinLabel(ipoint+1)).Atoi()*1.0;
+      }
+      else
+      {
+        runNumber = g->GetX()[ipoint];
+      }
+      
+      if ( igraph == 0 )
+      {
+        xref = g->GetX()[ipoint];
+        x = runNumber;
+        xerr = g->GetEX()[ipoint];
+      }
+      else
+      {
+        if ( xref != g->GetX()[ipoint] )
+        {
+          AliError(Form("Cannot sum graphs with different axis : get %e and expected %e : %s vs %s",xref,x,selected.At(0)->GetName(),g->GetName()));
+          return;
+        }
+      }
+      
+      Double_t e2 = g->GetEY()[ipoint]*g->GetEY()[ipoint];
+      
+      if ( e2 != 0.0 )
+      {
+        sum += g->GetY()[ipoint]/e2;
+        sume2 += 1.0/e2;
+      }
+    }
+    
+    if (sume2 != 0.0)
+    {
+      vx.push_back(x);
+      vxerr.push_back(xerr);
+      vy.push_back(sum/sume2);
+      vyerr.push_back(TMath::Sqrt(1/sume2));
+    }
+  }
+  
+  Int_t n = selected.GetEntries();
+  
+  TString name(graphName);
+  TString title(Form("Weighted mean from %d individual graphs",n));
+  
+  if ( strlen(graphName) == 0)
+  {
+    name = TString::Format("WeightMeanFnorm%s",patternOrList);
+    name.ReplaceAll(",","_");
+    title = TString::Format("WeightMeanFnorm%s from %d individual graphs",patternOrList,n);
+  }
+  
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
+
+
diff --git a/PWG/muondep/AliAnalysisMuMuFnormBeta.h b/PWG/muondep/AliAnalysisMuMuFnormBeta.h
new file mode 100644
index 0000000..3807e77
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuFnormBeta.h
@@ -0,0 +1,148 @@
+#ifndef ALIANALYSISMUMUFNORMBETA_H
+#define ALIANALYSISMUMUFNORMBETA_H
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+#ifndef ROOT_TObject
+#  include "TObject.h"
+#endif
+
+#ifndef ROOT_TString
+#  include "TString.h"
+#endif
+
+#include <set>
+#include <vector>
+
+class TObjArray;
+class TGraphErrors;
+class TGraph;
+class AliAnalysisMuMuResult;
+class AliCounterCollection;
+class AliMergeableCollection;
+
+class AliAnalysisMuMuFnormBeta : public TObject
+{
+
+public:
+  
+  enum ETriggerType
+  {
+    kMB=1,
+    kMUL=2,
+    kMSL=3,
+    kMSH=4
+  };
+  
+  AliAnalysisMuMuFnormBeta(AliCounterCollection& cc,
+                       AliAnalysisMuMuFnormBeta::ETriggerType triggerType=AliAnalysisMuMuFnormBeta::kMUL,
+                       const char* ocdbpath="raw://",
+                       Bool_t compactGraphs=kFALSE);
+  
+  virtual ~AliAnalysisMuMuFnormBeta();
+  
+  void ComputeFnorm();
+  
+  void ComputeCorrectionFactors(Int_t eventSelectionCorrected);
+
+  void ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+
+  void ComputeFnormScalers(Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+  void ComputeGraphRelDif(const char* a, const char* b) const;
+
+  void ComputeNofEvents(ETriggerType triggerType, Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+  void ComputePileUpGraph(ETriggerType tt, Int_t eventSelectionCorrected=0);
+  
+  void ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected);
+
+  void ComputeResultsFromGraphs();
+
+  void ComputeTriggerFractions(ETriggerType triggerType, Bool_t physicsSelectionCorrected);
+  
+  void ComputeTriggerL0B(ETriggerType tt);
+
+  //  void ComputeTSGraph(ETriggerType tt); // Commented out in the implementation file
+
+  AliMergeableCollection* DetachMC();
+
+  void DrawWith2Scales(const char* graphName1, const char* graphName2);
+  
+  TString GetEventSelectionName(Int_t eventSelectionCorrected) const;
+
+  //  void GetFnorm(Int_t runNumber, const char* eventSelection, Double_t& value, Double_t& error) const; // Not implemented
+  
+  TGraphErrors* GetGraph(const char* name) const;
+  
+  void GetPurity(const char* triggerClassName, Int_t runNumber, Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const;
+
+  void GetValueAndErrorFromGraph(TGraphErrors* graph,
+                                 Int_t runNumber,
+                                 Double_t& value,
+                                 Double_t& error) const;
+  
+  AliAnalysisMuMuResult* GetResult(const char* name) const;
+
+  AliAnalysisMuMuResult* GetRunIntegratedResult(const TGraphErrors& g, const char* basename="Fnorm");
+
+  AliMergeableCollection* MC() const;
+  
+  void MultiplyGraphs(const char* g1, const char* g2, const char* name="");
+  
+  TString OCDBPath() const { return fOCDBPath; }
+  
+  void Print(Option_t* opt="") const;
+
+  void ScalerFnorm(Double_t& value, Double_t& error,
+                   Double_t L0bCMUL7, Double_t purityCMUL7, Double_t purityCMUL7error,
+                   Double_t L0bCINT7, Double_t purityCINT7, Double_t purityCINT7error,
+                   Double_t pileUpFactor, Double_t pileUpFactorError);
+  
+  void ShowFnorm(const TObjArray& a) const;
+
+  Bool_t TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const;
+
+  void WeightedMeanGraphs(const char* pattern, const char* name="");
+  
+private:
+  
+  AliAnalysisMuMuFnormBeta(const AliAnalysisMuMuFnormBeta& rhs); // not implemented on purpose
+  AliAnalysisMuMuFnormBeta& operator=(const AliAnalysisMuMuFnormBeta& rhs); // not implemented on purpose
+
+  TGraphErrors* CreateAndAddGraph(const TString& name,
+                                  const TString& title,
+                                  const std::vector<double>& vx,
+                                  const std::vector<double>& vxerr,
+                                  const std::vector<double>& vy,
+                                  const std::vector<double>& vyerr) const;
+
+  Double_t GetSum(const char* triggerClassName, Int_t runNumber, Int_t eventSelectionCorrected) const;
+
+  TString GetTriggerClassName(ETriggerType tt, Int_t runNumber) const;
+
+  TString GetTriggerTypeName(ETriggerType tt) const;
+
+  std::set<int> RunNumbers() const;
+
+  TString MBTriggerClassName(Int_t runNumber) const;
+  TString MSLTriggerClassName(Int_t runNumber) const;
+  TString MULTriggerClassName(Int_t runNumber) const;
+  TString MSHTriggerClassName(Int_t runNumber) const;
+
+private:
+  
+  /*const*/ AliCounterCollection& fCounterCollection; // collection of trigger counters (not owner)
+  mutable AliMergeableCollection* fMergeableCollection; // collection of results, histograms, graphs (ownership is in fIsOwner)
+  Bool_t fIsOwner; // whether we are the owner of the mergeable collection
+  TString fOCDBPath; // OCDB to be used (raw:// by default)
+  mutable AliAnalysisMuMuResult* fResult; // combined result of the various computations
+  Bool_t fIsCompactGraphs; // whether the graph produced should be compact
+  ETriggerType fReferenceTriggerType; // reference trigger to get the weighting factors
+  
+  ClassDef(AliAnalysisMuMuFnormBeta,0) // class to compute MB to MUON trigger normalization factor
+};
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx b/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
index 16b1af2..b3fa926 100644
--- a/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
+++ b/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
@@ -1469,6 +1469,310 @@ void AliAnalysisMuMuJpsiResult::FitPSINA60NEW()
   Set(Form("Nof%s",particleName.Data()),njpsi,nerr);
 }
 
+// //_____________________________________________________________________________
+// void AliAnalysisMuMuJpsiResult::FitPSICB2VWG()
+// {
+//     /// Fit using 1 extended crystal ball (signal) + variable width gaussian (background)
+//     //Refresh
+//     fHisto->GetListOfFunctions()->Delete();
+//     //Check if values given in MuMuConfig
+//     Double_t alphaLow = GetValue("alJPsi");
+//     Double_t nLow = GetValue("nlJPsi");
+//     Double_t alphaUp = GetValue("auJPsi");
+//     Double_t nUp = GetValue("nuJPsi");
+//     Double_t fitRangeLow = GetValue(kFitRangeLow);
+//     Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+    
+//     TString msg;
+//     //Output Message
+//     if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+//     if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+//     if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+//     if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+    
+//     AliDebug(1,Form("Fit with jpsi VWG %s",msg.Data()));
+    
+//     //  std::cout << "Tails parameters: " << msg.Data() << std::endl;
+//     //Create pointer and configure signal+bck fit functions
+//     TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalOneCB2VWG,fitRangeLow,fitRangeHigh,11,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
+    
+//     fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
+//     //                        0      1       2       3       4      5      6
+//                           "alJPsi","nlJPsi","auJPsi","nuJPsi");
+//     //                         7        8        9        10
+
+    
+//     // Create pointer for bck function 
+//     TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+    
+//     const char* fitOption = "SER"; //We can add NO to avoid plotting
+    
+// //#if 0
+// //    bck->SetParameter(0,fHisto->GetMaximum());
+// //    bck->SetParameter(1,3);
+// //    bck->SetParameter(2,10);
+// //    bck->SetParameter(3,10);
+// //    
+// //    bck->SetParLimits(1, 0., 100.);
+// //    bck->SetParLimits(2, 0., 100.);
+// //    bck->SetParLimits(3, 0., 100.);
+// //    
+// //    SetFitRejectRange(2.7,3.5);
+// //    
+// //    fHisto->Fit(bck,fitOption,"");
+// //    
+// //    for ( Int_t i = 0; i < 4; ++i )
+// //        {
+// //        Double_t a,b;
+// //        bck->GetParLimits(i,a,b);
+// //        fitTotal->SetParameter(i,bck->GetParameter(i));
+// //        fitTotal->SetParLimits(i,a,b);
+// //        }
+// //#endif
+//     // Create pointer for bck fitting
+//     TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+//     // To set first parameter
+//     Int_t bin = fHisto->FindBin(0.26);
+//     // Setting parameters
+//     bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//     // Reject region ot J/Psi
+//     SetFitRejectRange(2.7,4.0);
+//     // Store fit results in a TFitResult
+//     TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
+    
+//     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+//     // if success a new fit is proceed
+//     if ( static_cast<int>(fitResultInit) )
+//         {
+//         bin = fHisto->FindBin(0.82);
+//         bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//         fitResultInit = fHisto->Fit(bckInit,"SR");
+//         }
+//     else if ( bckInit->GetParameter(0) < 0 )
+//         {
+//         bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//         }
+//     // ??
+//     SetFitRejectRange();
+//     // Set bck paramaters from precedent fit to fitTotal
+//     for ( Int_t i = 0; i < 4; ++i )
+//         {
+//         fitTotal->SetParameter(i, bckInit->GetParameter(i));
+//         }
+    
+//     // Set J/Psi parameters to FitTotal
+//     bin = fHisto->FindBin(3.09);
+//     fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm
+    
+//     fitTotal->SetParameter(5, 3.1); // mean
+//     fitTotal->SetParLimits(5, 3.0, 3.2);
+    
+//     fitTotal->SetParameter(6, 0.08); // sigma
+//     fitTotal->SetParLimits(6, 0.05, 0.09);
+//     // Set parameters from MuMuConfig if present
+//     if ( IsValidValue(alphaLow) )
+//         {
+//         fitTotal->FixParameter(7, alphaLow);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(7,0.9);
+//         fitTotal->SetParLimits(7,0.1,10.0);
+//         }
+    
+//     if ( IsValidValue(nLow) )
+//         {
+//         fitTotal->FixParameter(8, nLow);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(8,5.0);
+//         fitTotal->SetParLimits(8,0.0,10.0);
+//         }
+    
+//     if ( IsValidValue(alphaUp) )
+//         {
+//         fitTotal->FixParameter(9, alphaUp);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(9, 2.0);
+//         fitTotal->SetParLimits(9,0.1,10.0);
+//         }
+    
+//     if ( IsValidValue(nUp) )
+//         {
+//         fitTotal->FixParameter(10, nUp);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(10,3.0);
+//         fitTotal->SetParLimits(10,0.0,10.0);
+//         }
+    
+    
+//     SetFitRejectRange();
+    
+//     //  std::cout << fitTotal->GetParameter(0) << std::endl; //Just a xcheck
+    
+//     TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    
+//     //  std::cout << fitTotal->GetParameter(0) << " ?= " << fitResult->Parameter(0) << std::endl; //Just a xcheck
+//     // Output message
+//     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+    
+//     //  std::cout << fitTotal->GetParameter(0) << std::endl; //Just a xcheck
+//     // Refit in case of error on kVWG to high
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
+//             {
+//             std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+            
+//             fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+//             }
+        
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Refit in case of KkVWG to low
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         std::cout << "//-------Refitting again (setting kVWG=kVWG*2)" << std::endl;
+        
+//         fitTotal->SetParameter(0, fHisto->GetMaximum()*2.); // kVWG
+        
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Idem
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+        
+//         fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+        
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Set parameters to fit Total and fit with it
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         for ( Int_t i = 0; i < 4; ++i )
+//             {
+//             fitTotal->SetParameter(i, bckInit->GetParameter(i));
+//             }
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+        
+//         if ( static_cast<int>(fitResult) ) std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+//         }
+    
+//     delete bckInit;
+//     // Set things ...
+//     Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+//     Set("FitNDF",fitTotal->GetNDF(),0.0);
+    
+//     Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+//     Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+//     // Create JPsi function and set parameters
+//     TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+//     signalJPsi->SetParameters(fitTotal->GetParameter(4),
+//                               fitTotal->GetParameter(5),
+//                               fitTotal->GetParameter(6),
+//                               fitTotal->GetParameter(7),
+//                               fitTotal->GetParameter(8),
+//                               fitTotal->GetParameter(9),
+//                               fitTotal->GetParameter(10));
+//     // Set bck parameter
+//     bck->SetParameters(fitTotal->GetParameter(0),
+//                        fitTotal->GetParameter(1),
+//                        fitTotal->GetParameter(2),
+//                        fitTotal->GetParameter(3));
+    
+//     // Set value + error for each parameters 
+//     Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+//     Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+//     Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+//     Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+//     Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+    
+//     Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+//     Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+//     Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+//     Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+    
+//     SetFitRejectRange();
+    
+//     AttachFunctionsToHisto(signalJPsi,bck,fitTotal,fitRangeLow,fitRangeHigh);
+    
+    
+//     Double_t cbParameters[7];
+//     Double_t covarianceMatrix[7][7];
+    
+//     for ( int ix = 0; ix < 7; ++ix )
+//         {
+//         cbParameters[ix] = fitTotal->GetParameter(ix+4);
+//         }
+    
+//     for ( int iy = 0; iy < 7; ++iy )
+//         {
+//         for ( int ix = 0; ix < 7; ++ix )
+//             {
+//             covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+//             }
+//         }
+    
+//     Double_t a = fHisto->GetXaxis()->GetXmin();
+//     Double_t b = fHisto->GetXaxis()->GetXmax();
+//     double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+//     double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+    
+//     Set("NofJPsi",njpsi,nerr);
+    
+//     double m = GetValue("mJPsi");
+//     double s = GetValue("sJPsi");
+//     double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+//     double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+    
+//     Set("NofJPsi3s",njpsi3s,nerr3s);
+    
+//     //Computation of bin significance and signal over background
+    
+//     Double_t bkgParameters[4];
+//     Double_t bkgcovarianceMatrix[4][4];
+    
+//     for ( int ix = 0; ix < 4; ++ix )
+//         {
+//         bkgParameters[ix] = fitTotal->GetParameter(ix);
+//         }
+    
+//     for ( int iy = 0; iy < 4; ++iy )
+//         {
+//         for ( int ix = 0; ix < 4; ++ix )
+//             {
+//             bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+//             }
+//         }
+    
+//     double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+//     double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+    
+//     double sOverB3s = njpsi3s / nbck3s;
+//     double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+    
+//     Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+    
+//     double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+//     double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+//                                 TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+    
+//     Set("Significance3s",sig,sigErr);
+    
+// }
+
+
+
 //_____________________________________________________________________________
 void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 {
@@ -1582,7 +1886,7 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
   fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm
   
   fitTotal->SetParameter(5, 3.15); // mean
-  fitTotal->SetParLimits(5, 2.95, 3.25);
+  fitTotal->SetParLimits(5, 2.95, 3.2);
   
   fitTotal->SetParameter(6, 0.08); // sigma
   fitTotal->SetParLimits(6, 0.05, 0.09);
@@ -5535,7 +5839,7 @@ Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
   
   if (callEnv.IsValid())
   {
-    callEnv.Execute(r);
+    callEnv.Execute(r);// here fit Method ("fit<SOMETHING>") is called and the fit is proceed.
   }
   else
   {
diff --git a/PWG/muondep/AliAnalysisMuMuJpsiResult.h b/PWG/muondep/AliAnalysisMuMuJpsiResult.h
index f8cff58..a239f40 100644
--- a/PWG/muondep/AliAnalysisMuMuJpsiResult.h
+++ b/PWG/muondep/AliAnalysisMuMuJpsiResult.h
@@ -76,7 +76,8 @@ public:
   void FitPSICOUNT();
   void FitPSICB2();
   void FitPSINA60NEW();
-  
+    
+  // void FitPSICB2VWG();
   void FitPSIPSIPRIMECB2VWG();
   void FitPSIPSIPRIMECB2POL2EXP();
   void FitPSIPSIPRIMENA60NEWVWG();
@@ -177,6 +178,8 @@ private:
   Double_t FitFunctionSignalCrystalBallExtended(Double_t *x,Double_t *par);
   
   Double_t FitFunctionNA60New(Double_t *x,Double_t *par);
+    
+  // Double_t FitFunctionTotalOneCB2VWG(Double_t *x,Double_t *par); // Correction here
   
   Double_t FitFunctionTotalTwoNA60NewVWG(Double_t *x, Double_t *par);
   
diff --git a/PWG/muondep/AliAnalysisMuMuSpectra.cxx b/PWG/muondep/AliAnalysisMuMuSpectra.cxx
index 9211ec9..843f6bd 100644
--- a/PWG/muondep/AliAnalysisMuMuSpectra.cxx
+++ b/PWG/muondep/AliAnalysisMuMuSpectra.cxx
@@ -457,9 +457,12 @@ TH1* AliAnalysisMuMuSpectra::Plot(const char* what, const char* subresult, Bool_
       std::cout << b.AsString();
       r->PrintValue(swhat.Data(),"",y,yerr);
       
+      //__________Config. Histo
       h->SetBinContent(j+1,y);
       h->SetBinError(j+1,yerr);
       h->GetXaxis()->SetBinLabel(j+1,b.AsString().Data());
+      h->GetYaxis()->SetTitle(swhat.Data());
+      //__________
     }
   }
   
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
new file mode 100644
index 0000000..945fd72
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
@@ -0,0 +1,236 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Mother class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsule)
+
+
+#include "AliLog.h"
+#include "TObject.h"
+#include <TString.h>
+#include <iostream>
+#include <string>
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "TObjArray.h"
+#include "TString.h"
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsule::AliAnalysisMuMuSpectraCapsule() : TObject()
+{
+  /// Default ctor
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsule::~AliAnalysisMuMuSpectraCapsule()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(const char* file, Double_t* constantArray, const TString* spectraName)
+{
+  /**
+   *
+   * Set member constants depending on centrality bin from an ewternfile.
+   *
+   */
+
+  // Arrays to store quantities from externFile
+  char centrality;
+  float interval[2];
+  float valueArray[10];
+  //    <NPART> d<NPART> TAA  dTAA  sys.AP  Traj  Trigg  Pair AccEff dAccEff
+  FILE*  infile;
+
+  // Reset on fConstant
+  for (int i = 0; i < 10; ++i)
+  {
+   constantArray[i]=0.;
+  }
+
+  AliDebug(1,Form("Reading from file %s",file));
+  
+  // PT and Y case
+  infile = fopen(file,"rb");
+  // Open file
+  if (infile != NULL)
+  {
+
+    AliDebug(1, " ==== opening file ==== ");
+    // Loop until end of file is reached
+    while(!feof(infile))
+    {
+      // Reminder :
+      // Centrality intervalLow_intervalHigh <NPART> <dNPART> TAA  dTAA  sys.AP  Traj  Trigg  Pair AccEff dAccEff
+      // Store value in array
+      fscanf(infile,"%s %f_%f %f %f %f %f %f %f %f %f %f %f ",
+                 &centrality,&interval[0],&interval[1],
+                 &valueArray[0],&valueArray[1],&valueArray[2],
+                 &valueArray[3],&valueArray[4],&valueArray[5],
+                 &valueArray[6],&valueArray[7],&valueArray[8],&valueArray[9]);
+      if(centrality == 'F') continue; // Don't read first line if begin by F=False
+
+      // Check Point
+        AliDebug(1,Form(" -- Selected line :"));
+        AliDebug(1,Form(" -- Centrality  <NPART> d<NPART>TAA  dTAA  sys.AP  Traj  Trigg  Pair  AccEff dAccEff"));
+        AliDebug(1,Form(" --  %s %.2f_%.2f  %f  %f  %f  %f  %f  %f  %f  %f %f %f",
+        &centrality,interval[0],interval[1],
+        valueArray[0],valueArray[1],valueArray[2],
+        valueArray[3],valueArray[4],valueArray[5],
+        valueArray[6],valueArray[7],valueArray[8],valueArray[9]));
+
+      // Make intervalArray a string
+      TString intervalLow  = TString::Format("%.2f",interval[0]);// Problem here : if interval[0] = 0.00 and not 00.00 in case of all interval containing 00.00. See second conditions
+      TString intervalHigh = TString::Format("%.2f",interval[1]);
+
+      // Select the good interval. Since interval is written in <binAsString>, just need them to match
+      if(spectraName->Contains(Form("%c0M",centrality)) && spectraName->Contains(Form("_%s_%s",intervalLow.Data(),intervalHigh.Data())))
+      {
+
+
+        for (int i = 0; i < 10; ++i)
+        {
+         constantArray[i]=valueArray[i];
+        }
+        fclose(infile);
+        AliDebug(1, " ==== Closing file ==== ");
+        return kTRUE;
+      }
+      else if (spectraName->Contains(Form("%c0M",centrality))&& spectraName->Contains(Form("00.00_%s",intervalHigh.Data())))
+      {
+
+        for (int i = 0; i < 10; ++i)
+        {
+         constantArray[i]=valueArray[i];
+        }
+        fclose(infile);
+        AliDebug(1, " ==== Closing file ==== ");
+        return kTRUE;
+      }
+      else
+      {
+        AliDebug(1,Form("Not the good interval, so continue ...."));
+        continue;
+      }
+    }
+    fclose(infile);
+    AliDebug(1, " ==== Closing file ==== ");
+  }
+  else
+  {
+    return kFALSE;
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsule::PrintNofWhat(const char* what) const
+{
+  /// Print whar number for each results on terminal.
+  
+
+  //Check point
+  if(!GetSpectra() || strcmp(what,"")==1 )
+    {
+      AliError("No Spectra or no arguments given !");
+      return ;
+    } 
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+  // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  //Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    Int_t nofSubResult = 0; // Counter for subresult
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+
+    //Some variables
+    TString  binAsString(r->AsString());// Usefull for the coming loop
+
+    cout << Form(" -_-_-_-_- %s_%s -_-_-_-_- ",binAsString.Data(),GetSpectraName().Data()) << endl;
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+        AliError(Form("Cannot find subresult "));
+        return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      //Get quantities
+      Double_t NofJPsiSub      = subresult->GetValue(what);
+      Double_t NofJPsiErrorStat = subresult->GetErrorStat(what);
+
+      //Output messages
+      cout << Form(" -------- ") << endl;
+      cout << Form(" -- subresult %s :  %.0f +/- %.0f ",sr->GetName(),NofJPsiSub,NofJPsiErrorStat) << endl;
+      nofSubResult++;
+
+    }
+    cout << Form(" -------- ") << endl;
+    cout << Form(" ------ Mean :  %.0f +/- %.0f +/- %.0f ------ ",result->GetValue(what),result->GetErrorStat(what),result->GetRMS(what)) << endl;
+    cout << "" << endl;
+    nofResult++;
+  }
+}
+
+
+
+
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
new file mode 100644
index 0000000..170a317
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
@@ -0,0 +1,67 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULE_H
+#define ALINANALYSISMUMUSPECTRACAPSULE_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsule : mother class to all capsule class.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include <TString.h>
+#include "TObject.h"
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectraCapsule : public TObject
+{
+  
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsule();
+  //dctor
+  virtual ~AliAnalysisMuMuSpectraCapsule();
+  // Compute Yield 
+  virtual TGraphErrors* ComputeYield(const char* what, const TH1* histo, const char* sResName) = 0;
+  // Draw fit results and save them if wanted
+  virtual void DrawResults(const char* printDirectoryPath, Bool_t Print, const char* particle)const = 0 ;
+  // Print some data members
+  virtual void Print(Option_t* opt) const = 0;
+  // Print constants used
+  virtual void PrintConst() const = 0;
+  // Number of "what" for all subresults
+  void PrintNofWhat(const char* what="") const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file, Double_t* constantArray, const TString* spectraName);
+  
+  // Protection to be sure each daughter class returns data members
+  const virtual Double_t              * GetConstArray()   const =0;
+  
+  const virtual AliAnalysisMuMuSpectra* GetSpectra()      const =0;
+  
+  const virtual TString                 GetSpectraName() const  =0;
+
+  private:
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsule(const AliAnalysisMuMuSpectraCapsule& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsule& operator=(const AliAnalysisMuMuSpectraCapsule& rhs);// not implemented on purpose
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsule,1)
+/// \endcond;
+};
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
new file mode 100644
index 0000000..2293914
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
@@ -0,0 +1,836 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePbP)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+#include <iostream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+namespace
+{
+
+  const Double_t BR             = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME : Fnorm store in TH1, make in general
+  const Double_t Fnorm          = 27.51;    // Normalization
+  const Double_t FnormStat      = 0.01;     // Normalization
+  const Double_t FnormSyst      = 0.97;     // Normalization
+  //pp Cross-section integrated in pt,y
+  const Double_t sigmaPP        = 3.343;    // for fully integrated case
+  const Double_t dsigmaPP       = 0.033;    // idem
+  const Double_t dsigmaPPCorr   = 0.022;    // for fully integrated case
+  const Double_t dsigmaPPUncorr = 0.021;    // idem
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError   = 3/100;
+  // Corr. error for centrality
+  const Double_t TrajCENT       = 11/100;
+  const Double_t TriggCENT      = 2/100;
+  const Double_t PairCENT       = 1/100;
+  // Corr. error for pt case
+  const Double_t TrajPT         = 1/100;
+  const Double_t TriggPT        = 1/100;
+  const Double_t PairPt         = 1/100;
+  // Corr. error for y case
+  const Double_t TrajY          = 1/100;
+  const Double_t TriggY         = 1/100;
+  const Double_t PairY          = 1/100;
+}
+
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePbP::AliAnalysisMuMuSpectraCapsulePbP(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath,
+const char                  * externFile,
+const char                  * externFile2)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath),
+  fExternFile(externFile),
+  fExternFile2(externFile2)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+
+  if(!AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(fExternFile2,&fConstArray[0],&fSpectraName))
+  {
+    AliWarning(Form("No extern file readed"));
+  }
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePbP::~AliAnalysisMuMuSpectraCapsulePbP()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePbP::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+  
+  if(!GetSpectra() || histo==0x0|| strcmp(what,"")==1) return 0x0;
+
+  // Some constants
+  const TString graphTitle = Form("%s-YIELD",GetSpectraName().Data());
+  TString sres(sResName);
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  // TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (GetSpectraName().Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    // graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (GetSpectraName().Contains("-PT")|| GetSpectraName().Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    // graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Store quantities
+    Double_t NofWhattTot = result->GetValue(what,sres.Data());
+    Double_t NofWhattTotError = result->GetErrorStat(what,sres.Data());
+
+    Double_t nEqMBTot      = histo->GetBinContent(nofResult+1);
+    Double_t nEqMBTotError = histo->GetBinError(nofResult+1);
+
+    AliDebug(1,Form("histo used    : %s",histo->GetTitle()));
+    AliDebug(1,Form("%s            = %f",what,NofWhattTot));
+    AliDebug(1,Form("%s error      = %f",what,NofWhattTotError));
+    AliDebug(1,Form("nEqMBTot      = %f",nEqMBTot));
+    AliDebug(1,Form("nEqMBTotError = %f",nEqMBTotError));
+
+    if( NofWhattTot==0||NofWhattTotError==0||nEqMBTot==0||nEqMBTotError==0)
+    {
+      AliError("Cannot set quantities properly");
+      return 0x0;
+    }
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(GetSpectraName().Contains("-INTEGRATED"))
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],yieldInt);
+      graph->SetPointError(nofResult,fConstArray[1],yieldIntError);
+      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult];
+      graph->SetPoint(nofResult,binCenter,yieldInt);
+      graph->SetPointError(nofResult,r->WidthX()/5,yieldInt);
+      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(GetSpectraName().Contains("-INTEGRATED"))graph->GetXaxis()->SetTitle(Form("INTEGRATED"));
+  else if (GetSpectraName().Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (GetSpectraName().Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("Yield");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+ return graph ;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::DrawResults( const char* printDirectoryPath,Bool_t Print,const char* particle) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+
+  //Pointer for functions
+    TF1* f1 = 0x0;
+    TF1* f2 = 0x0;
+    TF1* f3 = 0x0;
+    TF1* f4 = 0x0;
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+  if ( fSpectraName.Contains(particle))
+      {
+      xmin = 2;
+      xmax = 6;
+      }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) {histos->Add(h);}
+      else
+      {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 )
+      {
+      nx = 2;
+      ny=0;
+      }
+  else if ( nofResult > 2 )
+      {
+      ny = TMath::Nint(TMath::Sqrt(nofResult));
+      nx = TMath::Nint((nofResult/ny) +0.6);
+      }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  if (Print)
+  {
+    // Save Canvas
+    cout << "Printing ..." << endl;
+    c->Print(Form("%s/%s.pdf",printDirectoryPath,c->GetTitle()));
+  }
+  delete bins;
+  delete histos;
+}
+
+
+//_____________________________________________________________________________
+TGraphErrors * AliAnalysisMuMuSpectraCapsulePbP::RpAAsGraphic(Double_t MUL) const
+{
+  /**
+   *
+   * Run over each bin, calculate R_pA according to fBinType throught GetValuesFromExternFiles() :
+   * Return a graph to be deleted by owner.
+   *
+   */
+
+  // Some constants
+  const TString histoName = Form("%s",fSpectraName.Data());
+
+  //Check point
+  if(!GetSpectra() || fExternFile.IsNull() ) return 0x0 ;
+
+  //Check point
+  if (MUL==0)
+  {
+    AliError(Form("NofMUL is null"));
+    return 0x0;
+  }
+
+  AliError("To be implemented !");
+  return 0x0;
+
+
+ //  // Pointers to handle results and subresults and binning
+ //  AliAnalysisMuMuResult    * result;
+ //  AliAnalysisMuMuBinning   ::Range* r;
+
+ // // Array to store bins for the while loop
+ //  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+ //  if (!bins)
+ //  {
+ //    AliError(Form("Cannot find bins"));
+ //    return 0x0;
+ //  }
+ //  // Array for listed quantities
+ //  Double_t num[8]={0.};
+ //  //  num[0]   ,  num[1]   ,   num[2]   ,   num[3]  ,  num[4] ,  num[5]  ,   num[6]   ,   num[7]
+ //  //  NofJpsi     JPsiStat     JPsiSyst     NormTot    RAA       StatErr     SystCorrErr  SystUnCorrErr
+ //  // --------------------------
+
+ //  // Here we define some pointers
+ //  TGraphErrors*graph(0x0);
+ //  // TGraphErrors*graph_sysUncorr(0x0);
+
+ //  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+ //  Int_t binsX = 0;
+
+ //  //________Define histo according to bin type
+ //  if (fSpectraName.Contains("-INTEGRATED"))
+ //  {
+ //    graph           = new TGraphErrors(1);
+ //    // graph_sysUncorr = new TGraphErrors(1);
+ //    graph->SetTitle(histoName.Data());
+ //    graph->SetMinimum(0.);
+ //    graph->SetMaximum(1.2);
+ //    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+ //  }
+ //  else if (fSpectraName.Contains("-PT")|| fSpectraName.Contains("-Y"))
+ //  {
+ //    binArray =GetSpectra()->Binning()->CreateBinArray();
+ //    binsX    = GetSpectra()->Binning()->GetNBinsX();
+
+ //    if (!binArray)
+ //    {
+ //      AliError(Form("Cannot set binArray"));
+ //      return 0x0;
+ //    }
+ //    if (binsX==0)
+ //    {
+ //      AliError(Form("Cannot set binsX"));
+ //      return 0x0;
+ //    }
+
+ //    graph           = new TGraphErrors(binsX);
+ //    // graph_sysUncorr = new TGraphErrors(binsX);
+ //    graph->SetTitle(histoName.Data());
+ //    graph->SetMinimum(0.);
+ //    graph->SetMaximum(1.2);
+ //    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+ //  }
+ //  else
+ //  {
+ //    cout << "Unknowned Bin type !" << endl;
+ //    return 0x0;
+ //  }
+ //  //________
+
+ //  //________Counters and Iterator for bin
+ //  Int_t nofResult = 0;
+ //  TIter nextBin(bins);
+ //  nextBin.Reset();
+ //  //________
+
+ //  // Loop on bins
+ //  //==============================================================================
+ //  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+ //  {
+ //    //________Make bin a MuMuResult
+ //    result = GetSpectra()->GetResultForBin(*r);
+ //    if (!result)
+ //    {
+ //      AliError(Form("Cannot find result "));
+ //      return 0x0;
+ //    }
+ //    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+ //    //________
+
+ //    // Get a string with bin name
+ //    TString binAsString = r->AsString();
+
+ //    // Store quantities
+ //    num[0] = result->GetValue("NofJPsi");
+ //    num[1] = result->GetErrorStat("NofJPsi");
+ //    num[2] = result->GetRMS("NofJPsi");
+
+ //    GetValuesFromExternFile(binAsString,&num[0],MUL);
+
+ //    //________Compute R_AA in case of fully integrated spectra
+ //    if(fSpectraName.Contains("-INTEGRATED"))
+ //    {
+ //      //Output messages
+ //      cout << Form("") << endl;
+ //      cout << Form("  |    %s    |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+
+ //      // Add results to TGraphs
+ //      graph->SetPoint(nofResult,fConstArray[0],num[4]);
+ //      graph->SetPointError(nofResult,fConstArray[1],num[5]);
+ //      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+ //      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+ //    }
+ //    else
+ //    {
+ //      num[4]=num[4]/(r->WidthX());
+ //      cout << Form("") << endl;
+ //      cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+ //      //Fill graph
+ //      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult] ;
+ //      graph->SetPoint(nofResult,binCenter,num[4]);
+ //      graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+ //      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+ //      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+ //    }
+ //    //________
+
+ //    nofResult++;
+ //  }
+
+ //  // Config. graphics
+ //  if(fSpectraName.Contains("INTEGRATED"))graph->GetXaxis()->SetTitle(Form("<NPart>"));
+ //  else if (fSpectraName.Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+ //  else if (fSpectraName.Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+ //  graph->GetYaxis()->SetTitle("R_{pA}");
+ //  graph->SetMarkerColor(4);
+ //  graph->SetMarkerStyle(21);
+
+ //  // delete graph;
+ //  // delete graph_sysUncorr;
+ //  delete bins;
+ //  delete binArray;
+
+ // return graph ;
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::GetValuesFromExternFile(TString sbin, Double_t numArray[], Double_t MUL) const
+{
+  /**
+   *
+   * Checks bin type and read files (or not) accordingly. Then computes and stores several results in numArray.
+   *
+   */
+  
+  AliWarning("INNER NORMALIZATION FACTOR, YOU MIGHT CHECK THE CODE !!");
+
+  AliError("To be implemented !");
+  return;
+  
+  // //________PT and Y case
+  // if (fSpectraName.Contains("-PT") || fSpectraName.Contains("-Y"))
+  // {
+  //   char status;
+
+  //    //________Arrays to store quantities from externFile
+  //   float intervalArray[2];
+  //   // intervalLow , intervalHight
+  //   //      0      ,      1
+  //   float valueArray[10];
+  //   //    sigmapp   dsigmapp   dsigmappCorr   dsigmappUncorr  AccEff   dAccEff  sysMC   TrajEffError  TriggerError   PairError
+  //   //________ﬁ
+
+  //   //________Open file
+  //   FILE*  infile;
+  //   infile = fopen(fExternFile.Data(),"rb") ;
+
+  //   if (infile != NULL)
+  //   {
+  //     AliDebug(1, " ==== opening file ==== ");
+  //     // Loop until end of file is reached
+  //     while(!feof(infile))
+  //     {
+  //       // Reminder :
+  //       // intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff sysMC TrajEffError  TriggerError   PairError;
+  //       // Store value in array
+  //       fscanf(infile,"%s %f_%f %f %f %f %f %f %f %f %f %f %f",&status,&intervalArray[0],&intervalArray[1],
+  //                                                  &valueArray[0],&valueArray[1],&valueArray[2],&valueArray[3],&valueArray[4],
+  //                                                  &valueArray[5],&valueArray[6],&valueArray[7],&valueArray[8],&valueArray[9]);
+  //       if(status == 'F') continue; // F = false, T =true
+  //       // Make intervalArray a string
+  //       TString intervalLow  = TString::Format("%.2f",intervalArray[0]);
+  //       TString intervalHigh = TString::Format("%.2f",intervalArray[1]);
+
+  //       // Select the good interval. Since interval is written in <binAsString>, just need them to match
+  //       if(sbin.Contains(Form("%s",intervalLow.Data())) && sbin.Contains(Form("%s",intervalHigh.Data())))
+  //       {
+  //         // Check Point
+  //         AliDebug(1,Form(" -- Selected line :"));
+  //         AliDebug(1,Form(" -- intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff  sysMC TrajEffError  TriggerError   PairErrorﬁ"));
+  //         AliDebug(1,Form(" --  %.2f  %.2f  %f  %f  %f  %f  %f  %f  %f  %f  %f  %f ",
+  //         intervalArray[0],intervalArray[1],valueArray[0],valueArray[1],valueArray[2],valueArray[3],valueArray[4],valueArray[5],valueArray[6],valueArray[7],valueArray[8],valueArray[9]));
+
+  //         //Normalization according to centrality bin
+  //         if (fSpectraName.Contains("V0M_00.00_90.00"))
+  //         {
+  //           numArray[3] = fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+  //         }
+  //         else
+  //         {
+  //           numArray[3] = (1./9.)*fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+  //         }
+
+  //         numArray[4] = numArray[0]/numArray[3];
+
+  //       }
+  //       else
+  //       {
+  //         AliDebug(1,Form("Not the good interval, so continue ...."));
+  //         continue;
+  //       }
+  //     }
+  //     fclose(infile);
+  //     AliDebug(1, " ==== Closing file ==== ");
+  //   }
+  //   else
+  //   {
+  //     cout << Form("Cannot open configuration file %s ",fExternFile.Data()) << endl;
+  //     return;
+  //   }
+  //   //________
+
+  //   if (fSpectraName.Contains("-PT") )
+  //   {
+  //     // Normalization factor due to how PP cross-section are calculated
+  //     numArray[4] = numArray[4]/1.5;
+
+  //     //Corr
+  //     numArray[6] = numArray[4] * TMath::Sqrt(TrajPT                       *TrajPT                       + // Traj. reconstruction Eff.
+  //                                             TriggPT                      *TriggPT                      + // Trigg Eff.
+  //                                             FnormSyst/Fnorm              *FnormSyst/Fnorm              + // Fnorm Syst
+  //                                             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2]+ // TAA syst.
+  //                                             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);  // dsigma_pp_Corr/sigma_pp
+
+
+  //   }
+  //   else if (fSpectraName.Contains("-Y"))
+  //   {
+  //     //Corr
+  //     numArray[6] = numArray[4] * TMath::Sqrt(TrajY                        *TrajY                         + // Traj. reconstruction Eff.
+  //                                             TriggY                       *TriggY                        + // Trigg Eff.
+  //                                             FnormSyst/Fnorm              *FnormSyst/Fnorm               + // Fnorm Syst
+  //                                             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2] + // TAA syst.
+  //                                             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);   // dsigma_pp_Corr/sigma_pp
+
+  //   }
+  //   else
+  //   {
+  //     AliError("Unowned bin type... I Told you !");
+  //     return;
+  //   }
+
+  //   //Stat
+  //   numArray[5] = numArray[4] * TMath::Sqrt(numArray[1]/numArray[0]    *numArray[1]/numArray[0]     + // Jpsi extraction
+  //                                           valueArray[1]/valueArray[0]*valueArray[1]/valueArray[0] ); // dsigma_pp/sigma_pp
+
+  //   //UnCorr
+  //   numArray[7] = numArray[4] * TMath::Sqrt(valueArray[6]             *valueArray[6]                   + // MC param.
+  //                                           numArray[2]/numArray[0]   *numArray[2]/numArray[0]         + // Signal extraction
+  //                                           valueArray[7]             *valueArray[7]                   + // Traj. Eff.
+  //                                           valueArray[8]             *valueArray[8]                   + // Trigg. Eff.
+  //                                           valueArray[9]             *valueArray[9]                   + // Pair. Eff.
+  //                                           valueArray[3]/valueArray[0]*valueArray[3]/valueArray[0]);     // dsigma_pp_Uncorr/sigma_pp
+  // }
+
+  // //________Compute R_AA in case of integrated spectra in PT and Y
+  // else if(fSpectraName.Contains("-INTEGRATED"))
+  // {
+  //   //Get quantities
+
+  //   //Normalization according to centrality bin
+  //   if (!fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = BR*fConstArray[2]*(Fnorm*MUL/9)*(sigmaPP/1000)*(fConstArray[8]);
+  //   else                                           numArray[3] = BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+  //   numArray[4] = numArray[0]/numArray[3];
+
+  //   //Stat error
+  //   numArray[5] = numArray[4] * TMath::Sqrt((numArray[1]/numArray[0])*(numArray[1]/numArray[0]) + // Jpsi extraction
+  //                                                    dsigmaPP/sigmaPP*dsigmaPP/sigmaPP          ); // dsigma_pp/sigma_pp
+  //   //Corr error
+  //   numArray[6] = numArray[4] * TMath::Sqrt(MCParamError        *MCParamError         + // MCParamError
+  //                                           fConstArray[4]      *fConstArray[4]       + // Traj. reconstruction Eff.
+  //                                           fConstArray[5]      *fConstArray[5]       + // Trig. Eff.
+  //                                           fConstArray[6]      *fConstArray[6]       + // Pair Reconst. Eff.
+  //                                           dsigmaPPCorr/sigmaPP*dsigmaPPCorr/sigmaPP + // dsigma_pp_Corr/sigma_pp
+  //                                           FnormSyst/Fnorm     *FnormSyst/Fnorm);      // Fnorm Syst
+  //   //Uncorr error
+  //   numArray[7] = numArray[4] * TMath::Sqrt(numArray[2]/numArray[0]      *numArray[2]/numArray[0]      + // Signal extraction
+  //                                           fConstArray[1]/fConstArray[0]*fConstArray[1]/fConstArray[0]);// TAA syst.
+  // }
+  // else
+  // {
+  //   AliError("Unowned bin type... I Told you !");
+  //   return;
+  // }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::PrintConst() const
+{
+  /**
+   *
+   * Print member constants
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else
+  {
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" Constants for Spectra %s",fSpectraName.Data()) << endl;
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" -- Value of <Npart>     = %f",fConstArray[0]) << endl;
+    cout << Form(" -- Value of d<Npart>    = %f",fConstArray[1]) << endl;
+    cout << Form(" -- Value of TAA         = %f",fConstArray[2]) << endl;
+    cout << Form(" -- Value of dTAA        = %f",fConstArray[3]) << endl;
+    cout << Form(" -- Value of sys.AP      = %f",fConstArray[4]) << endl;
+    cout << Form(" -- Value of Traj. err.  = %f",fConstArray[5]) << endl;
+    cout << Form(" -- Value of Trigg. err. = %f",fConstArray[6]) << endl;
+    cout << Form(" -- Value of Pair. err.  = %f",fConstArray[7]) << endl;
+    cout << Form(" -- Value of AccEff      = %f",fConstArray[8]) << endl;
+    cout << Form(" -- Value of dAccEff     = %f",fConstArray[9]) << endl;
+  }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
new file mode 100644
index 0000000..3a5f79e
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
@@ -0,0 +1,87 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPBP_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPBP_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbP : helper class to deal with results stored in a spectra with pPb methods. 
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePbP : public AliAnalysisMuMuSpectraCapsule
+{
+  
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePbP(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="",
+                             const char                              * externFile="",
+                             const char                              * externFile2="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePbP();
+  // Compute Yield 
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* printDirectoryPath="histo",Bool_t Print=kFALSE,const char* particle="PSI")const;  
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+  // Compute R_pA
+  TGraphErrors* RpAAsGraphic(Double_t MUL) const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const Double_t              * GetConstArray() const {return fConstArray;};
+  const AliAnalysisMuMuSpectra* GetSpectra()    const {return fSpectra;};
+  const TString                GetSpectraName() const {return fSpectraName;};
+
+private:
+  // Read and compute values from extern file
+  void GetValuesFromExternFile(TString sbin, Double_t numArray[],Double_t MUL) const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file);
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePbP(const AliAnalysisMuMuSpectraCapsulePbP& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePbP& operator=(const AliAnalysisMuMuSpectraCapsulePbP& rhs);// not implemented on purpose
+
+  
+private:
+  TString fExternFile;      // name of spectra selected
+  TString fExternFile2;     // name of spectra selected
+  Double_t fConstArray[10]; // Array to store constant according to centrality bins
+  
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePbP,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
new file mode 100644
index 0000000..7fec54e
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
@@ -0,0 +1,930 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePbPb)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+#include <iostream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+namespace
+{
+  const Double_t BR             = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME : Fnorm store in TH1, make in general
+  const Double_t Fnorm          = 15.18;    // Normalization
+  const Double_t FnormStat      = 0.03;     // Normalization
+  const Double_t FnormSyst      = 0.97;     // Normalization
+  //pp Cross-section integrated in pt,y
+  const Double_t sigmaPP        = 5.457857;    // for fully integrated case
+  const Double_t dsigmaPP       = 9.950825e-02;    // idem
+  const Double_t dsigmaPPCorr   = 0.022;    // for fully integrated case
+  const Double_t dsigmaPPUncorr = 0.021;    // idem
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError   = 3/100;
+  // Corr. error for centrality
+  const Double_t TrajCENT       = 11/100;
+  const Double_t TriggCENT      = 2/100;
+  const Double_t PairCENT       = 1/100;
+  // Corr. error for pt case
+  const Double_t TrajPT         = 1/100;
+  const Double_t TriggPT        = 1/100;
+  const Double_t PairPt         = 1/100;
+  // Corr. error for y case
+  const Double_t TrajY          = 1/100;
+  const Double_t TriggY         = 1/100;
+  const Double_t PairY          = 1/100;
+}
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePbPb::AliAnalysisMuMuSpectraCapsulePbPb(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath,
+const char                  * externFile,
+const char                  * externFile2)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath),
+  fExternFile(externFile),
+  fExternFile2(externFile2)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+
+  if(!AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(fExternFile2,&fConstArray[0],&fSpectraName))
+  {
+    AliWarning(Form("No extern file readed"));
+  }
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePbPb::~AliAnalysisMuMuSpectraCapsulePbPb()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePbPb::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+  
+  if(!GetSpectra() || histo==0x0|| strcmp(what,"")==1) return 0x0;
+
+  // Some constants
+  const TString graphTitle = Form("%s-YIELD",GetSpectraName().Data());
+  TString sres(sResName);
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  // TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (GetSpectraName().Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    // graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (GetSpectraName().Contains("-PT")|| GetSpectraName().Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    // graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Store quantities
+    Double_t NofWhattTot = result->GetValue(what,sres.Data());
+    Double_t NofWhattTotError = result->GetErrorStat(what,sres.Data());
+
+    Double_t nEqMBTot      = histo->GetBinContent(nofResult+1);
+    Double_t nEqMBTotError = histo->GetBinError(nofResult+1);
+
+    AliDebug(1,Form("histo used    : %s",histo->GetTitle()));
+    AliDebug(1,Form("%s            = %f",what,NofWhattTot));
+    AliDebug(1,Form("%s error      = %f",what,NofWhattTotError));
+    AliDebug(1,Form("nEqMBTot      = %f",nEqMBTot));
+    AliDebug(1,Form("nEqMBTotError = %f",nEqMBTotError));
+
+    if( NofWhattTot==0||NofWhattTotError==0||nEqMBTot==0||nEqMBTotError==0)
+    {
+      AliError("Cannot set quantities properly");
+      return 0x0;
+    }
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(GetSpectraName().Contains("-INTEGRATED"))
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],yieldInt);
+      graph->SetPointError(nofResult,fConstArray[1],yieldIntError);
+      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult];
+      graph->SetPoint(nofResult,binCenter,yieldInt);
+      graph->SetPointError(nofResult,r->WidthX()/5,yieldInt);
+      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(GetSpectraName().Contains("-INTEGRATED"))graph->GetXaxis()->SetTitle(Form("INTEGRATED"));
+  else if (GetSpectraName().Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (GetSpectraName().Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("Yield");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+ return graph ;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::DrawResults( const char* printDirectoryPath,Bool_t Print,const char* particle) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+
+  //Pointer for functions
+    TF1* f1 = 0x0;
+    TF1* f2 = 0x0;
+    TF1* f3 = 0x0;
+    TF1* f4 = 0x0;
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+  if ( fSpectraName.Contains(particle))
+      {
+      xmin = 2;
+      xmax = 6;
+      }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) {histos->Add(h);}
+      else
+      {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 )
+      {
+      nx = 2;
+      ny=0;
+      }
+  else if ( nofResult > 2 )
+      {
+      ny = TMath::Nint(TMath::Sqrt(nofResult));
+      nx = TMath::Nint((nofResult/ny) +0.6);
+      }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny,0,0);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      f1 = h->GetFunction("signal");
+      if(f1) f1->DrawCopy("same");
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  if (Print)
+  {
+    // Save Canvas
+    cout << "Printing ..." << endl;
+    c->Print(Form("%s/%s.pdf",printDirectoryPath,c->GetTitle()));
+  }
+  delete bins;
+  delete histos;
+}
+
+
+//_____________________________________________________________________________
+TGraphErrors * AliAnalysisMuMuSpectraCapsulePbPb::RAAasGraphic(Double_t MUL) const
+{
+  /**
+   *
+   * Run over each bin, calculate RAA according to fBinType throught GetValuesFromExternFiles() :
+   * Return a graph to be deleted by owner.
+   *
+   */
+
+  // Some constants
+  const TString histoName = Form("%s",fSpectraName.Data());
+
+  //Check point
+  if(!GetSpectra() || fExternFile.IsNull() ) return 0x0 ;
+
+  //Check point
+  if (MUL==0)
+  {
+    AliError(Form("NofMUL is null"));
+    return 0x0;
+  }
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+  // Array for listed quantities
+  Double_t num[8]={0.};
+  //  num[0]   ,  num[1]   ,   num[2]   ,   num[3]  ,  num[4] ,  num[5]  ,   num[6]   ,   num[7]
+  //  NofJpsi     JPsiStat     JPsiSyst     NormTot    RAA       StatErr     SystCorrErr  SystUnCorrErr
+  // --------------------------
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (fSpectraName.Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(histoName.Data());
+    graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (fSpectraName.Contains("-PT")|| fSpectraName.Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX    = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(histoName.Data());
+    graph->SetMinimum(0.);
+    graph->SetMaximum(1.2);
+    graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Get a string with bin name
+    TString binAsString = r->AsString();
+
+    // Store quantities
+    num[0] = result->GetValue("NofJPsi");
+    num[1] = result->GetErrorStat("NofJPsi");
+    num[2] = result->GetRMS("NofJPsi");
+
+    //Main methods
+    ComputeRAA(binAsString,&num[0],MUL);
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(fSpectraName.Contains("-INTEGRATED"))
+    {
+      //Output messages
+      cout << Form("") << endl;
+      cout << Form("  |    %s    |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],num[4]);
+      graph->SetPointError(nofResult,fConstArray[1],num[5]);
+      graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+      graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else if (fSpectraName.Contains("-PT"))
+    {
+      num[4]=num[4]/(r->WidthX());
+      cout << Form("") << endl;
+      cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult] ;
+      graph->SetPoint(nofResult,binCenter,num[4]);
+      graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+      graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    else if (fSpectraName.Contains("-Y"))
+        {
+        num[4]=num[4]/(r->WidthX());
+        cout << Form("") << endl;
+        cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+        //Fill graph
+        Double_t binCenter = -((binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult]) ;
+        graph->SetPoint(nofResult,binCenter,num[4]);
+        graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+        graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+        graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+        }
+    else return 0x0;
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(fSpectraName.Contains("INTEGRATED"))graph->GetXaxis()->SetTitle(Form("<NPart>"));
+  else if (fSpectraName.Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (fSpectraName.Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("R_{AA}");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  //Add and merge all Graph
+  TList* l = new TList();
+  l->Add(graph_sysUncorr);
+  if(0.>graph->Merge(l)) return 0x0;
+
+
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+ return graph ;
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::ComputeRAA(TString sbin, Double_t numArray[], Double_t MUL) const
+{
+  /**
+   *
+   * Checks bin type and read files (or not) accordingly. Then computes and stores several results in numArray.
+   *
+   */
+  
+  AliWarning("INNER NORMALIZATION FACTOR, YOU MIGHT CHECK THE CODE !!");
+
+  //________PT and Y case
+  if (fSpectraName.Contains("-PT") || fSpectraName.Contains("-Y"))
+  {
+    char status;
+
+    //  //________Arrays to store quantities from externFile
+    // float intervalArray[2];
+    // // intervalLow , intervalHight
+    // //      0      ,      1
+    float valueArray[10];
+    //    sigmapp   dsigmapp   dsigmappCorr   dsigmappUncorr  AccEff   dAccEff  sysMC   TrajEffError  TriggerError   PairError
+    //________ﬁ
+
+    if(!ReadFromFile(sbin,&valueArray[0])) return;
+    // //________Open file
+    // FILE*  infile;
+    // infile = fopen(fExternFile.Data(),"rb") ;
+
+    // if (infile != NULL)
+    // {
+    //   AliDebug(1, " ==== opening file ==== ");
+    //   // Loop until end of file is reached
+    //   while(!feof(infile))
+    //   {
+    //     // Reminder :
+    //     // intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff sysMC TrajEffError  TriggerError   PairError;
+    //     // Store value in array
+    //     fscanf(infile,"%s %f_%f %f %f %f %f %f %f %f %f %f %f",&status,&intervalArray[0],&intervalArray[1],
+    //                                                &valueArray[0],&valueArray[1],&valueArray[2],&valueArray[3],&valueArray[4],
+    //                                                &valueArray[5],&valueArray[6],&valueArray[7],&valueArray[8],&valueArray[9]);
+    //     if(status == 'F') continue; // F = false, T =true
+    //     // Make intervalArray a string
+    //     TString intervalLow  = TString::Format("%.2f",intervalArray[0]);
+    //     TString intervalHigh = TString::Format("%.2f",intervalArray[1]);
+
+    //     // Select the good interval. Since interval is written in <binAsString>, just need them to match
+    //     if(sbin.Contains(Form("%s",intervalLow.Data())) && sbin.Contains(Form("%s",intervalHigh.Data())))
+    //     {
+    //       // Check Point
+    //       AliDebug(1,Form(" -- Selected line :"));
+    //       AliDebug(1,Form(" -- intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff  sysMC TrajEffError  TriggerError   PairErrorﬁ"));
+    //       AliDebug(1,Form(" --  %.2f  %.2f  %f  %f  %f  %f  %f  %f  %f  %f  %f  %f ",
+    //       intervalArray[0],intervalArray[1],valueArray[0],valueArray[1],valueArray[2],valueArray[3],valueArray[4],valueArray[5],valueArray[6],valueArray[7],valueArray[8],valueArray[9]));
+
+    //Normalization according to centrality bin
+    if (fSpectraName.Contains("V0M_00.00_90.00"))
+    {
+      numArray[3] = fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+    }
+    else
+    {
+      numArray[3] = (1./9.)*fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+    }
+
+    numArray[4] = numArray[0]/numArray[3];
+
+    //     }
+    //     else
+    //     {
+    //       AliDebug(1,Form("Not the good interval, so continue ...."));
+    //       continue;
+    //     }
+    //   }
+    //   fclose(infile);
+    //   AliDebug(1, " ==== Closing file ==== ");
+    // }
+    // else
+    // {
+    //   cout << Form("Cannot open configuration file %s ",fExternFile.Data()) << endl;
+    //   return;
+    // }
+    // //________
+
+    if (fSpectraName.Contains("-PT") )
+    {
+      // Normalization factor due to how PP cross-section are calculated
+      numArray[4] = numArray[4];
+
+      //Corr
+      numArray[6] = numArray[4] * AliAnalysisMuMuResult::ErrorABCDE(1.,TrajPT,1.,TriggPT,Fnorm,FnormSyst,fConstArray[2],fConstArray[3],valueArray[0],valueArray[2]); 
+                                  // TMath::Sqrt(TrajPT                       *TrajPT                       + // Traj. reconstruction Eff.
+                                  //             TriggPT                      *TriggPT                      + // Trigg Eff.
+                                  //             FnormSyst/Fnorm              *FnormSyst/Fnorm              + // Fnorm Syst
+                                  //             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2]+ // TAA syst.
+                                  //             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);  // dsigma_pp_Corr/sigma_pp
+
+
+    }
+    else if (fSpectraName.Contains("-Y"))
+    {
+      //Corr
+      numArray[6] = numArray[4] * AliAnalysisMuMuResult::ErrorABCDE(1.,TrajY,1.,TriggY,Fnorm,FnormSyst,fConstArray[2],fConstArray[3],valueArray[0],valueArray[2]); 
+                                  // TMath::Sqrt(TrajY                        *TrajY                         + // Traj. reconstruction Eff.
+                                  //             TriggY                       *TriggY                        + // Trigg Eff.
+                                  //             FnormSyst/Fnorm              *FnormSyst/Fnorm               + // Fnorm Syst
+                                  //             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2] + // TAA syst.
+                                  //             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);   // dsigma_pp_Corr/sigma_pp
+
+    }
+    else
+    {
+      AliError("Unowned bin type... I Told you !");
+      return;
+    }
+
+    //Stat
+    numArray[5] = numArray[4] * AliAnalysisMuMuResult::ErrorAB(numArray[0],numArray[1],valueArray[0],valueArray[1]);
+
+                                    // TMath::Sqrt(numArray[1]/numArray[0]    *numArray[1]/numArray[0]     + // Jpsi extraction
+                                    //         valueArray[1]/valueArray[0]*valueArray[1]/valueArray[0] ); // dsigma_pp/sigma_pp
+
+    //UnCorr
+    numArray[7] = numArray[4] * AliAnalysisMuMuResult::ErrorABCD(1.,valueArray[6],numArray[0],numArray[2],1.,valueArray[7],1.,valueArray[8]) 
+                              * AliAnalysisMuMuResult::ErrorAB(1.,valueArray[9],valueArray[0],valueArray[3]);
+
+
+                                // TMath::Sqrt(valueArray[6]             *valueArray[6]                   + // MC param.
+                                //             numArray[2]/numArray[0]   *numArray[2]/numArray[0]         + // Signal extraction
+                                //             valueArray[7]             *valueArray[7]                   + // Traj. Eff.
+                                //             valueArray[8]             *valueArray[8]                   + // Trigg. Eff.
+                                //             valueArray[9]             *valueArray[9]                   + // Pair. Eff.
+                                //             valueArray[3]/valueArray[0]*valueArray[3]/valueArray[0]);     // dsigma_pp_Uncorr/sigma_pp
+  }
+
+  //________Compute R_AA in case of integrated spectra in PT and Y
+  else if(fSpectraName.Contains("-INTEGRATED"))
+  {
+    //Get quantities
+    //Normalization according to centrality bin
+    if (!fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = (1./9.)*BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+    else                                           numArray[3] = BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+    numArray[4] = numArray[0]/numArray[3];
+
+    //Stat error
+    numArray[5] = numArray[4] * AliAnalysisMuMuResult::ErrorAB(numArray[0],numArray[1],sigmaPP,dsigmaPP);
+
+                                // TMath::Sqrt((numArray[1]/numArray[0])*(numArray[1]/numArray[0]) + // Jpsi extraction
+                                //                      dsigmaPP/sigmaPP*dsigmaPP/sigmaPP          ); // dsigma_pp/sigma_pp
+    //Corr error
+    numArray[6] = numArray[4] * AliAnalysisMuMuResult::ErrorABC(1.,MCParamError,1.,fConstArray[4],1.,fConstArray[5])
+                              * AliAnalysisMuMuResult::ErrorABC(1.,fConstArray[6],sigmaPP,dsigmaPPCorr,Fnorm,FnormSyst);
+
+    // TMath::Sqrt(MCParamError        *MCParamError         + // MCParamError
+    //                                         fConstArray[4]      *fConstArray[4]       + // Traj. reconstruction Eff.
+    //                                         fConstArray[5]      *fConstArray[5]       + // Trig. Eff.
+    //                                         fConstArray[6]      *fConstArray[6]       + // Pair Reconst. Eff.
+    //                                         dsigmaPPCorr/sigmaPP*dsigmaPPCorr/sigmaPP + // dsigma_pp_Corr/sigma_pp
+    //                                         FnormSyst/Fnorm     *FnormSyst/Fnorm);      // Fnorm Syst
+
+    //Uncorr error
+    numArray[7] = numArray[4] * AliAnalysisMuMuResult::ErrorAB(numArray[0],numArray[2],fConstArray[0],fConstArray[1]);
+
+
+    // TMath::Sqrt(numArray[2]/numArray[0]      *numArray[2]/numArray[0]      + // Signal extraction
+    //                                         fConstArray[1]/fConstArray[0]*fConstArray[1]/fConstArray[0]);// TAA syst.
+    //                                         
+  }
+  else
+  {
+    AliError("Unowned bin type... I Told you !");
+    return;
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::PrintConst() const
+{
+  /**
+   *
+   * Print member constants
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else
+  {
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" Constants for Spectra %s",fSpectraName.Data()) << endl;
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" -- Value of <Npart>     = %f",fConstArray[0]) << endl;
+    cout << Form(" -- Value of d<Npart>    = %f",fConstArray[1]) << endl;
+    cout << Form(" -- Value of TAA         = %f",fConstArray[2]) << endl;
+    cout << Form(" -- Value of dTAA        = %f",fConstArray[3]) << endl;
+    cout << Form(" -- Value of sys.AP      = %f",fConstArray[4]) << endl;
+    cout << Form(" -- Value of Traj. err.  = %f",fConstArray[5]) << endl;
+    cout << Form(" -- Value of Trigg. err. = %f",fConstArray[6]) << endl;
+    cout << Form(" -- Value of Pair. err.  = %f",fConstArray[7]) << endl;
+    cout << Form(" -- Value of AccEff      = %f",fConstArray[8]) << endl;
+    cout << Form(" -- Value of dAccEff     = %f",fConstArray[9]) << endl;
+  }
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsulePbPb::ReadFromFile(TString sbin, float valueArray[]) const
+{
+  /**
+   *
+   * Read extern file and gives associated values
+   *
+   */
+
+    char status;
+    float intervalArray[2];
+
+    //________Open file
+    FILE*  infile;
+    infile = fopen(fExternFile.Data(),"rb") ;
+
+    if (infile != NULL)
+    {
+      AliDebug(1, " ==== opening file ==== ");
+      // Loop until end of file is reached
+      while(!feof(infile))
+      {
+        // Reminder :
+        // intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff sysMC TrajEffError  TriggerError   PairError;
+        // Store value in array
+        fscanf(infile,"%s %f_%f %f %f %f %f %f %f %f %f %f %f",&status,&intervalArray[0],&intervalArray[1],
+                                                   &valueArray[0],&valueArray[1],&valueArray[2],&valueArray[3],&valueArray[4],
+                                                   &valueArray[5],&valueArray[6],&valueArray[7],&valueArray[8],&valueArray[9]);
+        if(status == 'F') continue; // F = false, T =true
+        // Make intervalArray a string
+        TString intervalLow  = TString::Format("%.2f",intervalArray[0]);
+        TString intervalHigh = TString::Format("%.2f",intervalArray[1]);
+
+        // Select the good interval. Since interval is written in <binAsString>, just need them to match
+        if(sbin.Contains(Form("%s",intervalLow.Data())) && sbin.Contains(Form("%s",intervalHigh.Data())))
+        {
+          // Check Point
+          AliDebug(1,Form(" -- Selected line :"));
+          AliDebug(1,Form(" -- intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff  sysMC TrajEffError  TriggerError   PairErrorﬁ"));
+          AliDebug(1,Form(" --  %.2f  %.2f  %f  %f  %f  %f  %f  %f  %f  %f  %f  %f ",
+          intervalArray[0],intervalArray[1],valueArray[0],valueArray[1],valueArray[2],valueArray[3],valueArray[4],valueArray[5],valueArray[6],valueArray[7],valueArray[8],valueArray[9]));
+
+          // //Normalization according to centrality bin
+          // if (fSpectraName.Contains("V0M_00.00_90.00"))
+          // {
+          //   numArray[3] = fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+          // }
+          // else
+          // {
+          //   numArray[3] = (1./9.)*fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+          // }
+
+          // numArray[4] = numArray[0]/numArray[3];
+
+        }
+        else
+        {
+          AliDebug(1,Form("Not the good interval, so continue ...."));
+          return kFALSE;
+        }
+      }
+      fclose(infile);
+      AliDebug(1, " ==== Closing file ==== ");
+      return kTRUE;
+    }
+    else return kFALSE;
+}
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h
new file mode 100644
index 0000000..faa07d6
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h
@@ -0,0 +1,89 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPBPB_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPBPB_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbPb : helper class to deal with results stored in a spectra with PbPb methods. 
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePbPb : public AliAnalysisMuMuSpectraCapsule
+{
+  
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePbPb(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="",
+                             const char                              * externFile="",
+                             const char                              * externFile2="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePbPb();
+  // Compute Yield 
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* printDirectoryPath="histo",Bool_t Print=kFALSE,const char* particle="PSI")const;  
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+  // Compute quantities linked to RAA
+  TGraphErrors* RAAasGraphic(Double_t MUL) const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const Double_t              * GetConstArray()     const {return fConstArray;};
+  const AliAnalysisMuMuSpectra* GetSpectra()       const {return fSpectra;};
+  const TString                GetSpectraName()    const {return fSpectraName;};
+
+private:
+  // Read and compute values from extern file
+  void ComputeRAA(TString sbin, Double_t numArray[],Double_t MUL) const;
+  // Read exterfil for Pt and Y case
+  Bool_t ReadFromFile(TString sbin, float valueArray[]) const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file);
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePbPb(const AliAnalysisMuMuSpectraCapsulePbPb& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePbPb& operator=(const AliAnalysisMuMuSpectraCapsulePbPb& rhs);// not implemented on purpose
+
+  
+private:
+  TString fExternFile;      // name of spectra selected
+  TString fExternFile2;     // name of spectra selected
+  Double_t fConstArray[10]; // Array to store constant according to centrality bins
+  
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePbPb,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliMuonAccEffSubmitter.cxx b/PWG/muondep/AliMuonAccEffSubmitter.cxx
index 969d556..39f535d 100644
--- a/PWG/muondep/AliMuonAccEffSubmitter.cxx
+++ b/PWG/muondep/AliMuonAccEffSubmitter.cxx
@@ -150,7 +150,22 @@ fUseAODMerging(kFALSE)
   SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P0","0.729545");
   SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P1","0.53837");
   SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P2","0.141776");
-  SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P3","0.0130173");
+  SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P3","0.0130173");  
+
+  // some default values for single muons ben
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PTMIN","0.35");
+  
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P0","135.137");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P1","0.555323");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P2","0.578374");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P3","10.1345");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P4","0.000232233");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P5","-0.924726");
+
+
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P0","1.95551");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P1","-0.104761");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P2","0.00311324");
 
   // some default values for GenBox
   
diff --git a/PWG/muondep/CMakeLists.txt b/PWG/muondep/CMakeLists.txt
index 8cc732f..0d5a70f 100644
--- a/PWG/muondep/CMakeLists.txt
+++ b/PWG/muondep/CMakeLists.txt
@@ -34,8 +34,11 @@ set(SRCS
   AliAnalysisTriggerScalers.cxx
   AliAnalysisMuMu.cxx
   AliAnalysisMuMuConfig.cxx
-  AliAnalysisMuMuResult.cxx
   AliAnalysisMuMuJpsiResult.cxx
+  AliAnalysisMuMuResult.cxx
+  AliAnalysisMuMuSpectraCapsule.cxx
+  AliAnalysisMuMuSpectraCapsulePbPb.cxx
+  AliAnalysisMuMuSpectraCapsulePbP.cxx
   AliAnalysisMuMuFnorm.cxx
   AliAnalysisMuMuGraphUtil.cxx
   AliAnalysisMuMuSpectra.cxx
diff --git a/PWG/muondep/PWGmuondepLinkDef.h b/PWG/muondep/PWGmuondepLinkDef.h
index 53f8b36..c6db0e2 100644
--- a/PWG/muondep/PWGmuondepLinkDef.h
+++ b/PWG/muondep/PWGmuondepLinkDef.h
@@ -14,6 +14,9 @@
 #pragma link C++ class AliAnalysisMuMuConfig+;
 #pragma link C++ class AliAnalysisMuMuResult+;
 #pragma link C++ class AliAnalysisMuMuJpsiResult+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsule+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePbPb+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePbP+;
 #pragma link C++ class AliAnalysisMuMuFnorm+;
 #pragma link C++ class AliAnalysisMuMuGraphUtil+;
 #pragma link C++ class AliAnalysisMuMuSpectra+;
diff --git a/PWGPP/MUON/dep/AliAnalysisTaskMuonTrackingEff.cxx b/PWGPP/MUON/dep/AliAnalysisTaskMuonTrackingEff.cxx
index cbb4a41..b5d83a2 100644
--- a/PWGPP/MUON/dep/AliAnalysisTaskMuonTrackingEff.cxx
+++ b/PWGPP/MUON/dep/AliAnalysisTaskMuonTrackingEff.cxx
@@ -100,11 +100,12 @@ AliAnalysisTaskMuonTrackingEff::AliAnalysisTaskMuonTrackingEff() :
   fDEPlanes(0x0),
   fClusters(0x0),
   fEvents(0x0),
+
   fChamberTDHistList(0x0),
   fChamberTTHistList(0x0),
   fChamberSDHistList(0x0),
   fExtraHistList(0x0)
-{
+  {
   /// Default constructor
 }
 
@@ -129,7 +130,7 @@ AliAnalysisTaskMuonTrackingEff::AliAnalysisTaskMuonTrackingEff(TString name) :
   fChamberTTHistList(0x0),
   fChamberSDHistList(0x0),
   fExtraHistList(0x0)
-{
+  {
   /// Constructor
   
   // Output slots
@@ -149,6 +150,7 @@ AliAnalysisTaskMuonTrackingEff::~AliAnalysisTaskMuonTrackingEff()
     delete fMuonTrackCuts;
     delete fClusters;
     delete fEvents;
+
     delete fChamberTDHistList;
     delete fChamberTTHistList;
     delete fChamberSDHistList;
@@ -480,10 +482,17 @@ void AliAnalysisTaskMuonTrackingEff::UserExec(Option_t *)
     }
     
   }
-  
+
+  fCounts->Count("Counts:NofEvent");
+
   // post the output data:
+<<<<<<< 9d26796b1f4800d4ba43643969d4c0adbd564598
   PostData(1, fClusters);
   PostData(2, fEvents);
+=======
+  PostData(1, fClusters);  
+  PostData(2, fCounts);  
+>>>>>>> Add inner counter for AliAnalysisTaskMuonTrackingEff
   PostData(3, fChamberTDHistList);
   PostData(4, fChamberTTHistList);
   PostData(5, fChamberSDHistList);
