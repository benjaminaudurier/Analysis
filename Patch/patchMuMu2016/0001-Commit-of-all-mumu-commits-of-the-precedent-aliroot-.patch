From 5d894e9eb61688f169718d2d590447dc5e202633 Mon Sep 17 00:00:00 2001
From: baudurie <benjamin.audurier@cern.ch>
Date: Thu, 29 Jan 2015 18:34:38 +0100
Subject: [PATCH 01/36] Commit of all mumu commits of the precedent aliroot
 system

---
 PWG/muon/AliAnalysisMuMuBase.cxx                   |    2 +-
 PWG/muon/AliAnalysisMuMuEventCutter.cxx            |  149 +-
 PWG/muon/AliAnalysisMuMuEventCutter.h              |   55 +-
 PWG/muon/AliAnalysisMuMuMinv.cxx                   |  627 +-
 PWG/muon/AliAnalysisTaskMuMu.cxx                   |   16 +-
 .../AccEffTemplates/GenParamCustomRadiativeDecay.C |   81 +
 .../AccEffTemplates/GenParamCustomSingleBen.C      |   94 +
 PWG/muondep/AliAnalysisMuMu.cxx                    | 8092 +++++++++++---------
 PWG/muondep/AliAnalysisMuMu.h                      |  571 +-
 PWG/muondep/AliAnalysisMuMuConfig.cxx              |  874 +--
 PWG/muondep/AliAnalysisMuMuConfig.h                |    2 +
 PWG/muondep/AliAnalysisMuMuFnorm.cxx               |  474 +-
 PWG/muondep/AliAnalysisMuMuFnorm.h                 |   13 +-
 PWG/muondep/AliAnalysisMuMuFnormBeta.cxx           | 1857 +++++
 PWG/muondep/AliAnalysisMuMuFnormBeta.h             |  148 +
 PWG/muondep/AliAnalysisMuMuJpsiResult.cxx          | 6000 ++++++++++-----
 PWG/muondep/AliAnalysisMuMuJpsiResult.h            |  176 +-
 PWG/muondep/AliAnalysisMuMuSpectra.cxx             |    3 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx      |  201 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsule.h        |   67 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx    |  463 ++
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h      |   80 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx   |  821 ++
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h     |   87 +
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx  |  843 ++
 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h    |   89 +
 PWG/muondep/AliMuonAccEffSubmitter.cxx             |   14 +
 PWG/muondep/CMakeLists.txt                         |    6 +-
 PWG/muondep/PWGmuondepLinkDef.h                    |    4 +
 29 files changed, 14954 insertions(+), 6955 deletions(-)
 create mode 100644 PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C
 create mode 100644 PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C
 create mode 100644 PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuFnormBeta.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
 create mode 100644 PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h

diff --git a/PWG/muon/AliAnalysisMuMuBase.cxx b/PWG/muon/AliAnalysisMuMuBase.cxx
index 8ba09d1..b48b873 100644
--- a/PWG/muon/AliAnalysisMuMuBase.cxx
+++ b/PWG/muon/AliAnalysisMuMuBase.cxx
@@ -97,7 +97,7 @@ TString AliAnalysisMuMuBase::BuildMCPath(const char* eventSelection, const char*
   
   TString mcPath;
   
-  mcPath.Form("/%s/%s",MCInputPrefix(),path.Data());
+  mcPath.Form("/%s%s",MCInputPrefix(),path.Data());
   
   return mcPath;
 }
diff --git a/PWG/muon/AliAnalysisMuMuEventCutter.cxx b/PWG/muon/AliAnalysisMuMuEventCutter.cxx
index a56e210..ea8e1ea 100644
--- a/PWG/muon/AliAnalysisMuMuEventCutter.cxx
+++ b/PWG/muon/AliAnalysisMuMuEventCutter.cxx
@@ -58,19 +58,19 @@ AliAnalysisMuMuEventCutter::AliAnalysisMuMuEventCutter(const char* triggerClasse
 {
   /// ctor
   TString tclasses(triggerClasses);
-  
+
   if ( !triggerClasses )
   {
     tclasses = "ANY";
   }
-  
+
   TString tinputs(triggerInputsMap);
-  
+
   if ( !triggerInputsMap )
   {
     tinputs = "";
   }
-  
+
   MuonEventCuts()->SetTrigClassPatterns(tclasses,tinputs);
 }
 
@@ -80,7 +80,7 @@ AliAnalysisMuMuEventCutter::AliAnalysisMuMuEventCutter(TList* triggerClasses, TL
 {
   /// ctor
   TString tclasses;
-  
+
   if ( !triggerClasses )
   {
     tclasses = "ANY";
@@ -89,20 +89,20 @@ AliAnalysisMuMuEventCutter::AliAnalysisMuMuEventCutter(TList* triggerClasses, TL
   {
     TObjString* tname;
     TIter next(triggerClasses);
-    
+
     while ( ( tname = static_cast<TObjString*>(next()) ) )
     {
       if (tclasses.Length()>0)
       {
         tclasses += ",";
       }
-      
+
       tclasses += tname->String();
     }
   }
-  
+
   TString tinputs;
-  
+
   if ( !triggerInputsMap )
   {
     tinputs = "";
@@ -111,20 +111,20 @@ AliAnalysisMuMuEventCutter::AliAnalysisMuMuEventCutter(TList* triggerClasses, TL
   {
     TObjString* tinputsname;
     TIter next(triggerInputsMap);
-    
+
     while ( ( tinputsname = static_cast<TObjString*>(next()) ) )
     {
       if (tinputs.Length()>0)
       {
         tinputs += ",";
       }
-      
+
       tinputs += tinputsname->String();
     }
   }
-  
+
   MuonEventCuts()->SetTrigClassPatterns(tclasses,tinputs);
-  
+
 }
 
 
@@ -142,10 +142,10 @@ Bool_t AliAnalysisMuMuEventCutter::SelectTriggerClass(const TString& firedTrigge
 {
   /// Forward the trigger class selection to MuonEventCuts::GetSelectedTrigClassesInEvent
   acceptedClasses = "";
-  
+
   TIter next(MuonEventCuts()->GetSelectedTrigClassesInEvent(firedTriggerClasses,L0,L1,L2));
   TObjString* str;
-  
+
   while ( ( str = static_cast<TObjString*>(next()) ) )
   {
     acceptedClasses += str->String();
@@ -154,29 +154,78 @@ Bool_t AliAnalysisMuMuEventCutter::SelectTriggerClass(const TString& firedTrigge
   return (acceptedClasses.Length()>0);
 }
 
+// //_____________________________________________________________________________
+// Bool_t AliAnalysisMuMuEventCutter::SelectTriggerClassWithInputHandler(const AliInputEventHandler& eventHandler,
+//                                                       TString& acceptedClasses) const
+// {
+//   /// Forward the trigger class selection to MuonEventCuts::GetSelectedTrigClassesInEvent
+//   acceptedClasses = "";
+//
+//   TIter next(MuonEventCuts()->GetSelectedTrigClassesInEvent(&eventHandler));
+//   TObjString* str;
+//
+//   while ( ( str = static_cast<TObjString*>(next()) ) )
+//   {
+//     acceptedClasses += str->String();
+//     acceptedClasses += " ";
+//   }
+//   return (acceptedClasses.Length()>0);
+// }
+
 //_____________________________________________________________________________
-Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelected(const AliInputEventHandler& eventHandler) const
+Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelectedANY(const AliInputEventHandler& eventHandler) const
 {
   /// Whether or not the event is physics selected
   return const_cast<AliInputEventHandler&>(eventHandler).IsEventSelected() & AliVEvent::kAny;
 }
 
+Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelectedINT7(const AliInputEventHandler& eventHandler) const
+{
+  /// Whether or not the event is physics selected
+  return const_cast<AliInputEventHandler&>(eventHandler).IsEventSelected() & AliVEvent::kINT7;
+}
+
+Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelectedINT8(const AliInputEventHandler& eventHandler) const
+{
+  /// Whether or not the event is physics selected
+  return const_cast<AliInputEventHandler&>(eventHandler).IsEventSelected() & AliVEvent::kINT8;
+}
+
+Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelectedMUL(const AliInputEventHandler& eventHandler) const
+{
+  /// Whether or not the event is physics selected
+  return const_cast<AliInputEventHandler&>(eventHandler).IsEventSelected() & AliVEvent::kMuonUnlikePB;
+}
+
+Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelectedMUSPB(const AliInputEventHandler& eventHandler) const
+{
+  /// Whether or not the event is physics selected
+  return const_cast<AliInputEventHandler&>(eventHandler).IsEventSelected() & AliVEvent::kMUSPB;
+}
+
+Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelectedMSL(const AliInputEventHandler& eventHandler) const
+{
+  /// Whether or not the event is physics selected
+  return const_cast<AliInputEventHandler&>(eventHandler).IsEventSelected() & AliVEvent::kMuonSingleLowPt7;
+}
+
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMuEventCutter::IsPhysicsSelectedVDM(const AliVEvent& event) const
 {
   // cut used in vdM scans
-  
+
+  printf("here !\n");
   AliVVZERO* vzero = event.GetVZEROData();
-  
+
   if (vzero)
   {
     Float_t v0a = vzero->GetV0ATime();
     Float_t v0c = vzero->GetV0CTime();
-    
+
     Float_t v0diff = v0a-v0c;
     Float_t v0sum = v0a+v0c;
-    
-    if ( ( v0sum > 10.5 && v0sum < 18 ) && ( v0diff > 4 && v0diff < 12 ) )
+
+    if ( ( v0sum > 11.5 && v0sum < 17.5 ) && ( v0diff > 5.5 && v0diff < 11.5 ) )
     {
       return kTRUE;
     }
@@ -190,30 +239,30 @@ Bool_t AliAnalysisMuMuEventCutter::IsMCEventNSD(const AliVEvent& event) const
   // Check for headers
   //FIXME: For now this is only valid for DPMJET
   //FIXME: working only on AODs
-  
+
   if ( static_cast<const AliVEvent*>(&event)->IsA() == AliESDEvent::Class() )
   {
     AliWarning("Not implemented for ESDs yet");
     return kFALSE;
   }
-  
+
   const AliAODEvent* eventAOD = static_cast<const AliAODEvent*>(&event);
-  
+
   AliAODMCHeader* mcHeader = static_cast<AliAODMCHeader*>(eventAOD->FindListObject(AliAODMCHeader::StdBranchName()));
-  
+
   if(mcHeader)
   {
     TList* lheaders = mcHeader->GetCocktailHeaders();
-    
+
     if ( lheaders->GetEntries() > 1 ) AliWarning("There is more than one header: The simulation is a cocktail");
-    
+
     AliGenEventHeader* mcGenH(0x0);
     AliGenHijingEventHeader* hHijing(0x0);
     AliGenDPMjetEventHeader* hDpmJet(0x0);
     TIter next(lheaders); // Get the iterator on the list of cocktail headers
 
 //    lheaders->Print();
-    
+
     while ( (mcGenH = static_cast<AliGenEventHeader*>(next())) ) // Loop over the cocktail headers
     {
 //      std::cout << mcGenH->GetName() << std::endl;
@@ -226,7 +275,7 @@ Bool_t AliAnalysisMuMuEventCutter::IsMCEventNSD(const AliVEvent& event) const
         hDpmJet = static_cast<AliGenDPMjetEventHeader*>(mcGenH);
       }
     } // End of loop over cocktail headers
-    
+
     if ( !hDpmJet && !hHijing )
     {
       AliError("No GenHeader found");
@@ -237,7 +286,7 @@ Bool_t AliAnalysisMuMuEventCutter::IsMCEventNSD(const AliVEvent& event) const
       Int_t nsd1,nsd2,ndd;
       Int_t npProj = hDpmJet->ProjectileParticipants();
       Int_t npTgt = hDpmJet->TargetParticipants();
-      
+
       // In p-Pb collisions: npProj >=1 (Pb) and npTgt = 1 (p) ->We have to use npProj
       // In Pb-p collisions: npProj =1 (p) and npTgt >= 1 (Pb) ->We have to use npTgt
       if ( npTgt >= npProj ) npProj = npTgt; // In order to use the correct value to compare to nsd1 and nsd2 (If in Pb-p we use npProj(=1), as soon as we have 1 nucleon difracted the event is flagged as SD, which is not correct)
@@ -245,7 +294,7 @@ Bool_t AliAnalysisMuMuEventCutter::IsMCEventNSD(const AliVEvent& event) const
 //      Int_t pType = hDpmJet->ProcessType();
 //      std::cout << "Nof Proj part = " << npProj << " ; Nof Tgt part = " << npTgt << std::endl;
       hDpmJet->GetNDiffractive(nsd1,nsd2,ndd);
-      
+
       if (ndd==0 && (npProj==nsd1 || npProj==nsd2))
       {
         return kFALSE; // reject SD
@@ -271,7 +320,7 @@ Bool_t AliAnalysisMuMuEventCutter::IsMCEventNSD(const AliVEvent& event) const
 Bool_t AliAnalysisMuMuEventCutter::IsAbsZBelowValue(const AliVEvent& event, const Double_t& z) const
 {
   // Checks if the absolute value of the Z component of the primary vertex is below a certain value
-  
+
   const AliVVertex* vertex = event.GetPrimaryVertex();
   return (TMath::Abs(vertex->GetZ())<=z);
 }
@@ -280,23 +329,23 @@ Bool_t AliAnalysisMuMuEventCutter::IsAbsZBelowValue(const AliVEvent& event, cons
 Bool_t AliAnalysisMuMuEventCutter::IsAbsZSPDBelowValue(const AliVEvent& event, const Double_t& z) const
 {
   // Checks if the absolute value of the SPD Z component of the given vertex is below a certain value
-  
+
   Double_t SPDzv(0.);
   Bool_t vertexFound(kFALSE);
-  
+
   const AliVVertex* SPDVertex = event.GetPrimaryVertexSPD();
   if ( SPDVertex )
   {
     vertexFound = kTRUE;
     SPDzv = SPDVertex->GetZ();
   }
-  
+
   if ( !vertexFound )
   {
     AliError("SPD |z| cut requested and no SPD vertex found in the event");
     return kFALSE;
   }
-  
+
   else return (TMath::Abs(SPDzv)<z);
 }
 
@@ -305,16 +354,16 @@ Bool_t AliAnalysisMuMuEventCutter::IsAbsZSPDBelowValue(const AliVEvent& event, c
 Bool_t AliAnalysisMuMuEventCutter::IsSPDzVertexInRange(AliVEvent& event, const Double_t& zMin, const Double_t& zMax) const
 {
   /// Whether or not the SPD Z vertex is in the range [zMin,zMax[
-  
+
   const AliVVertex* SPDVertex = event.GetPrimaryVertexSPD();
-  
+
   if ( !SPDVertex )
   {
     AliError("Cut on SPD z Vertex requested for an event with no SPD vertex info");
     return kFALSE;
   }
   Double_t zV = SPDVertex->GetZ();
-  
+
   if ( zV >= zMin && zV < zMax ) return kTRUE;
   else return kFALSE;
 }
@@ -335,9 +384,9 @@ Bool_t AliAnalysisMuMuEventCutter::IsSPDzQA(const AliVEvent& event, /*const AliV
 {
   // Checks if the value of the Z component of the given vertex fullfills the quality assurance condition
   Double_t zRes,zvertex;
-  
+
   const AliVVertex* vertex = event.GetPrimaryVertex();
-  
+
   if ( vertex )
   {
     const AliVVertex* SPDVertex = event.GetPrimaryVertexSPD();
@@ -376,31 +425,31 @@ Bool_t AliAnalysisMuMuEventCutter::IsSPDzQA(const AliVEvent& event, /*const AliV
 Bool_t AliAnalysisMuMuEventCutter::IsMeandNchdEtaInRange(AliVEvent& event, const Double_t& dNchdEtaMin, const Double_t& dNchdEtaMax) const
 {
   TList* nchList = static_cast<TList*>(event.FindListObject("NCH"));
-  
+
   if (!nchList || nchList->IsEmpty())
   {
     AliFatal("No NCH information found in event. Nch analysis MUST be executed to apply a NCH cut");
     return kFALSE;
   }
-  
+
   Int_t i(0);
   Bool_t parFound(kFALSE);
   TParameter<Double_t>* eventdNchdEta;
-  
+
   while ( !parFound )
   {
     while ( nchList->At(i)->IsA() != TParameter<Double_t>::Class() )
     {
       i++;
     }
-    
+
     eventdNchdEta = static_cast<TParameter<Double_t>*>(nchList->At(i));
-    
+
     if ( TString(eventdNchdEta->GetName()).Contains("MeandNchdEta") ) parFound = kTRUE;
   }
-  
+
   Double_t meandNchdEta = eventdNchdEta->GetVal();
-  
+
   if ( meandNchdEta >= dNchdEtaMin && meandNchdEta < dNchdEtaMax ) return kTRUE;
   else return kFALSE;
 }
@@ -410,7 +459,7 @@ AliMuonEventCuts*
 AliAnalysisMuMuEventCutter::MuonEventCuts() const
 {
   /// Return the single instance of AliMuonEventCuts object we're using
-  
+
   if (!fMuonEventCuts)
   {
     fMuonEventCuts = new AliMuonEventCuts("EventCut","");
@@ -454,7 +503,7 @@ void AliAnalysisMuMuEventCutter::NameOfIsMeandNchdEtaInRange(TString& name, cons
 Bool_t AliAnalysisMuMuEventCutter::IsTZEROPileUp(const AliVEvent& event) const
 {
   Bool_t pileupFlag(kFALSE);
-  
+
   if ( event.IsA() == AliESDEvent::Class() )
   {
     const AliESDTZERO* tzero = static_cast<AliESDEvent&>(const_cast<AliVEvent&>(event)).GetESDTZERO();
diff --git a/PWG/muon/AliAnalysisMuMuEventCutter.h b/PWG/muon/AliAnalysisMuMuEventCutter.h
index 342d383..8284023 100644
--- a/PWG/muon/AliAnalysisMuMuEventCutter.h
+++ b/PWG/muon/AliAnalysisMuMuEventCutter.h
@@ -27,56 +27,73 @@ public:
   AliAnalysisMuMuEventCutter(const char* triggerClassesToConsider="", const char* inputs="");
   AliAnalysisMuMuEventCutter(TList* triggerClassesToConsider, TList* triggerInputsMap);
   virtual ~AliAnalysisMuMuEventCutter();
-  
+
   Bool_t SelectTriggerClass(const TString& firedTriggerClasses, TString& acceptedClasses,
                             UInt_t L0, UInt_t L1, UInt_t L2) const;
-  
+
+  // Bool_t SelectTriggerClassWithInputHandler(const AliInputEventHandler& eventHandler,TString& acceptedClasses) const;
+
   Bool_t IsTrue(const AliVEvent& /*event*/) const { return kTRUE; }
   void NameOfIsTrue(TString& name) const { name="ALL"; }
 
   Bool_t IsFalse(const AliVEvent& /*event*/) const { return kFALSE; }
   void NameOfIsFalse(TString& name) const { name="NONE"; }
 
-  Bool_t IsPhysicsSelected(const AliInputEventHandler& eventHandler) const;
-  void NameOfIsPhysicsSelected(TString& name) const { name="PSALL"; }
+  Bool_t IsPhysicsSelectedANY(const AliInputEventHandler& eventHandler) const;
+  void NameOfIsPhysicsSelectedANY(TString& name) const { name="PSANY"; }
+
+  Bool_t IsPhysicsSelectedINT7(const AliInputEventHandler& eventHandler) const;
+  void NameOfIsPhysicsSelectedINT7(TString& name) const { name="PSINT7"; }
+
+  Bool_t IsPhysicsSelectedINT8(const AliInputEventHandler& eventHandler) const;
+  void NameOfIsPhysicsSelectedINT8(TString& name) const { name="PSINT8"; }
+
+  Bool_t IsPhysicsSelectedMUL(const AliInputEventHandler& eventHandler) const;
+  void NameOfIsPhysicsSelectedMUL(TString& name) const { name="PSMUL"; }
+
+  Bool_t IsPhysicsSelectedMUSPB(const AliInputEventHandler& eventHandler) const;
+  void NameOfIsPhysicsSelectedMUSPB(TString& name) const { name="PSMUSPB"; }
+
+  Bool_t IsPhysicsSelectedMSL(const AliInputEventHandler& eventHandler) const;
+  void NameOfIsPhysicsSelectedMSL(TString& name) const { name="PSMSL"; }
 
   Bool_t IsPhysicsSelectedVDM(const AliVEvent& event) const;
   void NameOfIsPhysicsSelectedVDM(TString& name) const { name="VDM"; }
-  
+
   Bool_t IsMCEventNSD(const AliVEvent& event) const;
   void NameOfIsMCEventNSD(TString& name) const { name="NSD"; }
 
   Bool_t IsAbsZBelowValue(const AliVEvent& event, const Double_t& z) const;
   void NameOfIsAbsZBelowValue(TString& name, const Double_t& z) const;
-  
+
   Bool_t IsAbsZSPDBelowValue(const AliVEvent& event, const Double_t& z) const;
   void NameOfIsAbsZSPDBelowValue(TString& name, const Double_t& z) const;
-  
+
   Bool_t IsSPDzVertexInRange(AliVEvent& event, const Double_t& zMin, const Double_t& zMax) const;
   void NameOfIsSPDzVertexInRange(TString& name, const Double_t& zMin, const Double_t& zMax) const;
-  
+
   Bool_t IsSPDzQA(const AliVEvent& event/*, const AliVVertex& vertex2Test*/, const Double_t& zResCut, const Double_t& zDifCut) const;
   void NameOfIsSPDzQA(TString& name, const Double_t& zResCut, const Double_t& zDifCut) const;
-  
+
   Bool_t HasSPDVertex(AliVEvent& event) const;
   void NameOfHasSPDVertex(TString& name) const { name = "HASSPD"; }
-  
+
   Bool_t IsMeandNchdEtaInRange(AliVEvent& event, const Double_t& dNchdEtaMin, const Double_t& dNchdEtaMax) const;
   void NameOfIsMeandNchdEtaInRange(TString& name, const Double_t& dNchdEtaMin, const Double_t& dNchdEtaMax) const;
-  
+
   Bool_t IsTZEROPileUp(const AliVEvent& event) const;
   void NameOfIsTZEROPileUp(TString& name) const { name="TZEROPILEUP"; }
-  
+
   AliMuonEventCuts* MuonEventCuts() const;
-  
+
 //  enum EEventCut
 //  {
 //    kEventIR2PILEUP     = BIT( 6), /// events with pile-up (using AliAnalysisUtils::IsOutOfBunchPileUp)
-//    
+//
 //    kEventGOODVERTEX    = BIT(10), /// events with a good vertex
 //    kEventZPOS          = BIT(14), /// events with z > 0
 //    kEventZNEG          = BIT(15), /// events with z < 0
-//    
+//
 //    kEventTRKLETA1      = BIT(20), /// event with at least one tracklet in |eta| < fTrackletEtaCutValue[0]
 
 //    kEvent0TVX          = BIT(31), /// events with 0TVX L0 input
@@ -84,16 +101,16 @@ public:
 //    kEvent0SM2          = BIT(33), /// events with 0SM2 L0 input
 //    kEvent0MSL          = BIT(34), /// events with 0MSL input
 //  };
-  
+
 private:
-  
+
   /// not implemented on purpose
   AliAnalysisMuMuEventCutter& operator=(const AliAnalysisMuMuEventCutter& rhs);
   /// not implemented on purpose
   AliAnalysisMuMuEventCutter(const AliAnalysisMuMuEventCutter& rhs);
-  
+
   mutable AliMuonEventCuts* fMuonEventCuts; // common cuts for muon events (from Diego)
-  
+
   ClassDef(AliAnalysisMuMuEventCutter,1) // default event cutters for AliAnalysisTaskMuMu
 };
 
diff --git a/PWG/muon/AliAnalysisMuMuMinv.cxx b/PWG/muon/AliAnalysisMuMuMinv.cxx
index d13dcb1..72f9bb0 100644
--- a/PWG/muon/AliAnalysisMuMuMinv.cxx
+++ b/PWG/muon/AliAnalysisMuMuMinv.cxx
@@ -272,9 +272,10 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
                                             const AliVParticle& tracki,
                                             const AliVParticle& trackj)
 {
-  /// Fill histograms for unlike-sign muon pairs for :
-  ///   - Reconstructed pairs (both data and MC)
-  ///   - input MC particle if running on MC
+  /// Fill histograms for unlike-sign muon pairs for reconstructed pairs.
+  /// Two types of recontructed histograms are filled for MC :
+  ///   - For all the tracks (like for Data, stored in the usual part of the histogram collection)
+  ///   - Only for MC tracks with MC label, meaning remove contrubution from any particule not comming from an initial simulatied particle ( usefull when running on embedding).
   /// A weight is also applied if specified (see inside)
   
   // Usual cuts
@@ -282,6 +283,10 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
   if (!AliAnalysisMuonUtility::IsMuonTrack(&tracki) ) return;
   if (!AliAnalysisMuonUtility::IsMuonTrack(&trackj) ) return;
   
+  // Make sure we take tracks from J/psi when running on embedding simulation
+  if (HasMC() && tracki.GetLabel() < 0 ) return;
+  if (HasMC() && trackj.GetLabel() < 0 ) return;
+  
   TLorentzVector pi(tracki.Px(),tracki.Py(),tracki.Pz(),
                     TMath::Sqrt(AliAnalysisMuonUtility::MuonMass2()+tracki.P()*tracki.P()));
   
@@ -290,58 +295,34 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
   
   pair4Momentum += pi;
   
-  ////  if (!IsHistogramDisabled("Chi12"))
-  ////  {
-  ////    proxy->Histo("Chi12")
-  ////    ->Fill(
-  ////           AliAnalysisMuonUtility::GetChi2perNDFtracker(&tracki),
-  ////           AliAnalysisMuonUtility::GetChi2perNDFtracker(&trackj));
-  ////  }
-  ////
-  ////  if (!IsHistogramDisabled("Rabs12"))
-  ////  {
-  ////    proxy->Histo("Rabs12")
-  ////    ->Fill(AliAnalysisMuonUtility::GetRabs(&tracki),
-  ////           AliAnalysisMuonUtility::GetRabs(&trackj));
-  ////  }
-  
-  // ---- Compute weighted histo for data ----
+  // Create proxy in AliMergeableCollection
   AliMergeableCollectionProxy* proxy = HistogramCollection()->CreateProxy(BuildPath(eventSelection,triggerClassName,centrality,pairCutName));
   
-  // Select weight acooring to <systLevel>
+  // Select weight accoring to <systLevel> (see constructor)
   Double_t inputWeight = WeightDistribution(pair4Momentum.Pt(),pair4Momentum.Rapidity());
   
-  if ( !IsHistogramDisabled("Pt") )
-  {
-    proxy->Histo("Pt")->Fill(pair4Momentum.Pt(),inputWeight);
-  }
-  if ( !IsHistogramDisabled("Y") )
-  {
-    proxy->Histo("Y")->Fill(pair4Momentum.Rapidity(),inputWeight);
-  }
-  if ( !IsHistogramDisabled("Eta") )
-  {
-    proxy->Histo("Eta")->Fill(pair4Momentum.Eta());
-  }
-  
+  // Fill Pt,Y,Eta histo
+  if ( !IsHistogramDisabled("Pt") )  proxy->Histo("Pt")->Fill(pair4Momentum.Pt(),inputWeight);
+  if ( !IsHistogramDisabled("Y") )   proxy->Histo("Y")->Fill(pair4Momentum.Rapidity(),inputWeight);
+  if ( !IsHistogramDisabled("Eta") ) proxy->Histo("Eta")->Fill(pair4Momentum.Eta());
+
   TLorentzVector* pair4MomentumMC(0x0);
   
   Double_t inputWeightMC(1.);
   AliMergeableCollectionProxy* mcProxy(0x0);
   
-  if ( HasMC() )
-  {
+  // Fill Pt,Y,Eta and PtRecVsSim histo for reconstructed MC particles
+  if ( HasMC() ){
+
+    // Create proxy for MC
     mcProxy = HistogramCollection()->CreateProxy(BuildMCPath(eventSelection,triggerClassName,centrality,pairCutName));
 
-    Int_t labeli = tracki.GetLabel();
-    Int_t labelj = trackj.GetLabel();
+    Int_t labeli = tracki.GetLabel(); // really usefull ??
+    Int_t labelj = trackj.GetLabel(); // really usefull ??
     
-    if ( labeli < 0 || labelj < 0 )
-    {
-      AliError("Got negative labels!");
-    }
-    else
-    {
+    if ( labeli < 0 || labelj < 0 )AliError("Got negative labels!");
+    else{
+
       AliVParticle* mcTracki = MCEvent()->GetTrack(labeli);
       AliVParticle* mcTrackj = MCEvent()->GetTrack(labelj);
       
@@ -353,93 +334,77 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
       mcpj += mcpi;
       
       inputWeightMC = WeightDistribution(mcpj.Pt(),mcpj.Rapidity());
-      
       proxy->Histo("PtRecVsSim")->Fill(mcpj.Pt(),pair4Momentum.Pt());
       
-      if ( !IsHistogramDisabled("Pt") )
-      {
-        mcProxy->Histo("Pt")->Fill(mcpj.Pt(),inputWeightMC);
-      }
-      if ( !IsHistogramDisabled("Y") )
-      {
-        mcProxy->Histo("Y")->Fill(mcpj.Rapidity(),inputWeightMC);
-      }
-      if ( !IsHistogramDisabled("Eta") )
-      {
-        mcProxy->Histo("Eta")->Fill(mcpj.Eta());
-      }
+      if ( !IsHistogramDisabled("Pt") )  mcProxy->Histo("Pt")->Fill(mcpj.Pt(),inputWeightMC);
+      if ( !IsHistogramDisabled("Y") )   mcProxy->Histo("Y")->Fill(mcpj.Rapidity(),inputWeightMC);
+      if ( !IsHistogramDisabled("Eta") ) mcProxy->Histo("Eta")->Fill(mcpj.Eta());
+
       pair4MomentumMC = &mcpj;
     }
   }
   
-  // --- Fill Inv. Mass histo. (can be weighted) ----
+  // Fill Inv. Mass histo. (can be weighted)
   TIter nextBin(fBinsToFill);
   AliAnalysisMuMuBinning::Range* r;
   
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
-  {
+  // Loop over all bin ranges 
+  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ){
+    
+    // Flag for cuts and ranges
     Bool_t ok(kFALSE);
     Bool_t okMC(kFALSE);
     
-    if ( r->IsIntegrated() )
-    {
+    //Fully integrated case
+    if ( r->IsIntegrated() ){
+      
       ok = kTRUE;
       if ( pair4MomentumMC ) okMC = kTRUE;
       
-      //_________________________
       TH1* h(0x0);
-      if ( pair4Momentum.M() >= 2.9 && pair4Momentum.M() <= 3.3 )
-      {
+
+      // Fill NchForJpsi histo
+      if ( pair4Momentum.M() >= 2.9 && pair4Momentum.M() <= 3.3 ){
+        
         h = proxy->Histo("NchForJpsi");
         
         Double_t ntrcorr = (-1.);
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        
+        if (list){
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
-            i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
+          while ( i < list->GetEntries() - 1 && !parFound ){
             
+            i++;
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++;// In case there is a diferent object, just to skip it
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("NtrCorr") )
-            {
+            if ( TString(p->GetName()).Contains("NtrCorr") ){
               parFound = kTRUE;
               ntrcorr = p->GetVal();
             }
           }
         }
-        
         h->Fill(ntrcorr);
-      }
-      else if ( pair4Momentum.M() >= 3.6 && pair4Momentum.M() <= 3.9)
-      {
-        h = proxy->Histo("NchForPsiP");
+      } 
+      else if ( pair4Momentum.M() >= 3.6 && pair4Momentum.M() <= 3.9){
         
+        h = proxy->Histo("NchForPsiP");
         Double_t ntrcorr = (-1.);
+        
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
+
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
+          while ( i < list->GetEntries() - 1 && !parFound ){
             i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
-            
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++; // In case there is a diferent object, just to skip it
+
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("NtrCorr") )
-            {
+            if ( TString(p->GetName()).Contains("NtrCorr") ){
               parFound = kTRUE;
               ntrcorr = p->GetVal();
             }
@@ -448,217 +413,172 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
         h->Fill(ntrcorr);
       }
     }
-    else if ( r->Is2D() )
-    {
-      if ( r->AsString().BeginsWith("PTVSY") )
-      {
+    // 2D Binning
+    else if ( r->Is2D() ){
+      if ( r->AsString().BeginsWith("PTVSY") ){
         ok = r->IsInRange(pair4Momentum.Rapidity(),pair4Momentum.Pt());
         if ( pair4MomentumMC ) okMC = r->IsInRange(pair4MomentumMC->Rapidity(),pair4MomentumMC->Pt());
       }
-      else if ( r->AsString().BeginsWith("YVSPT") )
-      {
+      else if ( r->AsString().BeginsWith("YVSPT") ){
         ok = r->IsInRange(pair4Momentum.Pt(),pair4Momentum.Rapidity());
         if ( pair4MomentumMC ) okMC = r->IsInRange(pair4MomentumMC->Pt(),pair4MomentumMC->Rapidity());
       }
-      else if ( r->Quantity() == "NTRCORRPT" )
-      {
+      else if ( r->Quantity() == "NTRCORRPT" ){
+        
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
+
+          while ( i < list->GetEntries() - 1 && !parFound ){
             i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
-            
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++;// In case there is a diferent object, just to skip it
+
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("NtrCorr") )
-            {
+            if ( TString(p->GetName()).Contains("NtrCorr") ){
               parFound = kTRUE;
               ok = r->IsInRange(p->GetVal(),pair4Momentum.Pt());
             }
           }
         }
-        
       }
-      else if ( r->Quantity() == "NTRCORRY" )
-      {
+      else if ( r->Quantity() == "NTRCORRY" ){
+        
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
+          while ( i < list->GetEntries() - 1 && !parFound ){
+
             i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
-            
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++;// In case there is a diferent object, just to skip it
+
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("NtrCorr") )
-            {
+            if ( TString(p->GetName()).Contains("NtrCorr") ){
               parFound = kTRUE;
               ok = r->IsInRange(p->GetVal(),pair4Momentum.Rapidity());
             }
           }
         }
-        
-      }
-      else
-      {
-        AliError(Form("Don't know how to deal with 2D bin %s",r->AsString().Data()));
       }
+      else AliError(Form("Don't know how to deal with 2D bin %s",r->AsString().Data()));
     }
-    else
-    {
-      if ( r->Quantity() == "PT" )
-      {
+    // The rest
+    else{
+      
+      if ( r->Quantity() == "PT" ){
         ok = r->IsInRange(pair4Momentum.Pt());
         if ( pair4MomentumMC ) okMC = r->IsInRange(pair4MomentumMC->Pt());
       }
-      else if ( r->Quantity() == "Y" )
-      {
+      else if ( r->Quantity() == "Y" ){
         ok = r->IsInRange(pair4Momentum.Rapidity());
         if ( pair4MomentumMC ) okMC = r->IsInRange(pair4MomentumMC->Rapidity());
       }
-      else if ( r->Quantity() == "PHI" )
-      {
+      else if ( r->Quantity() == "PHI" ){
         ok = r->IsInRange(pair4Momentum.Phi());
         if ( pair4MomentumMC ) okMC = r->IsInRange(pair4MomentumMC->Phi());
       }
-      else if ( r->Quantity() == "DNCHDETA" )
-      {
+      else if ( r->Quantity() == "DNCHDETA" ){
+        
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
+          while ( i < list->GetEntries() - 1 && !parFound ){
+
             i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
-            
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++;// In case there is a diferent object, just to skip it
+
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("dNchdEta") )
-            {
+            if ( TString(p->GetName()).Contains("dNchdEta") ){
               parFound = kTRUE;
               ok = r->IsInRange(p->GetVal());
             }
           }
         }
-        
       }
-      else if ( r->Quantity() == "NTRCORR" || r->Quantity() == "RELNTRCORR" )
-      {
+      else if ( r->Quantity() == "NTRCORR" || r->Quantity() == "RELNTRCORR" ){
+        
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
+          
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
+          while ( i < list->GetEntries() - 1 && !parFound ){
+            
             i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++;// In case there is a diferent object, just to skip it
             
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("NtrCorr") )
-            {
+            if ( TString(p->GetName()).Contains("NtrCorr") ){
               parFound = kTRUE;
               if ( r->Quantity() == "NTRCORR" ) ok = r->IsInRange(p->GetVal());
               else ok = r->IsInRange(p->GetVal()/5.97);
             }
           }
         }
-        
       }
-      else if ( r->Quantity() == "V0ACORR" )
-      {
+      else if ( r->Quantity() == "V0ACORR" ){
+
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
+          
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
-            i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
+          while ( i < list->GetEntries() - 1 && !parFound ){
             
+            i++;
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++;// In case there is a diferent object, just to skip it
+
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("V0ACorr") )
-            {
+            if ( TString(p->GetName()).Contains("V0ACorr") ){
               parFound = kTRUE;
               ok = r->IsInRange(p->GetVal());
             }
           }
         }
-        
       }
-      else if ( r->Quantity() == "V0CCORR" )
-      {
+      else if ( r->Quantity() == "V0CCORR" ){
+        
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
+
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
+          while ( i < list->GetEntries() - 1 && !parFound ){
+
             i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
-            
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 )  i++;// In case there is a diferent object, just to skip it
+
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("V0CCorr") )
-            {
+            if ( TString(p->GetName()).Contains("V0CCorr") ){
               parFound = kTRUE;
               ok = r->IsInRange(p->GetVal());
             }
           }
-        }
-        //          else AliFatal("No ntrcorr info on Event");
-        
+        }        
       }
-      else if ( r->Quantity() == "V0MCORR" )
-      {
+      else if ( r->Quantity() == "V0MCORR" ){
+
         TList* list = static_cast<TList*>(Event()->FindListObject("NCH"));
-        if (list)
-        {
+        if (list){
+
           Int_t i(-1);
           Bool_t parFound(kFALSE);
-          while ( i < list->GetEntries() - 1 && !parFound )
-          {
-            i++;
-            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) // In case there is a diferent object, just to skip it
-            {
-              i++;
-            }
+          while ( i < list->GetEntries() - 1 && !parFound ){
             
+            i++;
+            while ( list->At(i)->IsA() != TParameter<Double_t>::Class() && i < list->GetEntries() - 1 ) i++;// In case there is a diferent object, just to skip it
+
             TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(list->At(i));
             
-            if ( TString(p->GetName()).Contains("V0MCorr") )
-            {
+            if ( TString(p->GetName()).Contains("V0MCorr") ){
               parFound = kTRUE;
               ok = r->IsInRange(p->GetVal());
             }
@@ -666,164 +586,102 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
         }
       }
     }
-    
-    if ( ok || okMC ) // Pair pass all conditions, either MC or not
-    {
+
+    // Pair pass all conditions, either MC or not, and fill Minv Histogrames
+    if ( ok || okMC ){
+      
       TString minvName = GetMinvHistoName(*r,kFALSE);
       
-      if (!IsHistogramDisabled(minvName.Data()))
-      {
+      if (!IsHistogramDisabled(minvName.Data())){
+        
         TH1* h(0x0);
-        if ( ok )
-        { 
+
+        if ( ok ){ 
           h = proxy->Histo(minvName.Data());
-          
           if (!h) AliError(Form("Could not get %s",minvName.Data()));
-          
           else h->Fill(pair4Momentum.M(),inputWeight);
         }
-        if( okMC )
-        { 
+        
+        if( okMC ){ 
           h = mcProxy->Histo(minvName.Data());
-          
           if (!h) AliError(Form("Could not get MC %s",minvName.Data()));
-          
           else h->Fill(pair4MomentumMC->M(),inputWeightMC); 
         }
         
-        if ( fcomputeMeanPt )
-        {
+        // Fille Mean pT
+        if ( fcomputeMeanPt ){
           TString hprofName("");
           
-          if ( ok )
-          {
+          if ( ok ){
             hprofName= Form("MeanPtVs%s",minvName.Data());
-            
             TProfile* hprof = Prof(eventSelection,triggerClassName,centrality,pairCutName,hprofName.Data());
-            
-            if ( !hprof )
-            {
-              AliError(Form("Could not get %s",hprofName.Data()));
-            }
-            else
-            {
-              //              hprof->Approximate(); //I dont think its necessary here
-              hprof->Fill(pair4Momentum.M(),pair4Momentum.Pt(),inputWeight);
-            }
+            if ( !hprof )AliError(Form("Could not get %s",hprofName.Data()));
+            else hprof->Fill(pair4Momentum.M(),pair4Momentum.Pt(),inputWeight);
           }
-          if ( okMC )
-          {
+          
+          if ( okMC ){
             hprofName= Form("MeanPtVs%s",minvName.Data());
-            
             TProfile* hprof = MCProf(eventSelection,triggerClassName,centrality,pairCutName,hprofName.Data());
-            
-            if ( !hprof )
-            {
-              AliError(Form("Could not get MC %s",hprofName.Data()));
-            }
-            
-            else
-            {
-              //              hprof->Approximate(); //I dont think its necessary here
-              hprof->Fill(pair4MomentumMC->M(),pair4MomentumMC->Pt(),inputWeightMC);
-            }
+            if ( !hprof )AliError(Form("Could not get MC %s",hprofName.Data()));
+            else hprof->Fill(pair4MomentumMC->M(),pair4MomentumMC->Pt(),inputWeightMC);
           }
         }
       }
       
-      if ( ShouldCorrectDimuonForAccEff() )
-      {
+      if ( ShouldCorrectDimuonForAccEff() ){
+        
         Double_t AccxEff(0);
         Bool_t okAccEff(kFALSE);
-        if ( ok )
-        {
+
+        if ( ok ){
           AccxEff = GetAccxEff(pair4Momentum.Pt(),pair4Momentum.Rapidity());
-          if ( AccxEff <= 0.0 )
-          {
-            AliError(Form("AccxEff < 0 for pt = %f & y = %f ",pair4Momentum.Pt(),pair4Momentum.Rapidity()));
-            //            continue;
-          }
+          if ( AccxEff <= 0.0 ) AliError(Form("AccxEff < 0 for pt = %f & y = %f ",pair4Momentum.Pt(),pair4Momentum.Rapidity()));
           else okAccEff = kTRUE;
         }
         
         Double_t AccxEffMC(0);
         Bool_t okAccEffMC(kFALSE);
-        if ( okMC )
-        {
+        
+        if ( okMC ){
           AccxEffMC= GetAccxEff(pair4MomentumMC->Pt(),pair4MomentumMC->Rapidity());
-          if ( AccxEffMC <= 0.0 )
-          {
-            AliError(Form("AccxEff < 0 for MC pair with pt = %f & y = %f ",pair4MomentumMC->Pt(),pair4MomentumMC->Rapidity()));
-            //            continue;
-          }
+          if ( AccxEffMC <= 0.0 ) AliError(Form("AccxEff < 0 for MC pair with pt = %f & y = %f ",pair4MomentumMC->Pt(),pair4MomentumMC->Rapidity()));
           else okAccEffMC = kTRUE;
         }
         
         minvName = GetMinvHistoName(*r,kTRUE);
         
-        if (!IsHistogramDisabled(minvName.Data()))
-        {
+        if (!IsHistogramDisabled(minvName.Data())){
+
           TH1* hCorr = proxy->Histo(minvName.Data());
           
-          if (!hCorr)
-          {
-            AliError(Form("Could not get %sr",minvName.Data()));
-          }
-          
-          else  if ( okAccEff ) hCorr->Fill(pair4Momentum.M(),inputWeight/AccxEff);
+          if (!hCorr) AliError(Form("Could not get %sr",minvName.Data()));
+          else if ( okAccEff ) hCorr->Fill(pair4Momentum.M(),inputWeight/AccxEff);
           
-          if( okAccEffMC )
-          {
-            hCorr = mcProxy->Histo(minvName.Data());
-            
-            if (!hCorr)
-            {
-              AliError(Form("Could not get MC %s",minvName.Data()));
-              //continue;
-            }
+          if( okAccEffMC ){
+            hCorr = mcProxy->Histo(minvName.Data());        
+            if (!hCorr) AliError(Form("Could not get MC %s",minvName.Data()));
             else hCorr->Fill(pair4MomentumMC->M(),inputWeightMC/AccxEffMC);
           }
           
-          if ( fcomputeMeanPt )
-          {
+          if ( fcomputeMeanPt ){
+
             TString hprofCorrName("");
-            if( ok )
-            {
+            
+            if( ok ){
               hprofCorrName = Form("MeanPtVs%s",minvName.Data());
-              
               TProfile* hprofCorr = Prof(eventSelection,triggerClassName,centrality,pairCutName,hprofCorrName.Data());
-              
-              if ( !hprofCorr )
-              {
-                AliError(Form("Could not get %s",hprofCorrName.Data()));
-              }
-              else if ( okAccEff )
-              {
-                //                hprofCorr->Approximate(); //I dont know if its necessary here
-                hprofCorr->Fill(pair4Momentum.M(),pair4Momentum.Pt(),inputWeight/AccxEff);
-              }
+              if ( !hprofCorr ) AliError(Form("Could not get %s",hprofCorrName.Data()));
+              else if ( okAccEff ) hprofCorr->Fill(pair4Momentum.M(),pair4Momentum.Pt(),inputWeight/AccxEff);
             }
-            if( okMC )
-            {
+            
+            if( okMC ){
               hprofCorrName = Form("MeanPtVs%s",minvName.Data());
-              
               TProfile* hprofCorr = MCProf(eventSelection,triggerClassName,centrality,pairCutName,hprofCorrName.Data());
-              
-              if ( !hprofCorr )
-              {
-                AliError(Form("Could not get MC %s",hprofCorrName.Data()));
-              }
-              else if ( okAccEffMC )
-              {
-                //                hprofCorr->Approximate(); //I dont know if its necessary here
-                hprofCorr->Fill(pair4MomentumMC->M(),pair4MomentumMC->Pt(),inputWeightMC/AccxEffMC);
-              }
+              if ( !hprofCorr ) AliError(Form("Could not get MC %s",hprofCorrName.Data()));
+              else if ( okAccEffMC )hprofCorr->Fill(pair4MomentumMC->M(),pair4MomentumMC->Pt(),inputWeightMC/AccxEffMC);
             }
-            
           }
-          
         }
-        
       }
     }
   }
@@ -835,7 +693,9 @@ void AliAnalysisMuMuMinv::FillHistosForPair(const char* eventSelection,
 //_____________________________________________________________________________
 void AliAnalysisMuMuMinv::FillHistosForMCEvent(const char* eventSelection,const char* triggerClassName,const char* centrality)
 {
-  // Fill the input Monte-Carlo histograms related to muons.
+  ///
+  /// Fill the input Monte-Carlo histograms related to the reconstructed muons.
+  /// 
   
   if ( !HasMC() ) return;
 
@@ -843,31 +703,35 @@ void AliAnalysisMuMuMinv::FillHistosForMCEvent(const char* eventSelection,const
   TString mcPath = BuildMCPath(eventSelection,triggerClassName,centrality); 
   AliMergeableCollectionProxy* mcProxy = HistogramCollection()->CreateProxy(mcPath);
 
+  // Create proxy to the Histogram Collection for input particles satisfying Y cut
   TString mcInYRangeProxyPath = mcPath;
   mcInYRangeProxyPath += "INYRANGE/";
   AliMergeableCollectionProxy* mcInYRangeProxy = HistogramCollection()->CreateProxy(mcInYRangeProxyPath);
   if(!mcInYRangeProxy) printf("Warning :  unable to create proxy for mcInYRangeProxy, will not be filled \n");
 
 
-  Int_t nMCTracks = MCEvent()->GetNumberOfTracks();
+  Int_t nMCTracks = MCEvent()->GetNumberOfTracks();// number of tracks in Event
 
   TIter nextBin(fBinsToFill);
   AliAnalysisMuMuBinning::Range* r;
 
-  for ( Int_t i = 0; i < nMCTracks; ++i )
-  {
+  // Loop over all events
+  for ( Int_t i = 0; i < nMCTracks; ++i ){
     AliVParticle* part = MCEvent()->GetTrack(i);// Get particle
     
-    if  (AliAnalysisMuonUtility::IsPrimary(part,MCEvent()) &&
-         part->GetMother()==-1)
-    {
-      Double_t inputWeight = WeightDistribution(part->Pt(),part->Y());// get the default WeightDistribution
+    // Select only primary particles
+    if  (AliAnalysisMuonUtility::IsPrimary(part,MCEvent()) && part->GetMother()==-1){ 
+      
+      // Get the default WeightDistribution
+      Double_t inputWeight = WeightDistribution(part->Pt(),part->Y());
+      
+      // Fill Pt, Y, Eta histos
       mcProxy->Histo("Pt")->Fill(part->Pt(),inputWeight);
       mcProxy->Histo("Y")->Fill(part->Y(),inputWeight);
       mcProxy->Histo("Eta")->Fill(part->Eta());
       
-      if ( part->Y() <= -2.5 && part->Y() >= -4.0 && mcInYRangeProxy )
-      {
+      // Fill Pt, Y, Eta histos if tracks rapidity in range
+      if ( part->Y() <= -2.5 && part->Y() >= -4.0 && mcInYRangeProxy ){
         mcInYRangeProxy->Histo("Pt")->Fill(part->Pt(),inputWeight);
         mcInYRangeProxy->Histo("Y")->Fill(part->Y(),inputWeight);
         mcInYRangeProxy->Histo("Eta")->Fill(part->Eta());
@@ -875,117 +739,68 @@ void AliAnalysisMuMuMinv::FillHistosForMCEvent(const char* eventSelection,const
       
       nextBin.Reset();
       
-      // Check which bins are in range
-      while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
-      {
+      // Loop on all range in order to fill Minv Histo
+      while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ){
+        
+        // Check if particles pass all the cuts for different bins
         Bool_t ok(kFALSE);
         
-        if ( r->IsIntegrated() )
-        {
-          ok = kTRUE;
-        }
-        else if ( r->Is2D() )
-        {
-          if ( r->AsString().BeginsWith("PTVSY") )
-          {
-            ok = r->IsInRange(part->Y(),part->Pt());
-          }
-          else if ( r->AsString().BeginsWith("YVSPT") )
-          {
-            ok = r->IsInRange(part->Pt(),part->Y());
-          }
-          else
-          {
-            AliError(Form("Don't know how to deal with 2D bin %s",r->AsString().Data()));
-          }
-        }
-        else
-        {
-          if ( r->Quantity() == "PT" )
-          {
-            ok = r->IsInRange(part->Pt());
-          }
-          else if ( r->Quantity() == "Y" )
-          {
-            ok = r->IsInRange(part->Y());
-          }
-          else if ( r->Quantity() == "PHI" )
-          {
-            ok = r->IsInRange(part->Phi());
-          }
+        if ( r->IsIntegrated() )ok = kTRUE;
+        // 2D Binning
+        else if ( r->Is2D() ){
+          if ( r->AsString().BeginsWith("PTVSY") )     ok = r->IsInRange(part->Y(),part->Pt());
+          else if ( r->AsString().BeginsWith("YVSPT") )ok = r->IsInRange(part->Pt(),part->Y());
+          else AliError(Form("Don't know how to deal with 2D bin %s",r->AsString().Data()));
+        } 
+        // 1D Binning
+        else {
+          if ( r->Quantity()      == "PT" ) ok = r->IsInRange(part->Pt());
+          else if ( r->Quantity() == "Y" )  ok = r->IsInRange(part->Y());
+          else if ( r->Quantity() == "PHI" )ok = r->IsInRange(part->Phi());
         }
         
-        // Fill histo if bin is in range
-        if ( ok )
-        {
+        // Fill Minv histo if bin is in range
+        if ( ok ){
           TString hname = GetMinvHistoName(*r,kFALSE);
           
-          if (!IsHistogramDisabled(hname.Data()))
-          {
-            
+          // Chek if histo disabled
+          if (!IsHistogramDisabled(hname.Data())){
             TH1* h = mcProxy->Histo(hname.Data());
-            
-            if (!h)
-            {
+            if (!h) {
               AliError(Form("Could not get /%s/%s/%s/%s/ %s",MCInputPrefix(),eventSelection,triggerClassName,centrality,hname.Data()));
               continue;
             }
-            
             h->Fill(part->M(),inputWeight);
-            
-            if ( part->Y() <= -2.5 && part->Y() >= -4.0 && mcInYRangeProxy  )
-            {
+
+            if ( part->Y() <= -2.5 && part->Y() >= -4.0 && mcInYRangeProxy  ){      
               h = mcInYRangeProxy->Histo(hname.Data());
-              if (!h)
-              {
+              if (!h){
                 AliError(Form("Could not get /%s/%s/%s/%s/INYRANGE %s",MCInputPrefix(),eventSelection,triggerClassName,centrality,hname.Data()));
                 continue;
               }
               h->Fill(part->M(),inputWeight);
             }
-            
           }
           
-          if ( fcomputeMeanPt )
-          {
-            TString hprofName= Form("MeanPtVs%s",hname.Data());
+          // Fill compute mean pt histo
+          if ( fcomputeMeanPt ){
             
-            TProfile* hprof = MCProf(eventSelection,triggerClassName,centrality,hprofName.Data());
+            TString hprofName = Form("MeanPtVs%s",hname.Data());
+            TProfile* hprof   = MCProf(eventSelection,triggerClassName,centrality,hprofName.Data());
             
-            if ( !hprof )
-            {
-              AliError(Form("Could not get %s",hprofName.Data()));
-            }
-            else
-            {
-              //              hprof->Approximate(); //I dont think its necessary here
-              hprof->Fill(part->M(),part->Pt(),inputWeight);
-            }
+            if ( !hprof )AliError(Form("Could not get %s",hprofName.Data()));
+            else hprof->Fill(part->M(),part->Pt(),inputWeight);
             
-            if ( part->Y() < -2.5 && part->Y() > -4.0 )
-            {
+            if ( part->Y() <= -2.5 && part->Y() >= -4.0 ){
               hprof = MCProf(eventSelection,triggerClassName,Form("%s/INYRANGE",centrality),hprofName.Data());
-              
-              if ( !hprof )
-              {
-                AliError(Form("Could not get %s",hprofName.Data()));
-              }
-              else
-              {
-                //              hprof->Approximate(); //I dont think its necessary here
-                hprof->Fill(part->M(),part->Pt(),inputWeight);
-              }
-              
+              if ( !hprof )AliError(Form("Could not get %s",hprofName.Data()));
+              else hprof->Fill(part->M(),part->Pt(),inputWeight);
             }
-            
-            
           }
-          
         }
       }
     }
-  }
-  
+  }  
 
   delete mcProxy;
   delete mcInYRangeProxy;
diff --git a/PWG/muon/AliAnalysisTaskMuMu.cxx b/PWG/muon/AliAnalysisTaskMuMu.cxx
index b6fd1db..2fdb825 100644
--- a/PWG/muon/AliAnalysisTaskMuMu.cxx
+++ b/PWG/muon/AliAnalysisTaskMuMu.cxx
@@ -307,7 +307,6 @@ void AliAnalysisTaskMuMu::FillHistos(const char* eventSelection,
   TIter nextTrackCut(fCutRegistry->GetCutCombinations(AliAnalysisMuMuCutElement::kTrack));
   TIter nextPairCut(fCutRegistry->GetCutCombinations(AliAnalysisMuMuCutElement::kTrackPair));
   
-  // loop on single tracks (whatever the type of tracks
   if ( !IsHistogrammingDisabled() && !fDisableHistoLoop )
   {
     // The main part, loop over subanalysis and fill histo
@@ -318,21 +317,22 @@ void AliAnalysisTaskMuMu::FillHistos(const char* eventSelection,
       if ( MCEvent() != 0x0 )
       {
         AliCodeTimerAuto(Form("%s (FillHistosForMCEvent)",analysis->ClassName()),1);
-        analysis->FillHistosForMCEvent(eventSelection,triggerClassName,centrality);
-      }
-      
-      {
-        AliCodeTimerAuto(Form("%s (FillHistosForEvent)",analysis->ClassName()),1);
-        analysis->FillHistosForEvent(eventSelection,triggerClassName,centrality);
+        analysis->FillHistosForMCEvent(eventSelection,triggerClassName,centrality);// Implemented in AliAnalysisMuMuNch and AliAnalysisMuMuMinv at the moment
       }
+ 
+      AliCodeTimerAuto(Form("%s (FillHistosForEvent)",analysis->ClassName()),1);
+      analysis->FillHistosForEvent(eventSelection,triggerClassName,centrality); // Implemented in AliAnalysisMuMuNch at the moment
       
+      // Loop on all event tracks 
       for (Int_t i = 0; i < nTracks; ++i)
       {
         AliVParticle* tracki = AliAnalysisMuonUtility::GetTrack(i,Event());
+
+       if (!AliAnalysisMuonUtility::IsMuonTrack(tracki) ) continue;
         
         nextTrackCut.Reset();
         AliAnalysisMuMuCutCombination* trackCut;
-        
+        // Loop on all event tracks 
         while ( ( trackCut = static_cast<AliAnalysisMuMuCutCombination*>(nextTrackCut()) ) )
         {
           if ( trackCut->Pass(*tracki) )
diff --git a/PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C b/PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C
new file mode 100644
index 0000000..d2cd660
--- /dev/null
+++ b/PWG/muondep/AccEffTemplates/GenParamCustomRadiativeDecay.C
@@ -0,0 +1,81 @@
+#if !defined(__CINT__) || defined(__MAKECINT__)
+#include <Riostream.h>
+#include "TRandom.h"
+#include "AliGenerator.h"
+#include "AliGenParam.h"
+#endif
+
+static Int_t IpCustom( TRandom *ran);
+static Double_t PtCustom( const Double_t *px, const Double_t */*dummy*/ );
+static Double_t YCustom( const Double_t *py, const Double_t */*dummy*/ );
+static Double_t V2Custom( const Double_t *pv, const Double_t */*dummy*/ );
+
+//-------------------------------------------------------------------------
+AliGenerator* GenParamCustom()
+{
+  
+  AliGenCocktail *gener = new AliGenCocktail();
+  
+  gener->UsePerEventRates();
+  AliGenParam *jpsiGener = new AliGenParam(1,-1,PtCustom,YCustom,V2Custom,IpCustom);
+  jpsiGener->SetMomentumRange(0,1e6);
+  jpsiGener->SetPtRange(0,999.);
+  jpsiGener->SetYRange(-4.2, -2.3);
+  jpsiGener->SetPhiRange(0., 360.);
+  
+  jpsiGener->SetTrackingFlag(1);
+  jpsiGener->SetForceDecay(kNoDecay);  // Jpsi particles decay are switched-off for Pythia
+  
+  // evtGen (for radiative decays)
+  AliGenEvtGen *evtGener = new AliGenEvtGen();
+  evtGener->SetForceDecay(kDiMuon);
+  evtGener->SetParticleSwitchedOff(AliGenEvtGen::kCharmPart);
+  
+  // add Jpsi generator to cocktail
+  gener->AddGenerator(jpsiGener,"Jpsi",1);
+  // add EvtGen generator to cocktail
+  gener->AddGenerator(evtGener,"EvtGen",1);
+  
+  return gener;
+  
+  return gener;
+}
+
+//-------------------------------------------------------------------------
+Int_t IpCustom( TRandom *)
+{
+  // particle to simulate (e.g. 443 for J/psi)
+  return VAR_GENPARAMCUSTOM_PDGPARTICLECODE;
+}
+
+//-------------------------------------------------------------------------
+Double_t PtCustom( const Double_t *px, const Double_t */*dummy*/ )
+{
+  // pT distribution
+  Double_t x=*px;
+  Float_t p0,p1,p2,p3;
+  p0 = VAR_GENPARAMCUSTOM_PT_P0; // 1.13e9;
+  p1 = VAR_GENPARAMCUSTOM_PT_P1; // 18.05;
+  p2 = VAR_GENPARAMCUSTOM_PT_P2; // 2.05;
+  p3 = VAR_GENPARAMCUSTOM_PT_P3; // 3.34;
+  return p0 *x / TMath::Power( p1 + TMath::Power(x,p2), p3 );
+}
+
+//-------------------------------------------------------------------------
+Double_t YCustom( const Double_t *py, const Double_t */*dummy*/ )
+{
+  // y distribution
+  Double_t y = *py;
+  Float_t p0,p1;
+  p0 = VAR_GENPARAMCUSTOM_Y_P0; // 4.08e5;
+  p1 = VAR_GENPARAMCUSTOM_Y_P1; // 7.1e4;
+  return p0 + p1*y;
+}
+
+//-------------------------------------------------------------------------
+Double_t V2Custom( const Double_t */*dummy*/, const Double_t */*dummy*/ )
+{
+  // v2
+  return 0.;
+}
+
diff --git a/PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C b/PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C
new file mode 100644
index 0000000..3f4daae
--- /dev/null
+++ b/PWG/muondep/AccEffTemplates/GenParamCustomSingleBen.C
@@ -0,0 +1,94 @@
+/*
+ *  MuonGenerator.C
+ *  aliroot_dev
+ *
+ *  Created by philippe pillot on 05/03/13.
+ *  Copyright 2013 SUBATECH. All rights reserved.
+ *
+ */
+
+
+#if !defined(__CINT__) || defined(__MAKECINT__)
+#include <Riostream.h>
+#include "TRandom.h"
+#include "AliGenerator.h"
+#include "AliGenParam.h"
+#endif
+
+
+static Int_t IpMuon( TRandom *ran);
+static Double_t PtMuon( const Double_t *px, const Double_t */*dummy*/ );
+static Double_t YMuon( const Double_t *py, const Double_t */*dummy*/ );
+static Double_t V2Muon( const Double_t *pv, const Double_t */*dummy*/ );
+
+
+//-------------------------------------------------------------------------
+AliGenerator* GenParamCustomSingle()
+{
+  AliGenParam *singleMu = new AliGenParam(1,-1,PtMuon,YMuon,V2Muon,IpMuon);
+  singleMu->SetMomentumRange(0,1e6);
+  singleMu->SetPtRange(VAR_GENPARAMCUSTOMSINGLE_PTMIN,999.);
+  singleMu->SetYRange(-4.2, -2.3);
+  singleMu->SetPhiRange(0., 360.);
+  singleMu->SetForceDecay(kNoDecay);
+  singleMu->SetTrackingFlag(1);
+  return singleMu;
+}
+
+//-------------------------------------------------------------------------
+Int_t IpMuon(TRandom *ran)
+{
+  // muon composition
+
+  if (ran->Rndm() < 0.5 )
+  {
+    return 13;
+  }
+  else
+  {
+    return -13;
+  }
+}
+
+//-------------------------------------------------------------------------
+Double_t PtMuon( const Double_t *px, const Double_t */*dummy*/ )
+{
+  // muon pT
+
+  Double_t x=*px;
+  Float_t p0,p1,p2,p3,p4,p5;
+
+  //Default param. = tuned MSL LHC15n
+  p0= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P0;//135.137
+  p1= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P1;//0.555323
+  p2= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P2;//0.578374
+  p3= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P3;//10.1345
+  p4= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P4;//0.000232233
+  p5= VAR_GENPARAMCUSTOMSINGLEBEN_PT_P5;//-0.924726
+
+
+  return p0 * (1. / TMath::Power(p1 + TMath::Power(x,p2), p3) + p4 * TMath::Exp(p5*x));
+}
+
+//-------------------------------------------------------------------------
+Double_t YMuon( const Double_t *py, const Double_t */*dummy*/ )
+{
+  // muon y
+
+  Double_t y = *py;
+  //pol4 only valid in y= -4;-2.5
+  Float_t p0,p1,p2;
+
+  //Default param. = tuned MSL LHC15n
+  p0= VAR_GENPARAMCUSTOMSINGLEBEN_Y_P0;//1.95551
+  p1= VAR_GENPARAMCUSTOMSINGLEBEN_Y_P1;//-0.104761
+  p2= VAR_GENPARAMCUSTOMSINGLEBEN_Y_P2;//0.00311324
+  return p0 * (1. + p1*y*y + p2*y*y*y*y);
+}
+
+//-------------------------------------------------------------------------
+Double_t V2Muon( const Double_t */*dummy*/, const Double_t */*dummy*/ )
+{
+  //muon v2
+  return 0.;
+}
diff --git a/PWG/muondep/AliAnalysisMuMu.cxx b/PWG/muondep/AliAnalysisMuMu.cxx
index a3528b1..cc0184e 100644
--- a/PWG/muondep/AliAnalysisMuMu.cxx
+++ b/PWG/muondep/AliAnalysisMuMu.cxx
@@ -25,6 +25,9 @@
 #include "AliAnalysisMuMuGraphUtil.h"
 #include "AliAnalysisMuMuJpsiResult.h"
 #include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+#include "AliAnalysisMuMuSpectraCapsulePP.h"
 #include "AliAnalysisTriggerScalers.h"
 #include "AliCounterCollection.h"
 #include "AliHistogramCollection.h"
@@ -36,6 +39,7 @@
 #include "TAxis.h"
 #include "TCanvas.h"
 #include "TColor.h"
+#include "TBox.h"
 #include "TF1.h"
 #include "TFile.h"
 #include "TGraphErrors.h"
@@ -51,6 +55,7 @@
 #include "TList.h"
 #include "TMap.h"
 #include "TMath.h"
+#include "TMethodCall.h"
 #include "TObjArray.h"
 #include "TObjString.h"
 #include "TParameter.h"
@@ -63,7 +68,7 @@
 #include <cassert>
 #include <map>
 #include <set>
-#include <string>
+#include <vector>
 #include "TLatex.h"
 
 using std::cout;
@@ -87,9 +92,9 @@ fParticleName(""),
 fConfig(new AliAnalysisMuMuConfig(config))
 {
   GetFileNameAndDirectory(filename);
-  
+
   GetCollections(fFilename,fDirectory,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
-  
+
   if ( IsSimulation() )
   {
     SetParticleNameFromFileName(fFilename);
@@ -112,30 +117,30 @@ fParticleName(""),
 fConfig(0x0)
 {
   // ctor
-  
+
   GetFileNameAndDirectory(filename);
 
   GetCollections(fFilename,fDirectory,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
-  
+
   if ( IsSimulation() )
   {
     SetParticleNameFromFileName(fFilename);
   }
-  
+
   if ( fCounterCollection )
   {
     if ( strlen(associatedSimFileName) )
     {
       fAssociatedSimulation = new AliAnalysisMuMu(associatedSimFileName);
     }
-    
+
     if ( strlen(associatedSimFileName2) )
     {
       fAssociatedSimulation2 = new AliAnalysisMuMu(associatedSimFileName2);
     }
-    
+
     fConfig = new AliAnalysisMuMuConfig;
-    
+
     fConfig->ReadFromFile(configurationFile);
   }
 }
@@ -144,7 +149,7 @@ fConfig(0x0)
 AliAnalysisMuMu::~AliAnalysisMuMu()
 {
   // dtor
-  
+
   if ( fAssociatedSimulation )
   {
     fAssociatedSimulation->Update();
@@ -153,9 +158,9 @@ AliAnalysisMuMu::~AliAnalysisMuMu()
   {
     fAssociatedSimulation2->Update();
   }
-  
+
   Update();
-  
+
   delete fCounterCollection;
   delete fBinning;
   delete fMergeableCollection;
@@ -179,9 +184,9 @@ void AliAnalysisMuMu::BasicCounts(Bool_t detailTriggers,
   //
   // If detailTriggers is kTRUE, will show the detail, including Physics Selection fraction,
   // for each trigger found (as opposed to just showing info for MB,MSL and MUL triggers)
-  
+
   if (!fMergeableCollection || !fCounterCollection) return;
-  
+
   TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
   TIter nextRun(runs);
 
@@ -191,14 +196,14 @@ void AliAnalysisMuMu::BasicCounts(Bool_t detailTriggers,
   TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
 
   Bool_t doPS = (events->FindObject("PSALL") != 0x0);
-  
+
   TObjString* srun;
   TObjString* strigger;
 
   ULong64_t localNmb(0);
   ULong64_t localNmsl(0);
   ULong64_t localNmul(0);
-  
+
   if ( totalNmb) *totalNmb = 0;
   if ( totalNmsl) *totalNmsl = 0;
   if ( totalNmul ) *totalNmul = 0;
@@ -206,34 +211,34 @@ void AliAnalysisMuMu::BasicCounts(Bool_t detailTriggers,
   while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
   {
     std::cout << Form("RUN %09d ",srun->String().Atoi());
-    
+
     TString details;
     ULong64_t nmb(0);
     ULong64_t nmsl(0);
     ULong64_t nmul(0);
-    
+
     nextTrigger.Reset();
-    
+
     Int_t nofPS(0);
-    
+
     while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
     {
-      
+
       if ( !Config()->Has(Config()->MinbiasTriggerKey(),strigger->String().Data(),IsSimulation()) &&
            !Config()->Has(Config()->DimuonTriggerKey(),strigger->String().Data(),IsSimulation()) &&
            !Config()->Has(Config()->MuonTriggerKey(),strigger->String().Data(),IsSimulation()) ) continue;
-          
+
       ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d/centrality:all",
                                                     strigger->String().Data(),"ALL",srun->String().Atoi())));
 
       details += TString::Format("\n%50s %10lld",strigger->String().Data(),n);
-      
+
 
       if ( doPS )
       {
         ULong64_t nps = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d/centrality:all",
                                                                     strigger->String().Data(),"PSALL",srun->String().Atoi())));
-        
+
         details += TString::Format(" PS %5.1f %%",nps*100.0/n);
 
         if (nps)
@@ -260,12 +265,12 @@ void AliAnalysisMuMu::BasicCounts(Bool_t detailTriggers,
         nmul += n;
         if ( totalNmul ) (*totalNmul) += n;
         localNmul += n;
-      }      
+      }
     }
-    
+
     std::cout << Form("MB %10lld MSL %10lld MUL %10lld %s",
                  nmb,nmsl,nmul,(nofPS == 0 ? "(NO PS AVAIL)": ""));
-    
+
 
     if ( detailTriggers )
     {
@@ -290,10 +295,19 @@ void AliAnalysisMuMu::BasicCounts(Bool_t detailTriggers,
 //_____________________________________________________________________________
 void AliAnalysisMuMu::CleanAllSpectra()
 {
-  /// Delete all the spectra we may have
+    /// Delete all the spectra we may have
 
-  OC()->RemoveByType("AliAnalysisMuMuSpectra");
-  Update();
+    OC()->RemoveByType("AliAnalysisMuMuSpectra");
+    Update();
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::CleanFNorm()
+{
+    /// Delete all the spectra we may have
+
+    OC()->Prune("/FNORM");
+    Update();
 }
 
 
@@ -303,28 +317,28 @@ TObjArray* AliAnalysisMuMu::CompareJpsiPerCMUUWithBackground(const char* jpsires
 {
   TFile* fjpsi = FileOpen(jpsiresults);
   TFile* fbck = FileOpen(backgroundresults);
-  
+
   if (!fjpsi || !fbck) return 0x0;
-  
+
   TGraph* gjpsi = static_cast<TGraph*>(fjpsi->Get("jpsipercmuu"));
-    
+
   std::vector<std::string> checks;
 
   checks.push_back("muminus-CMUU7-B-NOPF-ALLNOTRD");
   checks.push_back("muplus-CMUU7-B-NOPF-ALLNOTRD");
   checks.push_back("muminus-CMUSH7-B-NOPF-MUON");
   checks.push_back("muplus-CMUSH7-B-NOPF-MUON");
-  
+
   if (!gjpsi) return 0x0;
 
   TObjArray* a = new TObjArray;
   a->SetOwner(kTRUE);
-  
+
   for ( std::vector<std::string>::size_type j = 0; j < checks.size(); ++j )
   {
-    
+
     TGraph* gback = static_cast<TGraph*>(fbck->Get(checks[j].c_str()));
-    
+
     if (!gback) continue;
 
     if ( gjpsi->GetN() != gback->GetN() )
@@ -332,26 +346,26 @@ TObjArray* AliAnalysisMuMu::CompareJpsiPerCMUUWithBackground(const char* jpsires
       AliErrorClass("graphs have different number of points !");
       continue;
     }
-    
+
     TGraphErrors* g = new TGraphErrors(gjpsi->GetN());
-    
-    for ( int i = 0; i < gjpsi->GetN(); ++i ) 
+
+    for ( int i = 0; i < gjpsi->GetN(); ++i )
     {
       double r1,r2,y1,y2;
-      
+
       gjpsi->GetPoint(i,r1,y1);
       gback->GetPoint(i,r2,y2);
-      
-      if ( r1 != r2 ) 
+
+      if ( r1 != r2 )
       {
         AliWarningClass(Form("run[%d]=%d vs %d",i,(int)r1,(int)r2));
         continue;
       }
-      
+
       g->SetPoint(i,y2,y1);
       //    g->SetPointError(i,gjpsi->GetErrorY(i),gback->GetErrorY(i));
     }
-    
+
     g->SetMarkerStyle(25+j);
     g->SetMarkerSize(1.2);
     if (j==0)
@@ -367,68 +381,68 @@ TObjArray* AliAnalysisMuMu::CompareJpsiPerCMUUWithBackground(const char* jpsires
     g->SetName(checks[j].c_str());
     a->AddLast(g);
   }
-  
+
   return a;
 }
 
 //_____________________________________________________________________________
 TGraph* AliAnalysisMuMu::CompareJpsiPerCMUUWithSimu(const char* realjpsiresults,
-                                                             const char* simjpsiresults)
+                                                    const char* simjpsiresults)
 {
   TFile* freal = FileOpen(realjpsiresults);
   TFile* fsim = FileOpen(simjpsiresults);
-  
+
   if (!freal || !fsim) return 0x0;
-  
+
   TGraph* greal = static_cast<TGraph*>(freal->Get("jpsipercmuu"));
   TGraph* gsim = static_cast<TGraph*>(fsim->Get("jpsipercmuu"));
-  
+
   TObjArray* a = new TObjArray;
   a->SetOwner(kTRUE);
-  
+
   if ( greal->GetN() != gsim->GetN() )
   {
     AliErrorClass("graphs have different number of points !");
     return 0x0;
   }
-    
+
   TGraphErrors* g = new TGraphErrors(greal->GetN());
   TGraphErrors* gratio = new TGraphErrors(greal->GetN());
-    
-  for ( int i = 0; i < greal->GetN(); ++i ) 
+
+  for ( int i = 0; i < greal->GetN(); ++i )
   {
     double r1,r2,y1,y2;
-    
+
     greal->GetPoint(i,r1,y1);
     gsim->GetPoint(i,r2,y2);
-    
-    if ( r1 != r2 ) 
+
+    if ( r1 != r2 )
     {
       AliWarningClass(Form("run[%d]=%d vs %d",i,(int)r1,(int)r2));
       continue;
     }
-    
+
     double ratio(0.0);
-    
+
     if ( TMath::Abs(y1)<1E-6 || TMath::Abs(y2)<1E-6)
     {
       g->SetPoint(i,0,0);
       g->SetPointError(i,0,0);
     }
     else
-    {    
+    {
       g->SetPoint(i,y2,y1);
       g->SetPointError(i,greal->GetErrorY(i),gsim ->GetErrorY(i));
       ratio = y2/y1;
     }
     gratio->SetPoint(i,r1,ratio);
   }
-    
+
   g->SetMarkerStyle(25);
   g->SetMarkerSize(1.2);
 
   new TCanvas;
-  
+
   g->Draw("ap");
 
   g->SetLineColor(1);
@@ -436,23 +450,382 @@ TGraph* AliAnalysisMuMu::CompareJpsiPerCMUUWithSimu(const char* realjpsiresults,
   g->SetName("jpsipercmuurealvssim");
 
   new TCanvas;
-  
+
   greal->Draw("alp");
   gsim->SetLineColor(4);
-  
+
   gsim->Draw("lp");
 
   new TCanvas;
   gratio->Draw("alp");
-  
+
   return g;
 }
 
 //_____________________________________________________________________________
-AliAnalysisMuMuConfig* AliAnalysisMuMu::Config()
+void AliAnalysisMuMu::DrawFitResults(const char* particle,
+                                     const char* binType,
+                                     const char* subresults,
+                                     Bool_t AccEffCorr
+                                     )const
+{
+    /// A function to use after JPsi()
+    /// Draw all results/subresults (i.e fit functions) spectras on a single canvas for every combination of Trigger / event Type / centrality / Pair cut.
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterater for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextBinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    AliAnalysisMuMuSpectra * spectra=0x0;
+
+    //Loop on particle
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextCentrality.Reset();
+
+                // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                    AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+                    nextPairCut.Reset();
+
+                    // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                        {
+                        AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+                        nextBinType.Reset();
+
+                        // Loop on each binType (PT or Y)
+                        //==============================================================================
+                        while ( ( sbinType = static_cast<TObjString*>(nextBinType()) ) )
+                            {
+                            AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
+                            // Output message
+                            cout << "---------------------" << endl;
+                            cout << "Looking for spectras ..."<< endl;
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra){
+                              AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                              return;
+                            }
+                            //________
+
+                            // Create pointer on fitted spectra. Any kind of capsule do the job
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,"","");
+                            if(!capsule){
+                              AliError("Could not find spetra !");
+                              return;
+                            }
+                            // Draw results
+                            capsule->DrawResults(particle,subresults);
+                            delete capsule;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+
+    return ;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::PrintFitParam( const char* particle,
+                                     const char* param,
+                                     const char* binType,
+                                     const char* subresult,
+                                     const char* printDirectoryPath,
+                                     Bool_t AccEffCorr
+                                     )const
 {
-  /// Return the configuration
-  return fConfig;
+    /// Draw fit parameter versus bin
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* paramArray    = TString(param).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* subresultArray     = TString(subresult).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterater for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextparam(paramArray);
+    TIter nextBinType(binTypeArray);
+    TIter nextSubResult(subresultArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparam;
+    TObjString* sbinType;
+    TObjString* ssubresult;
+    TObjString* scentrality;
+
+    AliAnalysisMuMuSpectra* spectra=0x0;
+    TObjArray* histoArray = new TObjArray(); // For centrality
+    TH1                   *h =0x0;
+    TH1                   *hcent =0x0;
+    TH1                   *href =0x0;
+
+
+    //Loop on param
+    while ( ( sparam = static_cast<TObjString*>(nextparam()) ) )
+    {
+      AliDebug(1,Form("param %s",sparam->String().Data()));
+      nextEventType.Reset();
+
+      // Loop on each envenType (see MuMuConfig)
+      //==============================================================================
+      while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+      {
+        AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+        nextTrigger.Reset();
+
+        // Loop on each trigger (see MuMuConfig)
+        //==============================================================================
+        while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+        {
+          AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+          nextCentrality.Reset();
+
+          // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+          //==============================================================================
+          while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+          {
+          AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+          nextBinType.Reset();
+
+          // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+          //==============================================================================
+          while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+          {
+            AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+            nextPairCut.Reset();
+            
+
+            // Loop on each binType (PT or Y)
+            //==============================================================================
+            while ( ( sbinType = static_cast<TObjString*>(nextBinType()) ) )
+            {
+              AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
+              // Output message
+              cout << "---------------------" << endl;
+              cout << "Looking for spectras ..."<< endl;
+
+              // Get spectra
+              TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),particle,sbinType->String().Data());
+              if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+              AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+              if(!spectra) {
+                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                return;
+              }
+
+              TCanvas *c = 0x0;
+              TLegend * leg = 0x0;
+              new TLegend(0.4,0.7,0.70,0.9);
+
+              // if(!sbinType->String().Contains("INTEGRATED")){
+                c = new TCanvas;
+                leg = new TLegend(0.4,0.7,0.70,0.9);
+                c->Divide(1,2,0,0);
+                leg->SetHeader(Form("Fit Parameters %s ",sparam->String().Data()));
+                leg->SetTextSize(0.03);
+              // }
+                                          
+              if(c) // Same as !INTEGRATED
+              {
+                c->cd(1);
+
+                nextSubResult.Reset();
+                int i= 1;
+                while ( ( ssubresult = static_cast<TObjString*>(nextSubResult()) ) )
+                {
+                  //Loop over subresults
+                  AliDebug(1,Form("-----SubResults %s",ssubresult->String().Data()));
+                  if(sparam->String().Contains("NofJPsi") &&  sbinType->String().Contains("PT"))h = spectra->Plot(param,ssubresult->String().Data(),kTRUE);
+                  else h = spectra->Plot(param,ssubresult->String().Data(),kFALSE);
+                  if(!h) {
+                    AliError(Form("Cannot find histo for SubResults %s",ssubresult->String().Data()));
+                    return;
+                  }
+                   // In case of INTEGRATED, create a new Histo
+                  if(sbinType->String().Contains("INTEGRATED")){
+                    histoArray->Add(h->Clone());
+                    continue;
+                  }
+
+                  // beautifull histo
+                  if(i!=3 &&i!=5 )h->SetMarkerColor(i); //nobody likes green and yellow
+                  h->SetMarkerSize(1.);
+                  h->SetMarkerStyle(20+i);
+                  h->SetName(Form(" %s for result %s and bin %s",param,ssubresult->String().Data(),sbinType->String().Data()));
+
+                  if(i==1) h->DrawCopy();
+                  else h->DrawCopy("same");
+                  leg->AddEntry(h,Form("%s with %s",param,ssubresult->String().Data()),"p");
+                  
+                  if (h) {
+                    printf("Replacing %s",h->GetName());
+                    OC()->Remove(Form("/%s/%s/%s/%s/FITPARAM/%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),h->GetName()));
+                  }
+                  Bool_t adoptOK = OC()->Adopt(Form("/%s/%s/%s/%s/FITPARAM",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data()),h);
+                  if ( adoptOK ) std::cout << "+++projection histo " << h->GetName() << " adopted" << std::endl;
+                  i++;
+                }
+                leg->Draw("same");
+
+                c->cd(2);
+
+                nextSubResult.Reset();
+                TLegend * leg2 = new TLegend(0.4,0.75,0.70,0.9);
+                leg2->SetHeader(Form("Ratio"));
+                leg2->SetTextSize(0.03);
+                int j= 1;
+                TString refName;
+                while ( ( ssubresult = static_cast<TObjString*>(nextSubResult()) ) )
+                {
+                  if(j==1){
+                    href = spectra->Plot(param,ssubresult->String().Data(),kFALSE);
+                    refName = href->GetName();
+                    j++;
+                    continue;
+                  }
+
+                  AliDebug(1,Form("-----SubResults %s",ssubresult->String().Data()));
+                  h = spectra->Plot(param,ssubresult->String().Data(),kFALSE);
+
+                  if(!h || !href )
+                  {
+                    AliError(Form("Cannot find histos for SubResults  ratio "));
+                    return;
+                  }
+                  if(j!=3 &&j!=5 )h->SetMarkerColor(j); //nobody likes green and yellow
+                  h->SetMarkerSize(1.);
+                  h->SetMarkerStyle(20+j);
+                  h->SetName(Form(" %s %s over %s for %s",param,ssubresult->String().Data(),refName.Data(),sbinType->String().Data()));
+                  h->Divide(href);
+                  if(j==2)h->DrawCopy();
+                  else h->DrawCopy("same");
+
+                  leg2->AddEntry(h,Form("Results %d over Result 1",j),"pe");
+                  j++;
+                  if (h)
+                  {
+                    printf("Replacing %s",h->GetName());
+                    OC()->Remove(Form("/%s/%s/%s/%s/FITPARAM/%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),h->GetName()));
+                  }
+                  Bool_t adoptOK = OC()->Adopt(Form("/%s/%s/%s/%s/FITPARAM",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data()),h);
+                  if ( adoptOK ) std::cout << "+++projection histo " << h->GetName() << " adopted" << std::endl;
+                }
+                leg2->Draw("same");
+              } else {
+                nextSubResult.Reset();
+                int i= 1;
+                while ( ( ssubresult = static_cast<TObjString*>(nextSubResult()) ) )
+                {
+                  //Loop over subresults
+                  AliDebug(1,Form("-----SubResults %s",ssubresult->String().Data()));
+                  h = spectra->Plot(param,ssubresult->String().Data(),kFALSE);
+                  if(!h) {
+                    AliError(Form("Cannot find histo for SubResults %s",ssubresult->String().Data()));
+                    return;
+                  }
+                  // histoArray->Add(h->Clone());
+                }
+              }
+            }
+          }
+
+          //Output for INTEGRATED
+        }
+      }
+    }
+  }
+  delete eventTypeArray ;
+  delete triggerArray ;
+  delete pairCutArray ;
+  delete centralityArray ;
+  delete paramArray ;
+  delete binTypeArray ;
+  delete histoArray ;
+
+  return ;
 }
 
 //_____________________________________________________________________________
@@ -466,31 +839,31 @@ void AliAnalysisMuMu::DrawMinv(const char* type,
                                const char* flavour) const
 {
   /// Draw minv spectra for binning of given type
-  
+
   if (!OC() || !BIN()) return;
-  
+
   TObjArray* bins = BIN()->CreateBinObjArray(particle,type,flavour);
   if (!bins)
   {
     AliError(Form("Could not get %s bins",type));
     return;
   }
-  
+
   Double_t xmin(-1);
   Double_t xmax(-1);
-  
+
   TString sparticle(particle);
   if ( sparticle=="PSI" )
   {
     xmin = 2;
     xmax = 6;
   }
-  
+
   Int_t nx(1);
   Int_t ny(1);
-  
+
   Int_t n = bins->GetEntries();
-  
+
   if ( n == 2 )
   {
     nx = 2;
@@ -500,20 +873,20 @@ void AliAnalysisMuMu::DrawMinv(const char* type,
     ny = TMath::Nint(TMath::Sqrt(n));
     nx = n/ny;
   }
-  
+
   TString stype(type);
   stype.ToUpper();
-  
+
   TString spectraName(Form("/%s/%s/%s/%s/%s-%s",eventType,trigger,centrality,pairCut,particle,stype.Data()));
-  
+
   if ( strlen(flavour))
   {
     spectraName += "-";
     spectraName += flavour;
   }
-  
+
   AliAnalysisMuMuSpectra* spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraName.Data()));
-  
+
   AliDebug(1,Form("spectraName=%s spectra=%p",spectraName.Data(),spectra));
 
   TObjArray* spectraBins(0x0);
@@ -521,44 +894,44 @@ void AliAnalysisMuMu::DrawMinv(const char* type,
   {
     spectraBins = spectra->BinContentArray();
   }
-  
+
   TCanvas* c = new TCanvas;
   c->Divide(nx,ny);
   c->Draw();
   gStyle->SetOptFit(1112);
-  
+
   c->Connect("ProcessedEvent(Int_t,Int_t,Int_t,TObject*)", "AliAnalysisMuMu",
               (void*)this, "ExecuteCanvasEvent(Int_t,Int_t,Int_t,TObject*)");
 
-  
+
   TIter next(bins);
   AliAnalysisMuMuBinning::Range* r;
   Int_t ci(0);
-  
+
   while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
   {
     TString name(Form("/%s/%s/%s/%s/MinvUS+%s",eventType,trigger,centrality,pairCut,r->AsString().Data()));
 
     AliDebug(1,name.Data());
-    
+
     AliAnalysisMuMuJpsiResult* spectraBin(0x0);
-    
+
     if ( spectraBins )
     {
       AliAnalysisMuMuResult* sr = static_cast<AliAnalysisMuMuResult*>(spectraBins->At(ci));
-      
+
       spectraBin = static_cast<AliAnalysisMuMuJpsiResult*>(sr->SubResult(subresultname));
-      
+
       AliDebug(1,Form("spectraBin(%s)=%p",subresultname,spectraBin));
     }
-    
+
     TH1* h = OC()->Histo(name.Data());
-    
+
     if ( spectraBin )
     {
       h = spectraBin->Histo();
     }
-    
+
     if (h)
     {
       ++ci;
@@ -569,16 +942,16 @@ void AliAnalysisMuMu::DrawMinv(const char* type,
         h->GetXaxis()->SetRangeUser(xmin,xmax);
       }
       h->Draw("histes");
-      
+
       TObject* f1 = h->GetListOfFunctions()->FindObject("fitTotal");
       if (f1)
       {
         f1->Draw("same");
       }
-      
+
       gPad->Modified();
       gPad->Update();
-      
+
       TObject* stats = h->FindObject("stats");
       if (stats)
       {
@@ -586,7 +959,7 @@ void AliAnalysisMuMu::DrawMinv(const char* type,
       }
     }
   }
-  
+
   delete bins;
 }
 
@@ -596,15 +969,15 @@ void AliAnalysisMuMu::DrawMinv(const char* type, const char* particle, const cha
   /// Draw minv spectra for binning of given type
 
 //  AliWarning("Reimplement me!");
-  
+
   if (!fConfig)
   {
     AliError("No configuration available yet. Don't know what to draw");
     return;
   }
-  
+
   const AliAnalysisMuMuConfig& c = *(Config());
-  
+
   DrawMinv(type,particle,
            c.First(c.DimuonTriggerKey(),IsSimulation()),
            c.First(c.EventSelectionKey(),IsSimulation()),
@@ -617,64 +990,387 @@ void AliAnalysisMuMu::DrawMinv(const char* type, const char* particle, const cha
 //___________________________________________________________________
 void AliAnalysisMuMu::ExecuteCanvasEvent(Int_t event, Int_t /*px*/, Int_t /*py*/, TObject *sel)
 {
-  // Actions in reponse to mouse button events.
-  
-  TCanvas* c = static_cast<TCanvas*>(gTQSender);
-  TPad* pad = static_cast<TPad*>(c->GetSelectedPad());
-  if (!pad) return;
-  
-//  if ((event == kButton1Down) ||
-  if (event == kButton1Double) 
-  {
-    
-//    Float_t x = pad->AbsPixeltoX(px);
-//    Float_t y = pad->AbsPixeltoY(py);
-//    x = pad->PadtoX(x);
-//    y = pad->PadtoY(y);
+    // Actions in reponse to mouse button events.
 
-//    std::cout << "event=" << event << " px=" << px << " py=" << py << " ";
-    
-    if ( sel && sel->InheritsFrom("TH1") )
-    {
-      TCanvas* clocal = new TCanvas;
-      clocal->SetLogy();
-      clocal->Draw();
-      sel->Draw();
-    }
+    TCanvas* c = static_cast<TCanvas*>(gTQSender);
+    TPad* pad = static_cast<TPad*>(c->GetSelectedPad());
+    if (!pad) return;
+
+    //  if ((event == kButton1Down) ||
+    if (event == kButton1Double)
+        {
+
+        //    Float_t x = pad->AbsPixeltoX(px);
+        //    Float_t y = pad->AbsPixeltoY(py);
+        //    x = pad->PadtoX(x);
+        //    y = pad->PadtoY(y);
+
+        //    std::cout << "event=" << event << " px=" << px << " py=" << py << " ";
+
+        if ( sel && sel->InheritsFrom("TH1") )
+            {
+            TCanvas* clocal = new TCanvas;
+            clocal->SetLogy();
+            clocal->Draw();
+            sel->Draw();
+            }
+        else
+            {
+            TList* list = pad->GetListOfPrimitives();
+            TIter next(list);
+            TObject* h;
+
+            while ( ( h = next() ) )
+                {
+                if ( h->InheritsFrom("TH1") )
+                    {
+                    TCanvas* clocal = new TCanvas;
+                    clocal->SetLogy();
+                    clocal->Draw();
+                    h->Draw();
+                    break;
+                    }
+                }
+
+            }
+
+        //      std::cout  << std::endl;
+
+        pad->Modified();
+        }
+
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::RAAasGraphic(const char* particle,
+                                   const char* binType,
+                                   const char* externfile,
+                                   const char* externfile2,
+                                   const char* RefCent,
+                                   Bool_t AccEffCorr
+                                   )const
+{
+    /**
+     * Function to use after fitting procedur ( Jpsi() for instance ).
+     * Loops over all combination of /eventype/trigger/centrality (etc.), compute, store and print RAA on terminal.
+     * <binType> can be either "PT"/"Y"/"INTEGRATED" for the moment.
+     *
+     * Some comments: In case of PT/Y/CENTRALITY(single bin), the method implemented in AliAnalysisMuMuSpectraCapsulePbPb does the job, but for RAAvsCENTRALITY,
+     * we have to create a new TGraph (see inside for details)
+     */
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
     else
-    {
-      TList* list = pad->GetListOfPrimitives();
-      TIter next(list);
-      TObject* h;
-      
-      while ( ( h = next() ) )
-      {
-        if ( h->InheritsFrom("TH1") )
         {
-          TCanvas* clocal = new TCanvas;
-          clocal->SetLogy();
-          clocal->Draw();
-          h->Draw();
-          break;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                             Computing RAA                             " << endl;
+        cout <<      " ================================================================ " << endl;
         }
-      }
-      
-    }
 
-//      std::cout  << std::endl;
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    // Pointers
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphErr=0x0;
+    TGraphErrors* graphErrCorr=0x0;
+    TGraphErrors* graphCent=0x0;
+    TGraphErrors* graphCentErr=0x0;
+    TList* list=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+
+    //Loop on particle type
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+
+                        //canvas
+                        TCanvas *c1 = new TCanvas;
+                        c1->Draw();
+                        //Divide canvas for pt and y bin
+                        if (!sbinType->String().Contains("INTEGRATED"))
+                        {
+                          Int_t nx(1);
+                          Int_t ny(1);
+                          Int_t nofGraph = centralityArray->GetEntries(); // # of histo
+                          if ( nofGraph == 2 ){
+                            nx=2;
+                            ny=0;
+                          } 
+                          else if ( nofGraph > 2 ){
+                            ny = TMath::Nint(TMath::Sqrt(nofGraph));
+                            nx = TMath::Nint((nofGraph/ny) +0.6);
+                          }
+                          c1->Divide(nx,ny);
+                        }
+                        else if (sbinType->String().Contains("INTEGRATED")){
+                          graphCent = new TGraphErrors(centralityArray->GetEntries());
+                          graphCent->SetMinimum(0.);
+                          graphCent->SetMaximum(1.2);
+                          graphCentErr = new TGraphErrors(centralityArray->GetEntries());
+                          graphCentErr->SetMinimum(0.);
+                          graphCentErr->SetMaximum(1.2);
+                        }
+                        gStyle->SetOptStat(0);
+
+                        cout << Form("  __________________________________________________________ ") << endl;
+                        cout << Form("  |         bin      |   JPsi Stat. Syst.| RAA  Stat. Syst. |<NPART>  d<NPART> |") << endl;
+
+                        Int_t n=1; // counter
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) ) {
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra){//protection
+                              AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                              return;
+                            }
+                            //________
+
+                            //________Get Trigger sum
+                            Int_t NofMUL = TMath::Nint(CC()->GetSum(Form("trigger:%s/event:%s/centrality:%s",strigger->String().Data(),seventType->String().Data(),RefCent)));
+                            //________
+
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,externfile,externfile2);
+                            if(!capsule) continue;
+                            AliDebug(1,Form("Spectra = %p",capsule));
+                            // capsule->PrintConst();
+
+                            // Get Graph with RAA results
+                            list = capsule->RAAasGraphic(NofMUL);
+
+                            if(!list) continue;
+                            AliDebug(1,Form("list = %p",list));
+
+                            // Draw Graph according to bin type
+                            if (!sbinType->String().Contains("INTEGRATED")){ // PT/Y/single centrality
+                              // Select subcanvas
+                              c1->cd(n);
+                              //legend
+                              TLegend * leg = new TLegend(0.2,0.8,0.90,0.9);
+                              leg->SetTextSize(0.04);
+                              leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=5.02 TeV, L_{int}=222 #mub^{-1}, %s",scentrality->String().Data()));
+                              //Draw it
+                              graph = static_cast<TGraphErrors*>(list->At(0)->Clone());
+                              graphErr = static_cast<TGraphErrors*>(list->At(1)->Clone());
+                              graphErrCorr = static_cast<TGraphErrors*>(list->At(2)->Clone());
+                              if (!graph || ! graphErr) {
+                                  printf("Did not find graph in the list");
+                                  return;
+                              }
+
+                              leg->AddEntry(graph,"Inclusive J/#psi","pe");
+                              leg->AddEntry(graphErr,"Syst. uncertainty","f");
+                              
+                              //Graph1
+                              graph->GetYaxis()->SetRangeUser(0,1.41);
+                              graph->Draw("ap");
+                              // Graph Syst.
+                              graphErr->SetFillColorAlpha(4,0.);
+                              graphErr->Draw("same5");
+                              leg->Draw();
+
+                              // Global box
+                              Double_t global = graphErrCorr->GetErrorY(0)/100.;
+                              TBox *globalBox =0x0;
+                              if(sbinType->String().Contains("PT"))globalBox= new TBox(11.5,1.-global,12,1+global);
+                              if(sbinType->String().Contains("Y"))globalBox= new TBox(-2.6,1.-global,-2.5,1+global);
+                              globalBox->SetFillColor(4);
+                              globalBox->Draw("F");
+                              printf("Global syst : %f\n",global );
+
+                              TLine *l = 0x0;
+                              if(sbinType->String().Contains("PT"))l = new TLine(0.,1.,12.,1.);
+                              if(sbinType->String().Contains("PT"))l = new TLine(-4.0,1.,-2.5,1.);
+                              l->SetLineStyle(2);
+                              l->Draw("same");
+
+                            } 
+                            
+                            else {// Integrated case
+                              
+                              if(!sbinType->String().Contains("INTEGRATED")) {// Protection
+                                cout << "Cannot plot INTEGRATED  ! Check it please :) " << endl;
+                                delete c1;
+                                return;
+                              }
+
+                              Double_t x=0;
+                              Double_t y=0;
+                              graph = static_cast<TGraphErrors*>(list->At(0)->Clone());
+                              graphErr = static_cast<TGraphErrors*>(list->At(1)->Clone());
+                              graphErrCorr = static_cast<TGraphErrors*>(list->At(2)->Clone());                              
+
+                              if (!graph || ! graphErr) {// Protection
+                                  printf("Did not find graph in the list");
+                                  return;
+                              }
+
+                              // Get point for each centrality
+                              Double_t dx = graph->GetErrorX(0);
+                              Double_t dy = graph->GetErrorY(0);
+                              Double_t dysys = graphErr->GetErrorY(0);
+                              graph->GetPoint(0,x,y);
+                              
+                              // Set them to a new graphic
+                              graphCent->SetPoint(n-1,x,y);
+                              graphCent->SetPointError(n-1,dx,dy);
+                              graphCent->SetTitle(graph->GetTitle());
+                              graphCentErr->SetPoint(n-1,x,y);
+                              graphCentErr->SetPointError(n-1,2.5,dysys);
+                            }
+                          n++;
+                          delete capsule;
+                        }
+                        cout << "" << endl;
+                        if (sbinType->String().Contains("INTEGRATED")){ //Print
+                                                      
+                          graphCent->GetXaxis()->SetTitle("<N_{part}>");
+                          graphCent->GetYaxis()->SetTitle("R_{AA}");
+                          graphCent->GetYaxis()->SetRangeUser(0,1.5);
+                          graphCent->SetMarkerColor(4);
+                          graphCent->SetMarkerStyle(21);
+                          graphCentErr->SetFillColorAlpha(4,0.);
+                          graphCent->SetTitle(Form("%s/%s/%s/%s/%s",seventType->String().Data(),
+                                                   strigger->String().Data(),
+                                                   spairCut->String().Data(),
+                                                   sparticle->String().Data(),
+                                                   sbinType->String().Data()));
+                          TLegend * leg = new TLegend(0.2,0.8,0.90,0.9);
+                          leg->SetHeader("ALICE, Pb-Pb #sqrt{s_{NN}}=5.02 TeV, L_{int}=222 #mub^{-1}, PT/Y integrated");
+                          leg->SetTextSize(0.03);
+                          leg->AddEntry(graphCent,"Inclusive J/#psi","pe");
+                          leg->AddEntry(graphCentErr,"Syst. uncertainty","f");
+
+                          graphCent->Draw("ap");
+                          graphCentErr->Draw("same5");
+                          leg->Draw();
+
+                          // Global box
+                          Double_t global = graphErrCorr->GetErrorY(0)/100.;
+                          TBox *globalBox = globalBox= new TBox(420,1.-global,430,1+global);
+                          globalBox->SetFillColor(4);
+                          globalBox->Draw("F");
+                          printf("Global syst : %f\n",global );
+
+                          TLine *l = new TLine(0.,1.,12.,1.);
+                          l->SetLineStyle(2);
+                          l->Draw("same");
+                        }
+                        //________ Update resultes in Mergeable collection
+                        TString id(Form("/RAA-%s/%s/%s/%s/%s",strigger->String().Data(),seventType->String().Data(),spairCut->String().Data(),sbinType->String().Data(),sparticle->String().Data()));
+                        TObject* o = 0x0;
+
+                        if (graph){// first graph
+
+                          o = fMergeableCollection->GetObject(Form("%s/%s",id.Data(),graph->GetName()));
+                          if (o){
+                            AliWarning(Form("Replacing %s/%s",id.Data(),graph->GetName()));
+                            fMergeableCollection->Remove(Form("%s/%s",id.Data(),graph->GetName()));
+                          }
+
+                          Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),graph);
+
+                          if ( adoptOK ) std::cout << "+++RAA graph " << graph->GetName() << " adopted" << std::endl;
+                          else AliError(Form("Could not adopt RAA grap %s",graph->GetName()));
+                        }
+                        if (graphCent){// second graph
+                          o = fMergeableCollection->GetObject(Form("%s/%s",id.Data(),graphCent->GetName()));
+                          if (o){
+                            AliWarning(Form("Replacing %s/%s",id.Data(),graphCent->GetName()));
+                            fMergeableCollection->Remove(Form("%s/%s",id.Data(),graphCent->GetName()));
+                          }
+
+                          Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),graphCent);
+
+                          if ( adoptOK ) std::cout << "+++RAA graph " << graphCent->GetName() << " adopted" << std::endl;
+                          else AliError(Form("Could not adopt RAA graph %s",graphCent->GetName()));
+                        }
+                        //________
+                        }
+                    }
+                }
+            }
+        }
+    delete list;
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+
+    return ;
 
-      pad->Modified();
-  }
-  
 }
 
 //_____________________________________________________________________________
-TString 
+TString
 AliAnalysisMuMu::ExpandPathName(const char* file)
 {
   // An expand method that lives alien URL as they are
   TString sfile;
-  
+
   if ( !sfile.BeginsWith("alien://") )
   {
     return gSystem->ExpandPathName(file);
@@ -682,9 +1378,9 @@ AliAnalysisMuMu::ExpandPathName(const char* file)
   else
   {
     if (!gGrid) TGrid::Connect("alien://");
-    if (!gGrid) return "";    
+    if (!gGrid) return "";
   }
-  
+
   return file;
 }
 
@@ -711,46 +1407,46 @@ void AliAnalysisMuMu::TwikiOutputFnorm(const char* series) const
     std::cout << "*|";
     graphs.Add(g);
   }
-  
+
   std::cout << std::endl;
-  
+
   TGraphErrors* g0 = static_cast<TGraphErrors*>(graphs.First());
   if (!g0) return;
-  
+
   for ( Int_t i = 0; i < g0->GetN(); ++i )
   {
     TString msg;
-    
+
     msg.Form("|%6d|",TMath::Nint(g0->GetX()[i]));
-    
+
     for ( Int_t j = 0; j < graphs.GetEntries(); ++j )
     {
       TGraphErrors* g = static_cast<TGraphErrors*>(graphs.At(j));
-      
+
       msg += TString::Format(" %6.2f +- %6.2f |",g->GetY()[i],g->GetEY()[i]);
     }
-    
+
     std::cout << msg.Data() << std::endl;
   }
-  
+
   next.Reset();
-  
+
   std::cout << "|*Weigthed mean (*)*|";
 
   AliAnalysisMuMuResult* r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
-  
+
   if (!r)
   {
     AliError("Could not find Fnorm result !");
     return;
   }
 
-  
+
   while ( ( s = static_cast<TObjString*>(next())) )
   {
     TString var("Fnorm");
     TString unit;
-    
+
     if ( s->String().BeginsWith("Fnorm") )
     {
       r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
@@ -760,7 +1456,7 @@ void AliAnalysisMuMu::TwikiOutputFnorm(const char* series) const
       r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/RelDif"));
       unit = "%";
     }
-      
+
     r->Exclude("*");
     r->Include(s->String().Data());
 
@@ -769,9 +1465,9 @@ void AliAnalysisMuMu::TwikiOutputFnorm(const char* series) const
                       r->GetErrorStat(var.Data()),
                       unit.Data());
   }
-  
+
   next.Reset();
-  
+
   std::cout << std::endl;
 
   std::cout << "|*RMS*|";
@@ -779,7 +1475,7 @@ void AliAnalysisMuMu::TwikiOutputFnorm(const char* series) const
   while ( ( s = static_cast<TObjString*>(next())) )
   {
     TString var("Fnorm");
-    
+
     if ( s->String().BeginsWith("Fnorm") )
     {
       r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/Fnorm"));
@@ -788,29 +1484,42 @@ void AliAnalysisMuMu::TwikiOutputFnorm(const char* series) const
     {
       r = static_cast<AliAnalysisMuMuResult*>(OC()->GetObject("/FNORM/RESULTS/RelDif"));
     }
-    
+
     r->Exclude("*");
     r->Include(s->String().Data());
-    
+
     Double_t d = 100.0*r->GetRMS(var.Data())/r->GetValue(var.Data());
-    
+
     std::cout << Form(" * %5.2f (%5.2f %%) * |",
                       r->GetRMS(var.Data()),d);
   }
-  
+
   std::cout << std::endl;
   std::cout << "(*) weight is the number of CMUL7-B-NOPF-MUON triggers (physics-selected and pile-up corrected) in each run" << std::endl;
-  
+
   delete what;
 }
 
 //_____________________________________________________________________________
-TFile* 
+TFile*
 AliAnalysisMuMu::FileOpen(const char* file)
 {
-  // Open a file after expansion of its name
-  
-  return TFile::Open(ExpandPathName(file).Data());
+    // Open a file after expansion of its name
+
+    return TFile::Open(ExpandPathName(file).Data());
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMu::First(const TString& list) const
+{
+    TObjArray* a = list.Tokenize(",");
+    if ( a->GetLast() < 0 ) return "";
+
+    TString rv = static_cast<TObjString*>(a->First())->String();
+
+    delete a;
+
+    return rv;
 }
 
 //_____________________________________________________________________________
@@ -826,31 +1535,31 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 {
   // Fit the minv/mpt spectra to find the given particle
   // Returns an array of AliAnalysisMuMuResult objects
-  
+
   TProfile::Approximate(); //To avoid bins with error=0 due to low statstics
-  
+
   static int n(0);
-  
+
+  //Check Binning list
   TObjArray* bins = binning.CreateBinObjArray(particle);
-  if (!bins)
-  {
+  if (!bins){
     AliError(Form("Did not get any bin for particle %s",particle));
     return 0x0;
   }
-  
+
+  //Check trigger list
   TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
-  if ( !triggers->FindObject(trigger) )
-  {
+  if ( !triggers->FindObject(trigger) ){
     AliError(Form("Did not find trigger %s",trigger));
     delete bins;
     delete triggers;
     return 0x0;
   }
   delete triggers;
-  
+
+  //Check event list
   TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
-  if ( !events->FindObject(eventType) )
-  {
+  if ( !events->FindObject(eventType) ){
     AliError(Form("Did not find eventType %s",eventType));
     delete bins;
     delete events;
@@ -859,91 +1568,87 @@ AliAnalysisMuMu::FitParticle(const char* particle,
   delete events;
 
   Int_t ntrigger = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s",trigger,eventType)));
-  
-  if  (ntrigger<=0)
-  {
+
+  //Check trigger
+  if  (ntrigger<=0) {
     AliError(Form("No trigger for trigger:%s/event:%s",trigger,eventType));
     delete bins;
     return 0x0;
   }
 
+  //Get number of runs and store it in nruns
   TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
   Int_t nruns = runs->GetEntries();
   delete runs;
-  
-  
+
+  // Create ID for the fit which will be used to name results
   TString id(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut));
-  
-//  binning.Print();
-  
+
+  //  binning.Print();
+
+  //The result pointer, will be return at the end
   AliAnalysisMuMuSpectra* spectra(0x0);
-  
+
+  // The binning pointer, which point at Pt binning, Y binning etc.
   AliAnalysisMuMuBinning::Range* bin;
   TIter next(bins);
-  
+
+  // Create an array (fitTypeArray) pointing on AliAnalysisMuMuConfig and store kFitTypeList.  Also create pointers and strings for several pointers
   TObjArray* fitTypeArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());
-  TIter nextFitType(fitTypeArray);
-  TObjString* fitType;
-  TString flavour;
-  TString sSpectraType(spectraType);
-  
+  TIter nextFitType(fitTypeArray);// Iterater for every fit types, i.e fitting functions and their config.
+  TObjString* fitType;// To point to the array (??)
+  TString flavour;// Flavour of the binning (ex: "JAVI","IGOR" ...)
+  TString sSpectraType(spectraType);// Make spectratype a string
+
+  // Add some element to ID
   TString spectraName(binning.GetName());
-  if ( flavour.Length() > 0 )
-  {
+  if ( flavour.Length() > 0 ){
     spectraName += "-";
     spectraName += flavour;
   }
-  if ( corrected )
-  {
+  if ( corrected ){
     spectraName += "-";
     spectraName += "AccEffCorr";
   }
-  
-//  Int_t binN(0);
+
+  //  Int_t binN(0);
+
+  //MAIN PART : Loop on every binning range
+  //==============================================================================
   while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
   {
+
+    // Choose correct histo type with <spectraType> and set it in <hname>
     TString hname;
-    if (!sSpectraType.CompareTo("minv"))
-    {
-      hname = corrected ? Form("MinvUS%s_AccEffCorr",bin->AsString().Data()) : Form("MinvUS+%s",bin->AsString().Data());
-    }
-    else if (!sSpectraType.CompareTo("mpt"))
-    {
-      hname = corrected ? Form("MeanPtVsMinvUS%s_AccEffCorr",bin->AsString().Data()) : Form("MeanPtVsMinvUS%s",bin->AsString().Data());
-    }
-    else
-    {
+    if (!sSpectraType.CompareTo("minv"))hname = corrected ? Form("MinvUS+%s_AccEffCorr",bin->AsString().Data()) : Form("MinvUS+%s",bin->AsString().Data());
+    else if (!sSpectraType.CompareTo("mpt"))hname = corrected ? Form("MeanPtVsMinvUS%s",bin->AsString().Data()) : Form("MeanPtVsMinvUS%s",bin->AsString().Data());
+    else {
       AliError("Wrong spectra type choice: Posibilities are: 'minv' or 'mpt' ");
       return 0x0;
     }
-    
+
+    // Print the fitting process on the terminal
     TString isCorr(corrected ? " AccEffCorr " : " ");
     std::cout << "---------------------------------//---------------------------------" << std::endl;
     std::cout << "Fitting" << isCorr.Data() << sSpectraType.Data() << " spectra in " << id.Data() << std::endl;
-    
-    TH1* histo = OC()->Histo(id.Data(),hname.Data());
 
-    if (!histo)
-    {
-//      if (!fBinning && bin->IsIntegrated() )
-//      {
-//        // old file, we only had MinvUSPt
-//        hminv = fMergeableCollection->Histo(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut),"MinvUSPt:py");
-//      }
-//      
-//      if (!hminv)
-//      {
-        AliError(Form("Could not find histo %s",hname.Data()));
-        continue;
-//      }
+    // Pointer to the histo from histo collection
+    TH1* histo = OC()->Histo(id.Data(),hname.Data());
+    if (!histo) {
+      AliError(Form("Could not find histo %s",hname.Data()));
+      continue;
     }
-    
+
+    // Make a clone of the histo to work with. Pointer changes for every iteration (n++)
     histo = static_cast<TH1*>(histo->Clone(Form("%s%d",sSpectraType.Data(),n++)));
-    
+
     const char* particleTmp = IsSimulation() ? GetParticleName() : "JPsi"; //At some point particleTmp should become particle (but for now particle is always = "psi")
-  
-    TString sparticleTmp(particleTmp);
-    
+
+    cout << "particleTmp =" << particleTmp << endl;
+
+    TString sparticleTmp(particleTmp);// Make a string of it
+
+    // Object that fit/work on the histo
     AliAnalysisMuMuJpsiResult* r = new AliAnalysisMuMuJpsiResult(particleTmp,
                                                                  *histo, // Result for current bin
                                                                  trigger,
@@ -951,204 +1656,172 @@ AliAnalysisMuMu::FitParticle(const char* particle,
                                                                  pairCut,
                                                                  centrality,
                                                                  *bin);
-    
+
     r->SetNofTriggers(ntrigger);
     r->SetNofRuns(nruns);
-    
+
     nextFitType.Reset();
 
-    Int_t added(0);    
-    
+    Int_t added(0);
+
+    // Loop on every fittype and create a subresult inside the spectra.
     while ( ( fitType = static_cast<TObjString*>(nextFitType())) )
     {
       // In this loop we create a Subresult for each fit inside the Result for current bin (AddFit will do)
-      
-      TString sFitType(fitType->String());
-      
-      if ( !sFitType.Contains(sSpectraType.Data()) ) continue;
-      
+      TString sFitType(fitType->String());// Get fitType as a string
+
+      if ( !sFitType.Contains(sSpectraType.Data()) ) continue;// Checkpoint
+
       AliDebug(1,Form("<<<<<< fitType=%s bin=%s",sFitType.Data(),bin->Flavour().Data()));
-      
+
       std::cout << "" << std::endl;
       std::cout << "---------------" << "Fit " << added + 1 << "------------------" << std::endl;
       std::cout << "Fitting " << hname.Data() << " with " << sFitType.Data() << std::endl;
       std::cout << "" << std::endl;
-      
+
+      // Conf. for MC Tails (see function type)
       if ( sFitType.Contains("mctails",TString::kIgnoreCase) ) //FIXME: Find a univoque way to determine the correctly the fit type
       {
         TString sbin = bin->AsString();
         TString spectraMCName = spectraName;
         AliAnalysisMuMuBinning::Range* binMC = bin;
-        
+
         if ((sbin.Contains("MULT") || sbin.Contains("NCH") || sbin.Contains("DNCHDETA") || sbin.Contains("V0A") || sbin.Contains("V0ACENT") || sbin.Contains("V0C") || sbin.Contains("V0M") || sbin.Contains("NTRCORR")|| sbin.Contains("RELNTRCORR")) && !sbin.Contains("NTRCORRPT") && !sbin.Contains("NTRCORRY"))
         {
           //-------has to have a better way to do it
           AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
           b->AddBin("psi","INTEGRATED");
-          
+
           binMC = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
-          
+
           spectraMCName = b->GetName();
           delete b;
-          
-//          if ( flavour.Length() > 0 ) //Commented cause we set no flavour in "INTEGRATED" bin in the analysis task
-//          {
-//            spectraMCName += "-";
-//            spectraMCName += flavour;
-//          }
+
           if ( corrected )
           {
             spectraMCName += "-";
             spectraMCName += "AccEffCorr";
           }
           //-----------
-
         }
-//        if( sbin.Contains("NTRCORRPT") || !sbin.Contains("NTRCORRY") )
-//        {
-//          spectraMCName.Remove(4,7);
-//          
-//          if ( spectraMCName.Contains("PT") )
-//          {
-//            AliAnalysisMuMuBinning* b = SIM()->BIN();
-//            
-//            TObjArray* binsPt = b->CreateBinObjArray(particle,"PT","");
-//            
-//            Int_t nEntrBinMC = binsPt->GetEntries();
-//            
-////            binsPt->Print();
-//            
-//            binMC = static_cast<AliAnalysisMuMuBinning::Range*>(binsPt->At(binN));
-//            
-//            if ( binN == nEntrBinMC - 1 ) binN = -1;
-//            
-//          }
-//          
-//        }
-        
-        //par = GetCB2Tails(*binInt,"MCTAILS",eventType,trigger,pairCut,corrected);Why I was taking the tails from the fitted data spectra?
+
         GetParametersFromMC(sFitType,Form("/%s/%s",centrality,pairCut),spectraMCName.Data(),binMC);
-        
-        if (sFitType.Length()>0)
-        {
-          added += ( r->AddFit(sFitType.Data()) == kTRUE );
-        }
+
+        if (sFitType.Length()>0) added += ( r->AddFit(sFitType.Data()) == kTRUE );
       }
-      
+
+      //Config. for mpt (see function type)
       else if ( sFitType.Contains("mpt",TString::kIgnoreCase) && !sFitType.Contains("minv",TString::kIgnoreCase) )
       {
         std::cout << "++The Minv parameters will be taken from " << spectraName.Data() << std::endl;
         std::cout << "" << std::endl;
-        
+
         AliAnalysisMuMuSpectra* minvSpectra = dynamic_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(id.Data(),spectraName.Data()));
-       
+
         if ( !minvSpectra )
         {
           AliError(Form("Cannot fit mean pt: could not get the minv spectra for %s",id.Data()));
           continue;//return 0x0;
         }
-        
+
         AliAnalysisMuMuJpsiResult* minvResult = static_cast<AliAnalysisMuMuJpsiResult*>(minvSpectra->GetResultForBin(*bin));
-        
+
         if ( !minvResult )
         {
           AliError(Form("Cannot fit mean pt: could not get the minv result for bin %s in %s",bin->AsString().Data(),id.Data()));
           continue; //return 0x0;
         }
-        
+
         TObjArray* minvSubResults = minvResult->SubResults();
         TIter nextSubResult(minvSubResults);
         AliAnalysisMuMuJpsiResult* fitMinv;
         TString subResultName;
-        
+
         Int_t nSubFit(0);
         while ( ( fitMinv = static_cast<AliAnalysisMuMuJpsiResult*>(nextSubResult())) )
         {
           TString fitMinvName(fitMinv->GetName());
           fitMinvName.Remove(fitMinvName.First("_"),fitMinvName.Sizeof()-fitMinvName.First("_"));
-          
+
           if ( !sFitType.Contains(fitMinvName) ) continue; //FIXME: Ambiguous, i.e. NA60NEWPOL2EXP & NA60NEWPOL2 (now its ok cause only VWG and POL2EXP are used, but care)
-          
+
           std::cout << "" << std::endl;
           std::cout <<  "      /-- SubFit " << nSubFit + 1 << " --/ " << std::endl;
           std::cout << "" << std::endl;
 
           TString sMinvFitType(sFitType);
-          
+
           GetParametersFromResult(sMinvFitType,fitMinv);//FIXME: Think about if this is necessary
-          
+
           added += ( r->AddFit(sMinvFitType.Data()) == kTRUE );
-          
+
           nSubFit++;
         }
       }
-      
-      else if ( sFitType.Contains("minv&mpt",TString::kIgnoreCase) )
-      {
-        AliWarning("Implement here the method to do the combined minv mpt fits");
-        //FIXME: Shall we use the fitType or spectraType to choose to perform combined fits? Cause we have to check what kind of object is returned by the combined fit in order to decide if we put it in a different spectra(spectraType would be the flag,and here we should update the spectraName) or as a subresult(fitType in this case)
-      }
-      
+
+      //Config. for mpt and minv (see function type)
+      else if ( sFitType.Contains("minv&mpt",TString::kIgnoreCase) ) AliWarning("Implement here the method to do the combined minv mpt fits");
+      //FIXME: Shall we use the fitType or spectraType to choose to perform combined fits? Cause we have to check what kind of object is returned by the combined fit in order to decide if we put it in a different spectra(spectraType would be the flag,and here we should update the spectraName) or as a subresult(fitType in this case)
+
+
+      //Config. for the rest (see function type)
       else
       {
         if ( sFitType.Contains("PSICB2",TString::kIgnoreCase) || sFitType.Contains("PSINA60NEW",TString::kIgnoreCase)) std::cout << "+Free tails fit... " << std::endl;
         else if ( sFitType.Contains("PSICOUNT",TString::kIgnoreCase) )  std::cout << Form("+Just counting %s...",GetParticleName()) << std::endl;
-        else std::cout << "+Using predefined tails... " << std::endl; 
-        
-        if ( sFitType.Contains("minvJPsi") && !sparticleTmp.Contains("JPsi") )
-        {
+        else std::cout << "+Using predefined tails... " << std::endl;
+
+        if ( sFitType.Contains("minvJPsi") && !sparticleTmp.Contains("JPsi") ){
           std::cout << "This fitting funtion is set to fit JPsi: Skipping fit..." << std::endl;
           continue;
         }
-        if ( sFitType.Contains("minvPsiP") && !sparticleTmp.Contains("PsiP") )
-        {
+        if ( sFitType.Contains("minvPsiP") && !sparticleTmp.Contains("PsiP") ){
           std::cout << "This fitting funtion is set to fit PsiP: Skipping fit..." << std::endl;
           continue;
         }
-        
+        // Here we call  FINALLY the fit functions
         added += ( r->AddFit(sFitType.Data()) == kTRUE );
       }
-      
+
       std::cout << "-------------------------------------" << std::endl;
       std::cout << "" << std::endl;
     }
-  
-    if ( !added ) continue;
-    
-//    TObjArray* a = r->SubResults(); // TEST
-//    a->Print();
-    
-    flavour = bin->Flavour();
-    
-    if (!spectra)
-    {
+
+    if ( !added ) continue;// checkpoint
+
+
+    flavour = bin->Flavour();// Get <flavour>
+
+    // Implement <spectra> and set its name
+    if (!spectra){
+
       TString spectraSaveName = spectraName;
-      if ( !sSpectraType.CompareTo("mpt") )
-      {
+      
+      if ( !sSpectraType.CompareTo("mpt") ){
         spectraSaveName += "-";
         spectraSaveName += "MeanPtVsMinvUS";
       }
-      
+
       spectra = new AliAnalysisMuMuSpectra(spectraSaveName.Data());
     }
-    
+
     Bool_t adoptOk = spectra->AdoptResult(*bin,r); // We adopt the Result for current bin into the spectra
-    
+
     if ( adoptOk ) std::cout << "Result " << r->GetName() << " adopted in spectra " << spectra->GetName() << std::endl;
     else AliError(Form("Error adopting result %s in spectra %s",r->GetName(),spectra->GetName()));
-      
-    
-    if ( IsSimulation() )
-    {
+
+
+    if ( IsSimulation() ) {
+      std::cout << "Computing AccEff Value Spectra " << std::endl;
       SetNofInputParticles(*r);
     }
-  
-//    binN++;
+
+      //    binN++;
   } // loop on bins
-  
+
   delete fitTypeArray;
   delete bins;
-  
+
   return spectra;
 }
 
@@ -1164,28 +1837,28 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //{
 //  // Fit the dimuon mean pt spectra to find the particle mean pt
 //  // Returns an array of AliAnalysisMuMuResult objects
-//  
+//
 //  TObjArray* bins = binning.CreateBinObjArray(particle);
 //  if (!bins)
 //  {
 //    AliError(Form("Did not get any bin for particle %s",particle));
 //    return 0x0;
 //  }
-//  
+//
 //  //  AliAnalysisMuMuBinning* binningMinv(0x0);
 //  //  TObjArray* binsMinv(0x0);
 //  //  AliAnalysisMuMuBinning::Range* binInt(0x0);
 //  //  AliAnalysisMuMuBinning::Range* testbin = static_cast<AliAnalysisMuMuBinning::Range*>(bins->At(0));
 //  //  TString sbins = testbin->AsString();
-//  
+//
 //  //  if ( sbins.Contains("MULT")) //For the multiplicity bins we will use the tails from the integrated Minv spectra
 //  //  {
 //  //    binningMinv = spectraMinv.Binning();
 //  //    binsMinv = binningMinv->CreateBinObjArray(particle);
 //  //    binInt = static_cast<AliAnalysisMuMuBinning::Range*>(binsMinv->At(0));
 //  //  }
-//  
-//  
+//
+//
 //  TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
 //  if ( !triggers->FindObject(trigger) )
 //  {
@@ -1195,7 +1868,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //    return 0x0;
 //  }
 //  delete triggers;
-//  
+//
 //  TObjArray* events = fCounterCollection->GetKeyWords("event").Tokenize(",");
 //  if ( !events->FindObject(eventType) )
 //  {
@@ -1205,50 +1878,50 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //    return 0x0;
 //  }
 //  delete events;
-//  
+//
 //  Int_t ntrigger = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s",trigger,eventType)));
-//  
+//
 //  if  (ntrigger<=0)
 //  {
 //    AliError(Form("No trigger for trigger:%s/event:%s",trigger,eventType));
 //    delete bins;
 //    return 0x0;
 //  }
-//  
+//
 //  AliAnalysisMuMuSpectra* sMinv = static_cast<AliAnalysisMuMuSpectra*>(spectraMinv.Clone());
 //  if(!sMinv)
 //  {
 //    AliError("Did not find inv mass spectra");
 //  }
-//  
-//  
-//  //  binning.Print();
-//  
+//
+//
+//  //  binning.Print();
+//
 //  AliAnalysisMuMuSpectra* spectra(0x0);
-//  
+//
 //  AliAnalysisMuMuBinning::Range* bin;
 //  //  AliAnalysisMuMuBinning::Range* binMinv;
 //  TIter next(bins);
-//  
+//
 //  //  TObjArray* fitTypeArray = fFitTypeList.Tokenize(",");
 //  //  TIter nextFitType(fitTypeArray);
 //  //  TObjString* fitType;
 //  TString flavour;
-//  
-//  
+//
+//
 //  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
 //  {
 //    std::cout << "---------------------------------" << std::endl;
 //    std::cout << "Fitting mean Pt in " << bin->AsString().Data() << " " << "for" << " " << eventType << "/" << trigger << "/" << centrality << "/" << pairCut << std::endl;
 //    std::cout << "---------------------------------" << std::endl;
-//    
-//    
+//
+//
 //    TString pname;
 //    if ( corrected ) pname = Form("MeanPtVsMinvUS%s_Corr",bin->AsString().Data());
 //    else pname = Form("MeanPtVsMinvUS%s",bin->AsString().Data());
-//    
+//
 //    TProfile* hmPt = static_cast<TProfile*>(fMergeableCollection->GetObject(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut),pname.Data()));
-//    
+//
 //    if (!hmPt)
 //    {
 //      //      if (!fBinning && bin->IsNullObject() )
@@ -1256,7 +1929,7 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //      //        // old file, we only had MinvUSPt
 //      //        hminv = fMergeableCollection->Histo(Form("/%s/%s/%s/%s",eventType,trigger,centrality,pairCut),"MinvUSPt:py");
 //      //      }
-//      
+//
 //      //      if (!hmPt)
 //      //      {
 //      AliDebug(1,Form("Could not find histo profile %s",pname.Data()));
@@ -1264,10 +1937,10 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //      //      }
 //    }
 //    hmPt->Approximate();
-//    
-//    
+//
+//
 //    //    hmPt = static_cast<TH1*>(hmPt->Clone(Form("mPtv%d",n++))); //Reuse this
-//    
+//
 //    //    if ( sbins.Contains("MULT") )
 //    //    {
 //    //      binMinv = binInt;
@@ -1276,50 +1949,50 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //    //    {
 //    //      binMinv = bin;
 //    //    }
-//    
+//
 //    AliAnalysisMuMuJpsiResult* rMinv = static_cast<AliAnalysisMuMuJpsiResult*>(sMinv->GetResultForBin(*bin/*Minv*/));
-//    
+//
 //    if( !rMinv )
 //    {
 //      AliError(Form("Did not find inv mass result inside spectra for bin %s",bin/*Minv*/->Quantity().Data()));
 //    }
-//    
+//
 //    TObjArray* fits = rMinv->SubResults();
 //    AliAnalysisMuMuResult* fitMinv;
 //    TIter nextFit(fits);
 //    TString fitName;
-//    
+//
 //    AliAnalysisMuMuJpsiResult* r = new AliAnalysisMuMuJpsiResult(*hmPt,
 //                                                         trigger,
 //                                                         eventType,
 //                                                         pairCut,
 //                                                         centrality,
 //                                                         *bin);
-//    
+//
 //    r->SetNofTriggers(ntrigger);
-//    
+//
 //    nextFit.Reset();
-//    
+//
 //    //    new TCanvas;
 //    Int_t i = 1;
-//    
+//
 //    while ( ( fitMinv = static_cast<AliAnalysisMuMuJpsiResult*>(nextFit())) )
 //    {
 //      std::cout << "" << std::endl;
 //      std::cout << "---------------" << "Fit " << i << "------------------" << std::endl;
 //      i++;
-//      
+//
 //      fitName = fitMinv->Alias();
 //      std::cout << "" << std::endl;
 //      std::cout << "Getting signal parameters from " << eventType << "/" << trigger << "/" << centrality << "/" << pairCut << "/" << spectraMinv.GetName()  << std::endl;
 //      std::cout << "" << std::endl;
-//      
+//
 //      if(fitName.BeginsWith("JPSI2CB2VWG") || fitName.BeginsWith("MCTAILS"))
 //      {
 //        Double_t par[14] = {fitMinv->GetValue("kVWG"),fitMinv->GetValue("mVWG"),fitMinv->GetValue("sVWG1"),
 //          fitMinv->GetValue("sVWG2"),fitMinv->GetValue("kPsi"),fitMinv->GetValue("MeanJpsi"),fitMinv->GetValue("SigmaJpsi"),
 //          fitMinv->GetValue("alPsi"),fitMinv->GetValue("nlPsi"),fitMinv->GetValue("auPsi"),fitMinv->GetValue("nuPsi"),fitMinv->GetValue("kPsi'"),fitMinv->GetValue("NofJpsi"),fitMinv->GetErrorStat("NofJpsi")}; //Create a method to get the parameters //The last 2 parameters are not used in the fit
-//        
+//
 //        if(fitName.BeginsWith("JPSI2CB2VWG"))
 //        {
 //          std::cout << "PRE-SET TAILS" << std::endl;
@@ -1332,16 +2005,16 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //          std::cout << "" << std::endl;
 //          r->AddMeanPtFit("MCTAILS-JPSI2CB2VWG:2",&par[0]);
 //        }
-//        
-//        
+//
+//
 //      }
-//      
+//
 //      //Make a part for NA48 and the rest of fitting functions.
-//      
+//
 //    }
-//    
+//
 //    flavour = bin->Flavour();
-//    
+//
 //    if (!spectra)
 //    {
 //      TString spectraName(Form("MeanPtVsMinvUS-%s",binning.GetName()));
@@ -1355,24 +2028,24 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 //        spectraName += "-";
 //        spectraName += "Corr";
 //      }
-//      
+//
 //      spectra = new AliAnalysisMuMuSpectra(spectraName.Data());
 //    }
-//    
+//
 //    spectra->AdoptResult(*bin,r);
-//    
+//
 //    //    if ( IsSimulation() )
 //    //    {
 //    //      SetNofInputParticles(*r);
 //    //    }
-//    
-//    
+//
+//
 //  } // loop on bins
-//  
+//
 //  //  delete fitTypeArray;
 //  delete sMinv;
 //  delete bins;
-//  
+//
 //  return spectra;
 //}
 
@@ -1380,971 +2053,1000 @@ AliAnalysisMuMu::FitParticle(const char* particle,
 void
 AliAnalysisMuMu::GetParametersFromMC(TString& fitType, const char* pathCentrPairCut, const char* spectraName, AliAnalysisMuMuBinning::Range* bin) const
 {
-  /// Get the parameters from the associated simulation. Is intended to be used in minv fits, where we need the tails from JPsi (and Psi')
-  // We can choose between the 2 associated simulations (a JPsi and Psi' ones) by setting the sim variable to "sim1" (fAssociatedSimulation by default) or "sim2" (fAssociatedSimulation2)
-  
-  if ( !SIM() && !SIM2() )
-  {
-    AliError("Cannot get MC tails without associated simulation(s) file(s) !");
-    fitType = "";
-    return;
-  }
-  
-  TString subResultName("");
-  if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) ) subResultName = "PSINA60NEW";//_1.5_4.2
-  else if ( fitType.Contains("CB2",TString::kIgnoreCase) ) subResultName = "PSICB2";//_2.2_3.9
-  else
-  {
-    AliError("I don't know from which MC subresult take the tails");
-    return;
-  }
-    
-  TObjArray* simArr = new TObjArray;
-  if ( SIM() ) simArr->Add(SIM());
-  if ( SIM2() && fitType.Contains("INDEPTAILS",TString::kIgnoreCase) ) simArr->Add(SIM2()); // If we have set the key to get the JPsi ans PsiP tails
-  
-  TIter nextSim(simArr);
-  AliAnalysisMuMu* currentSIM;
-  
-  TString spath(pathCentrPairCut);
-  
-  spath.Prepend(Form("/%s",Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data()));//FIXME: Care with this when there is more than one selection in the list
-  spath.Prepend(Form("/%s",Config()->First(Config()->EventSelectionKey(),kTRUE).Data()));
-  
-  
-  while ( (currentSIM = static_cast<AliAnalysisMuMu*>(nextSim())) )
-  {
-    AliAnalysisMuMuSpectra* minvMCSpectra = currentSIM->SPECTRA(Form("%s/%s",spath.Data(),spectraName));
-    if (!minvMCSpectra)
-    {
-      AliError(Form("Could not find spectra %s/%s for associated simulation",spath.Data(),spectraName));
-      currentSIM->OC()->Print("*:Ali*");
-      fitType = "";
-      continue;
-    }
-    
-    AliAnalysisMuMuJpsiResult* minvMCResult = static_cast<AliAnalysisMuMuJpsiResult*>(minvMCSpectra->GetResultForBin(*bin));
-    if ( !minvMCResult )
-    {
-      AliError(Form("Cannot get MC tails cause the minv result for bin %s in %s/%s was not found",bin->AsString().Data(),spath.Data(),spectraName));
-      fitType = "";
-      continue;
-    }
-    
-    AliAnalysisMuMuJpsiResult* r = dynamic_cast<AliAnalysisMuMuJpsiResult*>(minvMCResult->SubResult(subResultName.Data())); //FIXME: Find an independet way of naming results
-    if  ( r && subResultName.Contains("PSICB2") )
-    {
-      fitType += Form(":al%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("al%s",currentSIM->GetParticleName())));
-      fitType += Form(":nl%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nl%s",currentSIM->GetParticleName())));
-      fitType += Form(":au%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("au%s",currentSIM->GetParticleName())));
-      fitType += Form(":nu%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nu%s",currentSIM->GetParticleName())));
-      
-      std::cout << " Using MC " << currentSIM->GetParticleName() << " CB2 tails... " << std::endl;
-      std::cout << std::endl;
-    }
-    else if ( r && subResultName.Contains("PSINA60NEW") )
-    {
-      fitType += Form(":p1L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1L%s",currentSIM->GetParticleName())));
-      fitType += Form(":p2L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2L%s",currentSIM->GetParticleName())));
-      fitType += Form(":p3L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3L%s",currentSIM->GetParticleName())));
-      fitType += Form(":p1R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1R%s",currentSIM->GetParticleName())));
-      fitType += Form(":p2R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2R%s",currentSIM->GetParticleName())));
-      fitType += Form(":p3R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3R%s",currentSIM->GetParticleName())));
-      
-      fitType += Form(":aL%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aL%s",currentSIM->GetParticleName())));
-      fitType += Form(":aR%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aR%s",currentSIM->GetParticleName())));
-      
-      std::cout << " Using MC " << currentSIM->GetParticleName() << " NA60New tails... " << std::endl;
-      std::cout << std::endl;
-    }
+    /// Get the parameters from the associated simulation. Is intended to be used in minv fits, where we need the tails from JPsi (and Psi')
+    // We can choose between the 2 associated simulations (a JPsi and Psi' ones) by setting the sim variable to "sim1" (fAssociatedSimulation by default) or "sim2" (fAssociatedSimulation2)
+
+    if ( !SIM() && !SIM2() )
+        {
+        AliError("Cannot get MC tails without associated simulation(s) file(s) !");
+        fitType = "";
+        return;
+        }
+
+    TString subResultName("");
+    if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) ) subResultName = "PSINA60NEW";//_1.5_4.2
+    else if ( fitType.Contains("CB2",TString::kIgnoreCase) ) subResultName = "PSICB2";//_2.2_3.9
     else
-    {
-      AliError(Form("Cannot get MC tails. MC Subresult %s not found",minvMCResult->GetName()));
-      fitType = "";
-    }
-  }
-  delete simArr;
+        {
+        AliError("I don't know from which MC subresult take the tails");
+        return;
+        }
+
+    TObjArray* simArr = new TObjArray;
+    if ( SIM() ) simArr->Add(SIM());
+    if ( SIM2() && fitType.Contains("INDEPTAILS",TString::kIgnoreCase) ) simArr->Add(SIM2()); // If we have set the key to get the JPsi ans PsiP tails
+
+    TIter nextSim(simArr);
+    AliAnalysisMuMu* currentSIM;
+
+    TString spath(pathCentrPairCut);
+
+    spath.Prepend(Form("/%s",Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data()));//FIXME: Care with this when there is more than one selection in the list
+    spath.Prepend(Form("/%s",Config()->First(Config()->EventSelectionKey(),kTRUE).Data()));
+
+
+    while ( (currentSIM = static_cast<AliAnalysisMuMu*>(nextSim())) )
+        {
+        AliAnalysisMuMuSpectra* minvMCSpectra = currentSIM->SPECTRA(Form("%s/%s",spath.Data(),spectraName));
+        if (!minvMCSpectra)
+            {
+            AliError(Form("Could not find spectra %s/%s for associated simulation",spath.Data(),spectraName));
+            currentSIM->OC()->Print("*:Ali*");
+            fitType = "";
+            continue;
+            }
+
+        AliAnalysisMuMuJpsiResult* minvMCResult = static_cast<AliAnalysisMuMuJpsiResult*>(minvMCSpectra->GetResultForBin(*bin));
+        if ( !minvMCResult )
+            {
+            AliError(Form("Cannot get MC tails cause the minv result for bin %s in %s/%s was not found",bin->AsString().Data(),spath.Data(),spectraName));
+            fitType = "";
+            continue;
+            }
+
+        AliAnalysisMuMuJpsiResult* r = dynamic_cast<AliAnalysisMuMuJpsiResult*>(minvMCResult->SubResult(subResultName.Data())); //FIXME: Find an independet way of naming results
+        if  ( r && subResultName.Contains("PSICB2") )
+            {
+            fitType += Form(":al%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("al%s",currentSIM->GetParticleName())));
+            fitType += Form(":nl%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nl%s",currentSIM->GetParticleName())));
+            fitType += Form(":au%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("au%s",currentSIM->GetParticleName())));
+            fitType += Form(":nu%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("nu%s",currentSIM->GetParticleName())));
+
+            std::cout << " Using MC " << currentSIM->GetParticleName() << " CB2 tails... " << std::endl;
+            std::cout << std::endl;
+            }
+        else if ( r && subResultName.Contains("PSINA60NEW") )
+            {
+            fitType += Form(":p1L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1L%s",currentSIM->GetParticleName())));
+            fitType += Form(":p2L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2L%s",currentSIM->GetParticleName())));
+            fitType += Form(":p3L%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3L%s",currentSIM->GetParticleName())));
+            fitType += Form(":p1R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p1R%s",currentSIM->GetParticleName())));
+            fitType += Form(":p2R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p2R%s",currentSIM->GetParticleName())));
+            fitType += Form(":p3R%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("p3R%s",currentSIM->GetParticleName())));
+
+            fitType += Form(":aL%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aL%s",currentSIM->GetParticleName())));
+            fitType += Form(":aR%s=%f",currentSIM->GetParticleName(),r->GetValue(Form("aR%s",currentSIM->GetParticleName())));
+
+            std::cout << " Using MC " << currentSIM->GetParticleName() << " NA60New tails... " << std::endl;
+            std::cout << std::endl;
+            }
+        else
+            {
+            AliError(Form("Cannot get MC tails. MC Subresult %s not found",minvMCResult->GetName()));
+            fitType = "";
+            }
+        }
+    delete simArr;
 }
 
 //_____________________________________________________________________________
 void
 AliAnalysisMuMu::GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const
 {
-  // Gets the parameters from a result, is intended to be used for mean pt fits where we need the signal and backgroud parameters
-  
-  AliWarning("Re-implement me !!!"); //FIXME: The parameters to get will depend on the fit function and also in this way is not suitable for other particles (ie Upsilon)(Find a way to get the particle(s) name)
-  
-  TString msg("");
-  if ( minvResult )
-  {
-    // We take the usual parameters (the ones from JPsi and the normalization of the Psi')
-    fitType += Form(":kJPsi=%f",minvResult->GetValue("kJPsi")); //FIXME: Names are not correct
-    fitType += Form(":mJPsi=%f",minvResult->GetValue("mJPsi"));
-    fitType += Form(":sJPsi=%f",minvResult->GetValue("sJPsi"));
-    
-    fitType += Form(":NofJPsi=%f",minvResult->GetValue("NofJPsi"));
-    fitType += Form(":ErrStatNofJPsi=%f",minvResult->GetErrorStat("NofJPsi"));
-    
-    fitType += Form(":kPsiP=%f",minvResult->GetValue("kPsiP"));
-    
-    TString minvName(minvResult->GetName());
-    
-    TString minvRangeParam = minvName;
-    minvRangeParam.Remove(0,minvRangeParam.First("_") + 1);
-    fitType += Form(":MinvRS=%s",minvRangeParam.Data());
-    
-    fitType += Form(":FSigmaPsiP=%f",minvResult->GetValue("FSigmaPsiP"));
-    
-    if ( fitType.Contains("CB2",TString::kIgnoreCase) )
-    {
-      fitType += Form(":alJPsi=%f",minvResult->GetValue("alJPsi"));
-      fitType += Form(":nlJPsi=%f",minvResult->GetValue("nlJPsi"));
-      fitType += Form(":auJPsi=%f",minvResult->GetValue("auJPsi"));
-      fitType += Form(":nuJPsi=%f",minvResult->GetValue("nuJPsi"));
-      
-      msg += "JPsi CB2 signal parameters";
-      //    fitType += Form(":NofPsiP=%f",minvResult->GetValue("NofPsiP"));
-      //    fitType += Form(":ErrStatNofPsiP=%f",minvResult->GetErrorStat("NofPsiP"));
-      
-      if ( fitType.Contains("INDEPTAILS") )
-      {
-//        minvName = minvResult->GetName();
-        if ( minvName.Contains("INDEPTAILS") )
+    // Gets the parameters from a result, is intended to be used for mean pt fits where we need the signal and backgroud parameters
+
+    AliWarning("Re-implement me !!!"); //FIXME: The parameters to get will depend on the fit function and also in this way is not suitable for other particles (ie Upsilon)(Find a way to get the particle(s) name)
+
+    TString msg("");
+    if ( minvResult )
         {
-          // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
-          fitType += Form(":alPsiP=%f",minvResult->GetValue("alPsiP"));
-          fitType += Form(":nlPsiP=%f",minvResult->GetValue("nlPsiP"));
-          fitType += Form(":auPsiP=%f",minvResult->GetValue("auPsiP"));
-          fitType += Form(":nuPsiP=%f",minvResult->GetValue("nuPsiP"));
-          fitType += Form(":mPsiP=%f",minvResult->GetValue("mPsiP"));
-          fitType += Form(":sPsiP=%f",minvResult->GetValue("sPsiP"));
-          
-          msg += " + PsiP CB2 signal parameters";
-        }
+        // We take the usual parameters (the ones from JPsi and the normalization of the Psi')
+        fitType += Form(":kJPsi=%f",minvResult->GetValue("kJPsi")); //FIXME: Names are not correct
+        fitType += Form(":mJPsi=%f",minvResult->GetValue("mJPsi"));
+        fitType += Form(":sJPsi=%f",minvResult->GetValue("sJPsi"));
+
+        fitType += Form(":NofJPsi=%f",minvResult->GetValue("NofJPsi"));
+        fitType += Form(":ErrStatNofJPsi=%f",minvResult->GetErrorStat("NofJPsi"));
+
+        fitType += Form(":kPsiP=%f",minvResult->GetValue("kPsiP"));
+
+        TString minvName(minvResult->GetName());
+
+        TString minvRangeParam = minvName;
+        minvRangeParam.Remove(0,minvRangeParam.First("_") + 1);
+        fitType += Form(":MinvRS=%s",minvRangeParam.Data());
+
+        fitType += Form(":FSigmaPsiP=%f",minvResult->GetValue("FSigmaPsiP"));
+
+        if ( fitType.Contains("CB2",TString::kIgnoreCase) )
+            {
+            fitType += Form(":alJPsi=%f",minvResult->GetValue("alJPsi"));
+            fitType += Form(":nlJPsi=%f",minvResult->GetValue("nlJPsi"));
+            fitType += Form(":auJPsi=%f",minvResult->GetValue("auJPsi"));
+            fitType += Form(":nuJPsi=%f",minvResult->GetValue("nuJPsi"));
+
+            msg += "JPsi CB2 signal parameters";
+            //    fitType += Form(":NofPsiP=%f",minvResult->GetValue("NofPsiP"));
+            //    fitType += Form(":ErrStatNofPsiP=%f",minvResult->GetErrorStat("NofPsiP"));
+
+            if ( fitType.Contains("INDEPTAILS") )
+                {
+                //        minvName = minvResult->GetName();
+                if ( minvName.Contains("INDEPTAILS") )
+                    {
+                    // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
+                    fitType += Form(":alPsiP=%f",minvResult->GetValue("alPsiP"));
+                    fitType += Form(":nlPsiP=%f",minvResult->GetValue("nlPsiP"));
+                    fitType += Form(":auPsiP=%f",minvResult->GetValue("auPsiP"));
+                    fitType += Form(":nuPsiP=%f",minvResult->GetValue("nuPsiP"));
+                    fitType += Form(":mPsiP=%f",minvResult->GetValue("mPsiP"));
+                    fitType += Form(":sPsiP=%f",minvResult->GetValue("sPsiP"));
+
+                    msg += " + PsiP CB2 signal parameters";
+                    }
+                else
+                    {
+                    AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
+                    fitType = "";
+                    return;
+                    }
+                }
+            }
+        else if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) )
+            {
+            fitType += Form(":p1LJPsi=%f",minvResult->GetValue("p1LJPsi"));
+            fitType += Form(":p2LJPsi=%f",minvResult->GetValue("p2LJPsi"));
+            fitType += Form(":p3LJPsi=%f",minvResult->GetValue("p3LJPsi"));
+            fitType += Form(":p1RJPsi=%f",minvResult->GetValue("p1RJPsi"));
+            fitType += Form(":p2RJPsi=%f",minvResult->GetValue("p2RJPsi"));
+            fitType += Form(":p3RJPsi=%f",minvResult->GetValue("p3RJPsi"));
+
+            fitType += Form(":aLJPsi=%f",minvResult->GetValue("aLJPsi"));
+            fitType += Form(":aRJPsi=%f",minvResult->GetValue("aRJPsi"));
+
+            msg += "JPsi NA60New signal parameters";
+
+            if ( fitType.Contains("INDEPTAILS") )
+                {
+                //        TString minvName(minvResult->GetName());
+                if ( minvName.Contains("INDEPTAILS") )
+                    {
+                    // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
+                    fitType += Form(":p1LPsiP=%f",minvResult->GetValue("p1LPsiP"));
+                    fitType += Form(":p2LPsiP=%f",minvResult->GetValue("p2LPsiP"));
+                    fitType += Form(":p3LPsiP=%f",minvResult->GetValue("p3LPsiP"));
+                    fitType += Form(":p1RPsiP=%f",minvResult->GetValue("p1RPsiP"));
+                    fitType += Form(":p2RPsiP=%f",minvResult->GetValue("p2RPsiP"));
+                    fitType += Form(":p3RPsiP=%f",minvResult->GetValue("p3RPsiP"));
+
+                    fitType += Form(":aLPsiP=%f",minvResult->GetValue("aLPsiP"));
+                    fitType += Form(":aRPsiP=%f",minvResult->GetValue("aRPsiP"));
+
+                    msg += " + PsiP NA60New signal parameters";
+
+                    }
+                else
+                    {
+                    AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
+                    fitType = "";
+                    return;
+                    }
+                }
+            }
         else
-        {
-          AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
-          fitType = "";
-          return;
-        }
-      }
-    }
-    else if ( fitType.Contains("NA60NEW",TString::kIgnoreCase) )
-    {
-      fitType += Form(":p1LJPsi=%f",minvResult->GetValue("p1LJPsi"));
-      fitType += Form(":p2LJPsi=%f",minvResult->GetValue("p2LJPsi"));
-      fitType += Form(":p3LJPsi=%f",minvResult->GetValue("p3LJPsi"));
-      fitType += Form(":p1RJPsi=%f",minvResult->GetValue("p1RJPsi"));
-      fitType += Form(":p2RJPsi=%f",minvResult->GetValue("p2RJPsi"));
-      fitType += Form(":p3RJPsi=%f",minvResult->GetValue("p3RJPsi"));
-      
-      fitType += Form(":aLJPsi=%f",minvResult->GetValue("aLJPsi"));
-      fitType += Form(":aRJPsi=%f",minvResult->GetValue("aRJPsi"));
-      
-      msg += "JPsi NA60New signal parameters";
-      
-      if ( fitType.Contains("INDEPTAILS") )
-      {
-//        TString minvName(minvResult->GetName());
-        if ( minvName.Contains("INDEPTAILS") )
-        {
-          // In case we use independent parameters tails for JPsi and Psi' we take also the Psi' ones
-          fitType += Form(":p1LPsiP=%f",minvResult->GetValue("p1LPsiP"));
-          fitType += Form(":p2LPsiP=%f",minvResult->GetValue("p2LPsiP"));
-          fitType += Form(":p3LPsiP=%f",minvResult->GetValue("p3LPsiP"));
-          fitType += Form(":p1RPsiP=%f",minvResult->GetValue("p1RPsiP"));
-          fitType += Form(":p2RPsiP=%f",minvResult->GetValue("p2RPsiP"));
-          fitType += Form(":p3RPsiP=%f",minvResult->GetValue("p3RPsiP"));
-          
-          fitType += Form(":aLPsiP=%f",minvResult->GetValue("aLPsiP"));
-          fitType += Form(":aRPsiP=%f",minvResult->GetValue("aRPsiP"));
-          
-          msg += " + PsiP NA60New signal parameters";
-          
+            {
+            AliError(Form("Cannot get the parameters from %s",minvResult->GetName()));
+            fitType = "";
+            return;
+            }
+        // Now we take the background parameters
+        if ( fitType.Contains("VWG_") || fitType.Contains("VWGINDEPTAILS") ) //FIXME: Check that cannot be misunderstood(like Exp x Pol2..). In fact it can be misunderstood since the meanpt function name has also the name of the function to fit the bkg (free parameters). Also add the rest of the BKG functions
+            {
+            fitType += Form(":kVWG=%f",minvResult->GetValue("kVWG"));
+            fitType += Form(":mVWG=%f",minvResult->GetValue("mVWG"));
+            fitType += Form(":sVWG1=%f",minvResult->GetValue("sVWG1"));
+            fitType += Form(":sVWG2=%f",minvResult->GetValue("sVWG2"));
+
+            msg += " + VWG Bkg parameters";
+            }
+        else if ( fitType.Contains("POL2EXP_") || fitType.Contains("POL2EXPINDEPTAILS") )
+            {
+            fitType += Form(":kPol2Exp=%f",minvResult->GetValue("kPol2Exp"));
+            fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
+            fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
+            fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
+            fitType += Form(":exp=%f",minvResult->GetValue("exp"));
+
+            msg += " + Pol2xExp Bkg parameters";
+            }
+        else if ( fitType.Contains("POL4EXP_") || fitType.Contains("POL4EXPINDEPTAILS") )
+            {
+            fitType += Form(":kPol4Exp=%f",minvResult->GetValue("kPol4Exp"));
+            fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
+            fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
+            fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
+            fitType += Form(":pol3=%f",minvResult->GetValue("pol3"));
+            fitType += Form(":pol4=%f",minvResult->GetValue("pol4"));
+            fitType += Form(":exp=%f",minvResult->GetValue("exp"));
+
+            msg += " + Pol4xExp Bkg parameters";
+            }
+        std::cout << "Using " << msg.Data() << " from " << minvResult->GetName() <<  " inv mass result" << std::endl;
+        std::cout << "" << std::endl;
         }
-        else
+    else
         {
-          AliError(Form("Cannot get PsiP tails from result. Result %s does not contain PsiP tails info => Fit will fail ",minvResult->GetName()));
-          fitType = "";
-          return;
+        AliError(Form("Cannot get tails from result. Result %s not found",minvResult->GetName()));
+        fitType = "";
+        return;
         }
-      }
-    }
-    else
-    {
-      AliError(Form("Cannot get the parameters from %s",minvResult->GetName()));
-      fitType = "";
-      return;
-    }
-    // Now we take the background parameters
-    if ( fitType.Contains("VWG_") || fitType.Contains("VWGINDEPTAILS") ) //FIXME: Check that cannot be misunderstood(like Exp x Pol2..). In fact it can be misunderstood since the meanpt function name has also the name of the function to fit the bkg (free parameters). Also add the rest of the BKG functions
-    {
-      fitType += Form(":kVWG=%f",minvResult->GetValue("kVWG"));
-      fitType += Form(":mVWG=%f",minvResult->GetValue("mVWG"));
-      fitType += Form(":sVWG1=%f",minvResult->GetValue("sVWG1"));
-      fitType += Form(":sVWG2=%f",minvResult->GetValue("sVWG2"));
-      
-      msg += " + VWG Bkg parameters";
-    }
-    else if ( fitType.Contains("POL2EXP_") || fitType.Contains("POL2EXPINDEPTAILS") )
-    {
-      fitType += Form(":kPol2Exp=%f",minvResult->GetValue("kPol2Exp"));
-      fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
-      fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
-      fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
-      fitType += Form(":exp=%f",minvResult->GetValue("exp"));
-      
-      msg += " + Pol2xExp Bkg parameters";
-    }
-    else if ( fitType.Contains("POL4EXP_") || fitType.Contains("POL4EXPINDEPTAILS") )
-    {
-      fitType += Form(":kPol4Exp=%f",minvResult->GetValue("kPol4Exp"));
-      fitType += Form(":pol0=%f",minvResult->GetValue("pol0"));
-      fitType += Form(":pol1=%f",minvResult->GetValue("pol1"));
-      fitType += Form(":pol2=%f",minvResult->GetValue("pol2"));
-      fitType += Form(":pol3=%f",minvResult->GetValue("pol3"));
-      fitType += Form(":pol4=%f",minvResult->GetValue("pol4"));
-      fitType += Form(":exp=%f",minvResult->GetValue("exp"));
-      
-      msg += " + Pol4xExp Bkg parameters";
-    }
-    std::cout << "Using " << msg.Data() << " from " << minvResult->GetName() <<  " inv mass result" << std::endl;
-    std::cout << "" << std::endl;
-  }
-  else
-  {
-    AliError(Form("Cannot get tails from result. Result %s not found",minvResult->GetName()));
-    fitType = "";
-    return;
-  }
 }
 
 //_____________________________________________________________________________
 ULong64_t AliAnalysisMuMu::GetTriggerScalerCount(const char* triggerList, Int_t runNumber)
 {
-  // Get the expected (from OCDB scalers) trigger count
-  
-  AliAnalysisTriggerScalers ts(runNumber,Config()->OCDBPath());
-  
-  TObjArray* triggers = TString(triggerList).Tokenize(",");
-  TObjString* trigger;
-  TIter next(triggers);
-  ULong64_t n(0);
-  
-  while ( ( trigger = static_cast<TObjString*>(next()) ) )
-  {
-    AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L2A",trigger->String().Data());
-    if (item)
-    {
-      n += item->Value();
-    }
-    delete item;
-  }
-  delete triggers;
-  
-  return n;
+    // Get the expected (from OCDB scalers) trigger count
+
+    AliAnalysisTriggerScalers ts(runNumber,Config()->OCDBPath());
+
+    TObjArray* triggers = TString(triggerList).Tokenize(",");
+    TObjString* trigger;
+    TIter next(triggers);
+    ULong64_t n(0);
+
+    while ( ( trigger = static_cast<TObjString*>(next()) ) )
+        {
+        AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L2A",trigger->String().Data());
+        if (item)
+            {
+            n += item->Value();
+            }
+        delete item;
+        }
+    delete triggers;
+
+    return n;
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuSpectra* AliAnalysisMuMu::GetSpectra(const char* what, const char* flavour) const
 {
-  /// get a given spectra
-  
-  TString swhat(what);
-  TString sflavour(flavour);
-  swhat.ToUpper();
-  sflavour.ToUpper();
-  
-  TString spectraName(Form("/%s/%s/PP/%s/PSI-%s",
-                           Config()->First(Config()->EventSelectionKey(),IsSimulation()).Data(),
-                           Config()->First(Config()->DimuonTriggerKey(),IsSimulation()).Data(),
-                           Config()->First(Config()->PairSelectionKey(),IsSimulation()).Data(),
-                           swhat.Data()));
+    /// get a given spectra
 
-  if (sflavour.Length()>0)
-  {
-    spectraName += "-";
-    spectraName += sflavour.Data();
-  }
+    TString swhat(what);
+    TString sflavour(flavour);
+    swhat.ToUpper();
+    sflavour.ToUpper();
 
-  return SPECTRA(spectraName.Data());
-}
+    TString spectraName(Form("/%s/%s/%s/%s/PSI-%s",
+                             Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
+                             Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
+                             Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
+                             Config()->First(Config()->PairSelectionKey(),kFALSE).Data(),
+                             swhat.Data()));
 
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::PlotAccEfficiency(const char* whatever)
-{
-  //FIXME::Make it general
-  if ( !IsSimulation() )
-  {
-    AliError("Could not get AccxEff histo: Not simulation file");
-    return 0x0;
-  }
-  
-  TString path(Form("/%s/%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kTRUE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kTRUE).Data(),
-                    Config()->First(Config()->PairSelectionKey(),kTRUE).Data()));
-  
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/%s",path.Data(),whatever)));
-  if ( !s )
-  {
-    AliError(Form("No AccEff spectra %s found in %s",whatever,path.Data()));
-    return 0x0;
-  }
-  
-  return s->Plot(Form("AccEff%s",GetParticleName()),"PSICOUNT",kFALSE);//_2.2_3.9
-                                                                                         
+    cout << "spectraName : " << spectraName.Data() << endl;
+
+    if (sflavour.Length()>0){
+      spectraName += "-";
+      spectraName += sflavour.Data();
+    }
+
+    return SPECTRA(spectraName.Data());
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeRelativeValueAndSESystematics(const char* quantity,const char* flavour,const char* value2Test, const char* binListToExclude, const char* fNormType, const char* evSelInt, const char* evSelDiff, const char* triggerCluster)
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::GetMCSpectra(const char* what , const char* EventSelection,  const char* DimuonTrigger,
+  const char* Centrality, const char* PairSelectionKey, const char* flavour) const
 {
-  /// Compute the relative (bin/integrated) Jpsi yield or <pT> in "quantity,flavour" bins from the mean value of the relative values of the tests used for the systematic uncertainty of signal extraction computation. Store also the systematic uncertainty tests.
-  ///
-  /// Important considerations:
-  ///   - No corrections can be applied to the yields or x-axis with this method
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL (for the integrated signal extraction) and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly.
-  ///
-  /// Parameters:
-  ///   - what,quantity and flavour defines the binning to test (output will be 1 plot per bin)
-  /// value2test is the observable we want to test ( i.e. NJpsi(bin)/integratedNJpsi, <pt>(bin)/integrated<pt>... )
-  ///   - value2test == yield -> NJpsi(bin)/integratedNJpsi
-  ///   - value2test == mpt -> <pt>(bin)/integrated<pt>
-  ///   - relative: kTRUE if relative yield (y/y_int) wants to be computed. Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
-  ///   - fNormType: Desired FNorm to use: "offline", "global" or "mean"
-  ///   - evSelInt: Event selection to compute integrated NofJpsi
-  ///   - evSelDiff: Event selection to compute diferential NofJpsi
-  ///   - triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-
-
-  TString sfNormType(fNormType);
-  TString sevSelInt(evSelInt);
-  TString sevSelDiff(evSelDiff);
+    /// get a given spectra
 
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi yield: Is a simulation file");
-    return;
-  }
+    TString swhat(what);
+    TString sflavour(flavour);
+    swhat.ToUpper();
+    sflavour.ToUpper();
 
-  TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
-  TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
-  TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
-  
-  //Path to get/store integrated results from Mergeable Collection
-  TString intPath(Form("%s/%s/%s/%s",
-                       sevSelInt.Data(),
-                       dimuonTriggerClassName.Data(),
-                       centralitySelection.Data(),
-                       pairSelection.Data()));
-
-  //Path to get/store differential results from Mergeable Collection
-  TString diffPath(Form("%s/%s/%s/%s",
-                        sevSelDiff.Data(),
-                        dimuonTriggerClassName.Data(),
-                        centralitySelection.Data(),
-                        pairSelection.Data()));
-
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
+    TString spectraName(Form("/%s/%s/%s/%s/PSI-%s",
+                             EventSelection,
+                             DimuonTrigger,
+                             Centrality,
+                             PairSelectionKey,
+                             swhat.Data()));
 
-  TString svalue2Test(value2Test);
-  TString shName("");
-  TString sObsInt("");
-  TString sObsBin("");
-  TString sflavour(flavour);
-  TString squantity(quantity);
-  squantity.ToUpper();
-  
-  TH1* hMB(0x0);
-  Double_t nEqMBTot(0.),nEqMBTotError(0.);
-  if ( !svalue2Test.CompareTo("yield",TString::kIgnoreCase) )
-  {
-    sObsInt = "PSI-INTEGRATED-AccEffCorr";
-    sObsBin = Form("PSI-%s-AccEffCorr",squantity.Data());
-    svalue2Test = "NofJPsi";
-    shName = "N^{J/#psi}_{bin}/N^{J/#psi}_{int}";
+    cout << "spectraName MC : " << spectraName.Data() << endl;
 
-     TH1* hMBTot = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data()));
-    if ( !hMBTot )
+    if (sflavour.Length()>0)
     {
-      AliWarning(Form("No eq Nof MB events found in %s: Yield will not be calculated",Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data())));
+      spectraName += "-";
+      spectraName += sflavour.Data();
     }
-    nEqMBTot = hMBTot->GetBinContent(1);
-    nEqMBTotError = hMBTot->GetBinError(1);
 
+    return SPECTRA(spectraName.Data());
+}
 
-    if ( sfNormType.Contains("offline") )
-    {
-      hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),sevSelDiff.Data(),quantity));
-      if ( !hMB )
-      {
-        AliWarning(Form("Histo hNofEqMBVS%s not found: Yield will not be calculated",quantity));
-      }
+//_____________________________________________________________________________
+TH1* AliAnalysisMuMu::PlotAccEfficiency(const char* whatever)
+{
+    //FIXME::Make it general
+    if ( !IsSimulation() )
+        {
+        AliError("Could not get AccxEff histo: Not simulation file");
+        return 0x0;
+        }
 
-      std::cout << " Using Fnorm from offline method " << std::endl;
-      std::cout <<  std::endl;
-    }
-    else if ( sfNormType.Contains("global") )
-    {
-      hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),sevSelDiff.Data(),quantity));
-      if ( !hMB )
-      {
-        AliError(Form("Histo hNofEqMBVS%sFromGlobal not found: Yield will not be calculated",quantity));
-      }
+    TString path(Form("/%s/%s/%s/%s",
+                      Config()->First(Config()->EventSelectionKey(),kTRUE).Data(),
+                      Config()->First(Config()->DimuonTriggerKey(),kTRUE).Data(),
+                      Config()->First(Config()->CentralitySelectionKey(),kTRUE).Data(),
+                      Config()->First(Config()->PairSelectionKey(),kTRUE).Data()));
 
-      std::cout << " Using Fnorm from global method " << std::endl;
-      std::cout <<  std::endl;
-    }
-    else if ( sfNormType.Contains("mean") )
-    {
-      hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromMean",striggerCluster.Data(),sevSelDiff.Data(),quantity));
-      if ( !hMB )
-      {
-        AliError(Form("Histo hNofEqMBVS%sFromMean not found: Yield will not be calculated",quantity));
-      }
+    AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/%s",path.Data(),whatever)));
+    if ( !s )
+        {
+        AliError(Form("No AccEff spectra %s found in %s",whatever,path.Data()));
+        return 0x0;
+        }
 
-      std::cout << " Using mean Fnorm " << std::endl;
-      std::cout <<  std::endl;
-    }
+    return s->Plot(Form("AccEff%s",GetParticleName()),"PSICOUNT",kFALSE);//_2.2_3.9
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeRelativeValueAndSESystematics(const char* quantity,const char* flavour,const char* value2Test, const char* binListToExclude, const char* fNormType, const char* evSelInt, const char* evSelDiff, const char* triggerCluster)
+{
+    /// Compute the relative (bin/integrated) Jpsi yield or <pT> in "quantity,flavour" bins from the mean value of the relative values of the tests used for the systematic uncertainty of signal extraction computation. Store also the systematic uncertainty tests.
+    ///
+    /// Important considerations:
+    ///   - No corrections can be applied to the yields or x-axis with this method
+    ///
+    ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
+    ///
+    ///   - The analysed file must contain the event selection PSALL (for the integrated signal extraction) and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly.
+    ///
+    /// Parameters:
+    ///   - what,quantity and flavour defines the binning to test (output will be 1 plot per bin)
+    /// value2test is the observable we want to test ( i.e. NJpsi(bin)/integratedNJpsi, <pt>(bin)/integrated<pt>... )
+    ///   - value2test == yield -> NJpsi(bin)/integratedNJpsi
+    ///   - value2test == mpt -> <pt>(bin)/integrated<pt>
+    ///   - relative: kTRUE if relative yield (y/y_int) wants to be computed. Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
+    ///   - fNormType: Desired FNorm to use: "offline", "global" or "mean"
+    ///   - evSelInt: Event selection to compute integrated NofJpsi
+    ///   - evSelDiff: Event selection to compute diferential NofJpsi
+    ///   - triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
+
+
+    TString sfNormType(fNormType);
+    TString sevSelInt(evSelInt);
+    TString sevSelDiff(evSelDiff);
+
+    if ( IsSimulation() )
+        {
+        AliError("Cannot compute J/Psi yield: Is a simulation file");
+        return;
+        }
+    TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
+    TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
+    TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
+
+    TString intPath(Form("%s/%s/%s/%s",
+                         sevSelInt.Data(),
+                         dimuonTriggerClassName.Data(),
+                         centralitySelection.Data(),
+                         pairSelection.Data())); //Path to get/store integrated results from Mergeable Collection
+
+    TString diffPath(Form("%s/%s/%s/%s",
+                          sevSelDiff.Data(),
+                          dimuonTriggerClassName.Data(),
+                          centralitySelection.Data(),
+                          pairSelection.Data())); //Path to get/store differential results from Mergeable Collection
+
+    TString striggerCluster(triggerCluster);
+    if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
+    else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
+    else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
     else
-    {
-      AliWarning("Dont know what Fnorm use: Yield will not be calculated");
-    }
+        {
+        AliError("Unknown trigger cluster");
+        return;
+        }
 
-  }
-  else if ( !svalue2Test.CompareTo("mpt",TString::kIgnoreCase) )
-  {
-    sObsInt = "PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS";
-    sObsBin = Form("PSI-%s-AccEffCorr-MeanPtVsMinvUS",squantity.Data());
-    svalue2Test = "MeanPtJPsi";
-    shName = "<p_{t}>^{bin}/<p_{t}>^{int}";
-  }
-  else
-  {
-    AliError("unrecognized value to test");
-    return;
-  }
+    TString svalue2Test(value2Test);
+    TString shName("");
+    TString sObsInt("");
+    TString sObsBin("");
+    TString sflavour(flavour);
+    TString squantity(quantity);
+    squantity.ToUpper();
+
+    TH1* hMB(0x0);
+    Double_t nEqMBTot(0.),nEqMBTotError(0.);
+    if ( !svalue2Test.CompareTo("yield",TString::kIgnoreCase) )
+        {
+        sObsInt = "PSI-INTEGRATED-AccEffCorr";
+        sObsBin = Form("PSI-%s-AccEffCorr",squantity.Data());
+        svalue2Test = "NofJPsi";
+        shName = "N^{J/#psi}_{bin}/N^{J/#psi}_{int}";
 
-  TString id(Form("/TESTSYST/%s/%s",sevSelInt.Data(),sevSelDiff.Data()));
+        TH1* hMBTot = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data()));
+        if ( !hMBTot )
+            {
+            AliWarning(Form("No eq Nof MB events found in %s: Yield will not be calculated",Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data())));
+            }
+        nEqMBTot = hMBTot->GetBinContent(1);
+        nEqMBTotError = hMBTot->GetBinError(1);
 
-  //________Get the integrated results
-  AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),sObsInt.Data())));
-  if ( !sInt )
-  {
-    AliError(Form("No integrated spectra %s found in %s",sObsInt.Data(),intPath.Data()));
-    return;
-  }
 
-  TObjArray* bin = BIN()->CreateBinObjArray("psi","integrated","");
-  if ( !bin )
-  {
-    AliError("No integrated bin found");
-    return;
-  }
-  AliAnalysisMuMuBinning::Range* r = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(0));
+        if ( sfNormType.Contains("offline") )
+            {
+            hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),sevSelDiff.Data(),quantity));
+            if ( !hMB )
+                {
+                AliWarning(Form("Histo hNofEqMBVS%s not found: Yield will not be calculated",quantity));
+                }
 
-  AliAnalysisMuMuJpsiResult* resInt =  static_cast<AliAnalysisMuMuJpsiResult*>(sInt->GetResultForBin(*r));
-  if ( !resInt )
-  {
-    AliError(Form("No integrated result found in spectra %s at %s",sObsInt.Data(),intPath.Data()));
-    return;
-  }
-  TObjArray* sresIntArray = resInt->SubResults();
+            std::cout << " Using Fnorm from offline method " << std::endl;
+            std::cout <<  std::endl;
+            }
+        else if ( sfNormType.Contains("global") )
+            {
+            hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),sevSelDiff.Data(),quantity));
+            if ( !hMB )
+                {
+                AliError(Form("Histo hNofEqMBVS%sFromGlobal not found: Yield will not be calculated",quantity));
+                }
 
-  delete bin;
-  //_________________________
+            std::cout << " Using Fnorm from global method " << std::endl;
+            std::cout <<  std::endl;
+            }
+        else if ( sfNormType.Contains("mean") )
+            {
+            hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromMean",striggerCluster.Data(),sevSelDiff.Data(),quantity));
+            if ( !hMB )
+                {
+                AliError(Form("Histo hNofEqMBVS%sFromMean not found: Yield will not be calculated",quantity));
+                }
 
+            std::cout << " Using mean Fnorm " << std::endl;
+            std::cout <<  std::endl;
+            }
+        else
+            {
+            AliWarning("Dont know what Fnorm use: Yield will not be calculated");
+            }
 
-  bin = BIN()->CreateBinObjArray("psi",squantity.Data(),sflavour.Data());
-  if ( !bin )
-  {
-    AliError(Form("%s-%s-%s binning does not exist","psi",squantity.Data(),sflavour.Data()));
-    return;
-  }
-  
-  //_______ Exclude desired bins
-  TIter nextBinTest(bin);
-
-  TString sbinListToExclude(binListToExclude);
-  TObjArray* abinListToExclude = sbinListToExclude.Tokenize(",");
-  TIter nextBinToExclude(abinListToExclude);
-  Int_t excl(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBinTest()) ) ) //Bin loop
-  {
-    nextBinToExclude.Reset();
-    TObjString* s(0x0);
-    while ( (s = static_cast<TObjString*>(nextBinToExclude())) )
-    {
-      if ( !r->AsString().CompareTo(s->GetString().Data()) )
-      {
-        std::cout << "Removing bin " << s->GetString().Data() << std::endl;
-        bin->RemoveAt(excl);
-      }
-    }
-    excl++;
-  }
-  std::cout <<  std::endl;
-  bin->Compress();
-  //_________________
-
-
-  //______Create arrays to store values inside
-  Int_t nbin = bin->GetEntries();
-  Int_t nsres = sresIntArray->GetEntries();
-  TObjArray* sResultNameArray= new TObjArray();
-  sResultNameArray->SetOwner();
-  std::vector<std::vector<double> > valuesArr;
-  valuesArr.resize(nbin+1, std::vector<double>(nsres,0));
-  std::vector<std::vector<double> > valuesErrorArr;
-  valuesErrorArr.resize(nbin+1, std::vector<double>(nsres,0));
-  //_________________________
-
-
-  //________Get the integrated values from results
-  TIter nextIntSubResult(sresIntArray);
-  AliAnalysisMuMuResult* sresInt(0x0);
-
-  TString testSig(""); //Strings for testing the name of the subresult to extract the number of tests for the systematics
-  TString testSPsip("");
-  TString testSresIntNameSig("");
-  TString testSresIntNameSPsip("");
-
-  Int_t nFitsSameSignal(0);
-  Int_t j(0);
-  while ( ( sresInt = static_cast<AliAnalysisMuMuResult*>(nextIntSubResult()) ) ) //Integrated SubResult loop
-  {
-    TString sresIntName(sresInt->GetName());
-    
-    valuesArr[0][j] = sresInt->GetValue(svalue2Test.Data());
-    valuesErrorArr[0][j] = sresInt->GetErrorStat(svalue2Test.Data());
-    sResultNameArray->Add(new TObjString(sresIntName.Data()));
+        }
+    else if ( !svalue2Test.CompareTo("mpt",TString::kIgnoreCase) )
+        {
+        sObsInt = "PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS";
+        sObsBin = Form("PSI-%s-AccEffCorr-MeanPtVsMinvUS",squantity.Data());
+        svalue2Test = "MeanPtJPsi";
+        shName = "<p_{t}>^{bin}/<p_{t}>^{int}";
+        }
+    else
+        {
+        AliError("unrecognized value to test");
+        return;
+        }
 
-    if ( j ==0 ) // Get the first and last part of name of the first subresult
-    {
-      testSresIntNameSig = sresIntName.Data();
-      testSresIntNameSPsip = sresIntName.Data();
+    TString id(Form("/TESTSYST/%s/%s",sevSelInt.Data(),sevSelDiff.Data()));
 
-      testSresIntNameSig.Remove(3,testSresIntNameSig.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
-      testSresIntNameSPsip.Remove(0,testSresIntNameSPsip.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
-    }
+    //________Get the integrated results
+    AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),sObsInt.Data())));
+    if ( !sInt )
+        {
+        AliError(Form("No integrated spectra %s found in %s",sObsInt.Data(),intPath.Data()));
+        return;
+        }
 
-    if ( sresIntName.Contains(testSresIntNameSig.Data()) && sresIntName.Contains(testSresIntNameSPsip.Data()) ) //This counts the number of times a fit with the same signal and same SigmaPsiP is repeated. This will be the number of tests for a given signal.
-    {
-      nFitsSameSignal++;
-    }
-    j++;
-  }
+    TObjArray* bin = BIN()->CreateBinObjArray("psi","integrated","");
+    if ( !bin )
+        {
+        AliError("No integrated bin found");
+        return;
+        }
+    AliAnalysisMuMuBinning::Range* r = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(0));
+
+    AliAnalysisMuMuJpsiResult* resInt =  static_cast<AliAnalysisMuMuJpsiResult*>(sInt->GetResultForBin(*r));
+    if ( !resInt )
+        {
+        AliError(Form("No integrated result found in spectra %s at %s",sObsInt.Data(),intPath.Data()));
+        return;
+        }
+    TObjArray* sresIntArray = resInt->SubResults();
 
-  std::cout << "Number of tests per signal/SigmaPsi' combination = " << nFitsSameSignal << std::endl;
-  std::cout <<  std::endl;
-  //____________________________________
-  
-  //__________Get the bin per bin results and the values
-  AliAnalysisMuMuSpectra* sBin = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),sObsBin.Data())));
-  if ( !sBin )
-  {
-    AliError(Form("No integrated spectra %s found in %s",sObsBin.Data(),diffPath.Data()));
     delete bin;
-    delete sResultNameArray;
-    return;
-  }
-  
-  TIter nextBin(bin);
-  AliAnalysisMuMuJpsiResult* sresBin(0x0);
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    sresBin =  static_cast<AliAnalysisMuMuJpsiResult*>(sBin->GetResultForBin(*r));
-    if ( !sresBin )
-    {
-      AliError(Form("No result found in spectra %s at %s for bin %s",sObsInt.Data(),diffPath.Data(),r->AsString().Data()));
-      delete bin;
-      delete sResultNameArray;
-      return;
-    }
-    
-    TObjArray* sresBinArray = sresBin->SubResults();
-    
-    if ( nsres != sresBinArray->GetEntries() )
-    {
-      AliError("Integrated and bins spectra have different number of subresults");
-      delete bin;
-      delete sResultNameArray;
-      return;
-    }
+    //_________________________
 
-    TIter nextSubResult(sresBinArray);
-    j = 0;
-    while ( (sresBin = static_cast<AliAnalysisMuMuJpsiResult*>(nextSubResult())) ) // Subresults loop
-    {
-      valuesArr[i][j] = sresBin->GetValue(svalue2Test.Data());
-      valuesErrorArr[i][j] = sresBin->GetErrorStat(svalue2Test.Data());
-      
-      j++;
 
-    } //End Subresults loop
-    i++;
+    bin = BIN()->CreateBinObjArray("psi",squantity.Data(),sflavour.Data());
+    if ( !bin )
+        {
+        AliError(Form("%s-%s-%s binning does not exist","psi",squantity.Data(),sflavour.Data()));
+        return;
+        }
 
-  } //End bin loop
-  //___________________________
+    //_______ Exclude desired bins
+    TIter nextBinTest(bin);
 
+    TString sbinListToExclude(binListToExclude);
+    TObjArray* abinListToExclude = sbinListToExclude.Tokenize(",");
+    TIter nextBinToExclude(abinListToExclude);
+    Int_t excl(0);
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBinTest()) ) ) //Bin loop
+        {
+        nextBinToExclude.Reset();
+        TObjString* s(0x0);
+        while ( (s = static_cast<TObjString*>(nextBinToExclude())) )
+            {
+            if ( !r->AsString().CompareTo(s->GetString().Data()) )
+                {
+                std::cout << "Removing bin " << s->GetString().Data() << std::endl;
+                bin->RemoveAt(excl);
+                }
+            }
+        excl++;
+        }
+    std::cout <<  std::endl;
+    bin->Compress();
+    //_________________
+
+
+    //______Create arrays to store values inside
+    Int_t nbin = bin->GetEntries();
+    Int_t nsres = sresIntArray->GetEntries();
+    TObjArray* sResultNameArray= new TObjArray();
+    sResultNameArray->SetOwner();
+    std::vector<std::vector<double> > valuesArr;
+    valuesArr.resize(nbin+1, std::vector<double>(nsres,0));
+    std::vector<std::vector<double> > valuesErrorArr;
+    valuesErrorArr.resize(nbin+1, std::vector<double>(nsres,0));
+    //_________________________
+
+
+    //________Get the integrated values from results
+    TIter nextIntSubResult(sresIntArray);
+    AliAnalysisMuMuResult* sresInt(0x0);
+
+    TString testSig(""); //Strings for testing the name of the subresult to extract the number of tests for the systematics
+    TString testSPsip("");
+    TString testSresIntNameSig("");
+    TString testSresIntNameSPsip("");
+
+    Int_t nFitsSameSignal(0);
+    Int_t j(0);
+    while ( ( sresInt = static_cast<AliAnalysisMuMuResult*>(nextIntSubResult()) ) ) //Integrated SubResult loop
+        {
+        TString sresIntName(sresInt->GetName());
 
-  //____________Compute the value ratios and systematic uncertainties on the ratios bin by bin
+        valuesArr[0][j] = sresInt->GetValue(svalue2Test.Data());
+        valuesErrorArr[0][j] = sresInt->GetErrorStat(svalue2Test.Data());
+        sResultNameArray->Add(new TObjString(sresIntName.Data()));
 
-      //______ Create histos to store signal extraction systematic uncertainties
-  TH1* hsyst = new TH1F(Form("%s_Systematics",value2Test),Form("%s Systematics results",value2Test),nbin,0,nbin);
-      //_________________________________
+        if ( j ==0 ) // Get the first and last part of name of the first subresult
+            {
+            testSresIntNameSig = sresIntName.Data();
+            testSresIntNameSPsip = sresIntName.Data();
 
-      //______ Create histos to store relative Jpsi yield or <p_T> vs bins
-  Int_t size = bin->GetEntriesFast();
-  Double_t* axis = new Double_t[size+1];
-  TIter next(bin);
-  AliAnalysisMuMuBinning::Range* b;
-  TH1* hy(0x0);
-  i = 0;
-  while ( ( b = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    axis[i] = b->Xmin();
-    ++i;
-  }
+            testSresIntNameSig.Remove(3,testSresIntNameSig.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
+            testSresIntNameSPsip.Remove(0,testSresIntNameSPsip.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
+            }
 
-  b = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(size-1));
+        if ( sresIntName.Contains(testSresIntNameSig.Data()) && sresIntName.Contains(testSresIntNameSPsip.Data()) ) //This counts the number of times a fit with the same signal and same SigmaPsiP is repeated. This will be the number of tests for a given signal.
+            {
+            nFitsSameSignal++;
+            }
+        j++;
+        }
 
-  axis[i] = b->Xmax();
+    std::cout << "Number of tests per signal/SigmaPsi' combination = " << nFitsSameSignal << std::endl;
+    std::cout <<  std::endl;
+    //____________________________________
 
-  if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
-  {
-    hy = new TH1D(Form("hMeanJPsiYieldVS%sRelative",quantity),Form("Relative J/#psi yield vs %s;%s;Y^{J/#psi}/Y^{J/#psi}_{int}",quantity,quantity)
-                  ,size,axis);
-  }
-  else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
-  {
-    hy = new TH1D(Form("hMeanJPsiMPtVS%sRelative",quantity),Form("Relative J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}/<p_{T}>^{J/#psi}_{int}",quantity,quantity)
-                  ,size,axis);
-  }
+    //__________Get the bin per bin results and the values
+    AliAnalysisMuMuSpectra* sBin = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),sObsBin.Data())));
+    if ( !sBin )
+        {
+        AliError(Form("No integrated spectra %s found in %s",sObsBin.Data(),diffPath.Data()));
+        delete bin;
+        delete sResultNameArray;
+        return;
+        }
 
-  if ( !hy )
-  {
-    AliError("No histogram created to store the results");
-    return;
-  }
-  delete[] axis;
-       //_________________________________
 
-  TString binName("");
-  for ( Int_t b = 1 ; b <= size ; b++ ) //Bin loop
-  {
+    TIter nextBin(bin);
+    AliAnalysisMuMuJpsiResult* sresBin(0x0);
+    Int_t i(1);
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
+        {
+        sresBin =  static_cast<AliAnalysisMuMuJpsiResult*>(sBin->GetResultForBin(*r));
+        if ( !sresBin )
+            {
+            AliError(Form("No result found in spectra %s at %s for bin %s",sObsInt.Data(),diffPath.Data(),r->AsString().Data()));
+            delete bin;
+            delete sResultNameArray;
+            return;
+            }
 
-    binName = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(b-1))->AsString().Data();
-//    TString savePath(Form("%s/%s",id.Data(),binName.Data()));
+        TObjArray* sresBinArray = sresBin->SubResults();
 
-    Int_t binUCTotal(1);
+        if ( nsres != sresBinArray->GetEntries() )
+            {
+            AliError("Integrated and bins spectra have different number of subresults");
+            delete bin;
+            delete sResultNameArray;
+            return;
+            }
 
-    TH1* hratiosBin = new TH1D(Form("SystTests_%s_Bkg_%s",sObsBin.Data(),binName.Data()),
-                               Form("%s Systematics tests for %s",binName.Data(),shName.Data()),j*nFitsSameSignal,0,
-                               j*nFitsSameSignal);
+        TIter nextSubResult(sresBinArray);
+        j = 0;
+        while ( (sresBin = static_cast<AliAnalysisMuMuJpsiResult*>(nextSubResult())) ) // Subresults loop
+            {
+            valuesArr[i][j] = sresBin->GetValue(svalue2Test.Data());
+            valuesErrorArr[i][j] = sresBin->GetErrorStat(svalue2Test.Data());
 
-    for ( Int_t k = 0 ; k < j ; k++ ) // Subresults loop for integrated values
-    {
-      //__Get the name of the signal and the Psi' sigma for the integrated result
-      TString signalNameInt(sResultNameArray->At(k)->GetName());
-      TString sPsiPNameInt(signalNameInt.Data());
+            j++;
 
-      signalNameInt.Remove(3,signalNameInt.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
-      sPsiPNameInt.Remove(0,sPsiPNameInt.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
-      //__
+            } //End Subresults loop
+        i++;
 
-      //      Int_t sizeName = signalName.Sizeof();
-      //      signalName.Remove(2,sizeName-3);
-      //      Int_t binUC(1);
+        } //End bin loop
+    //___________________________
 
-      for ( Int_t l = 0; l < j ; l++) //Subresults loop for bins values
-      {
-        TString binSignalName(sResultNameArray->At(l)->GetName());
 
-        Double_t ratio,ratioError(0.);
+    //____________Compute the value ratios and systematic uncertainties on the ratios bin by bin
 
-        ratio = valuesArr[b][l] / valuesArr[0][k];
-        //          ratioError = TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[0][k],2.) + TMath::Power(valuesArr[b][l]*valuesErrorArr[0][k] / TMath::Power(valuesArr[0][k],2.),2.) );
+    //______ Create histos to store signal extraction systematic uncertainties
+    TH1* hsyst = new TH1F(Form("%s_Systematics",value2Test),Form("%s Systematics results",value2Test),nbin,0,nbin);
+    //_________________________________
 
-        if ( (valuesErrorArr[b][l] != 0) && (valuesErrorArr[0][k] != 0) ) // We only give an error!=0 if the errors of the int and bin values are both !=0 (Otherwise it means that there was a problem with the fit so we fix the error to 0 to skip the test later on)
+    //______ Create histos to store relative Jpsi yield or <p_T> vs bins
+    Int_t size = bin->GetEntriesFast();
+    Double_t* axis = new Double_t[size+1];
+    TIter next(bin);
+    AliAnalysisMuMuBinning::Range* b;
+    TH1* hy(0x0);
+    i = 0;
+    while ( ( b = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
         {
-          ratioError = ratio*TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[b][l],2.) + TMath::Power(valuesErrorArr[0][k] / valuesArr[0][k],2.) );
+        axis[i] = b->Xmin();
+        ++i;
         }
 
-        if ( binSignalName.Contains(signalNameInt.Data()) && binSignalName.Contains(sPsiPNameInt.Data()) ) // In this case the integrated and bin values have the same signal shape and Psi' sigma, so the result is stored
-        {
-          hratiosBin->GetXaxis()->SetBinLabel(binUCTotal,Form("%s/%s",sResultNameArray->At(l)->GetName(),sResultNameArray->At(k)->GetName()));
+    b = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(size-1));
 
-          hratiosBin->SetBinContent(binUCTotal,ratio);
-          hratiosBin->SetBinError(binUCTotal,ratioError);
+    axis[i] = b->Xmax();
 
-          binUCTotal++;
+    if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
+        {
+        hy = new TH1D(Form("hMeanJPsiYieldVS%sRelative",quantity),Form("Relative J/#psi yield vs %s;%s;Y^{J/#psi}/Y^{J/#psi}_{int}",quantity,quantity)
+                      ,size,axis);
+        }
+    else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
+        {
+        hy = new TH1D(Form("hMeanJPsiMPtVS%sRelative",quantity),Form("Relative J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}/<p_{T}>^{J/#psi}_{int}",quantity,quantity)
+                      ,size,axis);
         }
 
-      }
-
-    }
-    //____ Take the Eq Nof MB events from the histos
-    Double_t nMBRatio(1.),nMBRatioError(0.);
-    if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
-    {
-      for (Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
-      {
+    if ( !hy )
+        {
+        AliError("No histogram created to store the results");
+        return;
+        }
+    delete[] axis;
+    //_________________________________
 
-        if ( !binName.CompareTo(hMB->GetXaxis()->GetBinLabel(i)) )
+    TString binName("");
+    for ( Int_t b = 1 ; b <= size ; b++ ) //Bin loop
         {
-          Double_t eqMBBin = hMB->GetBinContent(i);
 
-          nMBRatio = nEqMBTot/eqMBBin;
-          nMBRatioError = nMBRatio*TMath::Sqrt( TMath::Power(nEqMBTotError/nEqMBTot,2.) + TMath::Power(hMB->GetBinError(i)/eqMBBin,2.) );
-        }
+        binName = static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(b-1))->AsString().Data();
+        //    TString savePath(Form("%s/%s",id.Data(),binName.Data()));
 
-      }
-    }
-    //_____________________
+        Int_t binUCTotal(1);
 
-    //________Mean, error on the mean and systematic uncertainty(signal extraction) computation for bin
-    //__Mean computation
-    Double_t num(0.),deno(0.);
-    for ( Int_t m = 1 ; m <= hratiosBin->GetNbinsX() ; m++ )
-    {
-      Double_t value = hratiosBin->GetBinContent(m); // Bin/Int value
-      Double_t error = hratiosBin->GetBinError(m); // Before this was divided by TMath::Sqrt(value);
+        TH1* hratiosBin = new TH1D(Form("SystTests_%s_Bkg_%s",sObsBin.Data(),binName.Data()),
+                                   Form("%s Systematics tests for %s",binName.Data(),shName.Data()),j*nFitsSameSignal,0,
+                                   j*nFitsSameSignal);
 
-      if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
+        for ( Int_t k = 0 ; k < j ; k++ ) // Subresults loop for integrated values
+            {
+            //__Get the name of the signal and the Psi' sigma for the integrated result
+            TString signalNameInt(sResultNameArray->At(k)->GetName());
+            TString sPsiPNameInt(signalNameInt.Data());
 
-      num += value; // We do not weight the values anymore with TMath::Power(weight,2.);
-      deno += 1.; // We do not weight the values anymore with 1./TMath::Power(weight,2.);
-    }
+            signalNameInt.Remove(3,signalNameInt.Sizeof()-3); // Get the first 3 characters which correspond to the signal shape (e.g CB2, NA6(0) ...)
+            sPsiPNameInt.Remove(0,sPsiPNameInt.Sizeof()-6); // Get the last 5 characters which correspond to the Psi' sigma (e.g. SP0.9 ...)
+            //__
 
-    Double_t mean = num/deno;
-    Double_t jpsiMean = mean*nMBRatio ; //Compute relative Jpsi yield
-    //__
+            //      Int_t sizeName = signalName.Sizeof();
+            //      signalName.Remove(2,sizeName-3);
+            //      Int_t binUC(1);
 
-    //__Error on the mean
-    Int_t nofvalidResults(0),nofTests(0);
-    Double_t w2err2(0.),sumw(0.);
-    for ( Int_t n = 1 ; n <= hratiosBin->GetNbinsX() ; n++ )
-    {
-      Double_t value = hratiosBin->GetBinContent(n);
-      Double_t error = hratiosBin->GetBinError(n);
-      Double_t weight = 1.; // We do not weight the values anymore with (error*error)/value;
+            for ( Int_t l = 0; l < j ; l++) //Subresults loop for bins values
+                {
+                TString binSignalName(sResultNameArray->At(l)->GetName());
 
-      nofTests++;
+                Double_t ratio,ratioError(0.);
 
-      if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
+                ratio = valuesArr[b][l] / valuesArr[0][k];
+                //          ratioError = TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[0][k],2.) + TMath::Power(valuesArr[b][l]*valuesErrorArr[0][k] / TMath::Power(valuesArr[0][k],2.),2.) );
 
-      w2err2 += weight*weight*error*error;
-      sumw += 1./weight;
+                if ( (valuesErrorArr[b][l] != 0) && (valuesErrorArr[0][k] != 0) ) // We only give an error!=0 if the errors of the int and bin values are both !=0 (Otherwise it means that there was a problem with the fit so we fix the error to 0 to skip the test later on)
+                    {
+                    ratioError = ratio*TMath::Sqrt( TMath::Power(valuesErrorArr[b][l] / valuesArr[b][l],2.) + TMath::Power(valuesErrorArr[0][k] / valuesArr[0][k],2.) );
+                    }
 
-      nofvalidResults++;
-    }
+                if ( binSignalName.Contains(signalNameInt.Data()) && binSignalName.Contains(sPsiPNameInt.Data()) ) // In this case the integrated and bin values have the same signal shape and Psi' sigma, so the result is stored
+                    {
+                    hratiosBin->GetXaxis()->SetBinLabel(binUCTotal,Form("%s/%s",sResultNameArray->At(l)->GetName(),sResultNameArray->At(k)->GetName()));
 
-    std::cout << std::endl;
-    std::cout << "Bin " << b << " number of valid tests = " << nofvalidResults << "(" << nofvalidResults*100./nofTests << "%)" << std::endl;
-    std::cout << std::endl;
+                    hratiosBin->SetBinContent(binUCTotal,ratio);
+                    hratiosBin->SetBinError(binUCTotal,ratioError);
 
-    Double_t errorMean = TMath::Sqrt(w2err2*nofvalidResults)/sumw;
-    Double_t jpsiErrorMean = jpsiMean*TMath::Sqrt( TMath::Power(errorMean/mean,2.) + TMath::Power(nMBRatioError/nMBRatio,2.) ); //Compute relative Jpsi yield error
-    //__
+                    binUCTotal++;
+                    }
 
-    Double_t val(0.),err(0.);
-    if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
-    {
-      val = jpsiMean;
-      err = jpsiErrorMean;
-    }
-    else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
-    {
-      val = mean;
-      err = errorMean;
-    }
+                }
 
-    hy->SetBinContent(b,val);
-    hy->SetBinError(b,err);
-    hy->GetXaxis()->SetBinLabel(b,binName.Data());
+            }
+        //____ Take the Eq Nof MB events from the histos
+        Double_t nMBRatio(1.),nMBRatioError(0.);
+        if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
+            {
+            for (Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
+                {
 
-    //__Systematic uncertainty
-    Double_t v1(0.),v2(0.),sum(0.);
-    for ( Int_t l = 1 ; l <= hratiosBin->GetNbinsX() ; l++ )
-    {
-      Double_t value = hratiosBin->GetBinContent(l);
-      Double_t error = hratiosBin->GetBinError(l); // Before this was divided by TMath::Sqrt(value);
+                if ( !binName.CompareTo(hMB->GetXaxis()->GetBinLabel(i)) )
+                    {
+                    Double_t eqMBBin = hMB->GetBinContent(i);
 
-      if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
+                    nMBRatio = nEqMBTot/eqMBBin;
+                    nMBRatioError = nMBRatio*TMath::Sqrt( TMath::Power(nEqMBTotError/nEqMBTot,2.) + TMath::Power(hMB->GetBinError(i)/eqMBBin,2.) );
+                    }
 
-      Double_t wi = 1.; // We do not wight anymore with 1./TMath::Power(error,2.);
-      v1 += wi;
-      v2 += wi*wi;
-      Double_t diff = value - mean;
-      sum += wi*diff*diff;
-      
-    }
+                }
+            }
+        //_____________________
 
-    Double_t syst = TMath::Sqrt( (v1/(v1*v1-v2)) * sum);
-    //__
-    
-    hsyst->GetXaxis()->SetBinLabel(b,binName.Data());
-    hsyst->SetBinContent(b,(syst*100.)/mean);
-    //________
-    
-    //___
-    TF1* meanF = new TF1("mean","[0]",0,j*nFitsSameSignal);
-    meanF->SetParameter(0,mean);
-    
-    TF1* meanFPS = new TF1("meanPS","[0]",0,j*nFitsSameSignal);
-    meanFPS->SetParameter(0,mean+syst);
-    meanFPS->SetLineStyle(2);
-    
-    TF1* meanFMS = new TF1("meanMS","[0]",0,j*nFitsSameSignal);
-    meanFMS->SetParameter(0,mean-syst);
-    meanFMS->SetLineStyle(2);
+        //________Mean, error on the mean and systematic uncertainty(signal extraction) computation for bin
+        //__Mean computation
+        Double_t num(0.),deno(0.);
+        for ( Int_t m = 1 ; m <= hratiosBin->GetNbinsX() ; m++ )
+            {
+            Double_t value = hratiosBin->GetBinContent(m); // Bin/Int value
+            Double_t error = hratiosBin->GetBinError(m); // Before this was divided by TMath::Sqrt(value);
 
-    hratiosBin->GetListOfFunctions()->Add(meanF);
-    hratiosBin->GetListOfFunctions()->Add(meanFPS);
-    hratiosBin->GetListOfFunctions()->Add(meanFMS);
-    
-    //___ Save the signal extraction systematic uncertainty histo for each bin
-    TH1* o = OC()->Histo(Form("%s",id.Data()),hratiosBin->GetName());
-    
-    if (o)
-    {
-      AliWarning(Form("Replacing %s/%s",id.Data(),hratiosBin->GetName()));
-      OC()->Remove(Form("%s/%s",id.Data(),hratiosBin->GetName()));
-    }
-    
-    Bool_t adoptOK = OC()->Adopt(id.Data(),hratiosBin);
-    
-    if ( adoptOK ) std::cout << "+++syst histo " << hratiosBin->GetName() << " adopted" << std::endl;
-    else AliError(Form("Could not adopt syst histo %s",hratiosBin->GetName()));
-    //__________________
-  }
-  //_____________________________________________________________________________
-  
-  
-  //___ Save the signal extraction systematic uncertainty histo for all the bins
-  TH1* o = OC()->Histo(Form("%s",id.Data()),hsyst->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hsyst->GetName()));
-    OC()->Remove(Form("%s/%s",id.Data(),hsyst->GetName()));
-  }
-  
-  Bool_t adoptOK = OC()->Adopt(id.Data(),hsyst);
-  
-  if ( adoptOK ) std::cout << "+++syst histo " << hsyst->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt syst histo %s",hsyst->GetName()));
-  //__________________
+            if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
 
+            num += value; // We do not weight the values anymore with TMath::Power(weight,2.);
+            deno += 1.; // We do not weight the values anymore with 1./TMath::Power(weight,2.);
+            }
 
-  //___ Save the Jpsi relative yield or <pT> histo
-  o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy->GetName());
+        Double_t mean = num/deno;
+        Double_t jpsiMean = mean*nMBRatio ; //Compute relative Jpsi yield
+        //__
 
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s","/RESULTS-%s/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/V0A",hy->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),diffPath.Data(),hy->GetName()));
-  }
+        //__Error on the mean
+        Int_t nofvalidResults(0),nofTests(0);
+        Double_t w2err2(0.),sumw(0.);
+        for ( Int_t n = 1 ; n <= hratiosBin->GetNbinsX() ; n++ )
+            {
+            Double_t value = hratiosBin->GetBinContent(n);
+            Double_t error = hratiosBin->GetBinError(n);
+            Double_t weight = 1.; // We do not weight the values anymore with (error*error)/value;
 
-  adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy);
+            nofTests++;
 
-  if ( adoptOK ) std::cout << "+++Yield histo " << hy->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hy->GetName()));
-  //__________________
-  
-  
-  delete bin;
-  delete sResultNameArray;
-  
-  return;
-  
-}
+            if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
 
+            w2err2 += weight*weight*error*error;
+            sumw += 1./weight;
 
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::PlotJpsiYield(const char* whatever)
-{
-  
-  //FIXME::Make it general
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi yield: Is a simulation file");
-    return 0x0;
-  }
-  
-  TString path(Form("/%s/%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
-  
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/%s",path.Data(),whatever)));
-  if ( !s )
-  {
-    AliError(Form("No spectra %s found in %s",whatever,path.Data()));
-    return 0x0;
-  }
-  
-  std::cout << "Number of J/Psi:" << std::endl;
-  TH1* hry = s->Plot("NofJPsi","PSIPSIPRIMECB2VWGINDEPTAILS",kFALSE); //Number of Jpsi
-  std::cout << "" << std::endl;
-  
-  std::cout << "Equivalent number of MB events:" << std::endl;
-  TH1* hN = ComputeEquNofMB();
-  std::cout << "" << std::endl;
-  
-  TH1* hy = static_cast<TH1*>(hry->Clone("CorrJPsiYields"));
-  Double_t bR = 0.0593; // BR(JPsi->mu+mu-)
-  Double_t bRerror = 0.0006 ;
-  
-  for (Int_t i = 1 ; i <= hy->GetNbinsX() ; i++)
-  {
-    Double_t yield = hry->GetBinContent(i)/(hN->GetBinContent(i)*bR);
-    Double_t yieldError = TMath::Sqrt(TMath::Power(hry->GetBinError(i)/(hN->GetBinContent(i)*bR),2.) +
-                                      TMath::Power(hN->GetBinError(i)*bR/TMath::Power(hN->GetBinContent(i)*bR,2.),2.) +
-                                      TMath::Power(hry->GetBinContent(i)*hN->GetBinContent(i)*bRerror/TMath::Power(hN->GetBinContent(i)*bR,2.),2.));
-    
-    std::cout << yield << " +- " << yieldError << std::endl;
-    
-    hy->SetBinContent(i,yield);
-    hy->SetBinError(i,yieldError);
-  }
-  
-  delete hry;
-  delete hN;
-  
-  return hy;
-}
+            nofvalidResults++;
+            }
 
+        std::cout << std::endl;
+        std::cout << "Bin " << b << " number of valid tests = " << nofvalidResults << "(" << nofvalidResults*100./nofTests << "%)" << std::endl;
+        std::cout << std::endl;
 
-//_____________________________________________________________________________
-UInt_t AliAnalysisMuMu::GetSum(AliCounterCollection& cc, const char* triggerList,
-                               const char* eventSelection, Int_t runNumber)
-{
-  TObjArray* ktrigger = cc.GetKeyWords("trigger").Tokenize(",");
-  TObjArray* kevent = cc.GetKeyWords("event").Tokenize(",");
-  TObjArray* a = TString(triggerList).Tokenize(" ");
-  TIter next(a);
-  TObjString* str;
-  
-  UInt_t n(0);
-  
-  TString sEventSelection(eventSelection);
-  sEventSelection.ToUpper();
+        Double_t errorMean = TMath::Sqrt(w2err2*nofvalidResults)/sumw;
+        Double_t jpsiErrorMean = jpsiMean*TMath::Sqrt( TMath::Power(errorMean/mean,2.) + TMath::Power(nMBRatioError/nMBRatio,2.) ); //Compute relative Jpsi yield error
+        //__
+
+        Double_t val(0.),err(0.);
+        if ( !svalue2Test.CompareTo("NofJPsi",TString::kIgnoreCase) )
+            {
+            val = jpsiMean;
+            err = jpsiErrorMean;
+            }
+        else if ( !svalue2Test.CompareTo("MeanPtJPsi",TString::kIgnoreCase) )
+            {
+            val = mean;
+            err = errorMean;
+            }
+
+        hy->SetBinContent(b,val);
+        hy->SetBinError(b,err);
+        hy->GetXaxis()->SetBinLabel(b,binName.Data());
+
+        //__Systematic uncertainty
+        Double_t v1(0.),v2(0.),sum(0.);
+        for ( Int_t l = 1 ; l <= hratiosBin->GetNbinsX() ; l++ )
+            {
+            Double_t value = hratiosBin->GetBinContent(l);
+            Double_t error = hratiosBin->GetBinError(l); // Before this was divided by TMath::Sqrt(value);
+
+            if ( !(error>0.0 ) ) continue; // Skip values with error=0 (There were problems with the fit)
+
+            Double_t wi = 1.; // We do not wight anymore with 1./TMath::Power(error,2.);
+            v1 += wi;
+            v2 += wi*wi;
+            Double_t diff = value - mean;
+            sum += wi*diff*diff;
+
+            }
+
+        Double_t syst = TMath::Sqrt( (v1/(v1*v1-v2)) * sum);
+        //__
+
+        hsyst->GetXaxis()->SetBinLabel(b,binName.Data());
+        hsyst->SetBinContent(b,(syst*100.)/mean);
+        //________
+
+        //___
+        TF1* meanF = new TF1("mean","[0]",0,j*nFitsSameSignal);
+        meanF->SetParameter(0,mean);
+
+        TF1* meanFPS = new TF1("meanPS","[0]",0,j*nFitsSameSignal);
+        meanFPS->SetParameter(0,mean+syst);
+        meanFPS->SetLineStyle(2);
+
+        TF1* meanFMS = new TF1("meanMS","[0]",0,j*nFitsSameSignal);
+        meanFMS->SetParameter(0,mean-syst);
+        meanFMS->SetLineStyle(2);
+
+        hratiosBin->GetListOfFunctions()->Add(meanF);
+        hratiosBin->GetListOfFunctions()->Add(meanFPS);
+        hratiosBin->GetListOfFunctions()->Add(meanFMS);
+
+        //___ Save the signal extraction systematic uncertainty histo for each bin
+        TH1* o = OC()->Histo(Form("%s",id.Data()),hratiosBin->GetName());
+
+        if (o)
+            {
+            AliWarning(Form("Replacing %s/%s",id.Data(),hratiosBin->GetName()));
+            OC()->Remove(Form("%s/%s",id.Data(),hratiosBin->GetName()));
+            }
+
+        Bool_t adoptOK = OC()->Adopt(id.Data(),hratiosBin);
+
+        if ( adoptOK ) std::cout << "+++syst histo " << hratiosBin->GetName() << " adopted" << std::endl;
+        else AliError(Form("Could not adopt syst histo %s",hratiosBin->GetName()));
+        //__________________
+        }
+    //_____________________________________________________________________________
+
+
+    //___ Save the signal extraction systematic uncertainty histo for all the bins
+    TH1* o = OC()->Histo(Form("%s",id.Data()),hsyst->GetName());
+
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s",id.Data(),hsyst->GetName()));
+        OC()->Remove(Form("%s/%s",id.Data(),hsyst->GetName()));
+        }
+
+    Bool_t adoptOK = OC()->Adopt(id.Data(),hsyst);
+
+    if ( adoptOK ) std::cout << "+++syst histo " << hsyst->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt syst histo %s",hsyst->GetName()));
+    //__________________
+
+
+    //___ Save the Jpsi relative yield or <pT> histo
+    o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy->GetName());
+
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s","/RESULTS-%s/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/V0A",hy->GetName()));
+        OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),diffPath.Data(),hy->GetName()));
+        }
+
+    adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy);
+
+    if ( adoptOK ) std::cout << "+++Yield histo " << hy->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt Yield histo %s",hy->GetName()));
+    //__________________
+
+
+    delete bin;
+    delete sResultNameArray;
+
+    return;
+
+}
+
+
+//_____________________________________________________________________________
+TH1* AliAnalysisMuMu::PlotJpsiYield(const char* whatever)
+{
+
+    //FIXME::Make it general
+    if ( IsSimulation() )
+        {
+        AliError("Cannot compute J/Psi yield: Is a simulation file");
+        return 0x0;
+        }
+
+    TString path(Form("/%s/%s/%s/%s",
+                      Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
+                      Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
+
+    AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("%s/PSI-%s",path.Data(),whatever)));
+    if ( !s )
+        {
+        AliError(Form("No spectra %s found in %s",whatever,path.Data()));
+        return 0x0;
+        }
+
+    std::cout << "Number of J/Psi:" << std::endl;
+    TH1* hry = s->Plot("NofJPsi","PSIPSIPRIMECB2VWGINDEPTAILS",kFALSE); //Number of Jpsi
+    std::cout << "" << std::endl;
+
+    std::cout << "Equivalent number of MB events:" << std::endl;
+    TH1* hN = ComputeEquNofMB();
+    std::cout << "" << std::endl;
+
+    TH1* hy = static_cast<TH1*>(hry->Clone("CorrJPsiYields"));
+    Double_t bR = 0.0593; // BR(JPsi->mu+mu-)
+    Double_t bRerror = 0.0006 ;
+
+    for (Int_t i = 1 ; i <= hy->GetNbinsX() ; i++)
+        {
+        Double_t yield = hry->GetBinContent(i)/(hN->GetBinContent(i)*bR);
+        Double_t yieldError = TMath::Sqrt(TMath::Power(hry->GetBinError(i)/(hN->GetBinContent(i)*bR),2.) +
+                                          TMath::Power(hN->GetBinError(i)*bR/TMath::Power(hN->GetBinContent(i)*bR,2.),2.) +
+                                          TMath::Power(hry->GetBinContent(i)*hN->GetBinContent(i)*bRerror/TMath::Power(hN->GetBinContent(i)*bR,2.),2.));
+
+        std::cout << yield << " +- " << yieldError << std::endl;
+
+        hy->SetBinContent(i,yield);
+        hy->SetBinError(i,yieldError);
+        }
+
+    delete hry;
+    delete hN;
+
+    return hy;
+}
+
+
+//_____________________________________________________________________________
+UInt_t AliAnalysisMuMu::GetSum(AliCounterCollection& cc, const char* triggerList,
+                               const char* eventSelection, Int_t runNumber)
+{
+  TObjArray* ktrigger = cc.GetKeyWords("trigger").Tokenize(",");
+  TObjArray* kevent = cc.GetKeyWords("event").Tokenize(",");
+  TObjArray* a = TString(triggerList).Tokenize(" ");
+  TIter next(a);
+  TObjString* str;
+  
+  UInt_t n(0);
+  
+  TString sEventSelection(eventSelection);
+  sEventSelection.ToUpper();
   
   if ( kevent->FindObject(sEventSelection.Data()) ) 
   {
@@ -2432,41 +3134,41 @@ AliAnalysisMuMu::GetCollections(const char* rootfile,
   /// rootfile is a filename, with an optional directory (with the syntax
   /// (filename.root:directory)
   /// where the collections are to be found.
- 
+
   oc = 0x0;
   cc = 0x0;
   bin = 0x0;
-  
-  
+
+
   TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(rootfile));
   if (!f)
   {
     f = TFile::Open(rootfile);
   }
-  
+
   if ( !f || f->IsZombie() )
   {
     return kFALSE;
   }
-  
+
   TString dir = subdir;
-  
+
   if (dir.Length())
   {
     dir.Remove(TString::kBoth,'/');
     dir += "/";
   }
-  
+
   f->GetObject(Form("%sOC",dir.Data()),oc);
   if (!oc)
   {
     f->GetObject(Form("%sMC",dir.Data()),oc);
   }
   f->GetObject(Form("%sCC",dir.Data()),cc);
-  
+
   TIter next(f->GetListOfKeys());
   TKey* key;
-  
+
   while ( ( key = static_cast<TKey*>(next())) && !bin )
   {
     if ( strcmp(key->GetClassName(),"AliAnalysisMuMuBinning")==0 )
@@ -2474,19 +3176,19 @@ AliAnalysisMuMu::GetCollections(const char* rootfile,
       bin = dynamic_cast<AliAnalysisMuMuBinning*>(key->ReadObj());
     }
   }
-  
+
   if ( (!oc || !cc) && fDirectory.Length()==0 )
   {
     // one more try, searching in subdirectories as well
     GetCollectionsFromAnySubdir(*f,oc,cc,bin);
   }
-  
+
   if (!oc || !cc)
   {
     AliError("Could not get OC, CC and BIN. Is that an old file ? Try to upgrade it or check it's the right file...");
     return kFALSE;
   }
-  
+
   // get run list
   TObjArray* runs = cc->GetKeyWords("run").Tokenize(",");
   runs->Sort();
@@ -2494,333 +3196,274 @@ AliAnalysisMuMu::GetCollections(const char* rootfile,
   TObjString* srun;
 
   runnumbers.clear();
-  
+
   while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
   {
     runnumbers.insert(srun->String().Atoi());
   }
-  
+
   delete runs;
-  
+
   return kTRUE;
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMu::IsSimulation() const
 {
-  // whether or not we have MC information
-  
-//  return kFALSE;
-  
-  if (!fMergeableCollection) return kFALSE;
-  
-  TList* list = fMergeableCollection->CreateListOfKeys(0);
-  TIter next(list);
-  TObjString* str;
-  Bool_t ok(kFALSE);
-  
-  while ( ( str = static_cast<TObjString*>(next()) ) )
-  {
-    if ( str->String().Contains(AliAnalysisMuMuBase::MCInputPrefix()) ) ok = kTRUE;
-  }
-  delete list;
-  
-  return ok;
+    // whether or not we have MC information
+
+    //  return kFALSE;
+
+    if (!fMergeableCollection) return kFALSE;
+
+    TList* list = fMergeableCollection->CreateListOfKeys(0);
+    TIter next(list);
+    TObjString* str;
+    Bool_t ok(kFALSE);
+
+    while ( ( str = static_cast<TObjString*>(next()) ) )
+        {
+        if ( str->String().Contains(AliAnalysisMuMuBase::MCInputPrefix()) ) ok = kTRUE;
+        }
+    delete list;
+
+    return ok;
 }
 
 //_____________________________________________________________________________
 Int_t
 AliAnalysisMuMu::Jpsi(const char* what, const char* binningFlavour, Bool_t fitmPt, Bool_t onlyCorrected)
 {
-  /// Fit the J/psi (and psiprime) peaks for the triggers in fDimuonTriggers list
-  /// what="integrated" => fit only fully integrated MinvUS
-  /// what="pt" => fit MinvUS in pt bins
-  /// what="y" => fit MinvUS in y bins
-  /// what="pt,y" => fit MinvUS in (pt,y) bins
-  
-  TStopwatch timer;
-  
-  if (!fMergeableCollection)
-  {
-    AliError("No mergeable collection. Consider Upgrade()");
-    return 0;
-  }
-  
-  Int_t nfits(0);
-  
-  TObjArray* triggerArray = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
-  TObjArray* eventTypeArray = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
-  TObjArray* pairCutArray = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
-  TObjArray* whatArray = TString(what).Tokenize(",");
-  TObjArray* centralityArray = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
-  
-  TIter nextTrigger(triggerArray);
-  TIter nextEventType(eventTypeArray);
-  TIter nextPairCut(pairCutArray);
-  TIter nextWhat(whatArray);
-  TIter nextCentrality(centralityArray);
-  
-  TObjString* trigger;
-  TObjString* eventType;
-  TObjString* pairCut;
-  TObjString* swhat;
-  TObjString* centrality;
-  
-  while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
-  {
-    AliAnalysisMuMuBinning* binning(0x0);
-    
-    if ( fBinning && swhat->String().Length() > 0 )
-    {
-      binning = fBinning->Project("psi",swhat->String().Data(),binningFlavour);
-    }
-    else
-    {
-      binning = new AliAnalysisMuMuBinning;
-      binning->AddBin("psi",swhat->String().Data());
-    }
-    
-    StdoutToAliDebug(1,std::cout << "++++++++++++ swhat=" << swhat->String().Data() << std::endl;);
-    
-    std::cout << "" << std::endl;
-    std::cout << "++++++++++++++++++" << "NEW BIN TYPE" << "+++++++++++++++++++" << std::endl;
-    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
-    std::cout << "++++++++++++ swhat=" << swhat->String().Data() << "++++++++++++++++++++" << std::endl;
-    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
-    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
-    std::cout << "" << std::endl;
-    std::cout << "" << std::endl;
-    
-    if (!binning)
-    {
-      AliError("oups. binning is NULL");
-      continue;
-    }
-    
-    StdoutToAliDebug(1,binning->Print(););
-    
-    nextTrigger.Reset();
-    
-    while ( ( trigger = static_cast<TObjString*>(nextTrigger())) )
-    {
-      AliDebug(1,Form("TRIGGER %s",trigger->String().Data()));
-      
-      nextEventType.Reset();
-      
-      while ( ( eventType = static_cast<TObjString*>(nextEventType())) )
-      {
-        AliDebug(1,Form("--EVENTTYPE %s",eventType->String().Data()));
-        
-        nextPairCut.Reset();
-        
-        while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) )
+    /// Fit the J/psi (and psiprime) peaks for the triggers in fDimuonTriggers list
+    /// what="integrated" => fit only fully integrated MinvUS
+    /// what="pt" => fit MinvUS in pt bins
+    /// what="y" => fit MinvUS in y bins
+    /// what="pt,y" => fit MinvUS in (pt,y) bins
+
+    TStopwatch timer;
+
+    if (!fMergeableCollection)
         {
-          AliDebug(1,Form("----PAIRCUT %s",pairCut->String().Data()));
-          
-          nextCentrality.Reset();
-          
-          while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) )
-          {
-            AliDebug(1,"----Fitting...");
-            
-            TObject* o;
-            
-            TString id(Form("/%s/%s/%s/%s",eventType->String().Data(),
-                            trigger->String().Data(),
-                            centrality->String().Data(),
-                            pairCut->String().Data()));
+        AliError("No mergeable collection. Consider Upgrade()");
+        return 0;
+        }
 
-            AliAnalysisMuMuSpectra* spectra(0x0);
-            if ( !onlyCorrected )
-            {
-              
-              spectra = FitParticle("psi",
-                                    trigger->String().Data(),
-                                    eventType->String().Data(),
-                                    pairCut->String().Data(),
-                                    centrality->String().Data(),
-                                    *binning);
-              
-              AliDebug(1,Form("----fitting done spectra = %p",spectra));
+    Int_t nfits(0);
+
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
+
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextCentrality(centralityArray);
+
+    TObjString* trigger;
+    TObjString* eventType;
+    TObjString* pairCut;
+    TObjString* swhat;
+    TObjString* centrality;
+
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) ) {
+      AliAnalysisMuMuBinning* binning(0x0);
+
+      if ( fBinning && swhat->String().Length() > 0 ) {
+        binning = fBinning->Project("psi",swhat->String().Data(),binningFlavour);
+      } else {
+        binning = new AliAnalysisMuMuBinning;
+        binning->AddBin("psi",swhat->String().Data());
+      }
+
+      StdoutToAliDebug(1,std::cout << "++++++++++++ swhat=" << swhat->String().Data() << std::endl;);
+
+      std::cout << "" << std::endl;
+      std::cout << "++++++++++++++++++" << "NEW BIN TYPE" << "+++++++++++++++++++" << std::endl;
+      std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
+      std::cout << "++++++++++++ swhat=" << swhat->String().Data() << "++++++++++++++++++++" << std::endl;
+      std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
+      std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++" << std::endl;
+      std::cout << "" << std::endl;
+      std::cout << "" << std::endl;
+
+      if (!binning) {
+        AliError("oups. binning is NULL");
+        continue;
+      }
+
+      StdoutToAliDebug(1,binning->Print(););
+      nextTrigger.Reset();
+      // Loop over all trigger
+      while ( ( trigger = static_cast<TObjString*>(nextTrigger())) ) {
+        AliDebug(1,Form("TRIGGER %s",trigger->String().Data()));
+        nextEventType.Reset();
+        // Loop over all evenType
+        while ( ( eventType = static_cast<TObjString*>(nextEventType())) ){
+          AliDebug(1,Form("--EVENTTYPE %s",eventType->String().Data()));
+          nextPairCut.Reset();
+          // Loop over all paircut
+          while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) ) {
+            AliDebug(1,Form("----PAIRCUT %s",pairCut->String().Data()));
+            nextCentrality.Reset();
+            // Loop over all centrality
+            while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) ) {
+              AliDebug(1,"----Fitting...");
+
+              TObject* o;
+              TString id(Form("/%s/%s/%s/%s",eventType->String().Data(),
+                              trigger->String().Data(),
+                              centrality->String().Data(),
+                              pairCut->String().Data()));
+
+              AliAnalysisMuMuSpectra* spectra(0x0);
               
-              if ( spectra )
-              {
-                ++nfits;
+              if ( !onlyCorrected ) {
+                spectra = FitParticle("psi",trigger->String().Data(),eventType->String().Data(),pairCut->String().Data(),centrality->String().Data(),*binning);
 
-                o = fMergeableCollection->GetObject(id.Data(),spectra->GetName());
+                AliDebug(1,Form("----fitting done spectra = %p",spectra));
 
-                AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
+                if ( spectra ) {
+                  ++nfits;
 
-                if (o)
-                {
-                  AliWarning(Form("Replacing %s/%s",id.Data(),spectra->GetName()));
-                  fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectra->GetName()));
-                }
+                  o = fMergeableCollection->GetObject(id.Data(),spectra->GetName());
+                  AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
 
-                Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectra);
+                  if (o) {
+                    AliWarning(Form("Replacing %s/%s",id.Data(),spectra->GetName()));
+                    fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectra->GetName()));
+                  }
+
+                  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectra);
 
-                if ( adoptOK ) std::cout << "+++Spectra " << spectra->GetName() << " adopted" << std::endl;
-                else AliError(Form("Could not adopt spectra %s",spectra->GetName()));
+                  if ( adoptOK ) std::cout << "+++Spectra " << spectra->GetName() << " adopted" << std::endl;
+                  else AliError(Form("Could not adopt spectra %s",spectra->GetName()));
 
-                StdoutToAliDebug(1,spectra->Print(););
+                  StdoutToAliDebug(1,spectra->Print(););
+                } else AliError("Error creating spectra");
               }
-              else AliError("Error creating spectra");
-            }
-            
-            AliDebug(1,"----Fitting corrected spectra...");
-            
-            AliAnalysisMuMuSpectra* spectraCorr = FitParticle("psi",
-                                                              trigger->String().Data(),
-                                                              eventType->String().Data(),
-                                                              pairCut->String().Data(),
-                                                              centrality->String().Data(),
-                                                              *binning,"minv",kTRUE);
-            
-            AliDebug(1,Form("----fitting done corrected spectra = %p",spectraCorr));
-            
-            o = 0x0;
-            if ( spectraCorr )
-            {
+
+              AliDebug(1,"----Fitting corrected spectra...");
+              AliAnalysisMuMuSpectra* spectraCorr = FitParticle("psi",trigger->String().Data(),eventType->String().Data(),pairCut->String().Data(),centrality->String().Data(),*binning,"minv",kTRUE);
+
+              AliDebug(1,Form("----fitting done corrected spectra = %p",spectraCorr));
+
+              // save results in mergeable collection
+              o = 0x0;
+              if ( spectraCorr ) {
               ++nfits;
-              
+
               o = fMergeableCollection->GetObject(id.Data(),spectraCorr->GetName());
-              
               AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
-              
-              if (o)
-              {
+
+              if (o) {
                 AliWarning(Form("Replacing %s/%s",id.Data(),spectraCorr->GetName()));
                 fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraCorr->GetName()));
               }
-              
+
               Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraCorr);
-              
+
               if ( adoptOK ) std::cout << "+++Spectra " << spectraCorr->GetName() << " adopted" << std::endl;
               else AliError(Form("Could not adopt spectra %s",spectraCorr->GetName()));
-              
+
               StdoutToAliDebug(1,spectraCorr->Print(););
-            }
-            else AliError("Error creating spectra");
-            
-            
-            if (fitmPt)
-            {
-              AliDebug(1,"----Fitting mean pt...");
-              
-              std::cout << "" << std::endl;
-              std::cout << "" << std::endl;
-              
-              if ( !onlyCorrected )
-              {
-                std::cout << "++++++++++++ Fitting mean Pt for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
-                if ( spectra )
-                {
-                  AliAnalysisMuMuSpectra* spectraMeanPt = FitParticle("psi",
-                                                                      trigger->String().Data(),
-                                                                      eventType->String().Data(),
-                                                                      pairCut->String().Data(),
-                                                                      centrality->String().Data(),
-                                                                      *binning,"mpt"/*,*spectra*/);
-                  
-                  
-                  
-                  AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPt));
+              } else AliError("Error creating spectra");
+
+
+              if (fitmPt) {
+                AliDebug(1,"----Fitting mean pt...");
+
+                std::cout << "" << std::endl;
+                std::cout << "" << std::endl;
+
+                if ( !onlyCorrected ){
+                  std::cout << "++++++++++++ Fitting mean Pt for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
+                  if ( spectra ) {
+                      AliAnalysisMuMuSpectra* spectraMeanPt = FitParticle("psi",
+                                                                          trigger->String().Data(),
+                                                                          eventType->String().Data(),
+                                                                          pairCut->String().Data(),
+                                                                          centrality->String().Data(),
+                                                                          *binning,"mpt"/*,*spectra*/);
+                      AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPt));
+                      o = 0x0;
+
+                      if ( spectraMeanPt ){
+                        ++nfits; //Review this
+
+                        o = fMergeableCollection->GetObject(id.Data(),spectraMeanPt->GetName());
+                        AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
+
+                        if (o) {
+                          AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPt->GetName()));
+                          fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPt->GetName()));
+                        }
+
+                        Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPt);
+
+                        if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPt->GetName() << " adopted" << std::endl;
+                        else AliError(Form("Could not adopt spectra %s",spectraMeanPt->GetName()));
+
+                      } else AliError("Error creating spectra");
+
+                  } else std::cout << "Mean pt fit failed: No inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
+                }
+                std::cout << "++++++++++++ Fitting corrected mean Pt for" << " " << swhat->String().Data() << " " << "slices" << std::endl;
+
+                if ( spectraCorr ){
+
+                  AliAnalysisMuMuSpectra* spectraMeanPtCorr = FitParticle("psi",trigger->String().Data(),eventType->String().Data(),pairCut->String().Data(),centrality->String().Data(),*binning,"mpt"/*,*spectraCorr*/,kTRUE);
+
+                  AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPtCorr));
+
                   o = 0x0;
 
-                  if ( spectraMeanPt )
-                  {
+                  if ( spectraMeanPtCorr ) {
                     ++nfits; //Review this
 
-                    o = fMergeableCollection->GetObject(id.Data(),spectraMeanPt->GetName());
+                    o = fMergeableCollection->GetObject(id.Data(),spectraMeanPtCorr->GetName());
 
                     AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
 
-                    if (o)
-                    {
-                      AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPt->GetName()));
-                      fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPt->GetName()));
+                    if (o) {
+                      AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPtCorr->GetName()));
+                      fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPtCorr->GetName()));
                     }
 
-                    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPt);
+                    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPtCorr);
 
-                    if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPt->GetName() << " adopted" << std::endl;
-                    else AliError(Form("Could not adopt spectra %s",spectraMeanPt->GetName()));
-                  }
-                  else AliError("Error creating spectra");
-                  
-                }
-                else std::cout << "Mean pt fit failed: No inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl; //Uncomment
+                    if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPtCorr->GetName() << " adopted" << std::endl;
+                    else AliError(Form("Could not adopt spectra %s",spectraMeanPtCorr->GetName()));
+                    } else AliError("Error creating spectra");
+                } else std::cout << "Corrected mean pt fit failed: No corrected inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl;
               }
+            }
+          }
+        }
+      }
+    }
 
-              std::cout << "++++++++++++ Fitting corrected mean Pt for" << " " << swhat->String().Data() << " " << "slices" << std::endl;
-              
-              if ( spectraCorr )
-              {
-                AliAnalysisMuMuSpectra* spectraMeanPtCorr  = FitParticle("psi",
-                                                                       trigger->String().Data(),
-                                                                       eventType->String().Data(),
-                                                                       pairCut->String().Data(),
-                                                                       centrality->String().Data(),
-                                                                       *binning,"mpt"/*,*spectraCorr*/,kTRUE);
-                
-                
-                
-                AliDebug(1,Form("----fitting done spectra = %p",spectraMeanPtCorr));
-                
-                o = 0x0;
-                
-                if ( spectraMeanPtCorr )
-                {
-                  ++nfits; //Review this
-                  
-                  o = fMergeableCollection->GetObject(id.Data(),spectraMeanPtCorr->GetName());
-                  
-                  AliDebug(1,Form("----nfits=%d id=%s o=%p",nfits,id.Data(),o));
-                  
-                  if (o)
-                  {
-                    AliWarning(Form("Replacing %s/%s",id.Data(),spectraMeanPtCorr->GetName()));
-                    fMergeableCollection->Remove(Form("%s/%s",id.Data(),spectraMeanPtCorr->GetName()));
-                  }
-                  
-                  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),spectraMeanPtCorr);
+    delete whatArray;
+    delete triggerArray;
+    delete eventTypeArray;
+    delete pairCutArray;
+    delete centralityArray;
 
-                  if ( adoptOK ) std::cout << "+++Spectra " << spectraMeanPtCorr->GetName() << " adopted" << std::endl;
-                  else AliError(Form("Could not adopt spectra %s",spectraMeanPtCorr->GetName()));
-                  
-                }
-                else AliError("Error creating spectra");
-                
-              }
-              
-              else std::cout << "Corrected mean pt fit failed: No corrected inv mass spectra for " << swhat->String().Data() << " " << "slices" << std::endl;
-              
-            }
-          }
+    StdoutToAliDebug(1,timer.Print(););
+
+    if (nfits)
+        {
+        Update();
+        //    ReOpen(fFilename,"UPDATE");
+        //    fMergeableCollection->Write("MC",TObjArray::kOverwrite);// | TObjArray::kSingleKey);
+        //    ReOpen(fFilename,"READ");
         }
-      }
-    }
-  }
-  
-  delete whatArray;
-  delete triggerArray;
-  delete eventTypeArray;
-  delete pairCutArray;
-  delete centralityArray;
-  
-  StdoutToAliDebug(1,timer.Print(););
 
-  if (nfits)
-  {
-    Update();
-//    ReOpen(fFilename,"UPDATE");
-//    fMergeableCollection->Write("MC",TObjArray::kOverwrite);// | TObjArray::kSingleKey);
-//    ReOpen(fFilename,"READ");
-  }
-  
-  
-  return nfits;
-  
+
+    return nfits;
+
 }
 
 //_____________________________________________________________________________
@@ -2829,346 +3472,475 @@ TGraph* AliAnalysisMuMu::PlotEventSelectionEvolution(const char* trigger1, const
                                                      Bool_t drawFills,
                                                      Bool_t asRejection) const
 {
-  if (!CC()) return 0x0;
-  
-  const std::set<int>& runnumbers = RunNumbers();
-  
-  TGraphErrors* g = new TGraphErrors(runnumbers.size());
-  
-  std::set<int>::const_iterator it;
-  Int_t i(0);
+    if (!CC()) return 0x0;
 
-  Double_t ymin(TMath::Limits<double>::Max());
-  Double_t ymax(TMath::Limits<double>::Min());
+    const std::set<int>& runnumbers = RunNumbers();
 
-  for ( it = runnumbers.begin(); it != runnumbers.end(); ++it )
-  {
-    Int_t runNumber = *it;
-    Double_t n = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger1,event1,runNumber));
-    Double_t d = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger2,event2,runNumber));
-    if (n>0 && d>0)
-    {
-      Double_t y = n/d;
-      
-      if ( fCorrectionPerRun )
-      {
-        Double_t xcorr,ycorr;
-        fCorrectionPerRun->GetPoint(i,xcorr,ycorr); // note that the fact that xcorr==runNumber has been checked by the SetCorrectionPerRun method
-        y *= ycorr;
-        // FIXME: should get the correction error here
-      }
-      
-      if ( asRejection ) y = 100*(1.0 - y);
-      ymin = TMath::Min(ymin,y);
-      ymax = TMath::Max(ymax,y);
-      Double_t yerr = y*AliAnalysisMuMuResult::ErrorAB(n,TMath::Sqrt(n),d,TMath::Sqrt(d));
-      g->SetPoint(i,runNumber,y);
-      g->SetPointError(i,0.5,yerr);
-      
-      ++i;
-    }
-    
-  }
+    TGraphErrors* g = new TGraphErrors(runnumbers.size());
 
-  TH2* hframe = new TH2F(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
-                         Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
-                         runnumbers.size()+50,
-                         *(runnumbers.begin())-25,
-                         *(runnumbers.rbegin())+25,100,0,ymax*1.3);
-  
-  gStyle->SetOptStat(0);
-  
-  hframe->Draw();
-  
-  hframe->GetXaxis()->SetNoExponent();
-           
-  hframe->GetYaxis()->SetTitle(asRejection ? "Rejection (%)" : "Ratio");
-  
-  g->Set(i);
-  g->SetTitle(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2));
-  g->GetXaxis()->SetNoExponent();
-  g->Draw("lp");
+    std::set<int>::const_iterator it;
+    Int_t i(0);
 
-  AliAnalysisTriggerScalers ts(RunNumbers(),Config()->OCDBPath());
+    Double_t ymin(TMath::Limits<double>::Max());
+    Double_t ymax(TMath::Limits<double>::Min());
 
-  if ( drawFills )
-  {
-    ts.DrawFills(ymin,ymax);
+    for ( it = runnumbers.begin(); it != runnumbers.end(); ++it )
+        {
+        Int_t runNumber = *it;
+        Double_t n = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger1,event1,runNumber));
+        Double_t d = CC()->GetSum(Form("trigger:%s/event:%s/run:%d",trigger2,event2,runNumber));
+        if (n>0 && d>0)
+            {
+            Double_t y = n/d;
+
+            if ( fCorrectionPerRun )
+                {
+                Double_t xcorr,ycorr;
+                fCorrectionPerRun->GetPoint(i,xcorr,ycorr); // note that the fact that xcorr==runNumber has been checked by the SetCorrectionPerRun method
+                y *= ycorr;
+                // FIXME: should get the correction error here
+                }
+
+            if ( asRejection ) y = 100*(1.0 - y);
+            ymin = TMath::Min(ymin,y);
+            ymax = TMath::Max(ymax,y);
+            Double_t yerr = y*AliAnalysisMuMuResult::ErrorAB(n,TMath::Sqrt(n),d,TMath::Sqrt(d));
+            g->SetPoint(i,runNumber,y);
+            g->SetPointError(i,0.5,yerr);
+
+            ++i;
+            }
+
+        }
+
+    TH2* hframe = new TH2F(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
+                           Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2),
+                           runnumbers.size()+50,
+                           *(runnumbers.begin())-25,
+                           *(runnumbers.rbegin())+25,100,0,ymax*1.3);
+
+    gStyle->SetOptStat(0);
+
+    hframe->Draw();
+
+    hframe->GetXaxis()->SetNoExponent();
+
+    hframe->GetYaxis()->SetTitle(asRejection ? "Rejection (%)" : "Ratio");
+
+    g->Set(i);
+    g->SetTitle(Form("%s %s-%s / %s-%s",(asRejection ? "1 - ":""),trigger1,event1,trigger2,event2));
+    g->GetXaxis()->SetNoExponent();
     g->Draw("lp");
-  }
-  
-  
-  std::map<std::string, std::pair<int,int> > periods;
-  
-  ts.GetLHCPeriodBoundaries(periods);
-  
-  TLegend* legend = new TLegend(0.15,0.82,0.90,0.92);
-  legend->SetFillColor(0);
-  Int_t n(0);
-  
 
-  for ( std::map<std::string, std::pair<int,int> >::const_iterator pit = periods.begin(); pit != periods.end(); ++pit )
-  {
-    std::string period = pit->first;
-    int run1 = (pit->second).first;
-    int run2 = (pit->second).second;
-    int nruns(0);
-    for ( std::set<int>::const_iterator rit = RunNumbers().begin(); rit != RunNumbers().end(); ++ rit )
-    {
-      if ( (*rit) >= run1 && (*rit) <= run2 )
-      {
-        ++nruns;
-      }
-    }
-    AliInfo(Form("Period %s runs %6d-%6d ; %d actual runs",period.c_str(),run1,run2,nruns));
-    
-    g->Fit("pol0","+Q","",run1,run2);
-    TF1* func = static_cast<TF1*>(g->GetListOfFunctions()->Last());
-    if (func)
-    {
-      func->SetLineColor(2+n);
-      legend->AddEntry(func,Form("%s %5.2f #pm %5.2f %s (rel. error %5.2f %%)",period.c_str(),func->GetParameter(0),func->GetParError(0),
-                                 (asRejection ? "%":""),100*func->GetParError(0)/func->GetParameter(0)));
-      ++n;
-    }
-  }
+    AliAnalysisTriggerScalers ts(RunNumbers(),Config()->OCDBPath());
 
-  legend->SetNColumns(3);
+    if ( drawFills )
+        {
+        ts.DrawFills(ymin,ymax);
+        g->Draw("lp");
+        }
 
-  Double_t mean = TMath::Mean(g->GetN(),g->GetY());
-  Double_t rms = TMath::RMS(g->GetN(),g->GetY());
-  
-  legend->AddEntry("",Form("Mean %5.2f RMS %5.2f (%5.2f %%)",mean,rms,(mean) ? 100.0*rms/mean : 0.0),"");
-  
-  legend->Draw();
-  
-  return g;
+
+    std::map<std::string, std::pair<int,int> > periods;
+
+    ts.GetLHCPeriodBoundaries(periods);
+
+    TLegend* legend = new TLegend(0.15,0.82,0.90,0.92);
+    legend->SetFillColor(0);
+    Int_t n(0);
+
+
+    for ( std::map<std::string, std::pair<int,int> >::const_iterator pit = periods.begin(); pit != periods.end(); ++pit )
+        {
+        std::string period = pit->first;
+        int run1 = (pit->second).first;
+        int run2 = (pit->second).second;
+        int nruns(0);
+        for ( std::set<int>::const_iterator rit = RunNumbers().begin(); rit != RunNumbers().end(); ++ rit )
+            {
+            if ( (*rit) >= run1 && (*rit) <= run2 )
+                {
+                ++nruns;
+                }
+            }
+        AliInfo(Form("Period %s runs %6d-%6d ; %d actual runs",period.c_str(),run1,run2,nruns));
+
+        g->Fit("pol0","+Q","",run1,run2);
+        TF1* func = static_cast<TF1*>(g->GetListOfFunctions()->Last());
+        if (func)
+            {
+            func->SetLineColor(2+n);
+            legend->AddEntry(func,Form("%s %5.2f #pm %5.2f %s (rel. error %5.2f %%)",period.c_str(),func->GetParameter(0),func->GetParError(0),
+                                       (asRejection ? "%":""),100*func->GetParError(0)/func->GetParameter(0)));
+            ++n;
+            }
+        }
+
+    legend->SetNColumns(3);
+
+    Double_t mean = TMath::Mean(g->GetN(),g->GetY());
+    Double_t rms = TMath::RMS(g->GetN(),g->GetY());
+
+    legend->AddEntry("",Form("Mean %5.2f RMS %5.2f (%5.2f %%)",mean,rms,(mean) ? 100.0*rms/mean : 0.0),"");
+
+    legend->Draw();
+
+    return g;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::ShowList(const char* title, const TString& list, const char separator) const
 {
-  /// Show a list of strings
-  TObjArray* parts = list.Tokenize(separator);
-  
-  std::cout << title << " (" << parts->GetEntries() << ") : " << std::endl;
-  
-  TIter next(parts);
-  TObjString* str;
-  
-  while ( ( str = static_cast<TObjString*>(next()) ) )
-  {
-    std::cout << "    " << str->String().Data() << std::endl;
-  }
-  
-  if ( parts->GetEntries()==0) std::cout << endl;
-  
-  delete parts;
+    /// Show a list of strings
+    TObjArray* parts = list.Tokenize(separator);
+
+    std::cout << title << " (" << parts->GetEntries() << ") : " << std::endl;
+
+    TIter next(parts);
+    TObjString* str;
+
+    while ( ( str = static_cast<TObjString*>(next()) ) )
+        {
+        std::cout << "    " << str->String().Data() << std::endl;
+        }
+
+    if ( parts->GetEntries()==0) std::cout << endl;
+
+    delete parts;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::Print(Option_t* opt) const
 {
     /// printout
-  std::cout << "Reading from file : " << fFilename.Data() << std::endl;
-  
-  TString copt(opt);
-  
-  if (IsSimulation() || SIM() )
-  {
-    copt += "SIM";
-  }
+    std::cout << "Reading from file : " << fFilename.Data() << std::endl;
 
-  if ( !IsSimulation() )
-  {
-    copt += "REAL";
-  }
-  
-  Config()->Print(copt.Data());
+    TString copt(opt);
+
+    if (IsSimulation() || SIM() )
+        {
+        copt += "SIM";
+        }
+
+    if ( !IsSimulation() )
+        {
+        copt += "REAL";
+        }
+
+    Config()->Print(copt.Data());
+
+    if ( RunNumbers().size() > 1 )
+        {
+        std::cout << RunNumbers().size() << " runs";
+        }
+    else
+        {
+        std::cout << RunNumbers().size() << " run";
+        }
 
-  if ( RunNumbers().size() > 1 )
-  {
-    std::cout << RunNumbers().size() << " runs";
-  }
-  else
-  {
-    std::cout << RunNumbers().size() << " run";
-  }
-  
-  if ( fCorrectionPerRun )
-  {
-    std::cout << " with correction factors";
-  }
-  std::cout << std::endl;
-  Int_t i(0);
-  for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
-  {
-    std::cout << (*it);
     if ( fCorrectionPerRun )
-    {
-      std::cout << Form("(%e)",fCorrectionPerRun->GetY()[i]);
-    }
-    std::cout << ",";
-    ++i;
-  }
-  std::cout << std::endl;
-  
-  TString sopt(opt);
-  sopt.ToUpper();
-  
-  if ( sopt.Contains("BIN") && BIN() )
-  {
-    std::cout << "Binning : " << std::endl;
-    TString topt(sopt);
-    topt.ReplaceAll("BIN","");
-    BIN()->Print(topt.Data());
-  }
-  if ( sopt.Contains("MC") && OC() )
-  {
-    TString topt(sopt);
-    topt.ReplaceAll("MC","");
-    OC()->Print(topt.Data());
-  }
-  if ( sopt.Contains("CC") && CC() )
-  {
-    CC()->Print("trigger/event");
-  }
-  
-  if ( sopt.Contains("SIZE") )
-  {
-    TFile* f = ReOpen(fFilename,"READ");
-    TIter next(f->GetListOfKeys());
-    TKey* key;
-    
-    while ( ( key = static_cast<TKey*>(next()) ) )
-    {
-      std::cout << key->GetName() << " " << key->GetNbytes() << " " << key->GetObjlen() << std::endl;
-    }
-  }
+        {
+        std::cout << " with correction factors";
+        }
+    std::cout << std::endl;
+    Int_t i(0);
+    for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
+        {
+        std::cout << (*it);
+        if ( fCorrectionPerRun )
+            {
+            std::cout << Form("(%e)",fCorrectionPerRun->GetY()[i]);
+            }
+        std::cout << ",";
+        ++i;
+        }
+    std::cout << std::endl;
+
+    TString sopt(opt);
+    sopt.ToUpper();
+
+    if ( sopt.Contains("BIN") && BIN() )
+        {
+        std::cout << "Binning : " << std::endl;
+        TString topt(sopt);
+        topt.ReplaceAll("BIN","");
+        BIN()->Print(topt.Data());
+        }
+    if ( sopt.Contains("MC") && OC() )
+        {
+        TString topt(sopt);
+        topt.ReplaceAll("MC","");
+        OC()->Print(topt.Data());
+        }
+    if ( sopt.Contains("CC") && CC() )
+        {
+        CC()->Print("trigger/event");
+        }
+
+    if ( sopt.Contains("SIZE") )
+        {
+        TFile* f = ReOpen(fFilename,"READ");
+        TIter next(f->GetListOfKeys());
+        TKey* key;
+
+        while ( ( key = static_cast<TKey*>(next()) ) )
+            {
+            std::cout << key->GetName() << " " << key->GetNbytes() << " " << key->GetObjlen() << std::endl;
+            }
+        }
 }
 
 //_____________________________________________________________________________
-TFile* AliAnalysisMuMu::ReOpen(const char* filename, const char* mode) const
+void AliAnalysisMuMu::PrintNofParticle(const char* particle, const char* what, const char* binType, Bool_t AccEffCorr) const
 {
-  /// Tries to reopen the file with a new mode
-  
-  TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(filename));
-  
-  if (f)
-  {
-    delete f;
-  }
-  
-  f = TFile::Open(filename,mode);
-  
-  if ( !f || !f->IsOpen() )
-  {
-    AliError(Form("Cannot open file %s in mode %s",filename,mode));
-    return 0x0;
-  }
-  
-  return f;
+    ///
+    /// Function to use after JPsi(). It loops over all combination of centrality/enventype/ trigger (etc.) and
+    /// print RAA on terminal accordingly. Fnorm / <T_AA> / other constants are written in AliAnalysisMuMuSpectraCapsulePbPb.
+    /// <binType> can be either "PT" or "Y" for the moment. This method reads sigma_pp value
+    /// from extern file who's line must be written as :
+    ///
+    /// intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff;
+    ///
+    /// WATCH OUT FOR UNITS !! Function is written for cross-section in microbarn in externFile
+    ///
+    /// note : For now, this method is set for a single centrality bin 0-90
+    /// TODO : Make it work with different centrality, i.e  need to read also an extra externfile with value who are function of centrality (<T_AA> for instance...)
+    ///
+    ///
+
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       Number of "<< particle << endl;
+        cout <<      " ================================================================ " << endl;
+        }
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* particleArray    = TString(particle).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextParticle(particleArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* strigger;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sparticle;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    //Loop on particle type
+    while ( ( sparticle = static_cast<TObjString*>(nextParticle()) ) )
+        {
+        AliDebug(1,Form("particle %s",sparticle->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( strigger = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",strigger->String().Data()));
+                nextCentrality.Reset();
+                // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                    AliDebug(1,Form("--CENTRALITY %s",scentrality->String().Data()));
+                    nextPairCut.Reset();
+                    // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                        {
+                        AliDebug(1,Form("---PAIRCUT %s",spairCut->String().Data()));
+                        nextbinType.Reset();
+                        // Loop on each type (pt or y)
+                        //==============================================================================
+                        while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                            {
+                            AliDebug(1,Form("----TYPE %s",sbinType->String().Data()));
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),strigger->String().Data(),scentrality->String().Data(),spairCut->String().Data(),sparticle->String().Data(),sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            
+                            if(!spectra){
+                              AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                              continue;
+                            }
+                            //________
+
+                            // Create pointer on fitted spectra
+                            AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,"","");
+                            
+                            if(!capsule){
+                              AliError("Could not find spetra !");
+                              continue;
+                            }
+                            
+                            AliDebug(1,Form("Spectra = %p",capsule));
+
+                            capsule->PrintNofWhat(what);
+                            delete capsule;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+    delete eventTypeArray ;
+    delete triggerArray ;
+    delete fitfunctionArray ;
+    delete pairCutArray ;
+    delete centralityArray ;
+    delete particleArray ;
+    delete binTypeArray ;
+
+    return ;
+
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::SetCentralitySelectionList(const char* centralitySelectionList)
+TFile* AliAnalysisMuMu::ReOpen(const char* filename, const char* mode) const
 {
-  /// Set centralities to be used during fitting
-  /// centralitySelectionList is a regular expression.
+    /// Tries to reopen the file with a new mode
 
-  TObjArray* centralities = BIN()->CreateBinObjArray("centrality");
-  TIter next(centralities);
-  AliAnalysisMuMuBinning::Range* r;
+    TFile* f = static_cast<TFile*>(gROOT->GetListOfFiles()->FindObject(filename));
 
-  TString csl;
+    if (f)
+        {
+        delete f;
+        }
 
-  TPRegexp re(centralitySelectionList);
-  
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    AliDebug(1,Form("r=%s",r->AsString().Data()));
-    if ( re.MatchB(r->AsString()) )
-    {
-      csl += r->AsString();
-      csl += ",";
-    }
-  }
-  
-  if ( IsSimulation() )  csl += " sim";
-  
-  Config()->Add(Config()->CentralitySelectionKey(),csl);
-  
-  delete centralities;
+    f = TFile::Open(filename,mode);
+
+    if ( !f || !f->IsOpen() )
+        {
+        AliError(Form("Cannot open file %s in mode %s",filename,mode));
+        return 0x0;
+        }
+
+    return f;
 }
 
+////_____________________________________________________________________________
+//void AliAnalysisMuMu::SetCentralitySelectionList(const char* centralitySelectionList)
+//{
+//  /// Set centralities to be used during fitting
+//  /// centralitySelectionList is a regular expression.
+//
+//  TObjArray* centralities = BIN()->CreateBinObjArray("centrality");
+//  TIter next(centralities);
+//  AliAnalysisMuMuBinning::Range* r;
+//
+//  TString csl;
+//
+//  TPRegexp re(centralitySelectionList);
+//
+//  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+//  {
+//    AliDebug(1,Form("r=%s",r->AsString().Data()));
+//    if ( re.MatchB(r->AsString()) )
+//    {
+//      csl += r->AsString();
+//      csl += ",";
+//    }
+//  }
+//
+//  Config()->SetList(AliAnalysisMuMuConfig::kCentralitySelectionList,IsSimulation(),csl);
+//
+//  delete centralities;
+//}
+
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMu::SetCorrectionPerRun(const TGraph& corr, const char* formula)
 {
     /// Sets the graph used to correct values per run
-  delete fCorrectionPerRun;
-  fCorrectionPerRun=0x0;
-  
-  // check that corr has the same runs as we do
-  
-  Int_t i(0);
-  
-  for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
-  {
-    Int_t corrRun = TMath::Nint(corr.GetX()[i]);
-    if (corrRun != *it)
-    {
-      AliError(Form("%d-th run mistmatch %d vs %d",i,corrRun,*it));
-      
-      return kFALSE;
-    }
-    ++i;
-  }
-  
-  fCorrectionPerRun = new TGraphErrors(corr.GetN());
+    delete fCorrectionPerRun;
+    fCorrectionPerRun=0x0;
 
-  TFormula* tformula(0x0);
-  if ( strlen(formula) > 0 )
-  {
-    tformula = new TFormula("SetCorrectionPerRunFormula",formula);
-  }
+    // check that corr has the same runs as we do
 
-  i = 0;
-  
-  for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
-  {
-    Double_t y = corr.GetY()[i];
-    
-    if ( tformula )
-    {
-      y = tformula->Eval(y);
-    }
-    fCorrectionPerRun->SetPoint(i,corr.GetX()[i],y);
-    ++i;
-  }
+    Int_t i(0);
 
-  delete formula;
-  
-  return kTRUE;
+    for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
+        {
+        Int_t corrRun = TMath::Nint(corr.GetX()[i]);
+        if (corrRun != *it)
+            {
+            AliError(Form("%d-th run mistmatch %d vs %d",i,corrRun,*it));
+
+            return kFALSE;
+            }
+        ++i;
+        }
+
+    fCorrectionPerRun = new TGraphErrors(corr.GetN());
+
+    TFormula* tformula(0x0);
+    if ( strlen(formula) > 0 )
+        {
+        tformula = new TFormula("SetCorrectionPerRunFormula",formula);
+        }
+
+    i = 0;
+
+    for ( std::set<int>::const_iterator it = RunNumbers().begin(); it != RunNumbers().end(); ++it )
+        {
+        Double_t y = corr.GetY()[i];
+
+        if ( tformula )
+            {
+            y = tformula->Eval(y);
+            }
+        fCorrectionPerRun->SetPoint(i,corr.GetX()[i],y);
+        ++i;
+        }
+
+    delete formula;
+
+    return kTRUE;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::SetNofInputParticles(AliAnalysisMuMuJpsiResult& r)
 {
-  /// Set the "NofInput" variable(s) of one result
-  
-  TString hname(Form("MinvUS%s",r.Bin().AsString().Data()));
+    /// Set the "NofInput" variable(s) of one result, equivalent to compute AccxEff
 
-  TH1* hinput = fMergeableCollection->Histo(Form("/%s/ALL/ANY/V0A/INYRANGE",AliAnalysisMuMuBase::MCInputPrefix()),hname.Data());
+    TString hname(Form("MinvUS+%s",r.Bin().AsString().Data()));
+    TString EventSelectionKey =Config()->First(Config()->EventSelectionKey(),IsSimulation());
+    TString Centrality        =Config()->First(Config()->CentralitySelectionKey(),IsSimulation());
+    TString DimuonTrigger     =Config()->First(Config()->DimuonTriggerKey(),IsSimulation());
 
-  if (!hinput)
-  {
-    AliError(Form("Got a simulation file where I did not find histogram /%s/ALL/EVERYTHING/ANY/INYRANGE/%s",AliAnalysisMuMuBase::MCInputPrefix(),hname.Data()));
+    TH1* hinput = fMergeableCollection->Histo(Form("/%s/%s/%s/%s/INYRANGE",AliAnalysisMuMuBase::MCInputPrefix(),EventSelectionKey.Data(),DimuonTrigger.Data(),Centrality.Data()),hname.Data());
 
-  }
-  else
-  {
-    r.SetNofInputParticles(*hinput);
-  }
+    if (!hinput)AliError(Form("Got a simulation file where I did not find histogram /%s/%s/%s/%s/INYRANGE/%s",AliAnalysisMuMuBase::MCInputPrefix(),EventSelectionKey.Data(),DimuonTrigger.Data(),Centrality.Data(),hname.Data()));
+    else r.SetNofInputParticles(*hinput);
 }
 
 //_____________________________________________________________________________
@@ -3176,7 +3948,7 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::SPECTRA(const char* fullpath) const
 {
   /// Shortcut method to get to a spectra
   if (!OC()) return 0x0;
-  
+
   return static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(fullpath));
 }
 
@@ -3184,36 +3956,42 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::SPECTRA(const char* fullpath) const
 void AliAnalysisMuMu::SelectRunByTrigger(const char* triggerList)
 {
   if (!fMergeableCollection || !fCounterCollection) return;
-  
+
   TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
   TIter nextRun(runs);
-  
+
   TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
   TIter nextTrigger(triggers);
-  
+
   TObjString* srun;
   TObjString* strigger;
-  
+
   TString striggerList(triggerList);
-  
+
   TList* runList = new TList();
-  
+
   while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
   {
-    
-    nextTrigger.Reset();
-    
-    while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
+
+    TList* runList = new TList();
+
+    while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
     {
-      if ( !striggerList.Contains(strigger->String().Data()) )
+
+      nextTrigger.Reset();
+
+      while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
       {
-        continue;
+        if ( !striggerList.Contains(strigger->String().Data()) )
+            {
+            continue;
+            }
+
+        ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d",
+                                                                  strigger->String().Data(),"PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",srun->String().Atoi())));
+        if ( n > 0 ) runList->Add(srun);
+
       }
-      
-      ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d",
-                                                                strigger->String().Data(),"PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",srun->String().Atoi())));
-      if ( n > 0 ) runList->Add(srun);
-  
     }
   }
     runList->Sort();
@@ -3232,37 +4010,37 @@ void AliAnalysisMuMu::TriggerCountCoverage(const char* triggerList,
                                            Bool_t compact,
                                            Bool_t orderByTriggerCount)
 {
-  // Give the fraction of triggers (in triggerList) relative 
+  // Give the fraction of triggers (in triggerList) relative
   // to what is expected in the scalers
-  
+
   TGrid::Connect("alien://"); // to insure the "Trying to connect to server... message does not pollute our output later on...
-  
+
   AliLog::EType_t oldLevel = static_cast<AliLog::EType_t>(AliLog::GetGlobalLogLevel());
-  
+
   AliLog::SetGlobalLogLevel(AliLog::kFatal);
-  
+
   if (!fMergeableCollection || !fCounterCollection) return;
-  
+
   TObjArray* runs = fCounterCollection->GetKeyWords("run").Tokenize(",");
   TIter nextRun(runs);
-  
+
   TObjArray* triggers = fCounterCollection->GetKeyWords("trigger").Tokenize(",");
   TIter nextTrigger(triggers);
-  
+
   TObjString* srun;
   TObjString* strigger;
-  
+
   TString striggerList(triggerList);
-  
+
   ULong64_t total(0);
   ULong64_t totalExpected(0);
   TString msg;
   std::multimap<ULong64_t,std::string> messages;
-  
+
   while ( ( srun = static_cast<TObjString*>(nextRun()) ) )
   {
     msg.Form("RUN %09d ",srun->String().Atoi());
-    
+
     if (!compact)
     {
         msg += "\n";
@@ -3271,28 +4049,28 @@ void AliAnalysisMuMu::TriggerCountCoverage(const char* triggerList,
     ULong64_t nmax(0);
 
     nextTrigger.Reset();
-    
+
     while ( ( strigger = static_cast<TObjString*>(nextTrigger()) ) )
     {
-      if ( !striggerList.Contains(strigger->String().Data()) ) 
+      if ( !striggerList.Contains(strigger->String().Data()) )
       {
         continue;
       }
-  
+
       ULong64_t n = TMath::Nint(fCounterCollection->GetSum(Form("trigger:%s/event:%s/run:%d",
                                                             strigger->String().Data(),"ALL",srun->String().Atoi())));
-    
+
       ULong64_t expected = GetTriggerScalerCount(strigger->String().Data(),srun->String().Atoi());
-    
-      
+
+
       nmax = TMath::Max(n,nmax);
-      
+
       total += n;
       totalExpected += expected;
-      
+
       msg += TString::Format("%30s %9lld expected %9lld [%s] ",strigger->String().Data(),n,expected,
                              (n>expected ? "!" : " "));
-      
+
       if ( expected > 0 ) {
         msg += TString::Format("fraction %5.1f %%",n*100.0/expected);
       }
@@ -3314,12 +4092,12 @@ void AliAnalysisMuMu::TriggerCountCoverage(const char* triggerList,
       }
     }
   }
-  
+
   std::multimap<ULong64_t,std::string>::const_reverse_iterator it;
-  
+
   ULong64_t current(0);
   Int_t n(0);
-  
+
   for ( it = messages.rbegin(); it != messages.rend(); ++it )
   {
     ++n;
@@ -3330,31 +4108,41 @@ void AliAnalysisMuMu::TriggerCountCoverage(const char* triggerList,
 
   std::cout << Form("--- TOTAL %lld expected %lld fraction %5.1f %%",
                     total,totalExpected,totalExpected ? total*100.0/totalExpected : 0.0) << std::endl;
-  
 
-   
-  AliLog::SetGlobalLogLevel(oldLevel);
-  delete triggers;
-  delete runs;
+
+    for ( it = messages.rbegin(); it != messages.rend(); ++it )
+        {
+        ++n;
+        current += it->first;
+        Double_t percent = ( total > 0.0 ? current*100.0/total : 0.0);
+        std::cout << Form("%10lld",it->first) << " " << it->second << " percentage of total = " << Form("%7.2f %% %3d",percent,n ) << std::endl;
+        }
+
+    std::cout << Form("--- TOTAL %lld expected %lld fraction %5.1f %%",
+                      total,totalExpected,totalExpected ? total*100.0/totalExpected : 0.0) << std::endl;
+
+
+
+    AliLog::SetGlobalLogLevel(oldLevel);
+    delete triggers;
+    delete runs;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::UnsetCorrectionPerRun()
 {
     // drop the correction factors
-  delete fCorrectionPerRun;
-  fCorrectionPerRun=0x0;
+    delete fCorrectionPerRun;
+    fCorrectionPerRun=0x0;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::Update()
 {
   /// update the current file with memory
- 
+
   if (!CC() || !OC()) return;
-  
-  std::cout << "fDirectory=" << fDirectory.Data() << std::endl;
-  
+
   ReOpen(fFilename,"UPDATE");
 
   if (OC())
@@ -3367,2154 +4155,1839 @@ void AliAnalysisMuMu::Update()
   }
 
   ReOpen(fFilename,"READ");
-  
+
   GetCollections(fFilename,fDirectory,fMergeableCollection,fCounterCollection,fBinning,fRunNumbers);
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMu::Upgrade(const char* filename)
 {
-  /// Upgrade a file
-  AliAnalysisMuMu m(filename);
-  
-  return m.Upgrade();
+    /// Upgrade a file
+    AliAnalysisMuMu m(filename);
+
+    return m.Upgrade();
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMu::Upgrade()
 {
-  /// Upgrade the current file
-  /// - from single list to one key per object, if needed
-  /// - from histogramCollection to mergeableCollection, if needed
+    /// Upgrade the current file
+    /// - from single list to one key per object, if needed
+    /// - from histogramCollection to mergeableCollection, if needed
 
-  
-  AliWarning("Out of date method");
-  
-  TFile* f = ReOpen(fFilename,"UPDATE");
-  
-  TList* list = static_cast<TList*>(f->Get("chist"));
-  
-  if (list)
-  {
-    // really old file where everything was in a single list
-  
-    AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(list->At(0));
-    AliCounterCollection* cc = static_cast<AliCounterCollection*>(list->At(1));
-    
-    AliMergeableCollection* mc = hc->Convert();
-    
-    f->cd();
-    
-    mc->Write("MC",TObject::kSingleKey);
-    cc->Write("CC",TObject::kSingleKey);
-    
-    f->Delete("chist;*");
-    
-    f->Write();
-    
-  }
-  else
-  {
-    AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(f->Get("HC"));
 
-    if ( hc )
-    {
-      // old file with histogram collection instead of mergeable collection
-      
-      AliMergeableCollection* mc = hc->Convert();
+    AliWarning("Out of date method");
 
-      f->cd();
+    TFile* f = ReOpen(fFilename,"UPDATE");
 
-      mc->Write("MC",TObject::kSingleKey);
+    TList* list = static_cast<TList*>(f->Get("chist"));
 
-      f->Delete("HC;*");
-      
-      f->Write();
-    }
-  }
+    if (list)
+        {
+        // really old file where everything was in a single list
 
-  delete f;
-  
-  return kTRUE;
-}
+        AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(list->At(0));
+        AliCounterCollection* cc = static_cast<AliCounterCollection*>(list->At(1));
 
-//_____________________________________________________________________________
-TH2* AliAnalysisMuMu::ComputeSPDCorrection(const char* type, const char* eventSel, const char* triggerSel, Bool_t bkgReject)
-{
-  TString stype(type);
-  TString evtype(eventSel);
-  TString trigtype(triggerSel);
-  
-  TH2* hNch = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NchVsZVertexVsEta",evtype.Data(),
-                                                 trigtype.Data()))); // Input Nch // //"/INPUT/QASPDZPSALL/NchVSEtaVSZVertMC"
-  if ( !hNch )
-  {
-    AliError("No Nch histo found");
-    return 0x0;
-  }
-  TH2* hNtr = static_cast<TH2*>(OC()->Histo(Form("/%s/%s/V0A/TrackletsVsZVertexVsEta",evtype.Data(),
-                                                trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
-  if ( !hNtr )
-  {
-    AliError("No tracklets histo found");
-    return 0x0;
-  }
-  
-  TH2* hNtrBkg = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NBkgTrackletsVsZVertexVsEta",evtype.Data(),
-                                                 trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
-  if ( !hNtrBkg )
-  {
-    AliError("No background tracklets histo found");
-    return 0x0;
-  }
+        AliMergeableCollection* mc = hc->Convert();
 
-  
-  TH2D* hSPDCorr = static_cast<TH2D*>(hNtr->Clone("SPDCorr"));
-  TString title("");\
-  if ( stype.Contains("oneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction");
-  else if ( stype.Contains("AccEffOnly")) hSPDCorr->SetTitle("SPD AccxEff correction");
-  else if ( stype.Contains("statOneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction stat. unc.");
-  
-  for (Int_t i = 1 ; i < hNch->GetNbinsX() ; i++)
-  {
-    for (Int_t j = 1 ; j < hNch->GetNbinsY() ; j++)
-    {
-      Int_t n = hNch->GetBin(i,j);
-      Double_t nch = hNch->GetBinContent(n);
-      Double_t ntr = hNtr->GetBinContent(n);
-      Double_t nBkgtr(0.);
-      if ( bkgReject ) nBkgtr = hNtrBkg->GetBinContent(n);
-      
-      Double_t corr(0.),corrErr(0.);
-      if ( nch != 0. )
-      {
-        corr = (ntr - nBkgtr)/nch;
-        corrErr = TMath::Max( 1./nch,TMath::Sqrt( corr*(1.-corr)/nch ) );
-      }
-      
-      if ( stype.Contains("oneOverAccEff"))
-      {
-        if ( corr > 0. )
+        f->cd();
+
+        mc->Write("MC",TObject::kSingleKey);
+        cc->Write("CC",TObject::kSingleKey);
+
+        f->Delete("chist;*");
+
+        f->Write();
+
+        }
+    else
         {
-          hSPDCorr->SetBinContent(n,1./corr);
-          hSPDCorr->SetBinError(n,corrErr/TMath::Power(corr,2.));
+        AliHistogramCollection* hc = static_cast<AliHistogramCollection*>(f->Get("HC"));
+
+        if ( hc )
+            {
+            // old file with histogram collection instead of mergeable collection
+
+            AliMergeableCollection* mc = hc->Convert();
+
+            f->cd();
+
+            mc->Write("MC",TObject::kSingleKey);
+
+            f->Delete("HC;*");
+
+            f->Write();
+            }
         }
-        else
+
+    delete f;
+
+    return kTRUE;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::PrintDistribution(const char* binType, const char* what, const char* sResName, const char* ColSys, Bool_t divideByBinWidth, Bool_t AccEffCorr)
+{
+    /// Compute what distribution vs binType. Delegate procedure to AliAnalysisSpectra object. It can be compute for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
+    ///
+    /// Parameters:
+    ///   -binType    : INTEGRATED, PT, Y (for now)
+    ///   -what       : The quantity (NofJPsi by default, but could be something else...)
+    ///   -AccEffCorr : Just a tag to select right histograms.
+    ///   -sResName   : subresult name to get the yield from. By default is "" (mean of all subresults)
+
+    if (!OC() || !CC())
         {
-          hSPDCorr->SetBinContent(n,0.);
-          hSPDCorr->SetBinError(n,1.);
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
         }
-        
-      }
-      else if ( stype.Contains("AccEffOnly"))
-      {
-        hSPDCorr->SetBinContent(n,corr);
-        hSPDCorr->SetBinError(n,corrErr);
-      }
-      else if ( stype.Contains("statOneOverAccEff"))
-      {
-        if ( corr != 0. )
+    else
         {
-          hSPDCorr->SetBinContent(n,(corrErr/TMath::Power(corr,2.)*100)/(1./corr));
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       PrintDistribution                          " << endl;
+        cout <<      " ================================================================ " << endl;
         }
-        else
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* swhat;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+    const TString syear(ColSys);
+
+    // Pointers
+    TH1* h= 0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+
+    //Loop on what type
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
         {
-          hSPDCorr->SetBinContent(n,-1);
+        AliDebug(1,Form("what %s",swhat->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+
+                        // //canvas
+                        // TCanvas *c1 = new TCanvas;
+                        // c1->Draw();
+                        // gStyle->SetOptStat(0);
+
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                            {
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),"PSI",sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+
+                            h= spectra->Plot(swhat->String().Data(),sResName,divideByBinWidth);
+                            TCanvas *c = new TCanvas;
+                            c->SetLogy();
+                            h->Draw();
+                            }
+                        }
+                    }
+                }
+            }
         }
 
-      }
-    }
-  }
-  
-  return hSPDCorr;
+    return;
 }
 
-//_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeFnorm()
+void AliAnalysisMuMu::ComputeDimuonRawCount(const Double_t rlow, const Double_t rhigh, const char* binType, const char* binRangeExluded, const char* flavour, Bool_t corrected)
 {
-  /// Compute the CMUL to CINT ratio(s)
-  
-  if (!CC()) return;
-  
-  OC()->Prune("/FNORM");
-  
-  AliAnalysisMuMuFnorm computer(*(CC()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());
-  
-  computer.ComputeFnorm();
+    /// Compute the raw count of dimuon pair
+    /// Parameters:
+    ///   - rlow,rhigh  : intervall in bin for the raw count
+    ///   -binType       : integrated,pt,y ...see your AddTaskMuMu
+    ///   -flavour       : Default is BENJ
+    ///   -corrected     : For nomenclature
+
+    if(!OC())
+    {
+        AliError("No mergeable. Consider Upgrade()");
+        return;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputeDimuonRawCount                          " << endl;
+        cout <<      " ================================================================ " << endl;
+    }
 
-  AliMergeableCollection* fnorm = computer.DetachMC();
-  
-  OC()->Attach(fnorm,"/FNORM/");
-  
-  Update();
-}
+     // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* binRangeExcludedArray     = TString(binRangeExluded).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+
+    // Pointers
+    TH1* h= 0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+
+
+    // Loop on each envenType (see MuMuConfig)
+    //==============================================================================
+    while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+    {
+        AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+        nextTrigger.Reset();
+        // Loop on each trigger (see MuMuConfig)
+        //==============================================================================
+        while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+        {
+            AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+            nextPairCut.Reset();
+            // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+            //==============================================================================
+            while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+            {
+                AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                nextbinType.Reset();
+                // Loop on each type (pt or y)
+                //==============================================================================
+                while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                {
+                    AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                    nextCentrality.Reset();
 
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::ComputeDiffFnormFromHistos(const char* what,const char* quantity,const char* flavour,Bool_t printout)
-{
-  /// OUTDATED METHOD: Compute the CMUL to CINT ratio(s) from the histos stored in the OC(). Now the Counter Collection is used for this (AliAnalysisMuMu::ComputeDiffFnormFromCounters)
-    
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,quantity,flavour));
-    return 0x0;
-  }
-  TObjArray* dNchdEtas = binning->CreateBinObjArray();
-  
-  Double_t* binArray = binning->CreateBinArray();
-  
-  TIter next(dNchdEtas);
-  AliAnalysisMuMuBinning::Range* r;
-  
-  Double_t FNorm(0.);
-  Double_t FNormError(0.);
-  
-  TH1* hFNorm = new TH1F("hFNorm","'Global' normalization factor vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
-  
-  Int_t bin(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    
-    TH1* hCMSL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMSL7-B-NOPF-MUON/V0A/%s",
-                             Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMSL )
-    {
-      AliError(Form("No event histo in bin %s found for CMSL7-B-NOPF-MUON",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
+
+                     AliAnalysisMuMuBinning* binning(0x0);
+
+                    if ( fBinning && sbinType->String().Length() > 0 )
+                    {
+                        binning = fBinning->Project("psi",sbinType->String().Data(),flavour);
+                    }
+                    else
+                    {
+                        binning = new AliAnalysisMuMuBinning;
+                        binning->AddBin("psi",sbinType->String().Data());
+                    }
+
+                    //Check Binning list
+                    TObjArray* bins = binning->CreateBinObjArray("psi");
+                    if (!bins)
+                    {
+                        AliError(Form("Did not get any bin for particle psi"));
+                        return;
+                    }
+                    // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                        AliDebug(1,Form("----CENTRALITY %s",scentrality->String().Data()));
+                        // The binning pointer, which point at Pt binning, Y binning etc.
+                        AliAnalysisMuMuBinning::Range* sbin;
+                        TIter next(bins);
+                        next.Reset();
+
+                        // Create ID for the fit which will be used to name results
+                        TString id(Form("/%s/%s/%s/%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data()));
+
+                        // Histo where we put the count
+                        const Double_t * binArrayX = binning->CreateBinArrayX();
+                        Int_t nBinX = binning->GetNBinsX();
+
+                        TH1* hraw = new TH1D(Form("hRawCountVS%s_%f-%f",sbinType->String().Data(),rlow,rhigh),Form("raw count of dimuon pairs for %s",id.Data()),nBinX,binArrayX);
+                        hraw->GetYaxis()->SetTitle(Form("raw count of dimuon pairs in [%0.2f;%0.2f] GeV/c",rlow,rhigh));
+                        hraw->GetXaxis()->SetTitle(sbinType->String().Data());
+
+                        // Loop on each range in bin
+                        //==============================================================================
+                        while ( ( sbin = static_cast<AliAnalysisMuMuBinning::Range*>(next())) )
+                        {
+                            AliDebug(1,Form("-----Bin range %s",sbin->AsString().Data()));
+
+                            if(binRangeExcludedArray->FindObject(sbin->AsString().Data())) {
+                               AliDebug(1,Form("-----Bin range is excluded"));
+                               continue;
+                            }
+                            // Create ID for the fit which will be used to name results
+                            TString id(Form("/%s/%s/%s/%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data()));
+                            TString hname = corrected ? Form("MinvUS+%s_AccEffCorr",sbin->AsString().Data()) : Form("MinvUS+%s",sbin->AsString().Data());
+
+                            // Pointer to the histo from histo collection
+                            h = OC()->Histo(id.Data(),hname.Data());
+                            if (!h)
+                            {
+                                AliError(Form("Could not find histo %s",hname.Data()));
+                                continue;
+                            }
+
+                            // Get X
+                            Double_t xmin = sbin->Xmin();
+                            Double_t xmax = sbin->Xmax();
+                            Double_t x = xmin + (xmax-xmin)/2;
+                            AliDebug(1,Form("x = %f \n", x));
+
+                            //find bin
+                            Int_t binLow   = h->FindBin(rlow);
+                            Int_t binHight = h->FindBin(rhigh);
+
+                            if(binLow==0 || binHight ==0)continue;
+                            // Fill
+                            Double_t rawCount =0.;
+                            for (Int_t i = binLow; i < binHight; ++i)
+                            {
+                                rawCount = rawCount + h->GetBinContent(i);
+                                AliDebug(1,Form("rawCount for %s in bin [%d]= %f \n",h->GetTitle(),i,rawCount));
+                            }
+                            if(rawCount!=0. )hraw->Fill(x,rawCount);
+
+                        }
+                        TH1* o = OC()->Histo(id.Data(),hraw->GetName());
+
+                        if (o)
+                        {
+                            AliWarning(Form("Replacing %s/%s",id.Data(),hraw->GetName()));
+                            OC()->Remove(Form("%s/%s",id.Data(),hraw->GetName()));
+                        }
+
+                        //Adopt
+                        Bool_t adoptOK = OC()->Adopt(Form("%s",id.Data()),hraw);
+
+                        if ( adoptOK ) std::cout << "+++raw histo " << hraw->GetName() << " adopted" << std::endl;
+                        else AliError(Form("Could not adopt Yield histo %s",hraw->GetName()));
+                        new TCanvas;
+                        hraw->DrawCopy("e0");
+
+                    }
+                    delete binning;
+
+                }
+            }
+        }
     }
-    
-    TH1* hCMSLandOMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMSL7-B-NOPF-MUON&0MUL/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMSLandOMUL )
+
+    return;
+}
+
+void AliAnalysisMuMu::ComputePPCrossSection(const char* binType, const char* particle, const char* what, Bool_t AccEffCorr)
+{
+    /// Compute the PP Cross section
+    /// Parameters:
+    ///   -particle   : default is PSI
+    ///   -particle   : default is CorrNofJPsi
+    ///   -binType    : integrated,pt,y ...see your AddTaskMuMu
+    ///   -sResName   : For a particular results
+    ///   -flavour    : Default is BENJ
+    ///   -AccEffCorr : For nomenclature
+
+    if(!OC())
     {
-      AliError(Form("No event histo in bin %s found for CMSL7-B-NOPF-MUON & 0MUL",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
+        AliError("No mergeable. Consider Upgrade()");
+        return;
     }
-    
-    TH1* hCINT = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CINT7-B-NOPF-ALLNOTRD/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCINT )
+    else
     {
-      AliError(Form("No event histo in bin %s found for CINT7-B-NOPF-ALLNOTRD",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputePPCrossSection                          " << endl;
+        cout <<      " ================================================================ " << endl;
     }
-    
-    TH1* hCINTandOMSL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CINT7-B-NOPF-ALLNOTRD&0MSL/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCINTandOMSL )
+
+     // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    // Pointers
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphErr=0x0;
+
+    TList* list=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+
+
+    // Loop on each envenType (see MuMuConfig)
+    //==============================================================================
+    while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
     {
-      AliError(Form("No event histo in bin %s found for CINT7-B-NOPF-ALLNOTRD & 0MSL",r->AsString().Data()));
-      delete binning;
-      delete dNchdEtas;
-      delete binArray;
-      delete hFNorm;
-      return 0x0;
+        AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+        nextTrigger.Reset();
+        // Loop on each trigger (see MuMuConfig)
+        //==============================================================================
+        while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+        {
+            AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+            nextPairCut.Reset();
+            // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+            //==============================================================================
+            while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+            {
+                AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                nextbinType.Reset();
+                // Loop on each type (pt or y)
+                //==============================================================================
+                while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                {
+                    AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+                    nextCentrality.Reset();
+
+
+                    // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                    //==============================================================================
+                    while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                    {
+                        AliDebug(1,Form("----CENTRALITY %s",scentrality->String().Data()));
+                        // The binning pointer, which point at Pt binning, Y binning etc.
+
+
+                        //________Get spectra
+                        TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),particle,sbinType->String().Data());
+                        if (AccEffCorr)spectraPath+="-AccEffCorr";
+
+                        AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                        if(!spectra){
+                          AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                          return;
+                        }
+                        //________
+
+                        // //________Get Trigger sum
+                        // Int_t NofMUL = TMath::Nint(CC()->GetSum(Form("trigger:%s/event:%s/centrality:%s",striggerDimuon->String().Data(),seventType->String().Data(),scentrality->String().Data())));
+                        // //________
+                        
+
+                        AliAnalysisMuMuSpectraCapsulePP * capsule = new AliAnalysisMuMuSpectraCapsulePP(spectra,spectraPath);
+                        if(!capsule) continue;
+                        AliDebug(1,Form("Spectra = %p",capsule));
+                        // capsule->PrintConst();
+
+                        // Get Graph with RAA results
+                        list = capsule->ComputePPCrossSection(what);
+
+                        AliDebug(1,Form("list = %p",list));
+                        if(!list) continue;
+                        
+
+                        graph = static_cast<TGraphErrors*>(list->At(0)->Clone());
+                        graphErr = static_cast<TGraphErrors*>(list->At(1)->Clone());
+
+                        graphErr->SetFillColor(2);
+                        graphErr->SetFillStyle(3001);
+                        graphErr->SetTitle(Form("J/psi cross section"));
+                        if(sbinType->String().Contains("PT")) graphErr->GetYaxis()->SetTitle(Form("d^{2}#sigma/dp_{T}(#muBxGeV^{-1}xc)"));
+                        if(sbinType->String().Contains("Y")) graphErr->GetYaxis()->SetTitle(Form("d^{2}#sigma/dY(#muB)"));
+                        graphErr->GetXaxis()->SetTitle(Form("%s",sbinType->String().Data()));
+                        graphErr->SetMarkerSize(1.7);
+
+                        TF1* fit=0x0;
+                        TFitResultPtr Fitpoint=0x0;
+
+                        if(sbinType->String().Contains("PT")){
+                            fit = new TF1("fit","[0]*x*(1/pow((1+pow(x/[1], [2])) ,[3]))",0,12);
+                            fit->SetParameters(2424.41, 4.74409,1.70488, 4.42257);
+                        }
+
+                        if(sbinType->String().Contains("Y")){
+                            fit= new TF1("fit","[0] * TMath::Exp(-0.5*TMath::Power((x-[1])/[2],2.))", -10, 2.5);
+                            fit->SetParameters(2.8,0.00,2.9271);
+                            fit->FixParameter(1,0.00);
+                        }
+                        new TCanvas;
+                        if(sbinType->String().Contains("PT")) gPad->SetLogy();
+
+                        TLegend * leg = new TLegend(0.4,0.7,0.70,0.9);
+                        leg->SetHeader(Form("ALICE, p-p #sqrt{s_{NN}}=5.02 TeV, L_{int}= 116.67 +/- 5.31 #mub^{-1})"));
+                        if(sbinType->String().Contains("PT")) leg->AddEntry(graph,"Inclusive J/#psi cross-section 2.5 < y < 4","pe");
+                        if(sbinType->String().Contains("Y")) leg->AddEntry(graph,"Inclusive J/#psi cross-section 0 < pT < 12 GeV/c^2","pe");
+                        leg->AddEntry(graphErr,"systematic uncertainty ","f");
+                        leg->SetTextSize(0.03);
+
+                        graphErr->DrawClone("A2P[]");
+
+                        if(fit) Fitpoint = graph->Fit("fit","SR");
+                        if(sbinType->String().Contains("PT") && static_cast<int>(Fitpoint)==0) printf("cross section = %f +/- %f \n",fit->Integral(0.,8.),fit->IntegralError(0.,8.));
+                        if(sbinType->String().Contains("Y")  && static_cast<int>(Fitpoint)==0)  printf("cross section = %f +/- %f \n",fit->Integral(-4.,-2.5),fit->IntegralError(-4.,-2.5));
+
+                        graph->DrawClone("Psame");
+                        leg->DrawClone("same");
+
+                    }
+                }
+            }
+        }
     }
-  
-    FNorm = (hCMSL->GetBinContent(1)/hCMSLandOMUL->GetBinContent(1))*(hCINT->GetBinContent(1)/hCINTandOMSL->GetBinContent(1));
-    FNormError = ErrorPropagationAxBoverCxD(hCMSL->GetBinContent(1),hCINT->GetBinContent(1),hCMSLandOMUL->GetBinContent(1),hCINTandOMSL->GetBinContent(1));
-    
-    if ( printout ) std::cout << r->AsString().Data() << " : " << FNorm << " +- " << FNormError << std::endl;
-    
-    hFNorm->SetBinContent(++bin,FNorm);
-    hFNorm->SetBinError(bin,FNormError);
-  }
-  
-  delete binning;
-  delete dNchdEtas;
-  delete[] binArray;
-  
-  return hFNorm;
+
+    return;
 }
 
+
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromInt(const char* triggerCluster, const char* eventSelection, AliMergeableCollection* mc, const char* what,const char* quantity,const char* flavour,Bool_t printout)
+TH2* AliAnalysisMuMu::ComputeSPDCorrection(const char* type, const char* eventSel, const char* triggerSel, Bool_t bkgReject)
 {
-  /// OUTDATED METHOD:Compute the CMUL to CINT ratio(s) form the ratio of "quantity" distributions, in bins. Now the Counter Collection is used for this (AliAnalysisMuMu::ComputeDiffFnormFromGlobal)
+    //FIX ME : make it general
+    //
+    //
+    TString stype(type);
+    TString evtype(eventSel);
+    TString trigtype(triggerSel);
+    // >Add centrality and title in the path<
+    TH2* hNch = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NchVsZVertexVsEta",evtype.Data(),
+                                                   trigtype.Data()))); // Input Nch // //"/INPUT/QASPDZPSALL/NchVSEtaVSZVertMC"
+    if ( !hNch )
+        {
+        AliError("No Nch histo found");
+        return 0x0;
+        }
+    // >Add centrality and title in the path<
+    TH2* hNtr = static_cast<TH2*>(OC()->Histo(Form("/%s/%s/V0A/TrackletsVsZVertexVsEta",evtype.Data(),
+                                                   trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
+    if ( !hNtr )
+        {
+        AliError("No tracklets histo found");
+        return 0x0;
+        }
+    // >Add centrality and title in the path<
+    TH2* hNtrBkg = static_cast<TH2*>(OC()->Histo(Form("/MCINPUT/%s/%s/V0A/NBkgTrackletsVsZVertexVsEta",evtype.Data(),
+                                                      trigtype.Data()))); // Reco tracklets //  //"/RECO/QASPDZPSALL/MB1/NtrVSEtaVSZVertMC"
+    if ( !hNtrBkg )
+        {
+        AliError("No background tracklets histo found");
+        return 0x0;
+        }
 
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
 
-  TString seventSelection(eventSelection);
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelection.Data()));
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,quantity,flavour));
-    return;
-  }
-  
-  TString path(Form("%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data()));
-  if ( !mc )
-  {
-    AliError("Error: No mergeable collection to get Nch histo");
-    delete binning;
-    return;
-  }
-  TH1* hNtr = static_cast<TH1*>(mc->Histo(Form("/%s/Nch",path.Data())));
-  if ( !hNtr )
-  {
-    AliError(Form("Error: No /%s/Nch histo in mergeable collection",path.Data()));
-    delete binning;
-    return;
-  }
-  Int_t nTrackletsCorrTot = hNtr->Integral();
-  
-  TObjArray* bin = binning->CreateBinObjArray(what,quantity,flavour);
-  Int_t nEntries = bin->GetEntries();
-  Double_t* binArray = binning->CreateBinArray();
-  Double_t FNormTot(0.);
-  Double_t FNormTotError(0.);
-  
-  TH1* hNorm = OC()->Histo(Form("%s/hFNormInt",id.Data()));
-  
-  TH1* hFNormTot = new TH1F("hFNormVSdNchdEtaFromInt","Normalization factor vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",nEntries,binArray);
-  
-  Double_t FNormGlobal = hNorm->GetBinContent(1);
-  Double_t FNormGlobalError = hNorm->GetBinError(1);
-  
-  if ( printout ) std::cout << "Global FNorm = " << FNormGlobal << " + - " << FNormGlobalError << std::endl;
-  
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    Double_t nTrklsCorrBin = hNtr->Integral(r->Xmin(),r->Xmax());
-    Double_t nTrklsCorrBinFrac = nTrklsCorrBin / nTrackletsCorrTot;
-    Double_t nTrklsCorrBinFracError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nTrklsCorrBin) / nTrackletsCorrTot,2.) +
-                                                  TMath::Power(TMath::Sqrt(nTrackletsCorrTot)*nTrklsCorrBin / TMath::Power(nTrackletsCorrTot,2.) ,2.) );
-    
-    FNormTot = FNormGlobal*nTrklsCorrBinFrac;
-    FNormTotError = TMath::Sqrt( TMath::Power(FNormGlobalError*nTrklsCorrBinFrac,2.) + TMath::Power(FNormGlobal*nTrklsCorrBinFracError,2.) );
+    TH2D* hSPDCorr = static_cast<TH2D*>(hNtr->Clone("SPDCorr"));
+    TString title("");\
+    if ( stype.Contains("oneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction");
+    else if ( stype.Contains("AccEffOnly")) hSPDCorr->SetTitle("SPD AccxEff correction");
+    else if ( stype.Contains("statOneOverAccEff")) hSPDCorr->SetTitle("SPD 1/AccxEff correction stat. unc.");
 
-    hFNormTot->SetBinContent(i,FNormTot);
-    hFNormTot->SetBinError(i,FNormTotError);
-    i++;
-    
-    if ( printout ) std::cout << "Bin: " << r->AsString().Data() << " ; " << " FNorm = " << FNormTot << " +- " << FNormTotError << std::endl;
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  
-  delete binning;
-  delete bin;
-  delete[] binArray;
+    for (Int_t i = 1 ; i < hNch->GetNbinsX() ; i++)
+        {
+        for (Int_t j = 1 ; j < hNch->GetNbinsY() ; j++)
+            {
+            Int_t n = hNch->GetBin(i,j);
+            Double_t nch = hNch->GetBinContent(n);
+            Double_t ntr = hNtr->GetBinContent(n);
+            Double_t nBkgtr(0.);
+            if ( bkgReject ) nBkgtr = hNtrBkg->GetBinContent(n);
+
+            Double_t corr(0.),corrErr(0.);
+            if ( nch != 0. )
+                {
+                corr = (ntr - nBkgtr)/nch;
+                corrErr = TMath::Max( 1./nch,TMath::Sqrt( corr*(1.-corr)/nch ) );
+                }
+
+            if ( stype.Contains("oneOverAccEff"))
+                {
+                if ( corr > 0. )
+                    {
+                    hSPDCorr->SetBinContent(n,1./corr);
+                    hSPDCorr->SetBinError(n,corrErr/TMath::Power(corr,2.));
+                    }
+                else
+                    {
+                    hSPDCorr->SetBinContent(n,0.);
+                    hSPDCorr->SetBinError(n,1.);
+                    }
+
+                }
+            else if ( stype.Contains("AccEffOnly"))
+                {
+                hSPDCorr->SetBinContent(n,corr);
+                hSPDCorr->SetBinError(n,corrErr);
+                }
+            else if ( stype.Contains("statOneOverAccEff"))
+                {
+                if ( corr != 0. )
+                    {
+                    hSPDCorr->SetBinContent(n,(corrErr/TMath::Power(corr,2.)*100)/(1./corr));
+                    }
+                else
+                    {
+                    hSPDCorr->SetBinContent(n,-1);
+                    }
+
+                }
+            }
+        }
+
+    return hSPDCorr;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnorm()
+{
+    /// Compute the CMUL to CINT ratio(s)
+
+    if (!CC()) return;
+
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM");
+    //Create the object
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());
+    //Compute Fnorm
+    computer.ComputeFnorm();
+    //Let go the ownership
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/");
+    //Update
+    Update();
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromCounters(const char* filePileUpCorr, const char* what,const char* quantity, const char* flavour, const char* triggerCluster, const char* eventSelectionFnorm, const char* eventSelectionYield,Bool_t printout)
+void AliAnalysisMuMu::ComputeNumberOfEvent()
 {
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), in bins.
-  ///
-  /// Important considerations:
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection to compute Fnorm and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly (Usually the event selection should be the same for the Fnorm and the analysis but the option to use 2 different ev. sel. is included). (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
-  /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
-
-
-  //_______ Definitions for the triggers used to extract the counts from the counter collection:
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-  
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  //_______
-  
+    /// Compute the CMUL to CINT ratio(s)
 
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
-    
-    while ( in.getline(line,1024,'\n'))
+    if (!OC() || !CC()|| !Config())
     {
-      TString lrun(line);
-      TString lvalue(line);
-      
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
-      
-      lvalue.Remove(0,lvalue.First("=")+1);
-      
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
-      
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeNumberOfEvent                 " << endl;
+        cout <<      " ================================================================ " << endl;
     }
-    corrPU = kTRUE;
-  }
-  //________
 
+    const AliAnalysisMuMuFnorm::ETriggerType triggerTypes[] = { AliAnalysisMuMuFnorm::kMB, AliAnalysisMuMuFnorm::kMUL, AliAnalysisMuMuFnorm::kMSL, AliAnalysisMuMuFnorm::kMSH };
+    const Bool_t trueFalse[] = { kTRUE, kFALSE };
 
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sQuantity(quantity);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
-  Double_t NofRuns = runs->GetEntries();
-  
-  TIter nextRun(runs);
-  TObjString* s;
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-    return;
-  }
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Double_t* binArray = binning->CreateBinArray();
-  Int_t nEntries = bin->GetEntries();
-  
-  TH1* h;
-  TH1* hNofEqMB = new TH1F(Form("hNofEqMBVS%s",sQuantity.Data()),Form("Equivalent MB events per CMUL vs %s",sQuantity.Data()),
-                           nEntries,binArray);
-  TH1* hFNormTot = new TH1F(Form("hFNormVS%s",sQuantity.Data()),Form("Normalization factor vs %s;%s;FNorm",sQuantity.Data(),
-                                                                     sQuantity.Data()),nEntries,binArray);
-
-  Double_t* FNormTot = new Double_t[nEntries];
-  Double_t* FNormTotError = new Double_t[nEntries];
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data()));
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Nevent");
 
-  TList* lRun2Reject = new TList();
-  lRun2Reject->SetOwner(kTRUE);
-  
-  Int_t i(0); // Bin number
-  TObjArray* aCluster = striggerCluster.Tokenize("-");
-  TIter nextCluster(aCluster);
-  TObjString* striggerClusterS;
-  
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    FNormTot[i] = 0;
-    FNormTotError[i] = 0;
-    if ( printout )
-    {
-      std::cout << "______________________________" << std::endl;
-      std::cout << "Bin: " << r->AsString().Data() << std::endl;
-    }
-    
-    hFNormTot->GetXaxis()->SetBinLabel(i+1,r->AsString().Data());
-    hNofEqMB->GetXaxis()->SetBinLabel(i+1,r->AsString().Data());
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),AliAnalysisMuMuFnorm::kMUL,Config()->OCDBPath(),Config()->CompactGraphs());// here trigger type doesn't count
 
-    h = new TH1F(Form("hFNormVSrun_%s",r->AsString().Data()),Form("Normalization factor vs run for %s ;run;FNorm",r->AsString().Data()),NofRuns,1,NofRuns);
-    //Set the run labels
-    
-    Double_t nCMULBin = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                          seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data())); //Nof CMUL7/8 events in Bin summed over runs
-    
-    Int_t j(1); //Run label index
-    nextRun.Reset();
-    while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
+    for ( Int_t i = 0; i < 4; ++i )
     {
-      Double_t nCMSL(0.),nCMSLandOMUL(0.);
-      nextCluster.Reset();
-      while ( (striggerClusterS = static_cast<TObjString*>(nextCluster())) && nCMSL == 0. )
-      {
-        nCMSL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s/centrality:V0A/run:%s/bin:%s",
-                                  seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),
-                                  s->GetName(),r->AsString().Data()));
-        
-        nCMSLandOMUL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s&0MUL/centrality:V0A/run:%s/bin:%s",
-                                         seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),
-                                         s->GetName(),r->AsString().Data()));
-      }
-      Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s/bin:%s",
-                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
-      
-      Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/run:%s/bin:%s",
-                                         seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
-      
-      Double_t nCINTandOMSL = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD&0MSL/centrality:V0A/run:%s/bin:%s",
-                                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName(),r->AsString().Data()));
-      
-      Double_t FNorm(0.);
-      Double_t FNormError(0.);
-      Double_t FNormError2(0.);
-      Double_t pUfactor = 1.;
-      if ( nCMSLandOMUL != 0. && nCINTandOMSL !=0. && nCMSL != 0. && nCINT !=0. )
-      {
-        if (corrPU)
+        for ( Int_t pileup = 0; pileup < 2; ++pileup )
         {
-          TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-          if ( p ) pUfactor = p->GetVal();
-          else
+          for ( Int_t ps = 0; ps < 2; ++ps )
           {
-            AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
+            computer.ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
           }
         }
-        
-        FNorm = (nCMSL*nCINT)*pUfactor/(nCMSLandOMUL*nCINTandOMSL);
-        FNormError = ErrorPropagationAxBoverCxD(nCMSL,nCINT,nCMSLandOMUL,nCINTandOMSL)*pUfactor;
-        FNormError2 = AliAnalysisMuMuResult::ErrorABCD(nCMSL, TMath::Sqrt(nCMSL), nCINT, TMath::Sqrt(nCINT), nCMSLandOMUL,
-                                                       TMath::Sqrt(nCMSLandOMUL), nCINTandOMSL, TMath::Sqrt(nCINTandOMSL));
-      }
-      else
-      {
-        if ( nCINT == 0 ) std::cout << " Warning: Run " << s->GetName() << " has no MB trigger in this bin" << std::endl;
-        
-        lRun2Reject->Add(new TObjString(s->GetName()));
-        if ( printout ) std::cout << "Run " << s->GetName() << " not used for FNorm cause lack of stats" << std::endl;
-        continue;
-      }
-      FNormTot[i] += FNorm*nCMUL; // This is the sum of equivalent Nof MB per CMUL run by run. NOTE: This sum is NOT always the total equivalent Nof MB per CMUL because in pp 2012 if just one cluster is used at a time this sum is not the sum for all runs
-      FNormTotError[i] += TMath::Power(nCMUL*FNormError,2.) + TMath::Power(FNorm*TMath::Sqrt(nCMUL),2.);
-      
-      if ( printout ) std::cout << "Run " << s->GetName() << " FNorm = " << FNorm << " +- " << FNormError << " (" << FNormError2 << ")" << " ; PUFactor =" << pUfactor << " ; " << "Nof CMUL = " << nCMUL << std::endl;
-      
-      h->GetXaxis()->SetBinLabel(j,s->GetName());
-      h->SetBinContent(j,FNorm);
-      h->SetBinError(j++,FNormError);
+    }
+
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Nevent");
+    //Update
+    Update();
+}
 
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeFnormWeightedMeanGraphs(AliAnalysisMuMuFnorm::ETriggerType refTrigger,const char* patternOrList, const char* graphName )
+{
+    /// Compute the FNorm Weighted Mean Graph
+    /// Parameters:
+    ///   - refTrigger    : kMUL, kMB ...
+    ///   - patternOrList : name of the graphs included in th emean proceedur. Two mean graphs are separated by ":" and graphics used to compute a mean graphs are
+    ///                     separated by ',' . For example: FnormOffline2PUPS,FnormOffline1PUPS:FnormOffline2PUPS,FnormOffline1PUPS,FnormScalers1PUPS will compute
+    ///                     one mean graph with  FnormOffline2PUPS - FnormOffline1PUPS, and one mean graph with FnormOffline2PUPS - FnormOffline1PUPS - FnormScalers1PUPS.
+    ///   -  graphName    : name of the output mean graph. Selected by default otherwise
+
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
     }
-    
-    TIter nextRejectRun(lRun2Reject);
-    TObjString* run2Rej;
-    Double_t nCMULBinRej(0.);
-    while ( (run2Rej = static_cast<TObjString*>(nextRejectRun())) )
+    else
     {
-      nCMULBinRej += CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data(),
-                                       run2Rej->GetName())); //Sum of CMUL7 events from rejected runs
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeFnormWeightedMeanGraphs                 " << endl;
+        cout <<      " ================================================================ " << endl;
     }
-    
-    nCMULBin = nCMULBin - nCMULBinRej;
-    lRun2Reject->Clear();
-    
-    FNormTotError[i] =  TMath::Sqrt(TMath::Power(TMath::Sqrt(FNormTotError[i])/nCMULBin,2.) + TMath::Power(FNormTot[i]*TMath::Sqrt(nCMULBin)/TMath::Power(nCMULBin,2.),2.));
-    FNormTot[i] = FNormTot[i]/nCMULBin;
-    
-    std::cout << "Mean FNorm in Bin = " << FNormTot[i]  << " +- " << FNormTotError[i] <<std::endl;
-    
-    hFNormTot->SetBinContent(i+1,FNormTot[i]);
-    hFNormTot->SetBinError(i+1,FNormTotError[i]);
-    
-    //____
-    Double_t nCMULBinYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                 seventSelectionYield.Data(),triggerType.Data(),colType.Data(),r->AsString().Data())); //Nof CMUL7/8 events in Bin summed over runs (for yield event selection)
-    
-    Double_t nofEqMB = FNormTot[i]*nCMULBinYield;
-    Double_t nofEqMBError = TMath::Sqrt( TMath::Power(FNormTotError[i]*nCMULBinYield,2.) + TMath::Power(FNormTot[i]*TMath::Sqrt(nCMULBinYield),2.) );
-    
-    std::cout << "EqMB in Bin  = " << nofEqMB << " +- " << nofEqMBError << " ; nCMUL (used for the yield) = " << nCMULBinYield << std::endl;
-    
-    hNofEqMB->SetBinContent(i+1,nofEqMB);
-    hNofEqMB->SetBinError(i+1,nofEqMBError);
-    //____
-    
-    TH1* o = fMergeableCollection->Histo(id.Data(),h->GetName());
-    
-    if (o)
+
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/WeightedMeanGraphs");
+
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
+
+    TString spattern(patternOrList);
+    TObjArray* slist(0x0);
+    slist = spattern.Tokenize(":");
+
+    TIter next(slist);
+    TObjString* str(0x0);
+
+
+
+    while ( ( str = static_cast<TObjString*>(next()) ) )
     {
-      AliWarning(Form("Replacing %s/%s",id.Data(),h->GetName()));
-      fMergeableCollection->Remove(Form("%s/%s",id.Data(),h->GetName()));
+        computer.WeightedMeanGraphs(str->String().Data(),graphName,OC());
     }
-    
-    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),h);
-    
-    if ( adoptOK ) std::cout << "+++FNorm histo " << h->GetName() << " adopted" << std::endl;
-    else AliError(Form("Could not adopt FNorm histo %s",h->GetName()));
-    
-    i++;
-    lRun2Reject->Clear();
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  
-  
-  o = fMergeableCollection->Histo(id.Data(),hNofEqMB->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNofEqMB->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNofEqMB->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNofEqMB);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNofEqMB->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNofEqMB->GetName()));
-  
-  delete binning;
-  delete runs;
-  delete aCluster;
-  delete bin;
-  delete[] binArray;
-  delete[] FNormTot;
-  delete[] FNormTotError;
-  delete lRun2Reject;
-  
-  return;
- 
+
+
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/WeightedMeanGraphs");
+    //Update
+    Update();
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeDiffFnormFromGlobal(const char* what, const char* quantity, const char* flavour,const char* triggerCluster,
-                                                 const char* eventSelectionFnorm, const char* eventSelectionYield,  Bool_t printout)
+void AliAnalysisMuMu::ComputeFnormScalers(AliAnalysisMuMuFnorm::ETriggerType refTrigger, Bool_t PileUpCorr)
 {
-  /// Compute the CMUL to CINT ratio(s) from the itegrated FNorm, in bins.
-  /// The FNorm bin by bin is computed as follows:
-  ///   FNorm^{i} = FNorm*( (N_{MB}^{i}/N_{MB}) / (N_{CMUL}^{i}/N_{CMUL}) )
+  /// Compute the MB to REF ratio using the scalers method (from OCDB)
   ///
-  /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection)(because the integrated Fnorm has to be computed in PSALL).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00" (Used for charged particle multiplicity analysis).
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
-
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-  
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sQuantity(quantity);
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data()));
-  
-  TH1* hFnormGlobalInt = OC()->Histo(id.Data(),"hFNormInt");
-  if( !hFnormGlobalInt)
-  {
-    AliError("hFNormInt not found");
-    return;
-  }
-  Double_t FNormGlobal = hFnormGlobalInt->GetBinContent(1);
-  Double_t FNormGlobalError = hFnormGlobalInt->GetBinError(1);
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-    return;
-  }
-  
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Double_t* binArray = binning->CreateBinArray();
-  Int_t nEntries = bin->GetEntries();
-
-  TH1* hNMBVSBin = new TH1F(Form("hNofEqMBVS%sFromGlobal",sQuantity.Data()),Form("Equivalent MB events per CMUL vs %s",sQuantity.Data())
-                            ,nEntries,binArray);
-  TH1* hFNormVSBin = new TH1F(Form("hFNormVS%sFromGlobal",sQuantity.Data()),Form("Normalization factor vs %s;%s;FNorm",sQuantity.Data(),sQuantity.Data()),
-                              nEntries,binArray);
-  
-  Double_t nCMULTot = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                                        seventSelectionFNorm.Data(),triggerType.Data(),colType.Data()));
-  
-  Double_t nCINTTot = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A",
-                                     seventSelectionFNorm.Data(),triggerType.Data(),colType.Data()));
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(1);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
-    
-    Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/bin:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
-    
-    Double_t f = nCMUL/nCMULTot;
-    Double_t fError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nCMUL)/nCMULTot,2.) + TMath::Power(nCMUL*TMath::Sqrt(nCMULTot)/TMath::Power(nCMULTot,2.),2.) );
-    
-    Double_t g = nCINT/nCINTTot;
-    Double_t gError = TMath::Sqrt( TMath::Power(TMath::Sqrt(nCINT)/nCINTTot,2.) + TMath::Power(nCINT*TMath::Sqrt(nCINTTot)/TMath::Power(nCINTTot,2.),2.) );
-    
-    Double_t value = FNormGlobal*(g/f);
-    Double_t error = TMath::Sqrt( TMath::Power(FNormGlobalError*(g/f),2.) + TMath::Power(FNormGlobal*(gError/f),2.) + TMath::Power(FNormGlobal*g*fError/TMath::Power(f,2.),2.) );
-    
-    hFNormVSBin->SetBinContent(i,value);
-    hFNormVSBin->SetBinError(i,error);
-    hFNormVSBin->GetXaxis()->SetBinLabel(i,r->AsString().Data());
+  /// i.e. Fnorm = L0B(MB) x PS(MB) x Fpile-up / ( L0B(REF) x PS(REF) )
+  ///
+  /// where MB is the minbias trigger
+  /// REF is the fReferenceTrigger
+  /// and PS is the fraction of events selected by the physics selection
+  ///
+  /// The correction factor (the two PS and one Fpile-up) are
+  /// taken from graphs computed in other methods
+  ///
+
 
-    if (printout)
+    if (!OC() || !CC()|| !Config())
     {
-      std::cout << "Bin " << r->AsString().Data() << " : " << std::endl;
-      std::cout << " FNorm = " << value << " +- " << error << " ; nCMUL = " << nCMUL << std::endl;
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeFnormScalers                 " << endl;
+        cout <<      " ================================================================ " << endl;
     }
 
-    Double_t nCMULYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-                                       seventSelectionYield.Data(),triggerType.Data(),colType.Data(),r->AsString().Data()));
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Scaler");
 
-    Double_t nMB = value*nCMULYield;
-    Double_t nMBerror = nMB*TMath::Sqrt( TMath::Power(error/value,2.) + TMath::Power(TMath::Sqrt(nCMULYield)/nCMULYield,2.) );
-    
-    if (printout) std::cout << " NEqMB = " << nMB << " +- " << nMBerror << " ; nCMUL (for yield) = " << nCMULYield << std::endl;
-    
-    hNMBVSBin->SetBinContent(i,nMB);
-    hNMBVSBin->SetBinError(i,nMBerror);
-    hNMBVSBin->GetXaxis()->SetBinLabel(i,r->AsString().Data());
-    
-    i++;
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),hFNormVSBin->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormVSBin->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormVSBin->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormVSBin);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormVSBin->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormVSBin->GetName()));
-  
-  o = fMergeableCollection->Histo(id.Data(),hNMBVSBin->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNMBVSBin->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNMBVSBin->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNMBVSBin);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNMBVSBin->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNMBVSBin->GetName()));
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
+
+    computer.ComputeFnormScalers(kFALSE,0);
+    if(PileUpCorr){
+        computer.ComputeFnormScalers(kTRUE,0);
+        computer.ComputeFnormScalers(kTRUE,1);
+    }
+
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Scaler");
+    //Update
+    Update();
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeIntFnormFromCounters(AliAnalysisMuMuFnorm::ETriggerType refTrigger, Bool_t PileUpCorr)
+{
+ /// Compute the CMUL to CINT ratio(s) in 1 or 2 steps (Offline method) from the CC(), in bins.
+ ///
+ /// Important considerations:
+ ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
+ ///   FIX ME : quantity not define in CC() for "pt" and "y".
+
+
+    if (!OC() || !CC()|| !Config())
+    {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+    }
+    else
+    {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                     ComputeIntFnormFromCounters                 " << endl;
+        cout <<      " ================================================================ " << endl;
+    }
+
+    //Delete precedent Fnorm
+    OC()->Prune("/FNORM/Offline");
+
+    AliAnalysisMuMuFnorm computer(*(CC()),*(Config()),refTrigger,Config()->OCDBPath(),Config()->CompactGraphs());
+
+    computer.ComputeFnormOffline(1,kFALSE,0); // CINT/CINT&0MUL
+    computer.ComputeFnormOffline(1,kFALSE,1); // CINT/CINT&0MUL + Event selection corrected
+    if(PileUpCorr) computer.ComputeFnormOffline(1,kTRUE,1); // CINT/CINT&0MUL + Event selection corrected + pileup correction
+
+    computer.ComputeFnormOffline(2,kFALSE,0); // CMSL/CMSL&0MUL x CINT/CINT&0MSL
+    computer.ComputeFnormOffline(2,kFALSE,1); // CMSL/CMSL&0MUL x CINT/CINT&0MSL + Event selection corrected
+    if(PileUpCorr) computer.ComputeFnormOffline(2,kTRUE,1); // CMSL/CMSL&0MUL x CINT/CINT&0MSL+ Event selection corrected + pileup correction
+
+    AliMergeableCollection* fnorm = computer.DetachMC();
+    //Set the new ownership
+    OC()->Attach(fnorm,"/FNORM/Offline/");
+    //Update
+    Update();
 
-  
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMu::ComputeMeanFnorm(const char* triggerCluster, const char* eventSelection, const char* what,const char* quantity,const char* flavour)
 {
-  /// Compute the mean Fnorm and mean NMB from the "offline" and "rescaled global" methods.
-  ///
-  /// Parameters:
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  
-  TString seventSelection(eventSelection);
-  TString striggerCluster(triggerCluster);
-  TString sQuantity(quantity);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
-  
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
+    /// Compute the mean Fnorm and mean NMB from the "offline" and "rescaled global" methods.
+    ///
+    /// Parameters:
+    ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
+    ///   -eventSelectionFnorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
+    ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
+    ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
+    ///   -quantity: binning type. By default "ntrcorr"
+    ///   -flavour: binning flavour. By default "D2H"
+
+    TString seventSelection(eventSelection);
+    TString striggerCluster(triggerCluster);
+    TString sQuantity(quantity);
+    if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
+    else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
+    else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
+    else
+        {
+        AliError("Unknown trigger cluster");
+        return;
+        }
 
-  TH1* hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMB )
-  {
-    AliError(Form("Histo hNofEqMBVS%s not found",sQuantity.Data()));
-    return;
-  }
-  
-  TH1* hMBG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMBG )
-  {
-    AliError(Form("Histo hNofEqMBVS%sFromGlobal not found",sQuantity.Data()));
-    return;
-  }
+    TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
+    if ( triggerType.Contains("7-") ) triggerType = "7";
+    else if ( triggerType.Contains("8-") ) triggerType = "8";
+    else
+        {
+        AliError("Unknown trigger type");
+        return;
+        }
 
-  TH1* hFnorm = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMB )
-  {
-    AliError(Form("Histo hFNormVS%s not found",sQuantity.Data()));
-    return;
-  }
-  
-  TH1* hFnormG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
-  if ( !hMBG )
-  {
-    AliError(Form("Histo hFNormVS%sFromGlobal not found",sQuantity.Data()));
-    return;
-  }
+    TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data());
+    if ( colType.Contains("-B-") ) colType = "B";
+    else if ( colType.Contains("-S-") ) colType = "S";
+    else
+        {
+        AliError("Unknown collision type");
+        return;
+        }
 
+    TH1* hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMB )
+        {
+        AliError(Form("Histo hNofEqMBVS%s not found",sQuantity.Data()));
+        return;
+        }
 
-//  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-//  if ( !binning )
-//  {
-//    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-//    return;
-//  }
-//  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelection.Data()));
-  
-  TH1* hMBMean = static_cast<TH1*>(hMBG->Clone());
-  hMBMean->SetName(Form("hNofEqMBVS%sFromMean",sQuantity.Data()));
-  
-  TH1* hFnormMean = static_cast<TH1*>(hFnorm->Clone());
-  hFnormMean->SetName(Form("hFNormVS%sFromMean",sQuantity.Data()));
-  
-  for ( Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
-  {
-    //______Mean NofMB computation
-    Double_t Fn = hMB->GetBinContent(i);
-    Double_t Fng = hMBG->GetBinContent(i);
-    
-    Double_t FnE = hMB->GetBinError(i);
-    Double_t FngE = hMBG->GetBinError(i);
-//
-//    Double_t meanBin = (Fn + Fng) / 2.;
-//    Double_t meanBinError = TMath::Sqrt( TMath::Power(FnE/2.,2.) + TMath::Power(FngE/2.,2.) );
-//    Double_t meanBinSys = TMath::Abs( meanBin - Fn );
+    TH1* hMBG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMBG )
+        {
+        AliError(Form("Histo hNofEqMBVS%sFromGlobal not found",sQuantity.Data()));
+        return;
+        }
 
-    Double_t meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
-    Double_t meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
-    Double_t meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
+    TH1* hFnorm = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%s",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMB )
+        {
+        AliError(Form("Histo hFNormVS%s not found",sQuantity.Data()));
+        return;
+        }
 
-    std::cout << "Bin : " << hMB->GetXaxis()->GetBinLabel(i) << std::endl;
-    
-    std::cout << " Mean NMB = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
-    << "%))" << std::endl;
-    
-    hMBMean->SetBinContent(i,meanBin);
-    hMBMean->SetBinError(i,meanBinError);
-    //______
-    
-    
-    //______Mean FNorm computation
-    Fn = hFnorm->GetBinContent(i);
-    Fng = hFnormG->GetBinContent(i);
-    
-    FnE = hFnorm->GetBinError(i);
-    FngE = hFnormG->GetBinError(i);
-    
-    meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
-    meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
-    meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
-    
-//    Double_t nCMULBin = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
-//                                          seventSelection.Data(),triggerType.Data(),colType.Data(),
-//                                          static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(i-1))->AsString().Data()));
-//
-//    if (printout) std::cout << meanBinSys/nCMULBin << std::endl;
-//
-//    Double_t meanFnBin = meanBin/nCMULBin;
-//    Double_t meanFnBinError = TMath::Sqrt( TMath::Power(meanBinError/nCMULBin,2) + TMath::Power(meanBin/TMath::Power(nCMULBin,2.),2) );
-//
-//    if (printout) std::cout << meanBinSys/nCMULBin/meanFnBin << std::endl;
-//
-//    if (printout) std::cout << meanFnBin << " +- " << meanFnBinError << std::endl;
+    TH1* hFnormG = OC()->Histo(Form("/FNORM-%s/%s/V0A/hFNormVS%sFromGlobal",striggerCluster.Data(),seventSelection.Data(),sQuantity.Data()));
+    if ( !hMBG )
+        {
+        AliError(Form("Histo hFNormVS%sFromGlobal not found",sQuantity.Data()));
+        return;
+        }
 
-    std::cout << " Mean FNorm = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
-    << "%)" << std::endl;
-    std::cout << std::endl;
 
-    hFnormMean->SetBinContent(i,meanBin);
-    hFnormMean->SetBinError(i,meanBinError);
-    //______
-  }
+    //  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
+    //  if ( !binning )
+    //  {
+    //    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
+    //    return;
+    //  }
+    //  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
 
-  TH1* o = fMergeableCollection->Histo(id.Data(),hMBMean->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hMBMean->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hMBMean->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hMBMean);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hMBMean->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hMBMean->GetName()));
-  
-  
-  o = fMergeableCollection->Histo(id.Data(),hFnormMean->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFnormMean->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFnormMean->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hFnormMean);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFnormMean->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFnormMean->GetName()));
+
+    TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelection.Data()));
+
+    TH1* hMBMean = static_cast<TH1*>(hMBG->Clone());
+    hMBMean->SetName(Form("hNofEqMBVS%sFromMean",sQuantity.Data()));
+
+    TH1* hFnormMean = static_cast<TH1*>(hFnorm->Clone());
+    hFnormMean->SetName(Form("hFNormVS%sFromMean",sQuantity.Data()));
+
+    for ( Int_t i = 1 ; i <= hMB->GetNbinsX() ; i++ )
+        {
+        //______Mean NofMB computation
+        Double_t Fn = hMB->GetBinContent(i);
+        Double_t Fng = hMBG->GetBinContent(i);
+
+        Double_t FnE = hMB->GetBinError(i);
+        Double_t FngE = hMBG->GetBinError(i);
+        //
+        //    Double_t meanBin = (Fn + Fng) / 2.;
+        //    Double_t meanBinError = TMath::Sqrt( TMath::Power(FnE/2.,2.) + TMath::Power(FngE/2.,2.) );
+        //    Double_t meanBinSys = TMath::Abs( meanBin - Fn );
+
+        Double_t meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
+        Double_t meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
+        Double_t meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
+
+        std::cout << "Bin : " << hMB->GetXaxis()->GetBinLabel(i) << std::endl;
+
+        std::cout << " Mean NMB = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
+        << "%))" << std::endl;
+
+        hMBMean->SetBinContent(i,meanBin);
+        hMBMean->SetBinError(i,meanBinError);
+        //______
+
+
+        //______Mean FNorm computation
+        Fn = hFnorm->GetBinContent(i);
+        Fng = hFnormG->GetBinContent(i);
+
+        FnE = hFnorm->GetBinError(i);
+        FngE = hFnormG->GetBinError(i);
+
+        meanBin = (Fn/TMath::Power(FnE,2.) + Fng/TMath::Power(FngE,2.)) / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) );
+        meanBinError = TMath::Sqrt(1. / ( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ));
+        meanBinSys = TMath::Sqrt( ( TMath::Power(Fn - meanBin,2.)/TMath::Power(FnE,2.) + TMath::Power(Fng - meanBin,2.)/TMath::Power(FngE,2.) )/( 1./TMath::Power(FnE,2.) + 1./TMath::Power(FngE,2.) ) );
+
+        //    Double_t nCMULBin = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/bin:%s",
+        //                                          seventSelection.Data(),triggerType.Data(),colType.Data(),
+        //                                          static_cast<AliAnalysisMuMuBinning::Range*>(bin->At(i-1))->AsString().Data()));
+        //
+        //    if (printout) std::cout << meanBinSys/nCMULBin << std::endl;
+        //
+        //    Double_t meanFnBin = meanBin/nCMULBin;
+        //    Double_t meanFnBinError = TMath::Sqrt( TMath::Power(meanBinError/nCMULBin,2) + TMath::Power(meanBin/TMath::Power(nCMULBin,2.),2) );
+        //
+        //    if (printout) std::cout << meanBinSys/nCMULBin/meanFnBin << std::endl;
+        //
+        //    if (printout) std::cout << meanFnBin << " +- " << meanFnBinError << std::endl;
+
+        std::cout << " Mean FNorm = " << meanBin << " +- " << meanBinError << " (stat) " << " +- " << meanBinSys << " (syst (" << (meanBinSys/meanBin)*100
+        << "%)" << std::endl;
+        std::cout << std::endl;
+
+        hFnormMean->SetBinContent(i,meanBin);
+        hFnormMean->SetBinError(i,meanBinError);
+        //______
+        }
+
+    TH1* o = fMergeableCollection->Histo(id.Data(),hMBMean->GetName());
+
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s",id.Data(),hMBMean->GetName()));
+        fMergeableCollection->Remove(Form("%s/%s",id.Data(),hMBMean->GetName()));
+        }
+
+    Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),hMBMean);
+
+    if ( adoptOK ) std::cout << "+++FNorm histo " << hMBMean->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt FNorm histo %s",hMBMean->GetName()));
+
+
+    o = fMergeableCollection->Histo(id.Data(),hFnormMean->GetName());
+
+    if (o)
+        {
+        AliWarning(Form("Replacing %s/%s",id.Data(),hFnormMean->GetName()));
+        fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFnormMean->GetName()));
+        }
+
+    adoptOK = fMergeableCollection->Adopt(id.Data(),hFnormMean);
+
+    if ( adoptOK ) std::cout << "+++FNorm histo " << hFnormMean->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt FNorm histo %s",hFnormMean->GetName()));
 
 
 }
 
+
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeIntFnormFromCounters(const char* filePileUpCorr, const char* triggerCluster, const char* eventSelectionFnorm, const char* eventSelectionYield, Bool_t printout)
+void AliAnalysisMuMu::PlotYiedWSyst(const char* triggerCluster)
 {
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), integrated.
-  ///
-  /// Important considerations:
-  ///   - If the analysed file has a binning, we must be sure that all events are included in the bins to get the correct integrated Fnorm.
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00, but by default is also PSALL (it can be different in case the aditional event cuts do not affect the J/psi yield, like for example a cut on |Z_vtx| < x cm)) to work correctly. (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
-  /// Parameters:
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -eventSelectionFNorm: event selection used for the normalization factor. By default is "PSALL" (only physics selection).
-  ///   -eventSelectionYield: event selection used for the yield analysis. By default is "PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00".
-  ///   -printout: option to print the Fnorm results. By default is kTRUE.
-
-
-  //_______ Definitions for the triggers used to extract the counts from the counter collection:
-  TString colType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data()); // Let the method know if the collision is beam-beam of satellite.
-  if ( colType.Contains("-B-") ) colType = "B";
-  else if ( colType.Contains("-S-") ) colType = "S";
-  else
-  {
-    AliError("Unknown collision type");
-    return;
-  }
-  
-  TString triggerType(Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data()); // Let the method know the MB trigger type (V0 or T0).
-  if ( triggerType.Contains("7-") ) triggerType = "7";
-  else if ( triggerType.Contains("8-") ) triggerType = "8";
-  else
-  {
-    AliError("Unknown trigger type");
-    return;
-  }
+    // Add syst. to yield and plot it
+    //
+    // FIX ME : make me more general
+    TString striggerCluster(triggerCluster);
+    if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
+    else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
+    else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
+    else
+        {
+        AliError("Unknown trigger cluster");
+        return;
+        }
 
-  TString striggerCluster(triggerCluster); // Let the method know in which cluster the CMUL trigger is included.
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  //________
 
-  TString seventSelectionFNorm(eventSelectionFnorm);
-  TString seventSelectionYield(eventSelectionYield);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
-  Double_t NofRuns = runs->GetEntries();
-  
+    TString path(Form("%s/%s/%s/%s",
+                      Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
+                      Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
+                      Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
 
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
-    
-    while ( in.getline(line,1024,'\n'))
-    {
-      TString lrun(line);
-      TString lvalue(line);
-      
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
-      
-      lvalue.Remove(0,lvalue.First("=")+1);
-      
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
-      
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
-    }
-    corrPU = kTRUE;
-  }
-  //________
+    TH1* hY = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),path.Data()),"hJPsiYieldVSdNchdEtaRelative");
+    if ( !hY )
+        {
+        AliError("No yield found");
+        return;
+        }
 
-  
-  TIter nextRun(runs);
-  TObjString* s;
-  
-  TH1* h;
-  
-  Double_t FNormTot(0.);
-  Double_t FNormTotError(0.);
-  
-  TString id(Form("/FNORM-%s/%s/V0A",striggerCluster.Data(),seventSelectionFNorm.Data())); // Path to save the Fnorm and EqNofMB histos in the mergeable collection
-  
-  h = new TH1F("hFNormIntVSrun","Integrated Normalization factor vs run;run;FNorm",NofRuns,1.,NofRuns);
-  
-  Double_t nCMULTot = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                                        seventSelectionFNorm.Data(),triggerType.Data(),colType.Data())); //Total Nof CMUL7 events in the event selection for the Fnorm
-  
-  TObjArray* aCluster = striggerCluster.Tokenize("-");
-  TIter nextCluster(aCluster);
-  TObjString* striggerClusterS;
-  
-  TList* lRun2Reject = new TList();
-  lRun2Reject->SetOwner(kTRUE);
-  
-  nextRun.Reset();
-  Int_t i(0);//Run label index
-  std::cout << std::endl;
-  std::cout << std::endl;
-  std::cout << std::endl;
-  std::cout << "Computing FNorm" << std::endl;
-  while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
-  {
-    Double_t nCMSL(0.),nCMSLandOMUL(0.);
-    nextCluster.Reset();
-    while ( (striggerClusterS = static_cast<TObjString*>(nextCluster())) && nCMSL == 0. ) // Loop on clusters (in case the single muon trigger is in different clusters depending on the run). We need to explicitly ask for using more than one cluster by setting "triggercluster" parameter
-    {
-      nCMSL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s/centrality:V0A/run:%s",
-                                seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),s->GetName()));
-      
-      nCMSLandOMUL = CC()->GetSum(Form("/event:%s/trigger:CMSL%s-%s-NOPF-%s&0MUL/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),striggerClusterS->GetName(),s->GetName()));
-    }
-    
-    Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
-    
-    Double_t nCINTandOMSL = CC()->GetSum(Form("/event:%s/trigger:CINT%s-%s-NOPF-ALLNOTRD&0MSL/centrality:V0A/run:%s",
-                                              seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
-    
-    Double_t nCMUL = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s",
-                                       seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),s->GetName()));
-    
-    Double_t FNorm(0.),FNormError(0.);
-    Double_t pUfactor = 1.;
-    if ( nCMSLandOMUL != 0. && nCINTandOMSL !=0. && nCMSL != 0. && nCINT !=0. )
-    {
-      if (corrPU) // Pile up correction
-      {
-        TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-        if ( p ) pUfactor = p->GetVal();
-        else
+    TString id(Form("/TESTSYST/%s",path.Data()));
+
+    TH1* hYSyst = static_cast<TH1*>(hY->Clone("RelYieldSyst"));
+    if ( !hYSyst )
         {
-          AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
+        AliError("No systematic found");
+        return;
         }
-      }
-      FNorm = (nCMSL*nCINT)*pUfactor/(nCMSLandOMUL*nCINTandOMSL); //Fnorm computation
-      FNormError = ErrorPropagationAxBoverCxD(nCMSL,nCINT,nCMSLandOMUL,nCINTandOMSL)*pUfactor;
-    }
-    else // If a run has no enough stats to compute FNorm it will be skipped to compute the run average
-    {
-      if ( nCINT == 0 ) std::cout << " Warning: Bad run " << s->GetName() << " has no MB trigger in this bin. Remove from analysis" << std::endl;
-      
-      lRun2Reject->Add(new TObjString(s->GetName()));
-      if ( printout ) std::cout << "Run " << s->GetName() << " not used for FNorm cause lack of stats" << std::endl;
-      continue;
-    }
-    
-    FNormTot += FNorm*nCMUL; // This is the sum of equivalent Nof MB per CMUL run by run (for the ev. selection used for the FNorm, not the yield one). NOTE: This sum is NOT always the total equivalent Nof MB per CMUL because in pp 2012 if just one cluster is set as input parameter "triggercluster", this sum is not the sum for all runs
-    FNormTotError += TMath::Power(nCMUL*FNormError,2.) + TMath::Power(FNorm*TMath::Sqrt(nCMUL),2.);
-    
-    if ( printout ) std::cout << "Run " << s->GetName() << " FNorm = " << FNorm << " +- " << FNormError << " ; PUFactor =" << pUfactor << " ; " << "Nof CMUL = " << nCMUL << std::endl;
-    
-    h->GetXaxis()->SetBinLabel(++i,s->GetName());
-    h->SetBinContent(i,FNorm);
-    h->SetBinError(i,FNormError);
-    
-  }
-  
-  TH1* o = fMergeableCollection->Histo(id.Data(),h->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),h->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),h->GetName()));
-  }
-  
-  Bool_t adoptOK = fMergeableCollection->Adopt(id.Data(),h);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << h->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",h->GetName()));
-  
-  
-  //______ Computation of the total Nof CMUL used to compute the FNorm
-  TIter nextRejectRun(lRun2Reject);
-  TObjString* run2Rej;
-  Double_t nCMULTotRej(0.);
-  while ( (run2Rej = static_cast<TObjString*>(nextRejectRun())) )
-  {
-    nCMULTotRej += CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A/run:%s",
-                                     seventSelectionFNorm.Data(),triggerType.Data(),colType.Data(),
-                                     run2Rej->GetName())); //Sum of CMUL7 events (for Fnorm event selection) from rejected runs
-  }
 
-  nCMULTot = nCMULTot - nCMULTotRej;
-  //_______
+    TH1* hS = OC()->Histo(id.Data(),"yield_Systematics");
 
+    for ( Int_t i = 1 ; i <= hY->GetNbinsX() ; i++ )
+        {
+        hYSyst->SetBinError(i,hS->GetBinContent(i)*hY->GetBinContent(i)/100.);
+        }
 
-  //_______ Integrated Fnorm computation
-  FNormTotError =  TMath::Sqrt(TMath::Power(TMath::Sqrt(FNormTotError)/nCMULTot,2.) + TMath::Power(FNormTot*TMath::Sqrt(nCMULTot)/TMath::Power(nCMULTot,2.),2.));
-  
-  FNormTot = FNormTot/nCMULTot; // nCMULTot is here nCMULTot - nCMULTotRej
-  
-  std::cout << "FNorm = " << FNormTot << " +- " << FNormTotError << std::endl;
-  
-  TH1* hFNormTot = new TH1F("hFNormInt","Global Normalization factor",1,0.,1.);
-  hFNormTot->SetBinContent(1,FNormTot);
-  hFNormTot->SetBinError(1,FNormTotError);
-  
-  o = fMergeableCollection->Histo(id.Data(),hFNormTot->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hFNormTot->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hFNormTot->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hFNormTot);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hFNormTot->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hFNormTot->GetName()));
-  //________
+    hY->Draw();
+    hYSyst->Draw("same");
+}
 
-  
-  //_______ Integrated Equivalent number of minimum bias events (for the yield computation event selection)
-  TH1* hNEqMB = new TH1F("hNEqMB","Equivalent number of MB events per CMUL",1,0.,1.);
-  
-  Double_t nCMULTotYield = CC()->GetSum(Form("/event:%s/trigger:CMUL%s-%s-NOPF-MUON/centrality:V0A",
-                               seventSelectionYield.Data(),triggerType.Data(),colType.Data())); //Total Nof CMUL7 events for the event selection used to compute the yield
-  
-  Double_t nofEqMB = FNormTot*nCMULTotYield;
-  Double_t nofEqMBError = TMath::Sqrt( TMath::Power(FNormTotError*nCMULTotYield,2.) + TMath::Power(FNormTot*TMath::Sqrt(nCMULTotYield),2.) );
-  
-  std::cout << "Nof CMUL tot (used for yield) = " << nCMULTotYield << " ; " << "EqMB = " << nofEqMB << " +- " << TMath::Sqrt(nofEqMBError) << std::endl;
-  
-  hNEqMB->SetBinContent(1,nofEqMB);
-  hNEqMB->SetBinError(1,nofEqMBError);
-  
-  o = fMergeableCollection->Histo(id.Data(),hNEqMB->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s",id.Data(),hNEqMB->GetName()));
-    fMergeableCollection->Remove(Form("%s/%s",id.Data(),hNEqMB->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(id.Data(),hNEqMB);
-  
-  if ( adoptOK ) std::cout << "+++FNorm histo " << hNEqMB->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt FNorm histo %s",hNEqMB->GetName()));
-  //_______
-  
-  delete runs;
-  delete lRun2Reject;
-  delete aCluster;
-  
-  return;
-  
+//_____________________________________________________________________________
+void AliAnalysisMuMu::ComputeJpsiYield(const char* binType, const char* what, const char* externfile, const char* externfile2, const char* sResName, const char* beamYear, Bool_t AccEffCorr)
+{
+    /// Compute the Jpsi yield, i.e NofJPsi/Fnorm. Delegate procedure to the right capsule object. It can be compute for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
+    ///
+    /// Parameters:
+    ///   -binType    : INTEGRATED, PT, Y (for now)
+    ///   -what       : The quantity divided by FNorm (NofJPsi by default, but could be something else...)
+    ///   -externfile : For the capsule
+    ///   -externfile2: For the capsule
+    ///   -AccEffCorr : Just a tag to select right histograms.
+    ///   -sResName   : subresult name to get the yield from. By default is "" (mean of all subresults)
+
+    if (!OC() || !CC())
+        {
+        AliError("No mergeable/counter collection. Consider Upgrade()");
+        return ;
+        }
+    else
+        {
+        cout <<      " ================================================================ " << endl;
+        cout <<      "                       ComputeJpsiYield                           " << endl;
+        cout <<      " ================================================================ " << endl;
+        }
+
+    // Get configuration settings
+    TObjArray* eventTypeArray   = Config()->GetListElements(Config()->EventSelectionKey(),IsSimulation());
+    TObjArray* triggerArray     = Config()->GetListElements(Config()->DimuonTriggerKey(),IsSimulation());
+    TObjArray* fitfunctionArray = Config()->GetListElements(Config()->FitTypeKey(),IsSimulation());// to add here an entry
+    TObjArray* pairCutArray     = Config()->GetListElements(Config()->PairSelectionKey(),IsSimulation());
+    TObjArray* centralityArray  = Config()->GetListElements(Config()->CentralitySelectionKey(),IsSimulation());
+    TObjArray* whatArray        = TString(what).Tokenize(",");
+    TObjArray* binTypeArray     = TString(binType).Tokenize(",");
+    TObjArray* bins;
+
+
+    // Iterator for loops
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextWhat(whatArray);
+    TIter nextbinType(binTypeArray);
+    TIter nextCentrality(centralityArray);
+
+    // Strings
+    TObjString* striggerDimuon;
+    TObjString* seventType;
+    TObjString* spairCut;
+    TObjString* swhat;
+    TObjString* sbinType;
+    TObjString* scentrality;
+
+    TString striggerMB  = Config()->First(Config()->MinbiasTriggerKey(),IsSimulation());
+    const TString syear(beamYear);
+
+
+
+    // Pointers
+    TH1* h= 0x0;
+    TGraphErrors* graph=0x0;
+    TGraphErrors* graphCent=0x0;
+    AliAnalysisMuMuSpectra spectra=0x0;
+
+    //Loop on what type
+    while ( ( swhat = static_cast<TObjString*>(nextWhat()) ) )
+        {
+        AliDebug(1,Form("what %s",swhat->String().Data()));
+        nextEventType.Reset();
+        // Loop on each envenType (see MuMuConfig)
+        //==============================================================================
+        while ( ( seventType = static_cast<TObjString*>(nextEventType())) )
+            {
+            AliDebug(1,Form("EVENTTYPE %s",seventType->String().Data()));
+            nextTrigger.Reset();
+            // Loop on each trigger (see MuMuConfig)
+            //==============================================================================
+            while ( ( striggerDimuon = static_cast<TObjString*>(nextTrigger())) )
+                {
+                AliDebug(1,Form("-TRIGGER %s",striggerDimuon->String().Data()));
+                nextPairCut.Reset();
+                // Loop on each paircut (not the ones in MuMuConfig but the ones set)
+                //==============================================================================
+                while ( ( spairCut = static_cast<TObjString*>(nextPairCut())) )
+                    {
+                    AliDebug(1,Form("--PAIRCUT %s",spairCut->String().Data()));
+                    nextbinType.Reset();
+                    // Loop on each type (pt or y)
+                    //==============================================================================
+                    while ( ( sbinType = static_cast<TObjString*>(nextbinType()) ) )
+                        {
+                        AliDebug(1,Form("---TYPE %s",sbinType->String().Data()));
+
+                        //canvas
+                        TCanvas *c1 = new TCanvas;
+                        c1->Draw();
+                        gStyle->SetOptStat(0);
+
+                        nextCentrality.Reset();
+                        // Loop on each centrality (not the ones in MuMuConfig but the ones set)
+                        //==============================================================================
+                        while ( ( scentrality = static_cast<TObjString*>(nextCentrality()) ) )
+                            {
+                            AliDebug(1,Form("---CENTRALITY %s",scentrality->String().Data()));
+
+                            //________Get Fnorm Histo
+                            TString id(Form("/FNORM-%s/%s/%s/%s",striggerDimuon->String().Data(),seventType->String().Data(),scentrality->String().Data(),syear.Data())); // Path to save the Fnorm and EqNofMB histos in the mergeable collection
+
+                            TString idHisto="";
+                            if (!sbinType->String().Contains("INTEGRATED")) idHisto= Form("hNofEqMBVS%s",sbinType->String().Data());
+                            else if (sbinType->String().Contains("INTEGRATED")) idHisto= Form("hFNormInt_%s",striggerMB.Data());
+
+                            h = OC()->Histo(Form("%s/%s",id.Data(),idHisto.Data()));
+                            if (!h)
+                                {
+                                AliError(Form("Could not find histo in %s/%s",id.Data(),idHisto.Data()));
+                                return;
+                                }
+                            //________
+
+                            //________Get spectra
+                            TString spectraPath= Form("/%s/%s/%s/%s/%s-%s",seventType->String().Data(),striggerDimuon->String().Data(),scentrality->String().Data(),spairCut->String().Data(),"PSI",sbinType->String().Data());
+                            if (AccEffCorr)spectraPath+="-AccEffCorr";
+                            AliAnalysisMuMuSpectra * spectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(spectraPath.Data()));
+                            if(!spectra)
+                                {
+                                AliError(Form("Cannot find spectra with name %s",spectraPath.Data()));
+                                return;
+                                }
+                            //________
+
+                            //________Select methods
+                            if(syear.Contains("PbPb"))
+                                {
+
+
+                                    AliAnalysisMuMuSpectraCapsulePbPb * capsule = new AliAnalysisMuMuSpectraCapsulePbPb(spectra,spectraPath,externfile,externfile2);
+                                    AliDebug(1,Form("Spectra = %p",capsule));
+
+                                    // Get Graph with Yield results
+                                    graph = capsule->ComputeYield(swhat->String().Data(),h,sResName);
+
+                                    TLegend * leg = new TLegend(0.4,0.7,0.90,0.9);
+                                    leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=2.76 TeV, L_{int}=70 #mub^{-1}, %s",scentrality->String().Data()));
+                                    leg->AddEntry(graph,"Inclusive J/#psi Yield","pe");
+                                    graph->Draw("ap");
+                                    leg->Draw();
+
+                                    delete capsule;
+                                }
+                            else if(syear.Contains("pPb") || syear.Contains("Pbp"))
+                                {
+                                AliAnalysisMuMuSpectraCapsulePbP * capsule = new AliAnalysisMuMuSpectraCapsulePbP(spectra,spectraPath,externfile,externfile2);
+                                AliDebug(1,Form("Spectra = %p",capsule));
+
+                                // Get Graph with Yield results
+                                graph = capsule->ComputeYield(swhat->String().Data(),h,sResName);
+
+                                TLegend * leg = new TLegend(0.4,0.7,0.90,0.9);
+                                leg->SetHeader(Form("ALICE, Pb-Pb #sqrt{s_{NN}}=2.76 TeV, L_{int}=70 #mub^{-1}, %s",scentrality->String().Data()));
+                                leg->AddEntry(graph,"Inclusive J/#psi Yield","pe");
+                                graph->Draw("ap");
+                                leg->Draw();
+
+                                delete capsule;
+                                }
+                            else if(syear.Contains("pp"))
+                                {
+                                AliError("No method implemented for this beam yet, but you're welcome to do it !");
+                                return;
+                                }
+
+                            //________ Update resultes in Mergeable collection
+                            TString id2(Form("/JpsiYield-%s/%s/%s/%s/%s",striggerDimuon->String().Data(),seventType->String().Data(),spairCut->String().Data(),sbinType->String().Data(),swhat->String().Data()));
+
+                            TObject* o = 0x0;
+
+                            if (graph)// first graph
+                                {
+                                o = fMergeableCollection->GetObject(Form("%s/%s",id2.Data(),graph->GetName()));
+
+                                if (o)
+                                    {
+                                    AliWarning(Form("Replacing %s/%s",id2.Data(),graph->GetName()));
+                                    fMergeableCollection->Remove(Form("%s/%s",id2.Data(),graph->GetName()));
+                                    }
+
+                                Bool_t adoptOK = fMergeableCollection->Adopt(id2.Data(),graph);
+
+                                if ( adoptOK ) std::cout << "+++JpsiYield graph " << graph->GetName() << " adopted" << std::endl;
+                                else AliError(Form("Could not adopt JpsiYield grap %s",graph->GetName()));
+                                }
+                            //________
+
+
+
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+    return;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::PlotYiedWSyst(const char* triggerCluster)
+void AliAnalysisMuMu::ComputeJpsiMPt(Bool_t relative, const char* evSelInt, const char* evSelDiff,const char* spectra, const char* sResName)
 {
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
-  
-  TString path(Form("%s/%s/%s/%s",
-                    Config()->First(Config()->EventSelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->DimuonTriggerKey(),kFALSE).Data(),
-                    Config()->First(Config()->CentralitySelectionKey(),kFALSE).Data(),
-                    Config()->First(Config()->PairSelectionKey(),kFALSE).Data()));
-  
-  TH1* hY = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),path.Data()),"hJPsiYieldVSdNchdEtaRelative");
-  if ( !hY )
-  {
-    AliError("No yield found");
-    return;
-  }
+    // ocMBTrigger is the mergeableCollection with the MB trigger dNchdEta plot (migth be the same as oc, in which case we set ocMBTrigger=0x0)
+    //FIXME::Make it general
+    // Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
 
-  TString id(Form("/TESTSYST/%s",path.Data()));
-  
-  TH1* hYSyst = static_cast<TH1*>(hY->Clone("RelYieldSyst"));
-  if ( !hYSyst )
-  {
-    AliError("No systematic found");
-    return;
-  }
 
-  TH1* hS = OC()->Histo(id.Data(),"yield_Systematics");
-  
-  for ( Int_t i = 1 ; i <= hY->GetNbinsX() ; i++ )
-  {
-    hYSyst->SetBinError(i,hS->GetBinContent(i)*hY->GetBinContent(i)/100.);
-  }
-    
-  hY->Draw();
-  hYSyst->Draw("same");
-}
+    TString swhat("");
+    TString sres("");
+    TString sspectra(spectra);
+    TString sevSelInt(evSelInt);
+    TString sevSelDiff(evSelDiff);
 
-//_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeJpsiYield( Bool_t relative, const char* fNormType, const char* evSelInt, const char* evSelDiff, const char* triggerCluster, const char* spectra, const char* sResName)
-{
-  /// Compute the Jpsi yield integrated and in bins, absolute or relative (Y_bin/Y_int). It can be calculated for an specific subresult (fit with an specific background shape, signal, fitting range... combination) or from the mean of all the subresults.
-  ///
-  /// Important considerations:
-  ///   - No corrections can be applied to the yields or x-axis with this method
-  ///
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL (fot integrated signal extraction) and the one used in the bin by bin yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly.
-  ///
-  /// Parameters:
-  ///   -relative: kTRUE if relative yield (y/y_int) is to be computed. Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
-  ///   -fNormType: Desired FNorm to use: "offline", "global" or "mean"
-  ///   -evSelInt: Event selection to compute integrated NofJpsi
-  ///   -evSelDiff: Event selection to compute diferential NofJpsi
-  ///   -triggercluster: cluster where the CMSL trigger is ("MUON" for pA but for pp2012 could be also "ALLNOTRD" for certain runs, the option "MUON-ALLNOTRD" accounts for both at the same time). By default is "MUON".
-  ///   -spectra: spectra (AliAnalysisMuMuSpectra) to be used to get the differential NofJpsi
-  ///   -sResName: subresult name to get the yield from. By default is "" (mean of all subresults)
-
-  TString sfNormType(fNormType);
-  TString swhat("");
-  TString sres(sResName);
-  TString sspectra(spectra);
-  TString sevSelInt(evSelInt);
-  TString sevSelDiff(evSelDiff);
-
-  if ( sspectra.Contains("DNCHDETA")) swhat = "dnchdeta";   //FIXME::Make it general for any bin quantity (pt,centrality...)
-  else if ( sspectra.Contains("NTRCORR") ) swhat = "ntrcorr";
-  else if ( sspectra.Contains("V0ACORR") ) swhat = "v0acorr";
-  else if ( sspectra.Contains("V0CCORR") ) swhat = "v0ccorr";
-  else if ( sspectra.Contains("V0MCORR") ) swhat = "v0mcorr";
+    if ( sspectra.Contains("DNCHDETA")) swhat = "dnchdeta";   //FIXME::Make it general for any bin quantity (pt,centrality...)
+    else if ( sspectra.Contains("NTRCORR") ) swhat = "ntrcorr";
 
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi yield: Is a simulation file");
-    return;
-  }
+    if ( strlen(sResName) > 0 ) sres = sResName; //sres = "MPTPSIPSIPRIMECB2VWG_BKGMPTPOL2";
 
-  TString striggerCluster(triggerCluster);
-  if ( striggerCluster.Contains("MUON") && !striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON";
-  else if ( striggerCluster.Contains("ALLNOTRD") && !striggerCluster.Contains("MUON") ) striggerCluster = "ALLNOTRD";
-  else if ( striggerCluster.Contains("MUON") && striggerCluster.Contains("ALLNOTRD") ) striggerCluster = "MUON-ALLNOTRD";
-  else
-  {
-    AliError("Unknown trigger cluster");
-    return;
-  }
+    if ( IsSimulation() )
+        {
+        AliError("Cannot compute J/Psi <pT>: Is a simulation file");
+        return;
+        }
+    TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
+    TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
+    TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
+
+    TString intPath(Form("%s/%s/%s/%s",
+                         sevSelInt.Data(),
+                         dimuonTriggerClassName.Data(),
+                         centralitySelection.Data(),
+                         pairSelection.Data())); //Path to store integrated result in Mergeable Collection
+
+    TString diffPath(Form("%s/%s/%s/%s",
+                          sevSelDiff.Data(),
+                          dimuonTriggerClassName.Data(),
+                          centralitySelection.Data(),
+                          pairSelection.Data())); //Path to store differential result in Mergeable Collection
+
+    if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
+
+    //_________Integrated mean pt
+    AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),"PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS")));
+    if ( !sInt )
+        {
+        AliError(Form("No spectra %s found in %s","PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS",intPath.Data()));
+        return;
+        }
 
-  TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
-  TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
-  TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
-  
-  //Path to get/store integrated results from Mergeable Collection
-  TString intPath(Form("%s/%s/%s/%s",
-                       sevSelInt.Data(),
-                       dimuonTriggerClassName.Data(),
-                       centralitySelection.Data(),
-                       pairSelection.Data()));
-  
-  //Path to get/store differential results from Mergeable Collection
-  TString diffPath(Form("%s/%s/%s/%s",
-                        sevSelDiff.Data(),
-                        dimuonTriggerClassName.Data(),
-                        centralitySelection.Data(),
-                        pairSelection.Data()));
+    AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
+    b->AddBin("psi","INTEGRATED");
 
+    AliAnalysisMuMuBinning::Range* bin = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
 
-  Double_t bR = 0.0593; // BR(JPsi->mu+mu-)
-  Double_t bRerror = 0.0006 ;
+    AliAnalysisMuMuResult* result = sInt->GetResultForBin(*bin);
+    if ( !result )
+        {
+        AliError(Form("No result for bin %s found in spectra %s",bin->AsString().Data(),sInt->GetName()));
+        return;
+        }
 
-  if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
 
-  //_________Integrated yield
-  AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),"PSI-INTEGRATED-AccEffCorr"))); //FIXME::Make it general
+    Double_t JPsiMPtTot = result->GetValue("MeanPtJPsi");
+    Double_t JPsiMPtTotError = result->GetErrorStat("MeanPtJPsi");
 
-  if ( !sInt )
-  {
-    AliError(Form("No spectra %s found in %s","PSI-INTEGRATED-AccEffCorr",intPath.Data()));
-    return;
-  }
+    std::cout << "Integrated J/Psi <pT> = " << JPsiMPtTot << " +- " << JPsiMPtTotError << std::endl;
+    std::cout << std::endl;
 
-  AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
-  b->AddBin("psi","INTEGRATED");
+    TH1* hMPtint = new TH1F("hJPsiMPtInt","Integrated J/#psi mean p_{T}",1,0.,1.);
+    hMPtint->SetBinContent(1,JPsiMPtTot);
+    hMPtint->SetBinError(1,JPsiMPtTotError);
 
-  AliAnalysisMuMuBinning::Range* bin = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
+    TH1* o = OC()->Histo(Form("/RESULTS/%s",intPath.Data()),hMPtint->GetName());
 
-  AliAnalysisMuMuResult* result = sInt->GetResultForBin(*bin);
-  if ( !result )
-  {
-    AliError(Form("No result for bin %s found in %s",bin->AsString().Data(),"PSI-INTEGRATED-AccEffCorr"));
-    return;
-  }
+    if (o)
+        {
+        AliWarning(Form("Replacing /RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
+        OC()->Remove(Form("/RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
+        }
 
-  Double_t NofJPsiTot = result->GetValue("NofJPsi",sres.Data());
-  Double_t NofJPsiTotError = result->GetErrorStat("NofJPsi",sres.Data());
+    Bool_t adoptOK = OC()->Adopt(Form("/RESULTS/%s",intPath.Data()),hMPtint);
 
-  TH1* hMBTot = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data()));
-  if ( !hMBTot )
-  {
-    AliError(Form("No eq Nof MB events found in %s",Form("/FNORM-%s/%s/V0A/hNEqMB",striggerCluster.Data(),sevSelInt.Data())));
-    return;
-  }
+    if ( adoptOK ) std::cout << "+++Mean Pt histo " << hMPtint->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt Mean Pt histo %s",hMPtint->GetName()));
 
-  Double_t nEqMBTot = hMBTot->GetBinContent(1);
-  Double_t nEqMBTotError = hMBTot->GetBinError(1);
+    delete b;
 
-  Double_t yieldInt = NofJPsiTot/(nEqMBTot*bR);
-  Double_t yieldIntError = yieldInt*TMath::Sqrt(TMath::Power(NofJPsiTotError/NofJPsiTot,2.) +
-                                       TMath::Power(nEqMBTotError/nEqMBTot,2.) +
-                                       TMath::Power(bRerror/bR,2.));
+    //_____Differential mean pt
 
-  std::cout << "Integrated yield = " << yieldInt << " +- " << yieldIntError << std::endl;
+    AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),spectra)));
+    if ( !s )
+        {
+        AliError(Form("No spectra %s found in %s",spectra,diffPath.Data()));
+        return;
+        }
 
-  TH1* hYint = new TH1F("hJPsiYieldInt","Integrated J/#psi yield",1,0.,1.);
-  hYint->SetBinContent(1,yieldInt);
-  hYint->SetBinError(1,yieldIntError);
+    std::cout << "Mean pt of J/Psi:" << std::endl;
+    TH1* hrmPt = s->Plot("MeanPtJPsi",sres.Data(),kFALSE); //MPT2CB2VWGPOL2INDEPTAILS//mean pt of Jpsi
+    std::cout << "" << std::endl;
 
-  TH1* o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),intPath.Data()),hYint->GetName());
 
-  if (o)
-  {
-    AliWarning(Form("Replacing /RESULTS-%s/%s/%s",striggerCluster.Data(),intPath.Data(),hYint->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),intPath.Data(),hYint->GetName()));
-  }
+    const TArrayD* binArray = hrmPt->GetXaxis()->GetXbins();
+    Int_t size = binArray->GetSize();
+    Double_t* axis = new Double_t[size];
 
-  Bool_t adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),intPath.Data()),hYint);
+    //  Double_t ptInt,ptIntError;
+    TH1* hmPt;
+    if ( relative )
+        {
+        //    TString path2(Form("/%s/%s/%s",
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kEventSelectionList,kFALSE)).Data(),
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kMinbiasTriggerList,kFALSE)).Data(),
+        //                       First(Config()->GetList(AliAnalysisMuMuConfig::kCentralitySelectionList,kFALSE)).Data()));
+        //
+        //    TH1* hdNch = OC()->Histo(path2.Data(),swhat.Data());
 
-  if ( adoptOK ) std::cout << "+++Yield histo " << hYint->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hYint->GetName()));
 
-  std::cout << std::endl;
 
-  delete b;
-  //_________
+        hmPt = new TH1D(Form("hJPsiMeanPtVS%sRelative",swhat.Data()),Form("Relative J/#psi mean p_{T} vs %s;%s;<p_{T}^{J/#psi}>/<p_{T}^{J/#psi}_{int}>",swhat.Data(),swhat.Data())
+                        ,size-1,axis);
 
+        //
+        //    ptInt = result->GetValue("MeanPtJPsi",sres.Data());
+        //    ptIntError = result->GetErrorStat("MeanPtJPsi",sres.Data());
 
+        }
+    else
+        {
+        hmPt = new TH1D(Form("hJPsiMeanPtVS%s",swhat.Data()),Form("J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}",swhat.Data(),swhat.Data())
+                        ,size-1,axis);
 
-  //_____Differential yield
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),sspectra.Data())));
-  if ( !s )
-  {
-    AliError(Form("No spectra %s found in %s",sspectra.Data(),diffPath.Data()));
-    return;
-  }
+        //    hmPt = static_cast<TH1D*>(hrmPt->Clone("hJPsiMeanPtVSdNchdEta"));
+        //    hmPt->SetTitle("J/#psi mean p_{T} vs dN_{ch}/d#eta");
+        //    hmPt->GetXaxis()->SetTitle("dN_{ch}/d#eta");
+        //    hmPt->GetYaxis()->SetTitle("<p_{T}^{J/#psi}>");
+        }
 
-  std::cout << "Number of J/Psi:" << std::endl;
-  TH1* hry = s->Plot("NofJPsi",sres.Data(),kFALSE); //Number of Jpsi
-  
-  std::cout << "" << std::endl;
-  
-  //  std::cout << "Equivalent number of MB events:" << std::endl;
-  TH1* hMB(0x0);
-  if ( sfNormType.Contains("offline") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%s",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
-    {
-      AliError(Form("Histo hNofEqMBVS%s not found",swhat.Data()));
-      return;
-    }
+    delete[] axis;
 
-    std::cout << " Using Fnorm from offline method " << std::endl;
-  }
-  else if ( sfNormType.Contains("global") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromGlobal",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
-    {
-      AliError(Form("Histo hNofEqMBVS%sFromGlobal not found",swhat.Data()));
-      return;
-    }
+    Double_t systMptInt[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //FIXME: find a way to give this as input
+    Double_t systMptBin[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
 
-    std::cout << " Using Fnorm from global method " << std::endl;
-  }
-  else if ( sfNormType.Contains("mean") )
-  {
-    hMB = OC()->Histo(Form("/FNORM-%s/%s/V0A/hNofEqMBVS%sFromMean",striggerCluster.Data(),sevSelDiff.Data(),swhat.Data()));
-    if ( !hMB )
-    {
-      AliError(Form("Histo hNofEqMBVS%sFromMean not found",swhat.Data()));
-      return;
-    }
+    Double_t systMptRel[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //signal extraction pPb
 
-    std::cout << " Using mean Fnorm " << std::endl;
-  }
-  else
-  {
-    AliError("Dont know what Fnorm use");
-    return;
-  }
-  
-  std::cout << std::endl;
+    //  Double_t systMptInt[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014}; //FIXME: find a way to give this as input
+    //  Double_t systMptBin[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014};
+    //
+    //  Double_t systMptRel[9] = {0.002,0.001,0.001,0.002,0.002,0.002,0.002,0.004,0.004}; //signal extraction pPb
 
-  TH1* hy;
-  const TArrayD* binArray = hry->GetXaxis()->GetXbins();
-  Int_t size = binArray->GetSize();
-  const Double_t* axis = binArray->GetArray();
+    //  Double_t systMptRel[9] = {0.002,0.001,0.012,0.001,0.002,0.002,0.001,0.004,0.003}; //signal extraction Pbp
 
-  if (sres.IsNull()) sres += "mean"; // To indicate that the result is computed from the mean yield of all the subresults
+    //  Double_t systMptRel[9] = {0.001,0.002,0.001,0.002,0.002,0.003,0.005,0.000,0.000}; //signal extraction pp|eta|<05
 
-  if ( relative )
-  {
-    hy = new TH1D(Form("hJPsiYieldVS%sRelative",swhat.Data()),Form("Relative J/#psi yield vs %s (%s);%s;Y^{J/#psi}/Y^{J/#psi}_{int}",swhat.Data(),sres.Data(),swhat.Data()),size-1,axis);
-  }
-  else
-  {
-    hy = new TH1D(Form("hJPsiYieldVS%s",swhat.Data()),Form("J/#psi yield vs %s (%s);%s;Y^{J/#psi}",swhat.Data(),sres.Data(),swhat.Data())
-                  ,size-1,axis);
-  }
+    //  Double_t systMptRel[9] = {0.002,0.002,0.002,0.002,0.001,0.002,0.001,0.012,0.000}; //signal extraction pp|eta|<1
 
-  delete axis;
-
-  // AccxEff(from rel diff or paper)  // Signal extraction
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.01,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.022,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.009,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.008,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.016 ,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.033,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.003,0.001,0.002,0.003,0.002,0.004,0.011,0.012,0.071};
-  //  Double_t systPU[9] = {0.00,0.01,0.012,0.014,0.014,0.019,0.020,0.021,0.040}; //_______pPb
-  // AccxEff(from paper)
-  //  Double_t systNofJpsiTot = 0.015;
-
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.007,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.028,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.016,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.006,2.) ),TMath::Sqrt( TMath::Power(0.024,2.) + TMath::Power(0.005 ,2.) ),TMath::Sqrt( TMath::Power(0.015,2.) + TMath::Power(0.016,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.005,0.004,0.004,0.004,0.003,0.002,0.002,0.04,0.04};
-  //  Double_t systPU[9] = {0.00,0.007,0.015,0.011,0.014,0.018,0.014,0.011,0.020}; //______Pbp
-  //  Double_t systNofJpsiTot = 0.015;
-
-  //  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.034,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.004,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.005,2.) ),TMath::Sqrt( TMath::Power(0.042,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.063,2.) + TMath::Power(0.014,2.) ),TMath::Sqrt( TMath::Power(0.094,2.) + TMath::Power(0.009,2.) ),TMath::Sqrt( TMath::Power(0.00,2.) + TMath::Power(0.00 ,2.) ),TMath::Sqrt( TMath::Power(0.00,2.) + TMath::Power(0.00,2.) )}; //FIXME: find a way to give this as input
-  //  Double_t systFNorm[9] = {0.004,0.019,0.002,0.012,0.048,0.063,0.082,0.000,0.000};
-  //  Double_t systPU[9] = {0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00}; //______pp |eta|<0.5
-  //  Double_t systNofJpsiTot = 0.017;
-
-//  Double_t systNofJpsiBin[9] = {TMath::Sqrt( TMath::Power(0.037,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.021,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.022,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.017,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.019,2.) + TMath::Power(0.001,2.) ),TMath::Sqrt( TMath::Power(0.036,2.) + TMath::Power(0.002,2.) ),TMath::Sqrt( TMath::Power(0.042,2.) + TMath::Power(0.001,2.) ),TMath::Sqrt( TMath::Power(0.039,2.) + TMath::Power(0.012 ,2.) ),TMath::Sqrt( TMath::Power(0.000,2.) + TMath::Power(0.000,2.) )}; //FIXME: find a way to give this as input
-//  Double_t systFNorm[9] = {0.026,0.002,0.015,0.019,0.012,0.030,0.015,0.119,0.000};
-//  Double_t systPU[9] = {0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00}; //______pp |eta|<1
-//  Double_t systNofJpsiTot = 0.017;
-  
-  Double_t systRNofJpsi[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  Double_t systFNormInt[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  Double_t systFNormBin[9] = {0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.000};
-  
-  TString* nameMB = new TString();
-  TString* nameY = new TString();
-  Int_t deltai(0);
-  for ( Int_t i = 1 ; i <= hy->GetNbinsX() ; i++ )
-  {
-    Int_t iMB = i + deltai;
-    nameMB->Replace(0,nameMB->Sizeof(),hMB->GetXaxis()->GetBinLabel(iMB));
-    nameY->Replace(0,nameY->Sizeof(),hry->GetXaxis()->GetBinLabel(i));
-    
-    // If the spectra had some results wich could not be fitted the corresponding bins are not in hry, producing a missmatchig between the bins in hMB and hry (Because hMB contains all the bins, even if for one bin the Fnorm could not be calculated). So we skip the hMB bin until matches with the hry one:
+    for ( Int_t i = 1 ; i <= hrmPt->GetNbinsX() ; i++ )
+        {
+        Double_t pt = hrmPt->GetBinContent(i);
+        Double_t ptError = hrmPt->GetBinError(i);
 
-    while ( nameMB->CompareTo(*nameY) )
-    {
-      deltai++;
-      iMB++;
-      nameMB->Replace(0,nameMB->Sizeof(),hMB->GetXaxis()->GetBinLabel(iMB));
-    }
+        std::cout << " Computing <pT> in bin " << hrmPt->GetXaxis()->GetBinLabel(i) << std::endl;
 
-    std::cout << " Computing yield in bin(" << iMB << "): " << nameMB->Data() << " with yield from bin (" << i << "): " << nameY->Data() << std::endl; //Just to check that the bin matching is ok
+        if ( relative )
+            {
+            ptError = TMath::Sqrt(TMath::Power(ptError/JPsiMPtTot,2.) + TMath::Power((pt*JPsiMPtTotError)/TMath::Power(JPsiMPtTot,2.),2.));
 
+            Double_t sMptInt = JPsiMPtTot*systMptInt[i-1];
+            Double_t sMptBin = pt*systMptBin[i-1];
+            Double_t sysMptRel = TMath::Sqrt( TMath::Power(sMptBin/JPsiMPtTot,2) + TMath::Power(pt*sMptInt/TMath::Power(JPsiMPtTot,2.),2.) );
 
-    Double_t yield = hry->GetBinContent(i)/(hMB->GetBinContent(iMB)*bR);
-    Double_t yieldError = yield*TMath::Sqrt(TMath::Power(hry->GetBinError(i)/hry->GetBinContent(i),2.) +
-                                            TMath::Power(hMB->GetBinError(iMB)/hMB->GetBinContent(iMB),2.) +
-                                            TMath::Power(bRerror/bR,2.));
+            pt /= JPsiMPtTot;
 
-    std::cout << "Yield = " << yield << " +- " << yieldError << " (stat) " << std::endl;
-    std::cout << std::endl;
-    
-    if ( relative )
-    {
-      yieldError = (yield/yieldInt)*TMath::Sqrt(TMath::Power(yieldError/yield,2.) + TMath::Power(yieldIntError/yieldInt,2.));
-      yield /= yieldInt;
-      
-      Double_t syst = yield*TMath::Sqrt( TMath::Power(systRNofJpsi[i-1],2.) + TMath::Power(systFNormInt[i-1],2.) +
-                                             TMath::Power(systFNormBin[iMB-1],2.) );
-      
-      std::cout << "Relative yield = " << yield << " +- " << yieldError << " (stat) " << " +- " << syst << " (sys) "  << std::endl;
-      std::cout << std::endl;
+            //      std::cout << TMath::Sqrt( TMath::Power(sysMptRel/pt,2.) +TMath::Power(systMptRel[i-1],2.) ) << std::endl;
 
-    }
+            std::cout << pt << " +- " << ptError << std::endl;
 
-    hy->SetBinContent(i,yield);
-    hy->SetBinError(i,yieldError);
-  }
+            }
 
-  delete nameMB;
-  delete nameY;
+        hmPt->SetBinContent(i,pt);
+        hmPt->SetBinError(i,ptError);
+        }
 
-  o = OC()->Histo(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy->GetName());
+    o = fMergeableCollection->Histo(Form("/RESULTS/%s",diffPath.Data()),hmPt->GetName());
 
-  if (o)
-  {
-    AliWarning(Form("Replacing %s/%s","/RESULTS-%s/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/V0A",hy->GetName()));
-    OC()->Remove(Form("/RESULTS-%s/%s/%s",striggerCluster.Data(),diffPath.Data(),hy->GetName()));
-  }
+    if (o)
+        {
+        AliWarning(Form("Replacing /RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
+        fMergeableCollection->Remove(Form("/RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
+        }
 
-  adoptOK = OC()->Adopt(Form("/RESULTS-%s/%s",striggerCluster.Data(),diffPath.Data()),hy);
+    adoptOK = fMergeableCollection->Adopt(Form("/RESULTS/%s",diffPath.Data()),hmPt);
 
-  if ( adoptOK ) std::cout << "+++Yield histo " << hy->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Yield histo %s",hy->GetName()));
-  
-  
+    if ( adoptOK ) std::cout << "+++Mean Pt histo " << hmPt->GetName() << " adopted" << std::endl;
+    else AliError(Form("Could not adopt mean pt histo %s",hmPt->GetName()));
+
+
+
+    delete hrmPt;
+
+
+    return;
 
-//  delete hry;
 
-  
-  return;
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeJpsiMPt(Bool_t relative, const char* evSelInt, const char* evSelDiff,const char* spectra, const char* sResName)
+void AliAnalysisMuMu::ComputeMBXSectionFractionInBins(const char* filePileUpCorr, const char* eventSelection, const char* what,const char* quantity
+                                                      ,const char* flavour)
 {
-  // ocMBTrigger is the mergeableCollection with the MB trigger dNchdEta plot (migth be the same as oc, in which case we set ocMBTrigger=0x0)
-  //FIXME::Make it general
-  // Note that here the ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios
+    /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), in bins.
+    ///
+    /// Important considerations:
+    ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
+    ///
+    ///   - The analysed file must contain the event selection PSALL and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly. (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
+    ///
+    /// Parameters:
+    ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
+    ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
+    ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
+    ///   -quantity: binning type. By default "ntrcorr"
+    ///   -flavour: binning flavour. By default "D2H"
+    ///   -eventSelection: desired event selection. By default is "PSALL" (no event cuts but physics selection).
+
+
+    //________Decoding of the pileup correction file
+    Bool_t corrPU(kFALSE);
+    TObjArray* pUCorr = new TObjArray();
+    if ( strlen(filePileUpCorr) > 0 )
+        {
+        std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
+        char line[1024];
+        ifstream in(filePileUpCorr);
 
+        while ( in.getline(line,1024,'\n'))
+            {
+            TString lrun(line);
+            TString lvalue(line);
 
-  TString swhat("");
-  TString sres("");
-  TString sspectra(spectra);
-  TString sevSelInt(evSelInt);
-  TString sevSelDiff(evSelDiff);
+            lrun.Remove(0,4);
+            lrun.Remove(6,67);
 
-  if ( sspectra.Contains("DNCHDETA")) swhat = "dnchdeta";   //FIXME::Make it general for any bin quantity (pt,centrality...)
-  else if ( sspectra.Contains("NTRCORR") ) swhat = "ntrcorr";
+            lvalue.Remove(0,lvalue.First("=")+1);
 
-  if ( strlen(sResName) > 0 ) sres = sResName; //sres = "MPTPSIPSIPRIMECB2VWG_BKGMPTPOL2";
+            std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
 
-  if ( IsSimulation() )
-  {
-    AliError("Cannot compute J/Psi <pT>: Is a simulation file");
-    return;
-  }
-  
-  TString dimuonTriggerClassName = Config()->First(Config()->DimuonTriggerKey(),kFALSE);
-  TString centralitySelection = Config()->First(Config()->CentralitySelectionKey(),kFALSE);
-  TString pairSelection = Config()->First(Config()->PairSelectionKey(),kFALSE);
-  
-  //Path to get/store integrated results from Mergeable Collection
-  TString intPath(Form("%s/%s/%s/%s",
-                       sevSelInt.Data(),
-                       dimuonTriggerClassName.Data(),
-                       centralitySelection.Data(),
-                       pairSelection.Data()));
-  
-  //Path to get/store differential results from Mergeable Collection
-  TString diffPath(Form("%s/%s/%s/%s",
-                        sevSelDiff.Data(),
-                        dimuonTriggerClassName.Data(),
-                        centralitySelection.Data(),
-                        pairSelection.Data()));
-  
-  
-  if ( relative ) AliWarning("The ratio is computed from the mean values of subresults (ymean/ymean_int) and is not the mean value of subresults ratios");
+            pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
+            }
+        corrPU = kTRUE;
+        }
+    //________
 
-  //_________Integrated mean pt
-  AliAnalysisMuMuSpectra* sInt = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",intPath.Data(),"PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS")));
-  if ( !sInt )
-  {
-    AliError(Form("No spectra %s found in %s","PSI-INTEGRATED-AccEffCorr-MeanPtVsMinvUS",intPath.Data()));
-    return;
-  }
-  
-  AliAnalysisMuMuBinning* b = new AliAnalysisMuMuBinning;
-  b->AddBin("psi","INTEGRATED");
-  
-  AliAnalysisMuMuBinning::Range* bin = static_cast<AliAnalysisMuMuBinning::Range*>(b->CreateBinObjArray()->At(0));
-  
-  AliAnalysisMuMuResult* result = sInt->GetResultForBin(*bin);
-  if ( !result )
-  {
-    AliError(Form("No result for bin %s found in spectra %s",bin->AsString().Data(),sInt->GetName()));
-    return;
-  }
-  
-  
-  Double_t JPsiMPtTot = result->GetValue("MeanPtJPsi");
-  Double_t JPsiMPtTotError = result->GetErrorStat("MeanPtJPsi");
 
-  std::cout << "Integrated J/Psi <pT> = " << JPsiMPtTot << " +- " << JPsiMPtTotError << std::endl;
-  std::cout << std::endl;
+    TString seventSelection(eventSelection);
+    TString sQuantity(quantity);
+    TString sruns = CC()->GetKeyWords("run");
+    TObjArray* runs = sruns.Tokenize(",");
 
-  TH1* hMPtint = new TH1F("hJPsiMPtInt","Integrated J/#psi mean p_{T}",1,0.,1.);
-  hMPtint->SetBinContent(1,JPsiMPtTot);
-  hMPtint->SetBinError(1,JPsiMPtTotError);
-  
-  TH1* o = OC()->Histo(Form("/RESULTS/%s",intPath.Data()),hMPtint->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing /RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
-    OC()->Remove(Form("/RESULTS/%s/%s",intPath.Data(),hMPtint->GetName()));
-  }
-  
-  Bool_t adoptOK = OC()->Adopt(Form("/RESULTS/%s",intPath.Data()),hMPtint);
-  
-  if ( adoptOK ) std::cout << "+++Mean Pt histo " << hMPtint->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt Mean Pt histo %s",hMPtint->GetName()));
-  
-  delete b;
+    TIter nextRun(runs);
+    TObjString* s;
 
-  //_____Differential mean pt
+    AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
+    if ( !binning )
+        {
+        AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
+        return;
+        }
+    TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
+    Int_t nEntries = bin->GetEntries();
 
-  AliAnalysisMuMuSpectra* s = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/%s/%s",diffPath.Data(),spectra)));
-  if ( !s )
-  {
-    AliError(Form("No spectra %s found in %s",spectra,diffPath.Data()));
-    return;
-  }
+    Double_t* nCINTBin = new Double_t[nEntries];
+    Double_t nCINTTot = 0. ;
 
-  std::cout << "Mean pt of J/Psi:" << std::endl;
-  TH1* hrmPt = s->Plot("MeanPtJPsi",sres.Data(),kFALSE); //MPT2CB2VWGPOL2INDEPTAILS//mean pt of Jpsi
-  std::cout << "" << std::endl;
+    TIter nextBin(bin);
+    AliAnalysisMuMuBinning::Range* r;
+    Int_t i(0); // Bin number
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
+        {
+        nCINTBin[i] = 0;
 
+        std::cout << "______________________________" << std::endl;
+        std::cout << "Bin: " << r->AsString().Data() << std::endl;
 
-  const TArrayD* binArray = hrmPt->GetXaxis()->GetXbins();
-  Int_t size = binArray->GetSize();
-  Double_t* axis = new Double_t[size];
-  
-//  Double_t ptInt,ptIntError;
-  TH1* hmPt;
-  if ( relative )
-  {
-    
-    hmPt = new TH1D(Form("hJPsiMeanPtVS%sRelative",swhat.Data()),Form("Relative J/#psi mean p_{T} vs %s;%s;<p_{T}^{J/#psi}>/<p_{T}^{J/#psi}_{int}>",swhat.Data(),swhat.Data())
-                    ,size-1,axis);
-    
-  }
-  else
-  {
-    hmPt = new TH1D(Form("hJPsiMeanPtVS%s",swhat.Data()),Form("J/#psi <p_{T}> vs %s;%s;<p_{T}>^{J/#psi}",swhat.Data(),swhat.Data())
-                    ,size-1,axis);
+        nextRun.Reset();
+        while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
+            {
 
+<<<<<<< 866b569b5f510c7fdc4b9c5e5f4a301d66425d0e
   }
   
   delete[] axis;
+=======
+            Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT7-B-NOPF-ALLNOTRD/centrality:V0A/run:%s/bin:%s",
+                                               seventSelection.Data(),s->GetName(),r->AsString().Data()));
+>>>>>>> Commit of all mumu commits of the precedent aliroot system
 
-  Double_t systMptInt[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //FIXME: find a way to give this as input
-  Double_t systMptBin[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
-  
-  Double_t systMptRel[12] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}; //signal extraction pPb
+            Double_t pUfactor = 1.;
+            if ( nCINT !=0. )
+                {
+                if (corrPU)
+                    {
+                    TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
+                    if ( p ) pUfactor = p->GetVal();
+                    else
+                        {
+                        AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
+                        }
+                    }
 
-//  Double_t systMptInt[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014}; //FIXME: find a way to give this as input
-//  Double_t systMptBin[9] = {0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.014};
-//
-//  Double_t systMptRel[9] = {0.002,0.001,0.001,0.002,0.002,0.002,0.002,0.004,0.004}; //signal extraction pPb
-  
-  //  Double_t systMptRel[9] = {0.002,0.001,0.012,0.001,0.002,0.002,0.001,0.004,0.003}; //signal extraction Pbp
-  
-  //  Double_t systMptRel[9] = {0.001,0.002,0.001,0.002,0.002,0.003,0.005,0.000,0.000}; //signal extraction pp|eta|<05
-  
-  //  Double_t systMptRel[9] = {0.002,0.002,0.002,0.002,0.001,0.002,0.001,0.012,0.000}; //signal extraction pp|eta|<1
-  
-  for ( Int_t i = 1 ; i <= hrmPt->GetNbinsX() ; i++ )
-  {
-    Double_t pt = hrmPt->GetBinContent(i);
-    Double_t ptError = hrmPt->GetBinError(i);
-    
-    std::cout << " Computing <pT> in bin " << hrmPt->GetXaxis()->GetBinLabel(i) << std::endl;
+                nCINT = nCINT*pUfactor;
+                }
+            else
+                {
+                std::cout << " Warning: Run " << s->GetName() << " has no MB trigger in this bin" << std::endl;
+                continue;
+                }
+            nCINTBin[i] += nCINT;
 
-    if ( relative )
-    {
-      ptError = TMath::Sqrt(TMath::Power(ptError/JPsiMPtTot,2.) + TMath::Power((pt*JPsiMPtTotError)/TMath::Power(JPsiMPtTot,2.),2.));
-      
-      Double_t sMptInt = JPsiMPtTot*systMptInt[i-1];
-      Double_t sMptBin = pt*systMptBin[i-1];
-      Double_t sysMptRel = TMath::Sqrt( TMath::Power(sMptBin/JPsiMPtTot,2) + TMath::Power(pt*sMptInt/TMath::Power(JPsiMPtTot,2.),2.) );
-      
-      pt /= JPsiMPtTot;
-      
-//      std::cout << TMath::Sqrt( TMath::Power(sysMptRel/pt,2.) +TMath::Power(systMptRel[i-1],2.) ) << std::endl;
-      
-      std::cout << pt << " +- " << ptError << std::endl;
+            std::cout << "Run " << s->GetName() <<  " ; " << "Nof CINT = " << nCINT << std::endl;
 
-    }
-    
-    hmPt->SetBinContent(i,pt);
-    hmPt->SetBinError(i,ptError);
-  }
-  
-  o = fMergeableCollection->Histo(Form("/RESULTS/%s",diffPath.Data()),hmPt->GetName());
-  
-  if (o)
-  {
-    AliWarning(Form("Replacing /RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
-    fMergeableCollection->Remove(Form("/RESULTS/%s/%s",diffPath.Data(),hmPt->GetName()));
-  }
-  
-  adoptOK = fMergeableCollection->Adopt(Form("/RESULTS/%s",diffPath.Data()),hmPt);
-  
-  if ( adoptOK ) std::cout << "+++Mean Pt histo " << hmPt->GetName() << " adopted" << std::endl;
-  else AliError(Form("Could not adopt mean pt histo %s",hmPt->GetName()));
-  
-  
-  
-  delete hrmPt;
-  
-  
-  return;
+            }
+
+        nCINTTot += nCINTBin[i];
+
+        std::cout << std::endl;
+
+        std::cout << "Nof CINT in bin = " << nCINTBin[i]  << std::endl;
+
+        i++;
+        }
+
+
+    nextBin.Reset();
+    i=0;
+    Double_t totXSectFract(0.);
+    while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
+        {
+        Double_t xSecFract = (nCINTBin[i] / nCINTTot)*100.;
 
+        totXSectFract += xSecFract;
+
+        std::cout << "Cross section Fraction in bin " << r->AsString().Data() << " = " << xSecFract  << std::endl;
+
+        i++;
+        }
+
+    std::cout << std::endl;
+    std::cout << "Total xSection in bins = " << totXSectFract  << std::endl;
+
+    delete binning;
+    delete runs;
+    delete bin;
+    delete[] nCINTBin;
+
+    return;
+
+}
+
+//_____________________________________________________________________________
+Double_t AliAnalysisMuMu::ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d)
+{
+    //Just valid for counts
+    Double_t error2 = TMath::Power(b/(c*d),2.)*a + TMath::Power(a/(c*d),2.)*b + TMath::Power(a*b*d,2.)*(c/TMath::Power(c*d,4.)) + TMath::Power(a*b*c,2.)*(d/TMath::Power(c*d,4.));
+
+    return TMath::Sqrt(error2);
+}
+
+// //_____________________________________________________________________________
+// TH1* AliAnalysisMuMu::ComputeEquNofMB(const char* what,const char* quantity,const char* flavour,Bool_t printout)
+// {
+//   //Compute Equivalent Numbre of MB bin by bin
+//
+//   // Get binning
+//   AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
+//
+//   // Copy binning array
+//   TObjArray* dNchdEtas = binning->CreateBinObjArray();
+//   Double_t* binArray = binning->CreateBinArray();
+//
+//   TIter next(dNchdEtas);
+//   AliAnalysisMuMuBinning::Range* r;
+//
+//   TH1* hFNorm = ComputeDiffFnormFromHistos(what,quantity,flavour,kFALSE);
+//
+//   TH1* hNMB = new TH1F("hNofEqMB","Equivalent number of MB triggers vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
+//
+//   Int_t bin(0);
+//   while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
+//   {
+//
+//     TH1* hCMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMUL7-B-NOPF-MUON/V0A/%s",
+//                                   Form("EventsIn%s",r->AsString().Data())));
+//     if ( !hCMUL )
+//     {
+//       AliError(Form("No event histo in bin %s found for CMUL7-B-NOPF-MUON",r->AsString().Data()));
+//       return 0x0;
+//     }
+//
+//     Double_t NMB = hCMUL->GetBinContent(1)*hFNorm->GetBinContent(++bin);
+//     Double_t NMBError = TMath::Sqrt(TMath::Power(hCMUL->GetBinContent(1)*hFNorm->GetBinError(bin),2.) + TMath::Power(TMath::Sqrt(hCMUL->GetBinContent(1))*hFNorm->GetBinContent(bin),2));
+//
+//     if ( printout ) std::cout << r->AsString().Data() << " : " << NMB << " +- " << NMBError << std::endl;
+//
+//     hNMB->SetBinContent(bin,NMB);
+//     hNMB->SetBinError(bin,NMBError);
+//   }
+//
+//   delete dNchdEtas;
+//   delete[] binArray;
+//
+//   return hNMB;
+// }
 
-}
 
 //_____________________________________________________________________________
-void AliAnalysisMuMu::ComputeMBXSectionFractionInBins(const char* filePileUpCorr, const char* eventSelection, const char* what,const char* quantity
-                                                      ,const char* flavour)
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const char* flavour,const char* accEffSubResultName)
 {
-  /// Compute the CMUL to CINT ratio(s) in 2 steps (Offline method) from the CC(), in bins.
-  ///
-  /// Important considerations:
-  ///   - The analysed file must contain the CMUL, CINT, CMSL, CMSL&0MUL and CINT&0MSL triggers to work correctly.
-  ///
-  ///   - The analysed file must contain the event selection PSALL and the one used in the yield analysis (i.e. PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00) to work correctly. (the first to compute the Fnorm and the second to get the NofCMUL used in the yield analysis to get the correct NofEqMB = Fnorm*NofCMUL)
-  ///
-  /// Parameters:
-  ///   -filePileUpCorr: txt file with the pile up correction run by run. Each line in the file must have the format:
-  ///                     RUN 195681 PERIOD LHC13d PILE-UP CORRECTION FACTOR (mu/(1-exp(-mu)) =  1.0015
-  ///   -what: what the binning range is about (J/psi, event...). By default is "psi".
-  ///   -quantity: binning type. By default "ntrcorr"
-  ///   -flavour: binning flavour. By default "D2H"
-  ///   -eventSelection: desired event selection. By default is "PSALL" (no event cuts but physics selection).
-
-
-  //________Decoding of the pileup correction file
-  Bool_t corrPU(kFALSE);
-  TObjArray* pUCorr = new TObjArray();
-  if ( strlen(filePileUpCorr) > 0 )
-  {
-    std::cout << "Extracting Pile-Up correction factors from " << filePileUpCorr << std::endl;
-    char line[1024];
-    ifstream in(filePileUpCorr);
+    /// Correct one spectra
 
-    while ( in.getline(line,1024,'\n'))
+    if (!SIM())
     {
-      TString lrun(line);
-      TString lvalue(line);
-
-      lrun.Remove(0,4);
-      lrun.Remove(6,67);
+      AliError("Cannot compute corrected yield without associated MC file !");
+      return 0x0;
+    }
 
-      lvalue.Remove(0,lvalue.First("=")+1);
+    TString Event         =Config()->First(Config()->EventSelectionKey(),kTRUE);
+    TString Centrality    =Config()->First(Config()->CentralitySelectionKey(),kTRUE);
+    TString DimuonTrigger =Config()->First(Config()->DimuonTriggerKey(),kTRUE);
+    TString PairSelection =Config()->First(Config()->PairSelectionKey(),kTRUE);
 
-      std::cout << "RUN: " << lrun.Data() << " PUFactor = " << lvalue.Data() << std::endl;
+    cout << " looking for spectra in : " << Form("%s,%s,%s,%s",Event.Data(),DimuonTrigger.Data(),Centrality.Data(),PairSelection.Data()) << endl;
 
-      pUCorr->Add(new TParameter<Double_t>(lrun.Data(),lvalue.Atof()));
+    AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
+    AliAnalysisMuMuSpectra* simSpectra = SIM()->GetMCSpectra(type,Event.Data(),DimuonTrigger.Data(),Centrality.Data(),PairSelection.Data(),flavour);
+    
+    if ( !realSpectra )
+    {
+      AliError("could not get real spectra");
+      return 0x0;
     }
-    corrPU = kTRUE;
-  }
-  //________
-
-
-  TString seventSelection(eventSelection);
-  TString sQuantity(quantity);
-  TString sruns = CC()->GetKeyWords("run");
-  TObjArray* runs = sruns.Tokenize(",");
 
-  TIter nextRun(runs);
-  TObjString* s;
+    if ( !simSpectra)
+    {
+      AliError("could not get sim spectra");
+      return 0x0;
+    }
 
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,sQuantity.Data(),flavour);
-  if ( !binning )
-  {
-    AliError(Form("%s-%s-%s binning does not exist",what,sQuantity.Data(),flavour));
-    return;
-  }
-  TObjArray* bin = binning->CreateBinObjArray(what,sQuantity.Data(),flavour);
-  Int_t nEntries = bin->GetEntries();
+    realSpectra->Correct(*simSpectra,"JPsi",accEffSubResultName);
 
-  Double_t* nCINTBin = new Double_t[nEntries];
-  Double_t nCINTTot = 0. ;
+    Update();
 
-  TIter nextBin(bin);
-  AliAnalysisMuMuBinning::Range* r;
-  Int_t i(0); // Bin number
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) ) //Bin loop
-  {
-    nCINTBin[i] = 0;
+    return realSpectra;
+}
 
-    std::cout << "______________________________" << std::endl;
-    std::cout << "Bin: " << r->AsString().Data() << std::endl;
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const char* flavour,const char* accEffSubResultName)
+{
+    // Compute yield from simulation file
+    //
+    // FIX ME: make it general
+    
+    TString Event         =Config()->First(Config()->EventSelectionKey(),kTRUE);
+    TString Centrality    =Config()->First(Config()->CentralitySelectionKey(),kTRUE);
+    TString DimuonTrigger =Config()->First(Config()->DimuonTriggerKey(),kTRUE);
+    TString PairSelection =Config()->First(Config()->PairSelectionKey(),kTRUE);
 
-    nextRun.Reset();
-    while ( ( s = static_cast<TObjString*>(nextRun())) ) //Run loop
-    {
+    if (!SIM()){
+      AliError("Cannot compute corrected yield without associated MC file !");
+      return 0x0;
+    }
 
-      Double_t nCINT = CC()->GetSum(Form("/event:%s/trigger:CINT7-B-NOPF-ALLNOTRD/centrality:V0A/run:%s/bin:%s",
-                                         seventSelection.Data(),s->GetName(),r->AsString().Data()));
+    AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
 
-      Double_t pUfactor = 1.;
-      if ( nCINT !=0. )
-      {
-        if (corrPU)
-        {
-          TParameter<Double_t>* p = static_cast<TParameter<Double_t>*>(pUCorr->FindObject(s->GetName()));
-          if ( p ) pUfactor = p->GetVal();
-          else
-          {
-            AliError(Form("Run %s not found in pile-up correction list",s->GetName()));
-          }
-        }
+    if ( !realSpectra ){
+      AliError("could not get real spectra");
+      return 0x0;
+    }
 
-        nCINT = nCINT*pUfactor;
-      }
-      else
-      {
-        std::cout << " Warning: Run " << s->GetName() << " has no MB trigger in this bin" << std::endl;
-        continue;
+    if (!realSpectra->HasValue("CoffNofJPsi")){
+      if (!CorrectSpectra(type,flavour,accEffSubResultName)){
+        AliError("Could not get corrected spectra");
+        return 0x0;
       }
-      nCINTBin[i] += nCINT;
-
-      std::cout << "Run " << s->GetName() <<  " ; " << "Nof CINT = " << nCINT << std::endl;
-
     }
 
-    nCINTTot += nCINTBin[i];
-
-    std::cout << std::endl;
+    AliAnalysisMuMuSpectra* simSpectra = SIM()->GetMCSpectra(type,Event.Data(),DimuonTrigger.Data(),Centrality.Data(),PairSelection.Data(),flavour);
 
-    std::cout << "Nof CINT in bin = " << nCINTBin[i]  << std::endl;
+    if ( !simSpectra){
+      AliErrorClass("could not get sim spectra");
+      return 0x0;
+    }
 
-    i++;
-  }
+    AliAnalysisMuMuBinning* binning = realSpectra->Binning();
+    TObjArray* bins = binning->CreateBinObjArray();
+    TIter nextBin(bins);
+    AliAnalysisMuMuBinning::Range* bin;
+    Int_t i(0);
+    AliAnalysisMuMuJpsiResult* r;
 
+    while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
+    {
+      r = static_cast<AliAnalysisMuMuJpsiResult*>(realSpectra->BinContentArray()->At(i));
 
-  nextBin.Reset();
-  i=0;
-  Double_t totXSectFract(0.);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
-  {
-    Double_t xSecFract = (nCINTBin[i] / nCINTTot)*100.;
+      StdoutToAliDebug(1,std::cout << "bin=";r->Print(););
 
-    totXSectFract += xSecFract;
+      AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
 
-    std::cout << "Cross section Fraction in bin " << r->AsString().Data() << " = " << xSecFract  << std::endl;
+      // Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
+      // Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+      //                                                             nofCINT7,TMath::Sqrt(nofCINT7),
+      //                                                             nofCMUL7,TMath::Sqrt(nofCMUL7));
 
-    i++;
-  }
+      // r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
+      //                                                                                               nofCINT7,TMath::Sqrt(nofCINT7)));
 
-  std::cout << std::endl;
-  std::cout << "Total xSection in bins = " << totXSectFract  << std::endl;
+      // Double_t yield =  r->GetValue("CorrNofJPsi") * mbeq;
 
-  delete binning;
-  delete runs;
-  delete bin;
-  delete[] nCINTBin;
+      // Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJPsi"), r->GetErrorStat("CorrNofJPsi"),
+      //                                                              mbeq,mbeqError);
 
-  return;
-  
-}
+      // r->Set("YJpsi",yield,yieldError);
 
-//_____________________________________________________________________________
-Double_t AliAnalysisMuMu::ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d)
-{
-  //Just valid for counts
-  Double_t error2 = TMath::Power(b/(c*d),2.)*a + TMath::Power(a/(c*d),2.)*b + TMath::Power(a*b*d,2.)*(c/TMath::Power(c*d,4.)) + TMath::Power(a*b*c,2.)*(d/TMath::Power(c*d,4.));
-  
-  return TMath::Sqrt(error2);
-}
+      r->Set("NofInputJPsi",rsim->GetValue("NofInputJPsi",accEffSubResultName),rsim->GetErrorStat("NofInputJPsi",accEffSubResultName));
+      r->Set("AccEffJPsi",rsim->GetValue("AccEffJPsi",accEffSubResultName),rsim->GetErrorStat("AccEffJPsi",accEffSubResultName));
 
-//_____________________________________________________________________________
-TH1* AliAnalysisMuMu::ComputeEquNofMB(const char* what,const char* quantity,const char* flavour,Bool_t printout)
-{
-  
-  AliAnalysisMuMuBinning* binning = BIN()->Project(what,quantity,flavour);
-  TObjArray* dNchdEtas = binning->CreateBinObjArray();
-  
-  Double_t* binArray = binning->CreateBinArray();
-  
-  TIter next(dNchdEtas);
-  AliAnalysisMuMuBinning::Range* r;
-  
-  TH1* hFNorm = ComputeDiffFnormFromHistos(what,quantity,flavour,kFALSE);
-  
-  TH1* hNMB = new TH1F("hNofEqMB","Equivalent number of MB triggers vs dN_{ch}/d#eta;dN_{ch}/d#eta;FNorm",dNchdEtas->GetEntries(),binArray);
-  
-  Int_t bin(0);
-  while ( ( r = static_cast<AliAnalysisMuMuBinning::Range*>(next()) ) )
-  {
-    
-    TH1* hCMUL = OC()->Histo(Form("/PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00/CMUL7-B-NOPF-MUON/V0A/%s",
-                                  Form("EventsIn%s",r->AsString().Data())));
-    if ( !hCMUL )
-    {
-      AliError(Form("No event histo in bin %s found for CMUL7-B-NOPF-MUON",r->AsString().Data()));
-      return 0x0;
+      ++i;
     }
-    
-    Double_t NMB = hCMUL->GetBinContent(1)*hFNorm->GetBinContent(++bin);
-    Double_t NMBError = TMath::Sqrt(TMath::Power(hCMUL->GetBinContent(1)*hFNorm->GetBinError(bin),2.) + TMath::Power(TMath::Sqrt(hCMUL->GetBinContent(1))*hFNorm->GetBinContent(bin),2));
-    
-    if ( printout ) std::cout << r->AsString().Data() << " : " << NMB << " +- " << NMBError << std::endl;
-    
-    hNMB->SetBinContent(bin,NMB);
-    hNMB->SetBinError(bin,NMBError);
-  }
-  
-  delete dNchdEtas;
-  delete[] binArray;
-  
-  return hNMB;
-}
-
-
-//_____________________________________________________________________________
-AliAnalysisMuMuSpectra* AliAnalysisMuMu::CorrectSpectra(const char* type, const char* flavour)
-{
-  /// Correct one spectra
-  
-  if (!SIM())
-  {
-    AliError("Cannot compute corrected yield without associated MC file !");
-    return 0x0;
-  }
 
-  const char* accEffSubResultName="PSICOUNT:1";
-  
-  AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
-  AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
-  
-  if ( !realSpectra )
-  {
-    AliError("could not get real spectra");
-    return 0x0;
-  }
-  
-  if ( !simSpectra)
-  {
-    AliError("could not get sim spectra");
-    return 0x0;
-  }
-  
-  realSpectra->Correct(*simSpectra,"Jpsi",accEffSubResultName);
+    delete bins;
 
-  Update();
-  
-  return realSpectra;
-}
+    Update();
 
-//_____________________________________________________________________________
-AliAnalysisMuMuSpectra* AliAnalysisMuMu::ComputeYield(const char* type, const char* flavour)
-{
-  if (!SIM())
-  {
-    AliError("Cannot compute corrected yield without associated MC file !");
-    return 0x0;
-  }
-  
-  const char* accEffSubResultName="PSICOUNT:1";
-  
-  AliAnalysisMuMuSpectra* realSpectra = GetSpectra(type,flavour);
-  
-  if ( !realSpectra )
-  {
-    AliError("could not get real spectra");
-    return 0x0;
-  }
-  
-  if (!realSpectra->HasValue("CoffNofJpsi"))
-  {
-    if (!CorrectSpectra(type,flavour))
-    {
-      AliError("Could not get corrected spectra");
-      return 0x0;
-    }
-  }
-  
-  AliAnalysisMuMuSpectra* simSpectra = SIM()->GetSpectra(type,flavour);
-  
-  if ( !simSpectra)
-  {
-    AliErrorClass("could not get sim spectra");
-    return 0x0;
-  }
-  
-  Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
-  Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
-  Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
-  
-  AliAnalysisMuMuBinning* binning = realSpectra->Binning();
-  TObjArray* bins = binning->CreateBinObjArray();
-  TIter nextBin(bins);
-  AliAnalysisMuMuBinning::Range* bin;
-  Int_t i(0);
-  AliAnalysisMuMuJpsiResult* r;
-  
-  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
-  {
-    r = static_cast<AliAnalysisMuMuJpsiResult*>(realSpectra->BinContentArray()->At(i));
-   
-    StdoutToAliDebug(1,std::cout << "bin=";r->Print(););
-    
-    AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
-    
-    Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
-    Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                                                nofCINT7,TMath::Sqrt(nofCINT7),
-                                                                nofCMUL7,TMath::Sqrt(nofCMUL7));
-    
-    r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
-                                                                                                nofCINT7,TMath::Sqrt(nofCINT7)));
-    
-    Double_t yield =  r->GetValue("CorrNofJpsi") * mbeq;
-    
-    Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJpsi"), r->GetErrorStat("CorrNofJpsi"),
-                                                                 mbeq,mbeqError);
-    
-    r->Set("YJpsi",yield,yieldError);
-    
-    r->Set("NofInputJpsi",rsim->GetValue("NofInputJpsi",accEffSubResultName),rsim->GetErrorStat("NofInputJpsi",accEffSubResultName));
-    r->Set("AccEffJpsi",rsim->GetValue("AccEffJpsi",accEffSubResultName),rsim->GetErrorStat("AccEffJpsi",accEffSubResultName));
-    
-    ++i;
-  }
-  
-  delete bins;
-  
-  Update();
-  
-  return realSpectra;
+    return realSpectra;
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* direction)
 {
   /// Compute the RAB...
-  
+
   if (!SIM()) return 0x0;
-  
+
   Double_t rapidityShift = 0.465;// 0.5*TMath::Log(208.0/82.0);
   const Double_t sqrts=5.023;
   const Double_t ymax=TMath::Log(sqrts*1000.0/3.096916);
   const Double_t tab = 0.093e-6; // nb^-1
   const Double_t tabError = 0.0035E-6; // nb^-1
   const char* accEffSubResultName="PSICOUNT:1";
-  
+
   TF1 ydist("ydist","[0]*TMath::Exp(-(x*x)/(2.0*0.39*0.39))",0.,0.5);
   ydist.SetParameter(0,1.);
 
@@ -5525,44 +5998,44 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* dire
   Double_t normalization = 0.25*(230.8+212.1)/ydist.Integral(y1_norma, y2_norma);
   ydist.SetParameter(0,normalization);
 //  AliInfoClass(Form("ymax=%e normalization=%f",ymax,ydist.Integral(y1_norma, y2_norma)));
-  
+
   AliAnalysisMuMuSpectra* realSpectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/PSALL/CMUL7-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
   AliAnalysisMuMuSpectra* simSpectra = static_cast<AliAnalysisMuMuSpectra*>(SIM()->OC()->GetObject(Form("/ALL/CMULLO-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
-  
+
   if ( !realSpectra )
   {
     AliErrorClass("could not get real spectra");
     return 0x0;
   }
-  
+
   if ( !simSpectra)
   {
     AliErrorClass("could not get sim spectra");
     return 0x0;
   }
-  
+
   AliAnalysisMuMuSpectra* corrSpectra = static_cast<AliAnalysisMuMuSpectra*>(realSpectra->Clone());
   corrSpectra->Correct(*simSpectra,"Jpsi",accEffSubResultName);
-  
+
   Double_t nofCMUL7 = CC()->GetSum(Form("trigger:CMUL7-B-NOPF-MUON/event:PSALL"));
   Double_t nofCINT7 = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD/event:PSALL"));
   Double_t nofCINT7w0MUL = CC()->GetSum(Form("trigger:CINT7-B-NOPF-ALLNOTRD&0MUL/event:PSALL"));
-  
+
   AliAnalysisMuMuBinning* binning = realSpectra->Binning();
   TObjArray* bins = binning->CreateBinObjArray();
   TIter nextBin(bins);
   AliAnalysisMuMuBinning::Range* bin;
   Int_t i(0);
   AliAnalysisMuMuJpsiResult* r;
-  
+
   Int_t n = bins->GetLast();
-  
+
   TObjArray finalBins(n+1);
   finalBins.SetOwner(kTRUE);
-  
+
   TObjArray finalResults(n+1);
   finalResults.SetOwner(kFALSE);
-  
+
   while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
   {
     Double_t ylowlab = bin->Xmin();
@@ -5570,13 +6043,13 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* dire
 
     Double_t ylowcms, yhighcms;
     Double_t ylownorm, yhighnorm;
-    
+
     if ( bin->IsIntegrated() )
     {
       ylowlab = -4;
       yhighlab = -2.5;
     }
-    
+
     if ( strcmp(direction,"pPb")==0 )
     {
       ylowcms = TMath::Abs(yhighlab) -  rapidityShift;
@@ -5591,31 +6064,36 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* dire
       ylownorm = -yhighcms/ymax;
       yhighnorm = -ylowcms/ymax;
     }
-    
-    
+
+
     Double_t brsigmapp = ydist.Integral(ylownorm,yhighnorm);
     Double_t brsigmappError = 0.0; // FIXME
-    
-    AliInfoClass(Form("y range : LAB %f ; %f CMS %f ; %f -> ynorm : %f ; %f -> BR x sigmapp = %f",
-                      ylowlab,yhighlab,ylowcms,yhighcms,ylownorm,yhighnorm,brsigmapp));
-    
-    r = static_cast<AliAnalysisMuMuJpsiResult*>(corrSpectra->BinContentArray()->At(i)->Clone());
+
+    AliAnalysisMuMuSpectra* realSpectra = static_cast<AliAnalysisMuMuSpectra*>(OC()->GetObject(Form("/PSALL/CMUL7-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
+    AliAnalysisMuMuSpectra* simSpectra = static_cast<AliAnalysisMuMuSpectra*>(SIM()->OC()->GetObject(Form("/ALL/CMULLO-B-NOPF-MUON/PP/pMATCHLOWRABSBOTH/PSI-%s",type)));
+
+    if ( !realSpectra )
+        {
+        AliErrorClass("could not get real spectra");
+        return 0x0;
+        }
+
 
     AliAnalysisMuMuJpsiResult* rsim = static_cast<AliAnalysisMuMuJpsiResult*>(simSpectra->BinContentArray()->At(i));
-    
+
     Double_t mbeq = nofCINT7w0MUL / ( nofCINT7 * nofCMUL7);
     Double_t mbeqError = mbeq * AliAnalysisMuMuResult::ErrorABC( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
                                          nofCINT7,TMath::Sqrt(nofCINT7),
                                          nofCMUL7,TMath::Sqrt(nofCMUL7));
-    
+
     r->Set("Fnorm",nofCINT7/nofCINT7w0MUL,(nofCINT7/nofCINT7w0MUL)*AliAnalysisMuMuResult::ErrorAB( nofCINT7w0MUL, TMath::Sqrt(nofCINT7w0MUL),
                                                                       nofCINT7,TMath::Sqrt(nofCINT7)));
-    
+
     Double_t yield =  r->GetValue("CorrNofJpsi") * mbeq;
 
     Double_t yieldError = yield * AliAnalysisMuMuResult::ErrorAB( r->GetValue("CorrNofJpsi"), r->GetErrorStat("CorrNofJpsi"),
                                           mbeq,mbeqError);
-    
+
     r->Set(Form("Y%sJpsi",direction),yield,yieldError);
 
     Double_t raa = yield/(tab*brsigmapp);
@@ -5626,21 +6104,21 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* dire
 
     r->Set("NofInputJpsi",rsim->GetValue("NofInputJpsi",accEffSubResultName),rsim->GetErrorStat("NofInputJpsi",accEffSubResultName));
     r->Set("AccEffJpsi",rsim->GetValue("AccEffJpsi",accEffSubResultName),rsim->GetErrorStat("AccEffJpsi",accEffSubResultName));
-    
+
     AliAnalysisMuMuBinning::Range* bincm = new AliAnalysisMuMuBinning::Range(bin->What(),bin->Quantity(),ylowcms,yhighcms);
-    
+
     r->SetBin(*bincm);
-        
+
     finalBins.Add(bincm);
     finalResults.Add(r);
-    
+
     ++i;
   }
-  
+
   delete bins;
-  
+
   AliAnalysisMuMuSpectra* spectra = new AliAnalysisMuMuSpectra(type,direction);
-  
+
   for ( i = 0; i <= n; ++i )
   {
     Int_t j(i);
@@ -5648,17 +6126,17 @@ AliAnalysisMuMuSpectra* AliAnalysisMuMu::RABy(const char* type, const char* dire
     {
       j = n-i;
     }
-    
+
     r = static_cast<AliAnalysisMuMuJpsiResult*>(finalResults.At(j));
 
     bin = static_cast<AliAnalysisMuMuBinning::Range*>(finalBins.At(j));
-    
+
     spectra->AdoptResult(*bin,r);
   }
-  
+
 
   delete corrSpectra;
-  
+
   return spectra;
 }
 
@@ -5674,9 +6152,9 @@ void AliAnalysisMuMu::SetConfig(const AliAnalysisMuMuConfig& config)
 Bool_t AliAnalysisMuMu::SetParticleNameFromFileName(const char* filename)
 {
   /// Try to get the simulated particle name from the filename
-  
+
   TString sFilename(filename);
-  
+
   if ( sFilename.Contains("JPSI",TString::kIgnoreCase) )
   {
     SetParticleName("JPsi");
@@ -5697,11 +6175,11 @@ Bool_t AliAnalysisMuMu::SetParticleNameFromFileName(const char* filename)
 void AliAnalysisMuMu::GetFileNameAndDirectory(const char* filename)
 {
   /// Split the filename[:subdir] into a file name and a subdir
-  
+
   fFilename = gSystem->ExpandPathName(filename);
-  
+
   fDirectory = "";
-  
+
   if ( fFilename.CountChar(':') )
   {
     fDirectory = filename;
@@ -5710,5 +6188,3 @@ void AliAnalysisMuMu::GetFileNameAndDirectory(const char* filename)
     fDirectory = fDirectory(colon+1,strlen(filename)-colon);
   }
 }
-
-
diff --git a/PWG/muondep/AliAnalysisMuMu.h b/PWG/muondep/AliAnalysisMuMu.h
index 7e85570..c752e7f 100644
--- a/PWG/muondep/AliAnalysisMuMu.h
+++ b/PWG/muondep/AliAnalysisMuMu.h
@@ -7,12 +7,13 @@
 // $Id$
 
 ///
-/// AliAnalysisMuMu : helper class to digest/plot/massage results from
+/// AliAnalysisMuMu : Facade class of all subclass called to digest/plot/massage results from
 /// AliAnalysisTaskMuMu
 ///
 /// author : Laurent Aphecetche (Subatech) and Javier Martin Blanco
 
 #include "AliAnalysisMuMuBinning.h"
+#include "AliAnalysisMuMuFnorm.h"
 #include "TNamed.h"
 #include <map>
 #include <set>
@@ -41,231 +42,367 @@ class AliAnalysisMuMu : public TObject, public TQObject
 
 public:
 
-  AliAnalysisMuMu(const char* filename, AliAnalysisMuMuConfig& config);
-
-  AliAnalysisMuMu(const char* filename,
-                  const char* associatedSimFileName="",
-                  const char* associatedSimFileName2="",
-                  const char* configurationFile="");
-  
-  virtual ~AliAnalysisMuMu();
-  
-  /* Basic checks */
-  void BasicCounts(Bool_t detailTrigger=kFALSE,
-                   ULong64_t* totalNmb=0x0,
-                   ULong64_t* totalNmsl=0x0,
-                   ULong64_t* totalNmul=0x0);
-  
-  void TriggerCountCoverage(const char* triggerList, Bool_t compact=kTRUE,
-                            Bool_t orderByTriggerCount=kTRUE);
-  
-  void SelectRunByTrigger(const char* triggerList);
-  
-  AliAnalysisMuMuSpectra* FitParticle(const char* particle,
-                                      const char* trigger,
-                                      const char* eventType,
-                                      const char* pairCut,
-                                      const char* centrality,
-                                      const AliAnalysisMuMuBinning& binning,
-                                      const char* spectraType="minv",
-                                      Bool_t corrected=kFALSE);
-
-  AliAnalysisMuMuSpectra* CorrectSpectra(const char* type, const char* flavour="");
-  
-  TH2* ComputeSPDCorrection(const char* type="oneOverAccEff", const char* eventSel="PSALL", const char* triggerSel="ANY", Bool_t bkgReject=kTRUE);
-  
-  void ComputeFnorm();
-  
-  TH1* ComputeDiffFnormFromHistos(const char* what="psi",const char* quantity="ntrcorr",const char* flavour="JAVI",Bool_t printout=kFALSE);
-  
-  void ComputeDiffFnormFromInt(const char* triggerCluster="MUON", const char* eventSelection="PSALL", AliMergeableCollection* mc=0x0, const char* what="psi",const char* quantity="ntrcorr",const char* flavour="JAVI",Bool_t printout=kTRUE);
-  
-  void ComputeDiffFnormFromCounters(const char* filePileUpCorr="", const char* what="psi", const char* quantity="ntrcorr",
-                                    const char* flavour="D2H",const char* triggerCluster="MUON",
-                                    const char* eventSelectionFNorm="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                                    const char* eventSelectionYield="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00", Bool_t printout=kTRUE);
-
-  void ComputeDiffFnormFromGlobal(const char* what="psi",const char* quantity="ntrcorr",const char* flavour="D2H",const char* triggerCluster="MUON",
-                                  const char* eventSelectionFnorm="PSALL",
-                                  const char* eventSelectionYield="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00", Bool_t printout=kTRUE);
-  
-  void ComputeMeanFnorm(const char* triggerCluster="MUON", const char* eventSelection="PSALL", const char* what="psi",const char* quantity="ntrcorr",
-                        const char* flavour="D2H");
-
-  void ComputeIntFnormFromCounters(const char* filePileUpCorr="", const char* triggerCluster="MUON", const char* eventSelectionFNorm="PSALL",
-                                   const char* eventSelectionYield="PSALL", Bool_t printout=kTRUE);
-
-  void PlotYiedWSyst(const char* triggerCluster="MUON");
-
-  void ComputeRelativeValueAndSESystematics(const char* quantity,const char* flavour,const char* value2Test, const char* binListToExclude,
-                                            const char* fNormType="mean", const char* evSelInt="PSALL",
-                                            const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                                            const char* triggerCluster="MUON");
-
-  void ComputeJpsiYield( Bool_t relative=kTRUE, const char* fNormType="mean", const char* evSelInt="PSALL",
-                        const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                        const char* triggerCluster="MUON", const char* whatever="PSI-NTRCORR-AccEffCorr", const char* sResName="");
-
-  void ComputeJpsiMPt(Bool_t relative=kTRUE, const char* evSelInt="PSALL", const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00"
-                      ,const char* spectra="PSI-NTRCORR-AccEffCorr-MeanPtVsMinvUS",const char* sResName="");
-
-  void ComputeMBXSectionFractionInBins(const char* filePileUpCorr="", const char* eventSelection="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
-                                       const char* what="psi",const char* quantity="ntrcorr", const char* flavour="D2H");
-
-  TH1* ComputeEquNofMB(const char* what="psi",const char* quantity="dnchdeta",const char* flavour="JAVI",Bool_t printout=kFALSE);
-
-  Double_t ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d);
-
-  void TwikiOutputFnorm(const char* series="FnormOffline2PUPS,FnormScalersPUPS,FnormBest2,RelDifFnormScalersPUPSvsFnormOffline2PUPS,FnormScalersPUVDM,RelDifFnormScalersPUPSvsFnormScalersPUVDM") const;
-
-  AliAnalysisMuMuSpectra* ComputeYield(const char* type, const char* flavour="");
-
-  void CleanAllSpectra();
-  
-  ///------
-  
-//  static AliAnalysisMuMuSpectra* ComputeYield(const char* realFile="ds.list.saf.root",
-//                                              const char* simFile="ds.sim.list.saf.root",
-//                                              const  char* type="PSI-Y VS PT");
-
-   AliAnalysisMuMuSpectra* RABy(const char* type="", const char* direction="pPb");
-
-  ///-------
-  
-  TGraph* PlotEventSelectionEvolution(const char* trigger1="CINT7-B-NOPF-MUON", const char* event1="PSALL",
-                                   const char* trigger2="CINT7-B-NOPF-MUON", const char* event2="PSALL",
-                                      Bool_t drawFills=kFALSE,
-                                      Bool_t asRejection=kTRUE) const;
-
-  Bool_t Upgrade();
-  
-   Bool_t Upgrade(const char* filename);
-  
-   TObjArray* CompareJpsiPerCMUUWithBackground(const char* jpsiresults="results.root",
-                                                     const char* backgroundresults="background.lhc11d.root");
-  
-   TGraph* CompareJpsiPerCMUUWithSimu(const char* realjpsiresults="results.root",
-                                      const char* simjpsiresults="results.sim.root");
-  
-  
-  static TFile* FileOpen(const char* file);
-  
-  static TString ExpandPathName(const char* file);
-  
-  
-  Bool_t GetCollections(const char* rootfile, const char* subdir,
-                        AliMergeableCollection*& oc,
-                        AliCounterCollection*& cc,
-                        AliAnalysisMuMuBinning*& bin,
-                        std::set<int>& runnumbers);
-  
-  AliAnalysisMuMuSpectra* GetSpectra(const char* what, const char* flavour="") const;
-  
-  TH1* PlotAccEfficiency(const char* whatever="PSI-INTEGRATED");
-  
-  TH1* PlotJpsiYield(const char* whatever="PSI-DNCHDETA-AccEffCorr");
-  
-  UInt_t GetSum(AliCounterCollection& cc, const char* triggerList, const char* eventSelection, Int_t runNumber=-1);
-  
-  ULong64_t GetTriggerScalerCount(const char* triggerList, Int_t runNumber);
-  
-  Int_t Jpsi(const char* what="integrated", const char* binningFlavour="", Bool_t fitmPt=kTRUE, Bool_t onlyCorrected=kTRUE);
-  
-  Bool_t IsSimulation() const;
-  
-  AliMergeableCollection* OC() const { return fMergeableCollection; }
-  AliCounterCollection* CC() const { return fCounterCollection; }
-  AliAnalysisMuMuBinning* BIN() const { return fBinning; }
-
-  void Print(Option_t* opt="") const;
-  
-  const std::set<int>& RunNumbers() const { return fRunNumbers; }
-  
-  void DrawMinv(const char* type,
-                const char* particle,
-                const char* trigger,
-                const char* eventType,
-                const char* pairCut,
-                const char* centrality,
-                const char* subresultname="",
-                const char* flavour="") const;
-
-  void DrawMinv(const char* type="PT", const char* particle="PSI", const char* flavour="", const char* subresultname="") const;
-  
-  Bool_t SetCorrectionPerRun(const TGraph& corr, const char* formula="");
-  
-  void UnsetCorrectionPerRun();
-  
-  void ExecuteCanvasEvent(Int_t event, Int_t px, Int_t py, TObject *sel);
-
-  std::vector<Double_t> GetMCCB2Tails(const AliAnalysisMuMuBinning::Range& bin) const;
-  
-  AliAnalysisMuMu* SIM() const { return fAssociatedSimulation; }
-  
-  AliAnalysisMuMu* SIM2() const { return fAssociatedSimulation2; }
-  
-  AliAnalysisMuMuSpectra* SPECTRA(const char* fullpath) const;
-  
-  void SetParticleName(const char* particleName) { fParticleName = particleName; }
-  
-  const char* GetParticleName() { return fParticleName; }
-  
-  void Update();
-
-  AliAnalysisMuMuConfig* Config();
-
-  AliAnalysisMuMuConfig* Config() const { return fConfig; }
-  
-  void SetConfig(const AliAnalysisMuMuConfig& config);
-
-  void SetCentralitySelectionList(const char* centralitySelectionList);
-  
-private:
-  AliAnalysisMuMu(const AliAnalysisMuMu& rhs); // not implemented on purpose
-  AliAnalysisMuMu& operator=(const AliAnalysisMuMu& rhs); // not implemented on purpose
+    AliAnalysisMuMu(const char* filename, AliAnalysisMuMuConfig& config);
+
+    AliAnalysisMuMu(
+      const char* filename="",
+      const char* associatedSimFileName="",
+      const char* associatedSimFileName2="",
+      const char* configurationFile="");
+
+    virtual ~AliAnalysisMuMu();
+
+    /* Basic checks */
+    void BasicCounts(
+      Bool_t detailTrigger=kFALSE,
+      ULong64_t* totalNmb=0x0,
+      ULong64_t* totalNmsl=0x0,
+      ULong64_t* totalNmul=0x0);
+
+    void TriggerCountCoverage(
+      const char* triggerList, 
+      Bool_t compact=kTRUE,
+      Bool_t orderByTriggerCount=kTRUE);
+
+    void SelectRunByTrigger(const char* triggerList);
+
+    AliAnalysisMuMuSpectra* FitParticle(
+      const char* particle,
+      const char* trigger,
+      const char* eventType,
+      const char* pairCut,
+      const char* centrality,
+      const AliAnalysisMuMuBinning& binning,
+      const char* spectraType="minv",
+      Bool_t corrected=kFALSE);
+
+    AliAnalysisMuMuSpectra* CorrectSpectra(
+      const char* type, 
+      const char* flavour="",
+      const char* accEffSubResultName="");
+
+    void PrintDistribution(
+      const char              * binType="Y",
+      const char              * what="NofJPsi",
+      const char              * sResName="",
+      const char              * ColSys="PbPb",
+      Bool_t divideByBinWidth =kTRUE,
+      Bool_t AccEffCorr       =kFALSE);
+
+    void PrintFitParam(
+      const char* particle ="PSI",
+      const char* param = "mJPsi",
+      const char* binType="PT",
+      const char* subresult="CB2VWG_2.4_4.5_SP1.2",
+      const char* printDirectoryPath="",
+      Bool_t AccEffCorr =kFALSE
+      )const;
+
+    void ComputeDimuonRawCount(
+      const Double_t rlow   = 2.8,
+      const Double_t rhight = 3.4,
+      const char            * binType="pt",
+      const char            * binRangeExluded="PT_BENJ_00.00_00.30,PT_BENJ_01.00_08.00,PT_BENJ_00.30_01.00",
+      const char            * flavour="BENJ",
+      Bool_t corrected      =kFALSE );
+
+    void ComputePPCrossSection(
+      const char        * binType="PT",
+      const char        * particle ="PSI",
+      const char        * what ="CorrNofJPsi",
+      Bool_t AccEffCorr =kFALSE);
+
+    TH2* ComputeSPDCorrection(
+      const char       * type="oneOverAccEff", 
+      const char       * eventSel="PSALL", 
+      const char       * triggerSel="ANY", 
+      Bool_t bkgReject =kTRUE);
+
+    void ComputeFnorm();
+
+    void ComputeNumberOfEvent();
+
+    void ComputeDiffFnormFromCounters(
+      const char      * filePileUpCorr="", 
+      const char      * what ="psi",
+      const char      * quantity="pt", 
+      const char      * flavour="BENJ", 
+      Bool_t printout =kTRUE);
+
+    void ComputeDiffFnormFromGlobal(
+      const char* what="psi",
+      const char* quantity="ntrcorr",
+      const char* flavour="D2H",
+      const char* triggerCluster="MUON",
+      const char* eventSelectionFnorm="PSALL",
+      const char* eventSelectionYield="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00", 
+      Bool_t printout=kTRUE);
+
+    void ComputeMeanFnorm(
+      const char* triggerCluster="MUON", 
+      const char* eventSelection="PSALL", 
+      const char* what="psi",
+      const char* quantity="ntrcorr",
+      const char* flavour="D2H");
+
+    void ComputeFnormWeightedMeanGraphs(
+      AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, 
+      const char          * patternOrList= "", 
+      const char          * graphName= "");
+
+    void ComputeFnormScalers(
+      AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, 
+      Bool_t PileUpCorr   =kFALSE);
+
+    void ComputeIntFnormFromCounters(
+      AliAnalysisMuMuFnorm::ETriggerType refTrigger = AliAnalysisMuMuFnorm::kMUL, 
+      Bool_t PileUpCorr =kFALSE);
+
+    void PlotYiedWSyst(const char* triggerCluster="MUON");
+
+    void ComputeRelativeValueAndSESystematics(
+      const char* quantity,const char* flavour,const char* value2Test, 
+      const char* binListToExclude,
+      const char* fNormType="mean", 
+      const char* evSelInt="PSALL",
+      const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
+      const char* triggerCluster="MUON");
+
+    void ComputeJpsiYield(
+      const char        * binType="INTEGRATED",
+      const char        * what="NofJPsi",
+      const char        * externfile1="externFile_PT.txt",
+      const char        * externfile2="externFile_CENT.txt",
+      const char        * sResName="",
+      const char        * beamYear="",
+      Bool_t AccEffCorr =kFALSE);
+
+    void ComputeJpsiMPt(
+      Bool_t relative=kTRUE, 
+      const char* evSelInt="PSALL", 
+      const char* evSelDiff="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
+      const char* spectra="PSI-NTRCORR-AccEffCorr-MeanPtVsMinvUS",
+      const char* sResName="");
+
+    void ComputeMBXSectionFractionInBins(
+      const char* filePileUpCorr="", 
+      const char* eventSelection="PSALLHASSPDSPDZQA_RES0.25_ZDIF0.50SPDABSZLT10.00",
+      const char* what="psi",
+      const char* quantity="ntrcorr", 
+      const char* flavour="D2H");
+
+    TH1* ComputeEquNofMB(
+      const char* what="psi",
+      const char* quantity="dnchdeta",
+      const char* flavour="JAVI",
+      Bool_t printout=kFALSE);
+
+    Double_t ErrorPropagationAxBoverCxD(Double_t a,Double_t b,Double_t c,Double_t d);
+
+    void TwikiOutputFnorm(const char* series="FnormOffline2PUPS,FnormScalersPUPS,FnormBest2,RelDifFnormScalersPUPSvsFnormOffline2PUPS,FnormScalersPUVDM,RelDifFnormScalersPUPSvsFnormScalersPUVDM") const;
+
+    AliAnalysisMuMuSpectra* ComputeYield(const char* type, const char* flavour="",const char* accEffSubResultName="PSICB2");
+
+    void CleanAllSpectra();
+
+    void CleanFNorm();
+
+    ///------
+    ///
+    void RAAasGraphic(
+      const char        * particle="PSI",
+      const char        * binType="PT",
+      const char        * externfile1="externFile_PT.txt",
+      const char        * externfile2="externFile_CENT.txt",
+      const char        * RefCent ="V0M_00.00_90.00",
+      Bool_t AccEffCorr =kFALSE)const;
+
+    void DrawFitResults(
+      const char        * particle="PSI",
+      const char        * binType="INTEGRATED",
+      const char        * subresults="",
+      Bool_t AccEffCorr =kFALSE)const;
+
+    void PrintNofParticle(
+      const char        * particle="PSI",
+      const char        * what="NofJPsi",
+      const char        * binType="PT",
+      Bool_t AccEffCorr =kFALSE) const;
+
+    //  static AliAnalysisMuMuSpectra* ComputeYield(const char* realFile="ds.list.saf.root",
+    //                                              const char* simFile="ds.sim.list.saf.root",
+    //                                              const  char* type="PSI-Y VS PT");
+
+    AliAnalysisMuMuSpectra* RABy(const char* type="", const char* direction="pPb");
+
+    ///-------
+
+    TGraph* PlotEventSelectionEvolution(
+    const char         * trigger1="CINT7-B-NOPF-MUON", 
+    const char         * event1="PSALL",
+    const char         * trigger2="CINT7-B-NOPF-MUON", 
+    const char         * event2="PSALL",
+    Bool_t drawFills   =kFALSE,
+    Bool_t asRejection =kTRUE) const;
+
+    Bool_t Upgrade();
+
+    Bool_t Upgrade(const char* filename);
+
+    TObjArray* CompareJpsiPerCMUUWithBackground(
+      const char* jpsiresults="results.root",
+      const char* backgroundresults="background.lhc11d.root");
+
+    TGraph* CompareJpsiPerCMUUWithSimu(
+      const char* realjpsiresults="results.root",
+      const char* simjpsiresults="results.sim.root");
+
+
+    static TFile* FileOpen(const char* file);
+
+    static TString ExpandPathName(const char* file);
+    
+    Bool_t GetCollections(
+      const char            * rootfile, 
+      const char            * subdir,
+      AliMergeableCollection*& oc,
+      AliCounterCollection  *& cc,
+      AliAnalysisMuMuBinning*& bin,
+      std                   ::set<int>& runnumbers);
+
+    AliAnalysisMuMuSpectra* GetSpectra(
+      const char* what, 
+      const char* flavour="") const;
+
+    AliAnalysisMuMuSpectra* GetMCSpectra(
+      const char* what ,
+      const char* EventSelection ="ALL" ,  
+      const char* DimuonTrigger="ANY", 
+      const char* Centrality="V0A", 
+      const char* PairSelectionKey="pALLPAIRYPAIRPTIN0.0-12.0RABSMATCHLOWETAPDCA", 
+      const char* flavour="BENJ") const;
+
+    TH1* PlotAccEfficiency(const char* whatever="PSI-INTEGRATED");
+
+    TH1* PlotJpsiYield(const char* whatever="PSI-DNCHDETA-AccEffCorr");
+
+    UInt_t GetSum(
+      AliCounterCollection& cc, 
+      const char* triggerList, 
+      const char* eventSelection, 
+      Int_t runNumber=-1);
+
+    ULong64_t GetTriggerScalerCount(const char* triggerList, Int_t runNumber);
+
+    Int_t Jpsi(
+      const char           * what="integrated", 
+      const char           * binningFlavour="", 
+      Bool_t fitmPt        =kTRUE, 
+      Bool_t onlyCorrected =kTRUE);
+
+    Bool_t IsSimulation() const;
+
+    AliMergeableCollection* OC() const { return fMergeableCollection; }
+    AliCounterCollection  * CC() const { return fCounterCollection; }
+    AliAnalysisMuMuBinning* BIN() const { return fBinning; }
+
+    void Print(Option_t* opt="") const;
+
+    const std::set<int>& RunNumbers() const { return fRunNumbers; }
+
+    void DrawMinv(
+      const char* type,
+      const char* particle,
+      const char* trigger,
+      const char* eventType,
+      const char* pairCut,
+      const char* centrality,
+      const char* subresultname="",
+      const char* flavour="") const;
+
+    void DrawMinv(
+      const char* type="PT", 
+      const char* particle="PSI", 
+      const char* flavour="", 
+      const char* subresultname="") const;
+
+    Bool_t SetCorrectionPerRun(const TGraph& corr, const char* formula="");
+
+    void UnsetCorrectionPerRun();
+
+    void ExecuteCanvasEvent(Int_t event, Int_t px, Int_t py, TObject *sel);
 
-  Bool_t SetParticleNameFromFileName(const char* filename);
+    std::vector<Double_t> GetMCCB2Tails(const AliAnalysisMuMuBinning::Range& bin) const;
 
-  void ShowList(const char* title, const TString& list, const char separator=',') const;
+    AliAnalysisMuMu* SIM() const { return fAssociatedSimulation; }
 
-  TFile* ReOpen(const char* filename, const char* mode) const;
+    AliAnalysisMuMu* SIM2() const { return fAssociatedSimulation2; }
 
-  void GetParametersFromMC(TString& fitType, const char* pathCentrPairCut, const char* spectraName, AliAnalysisMuMuBinning::Range* bin) const;
-  void GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const;
+    AliAnalysisMuMuSpectra* SPECTRA(const char* fullpath) const;
 
-  void GetCollectionsFromAnySubdir(TDirectory& dir,
-                                   AliMergeableCollection*& oc,
-                                   AliCounterCollection*& cc,
-                                   AliAnalysisMuMuBinning*& bin);
+    void SetParticleName(const char* particleName) { fParticleName = particleName; }
 
-  void GetFileNameAndDirectory(const char* filename);
+    const char* GetParticleName() { return fParticleName; }
 
+    void Update();
+
+    // AliAnalysisMuMuConfig* Config();
+
+    AliAnalysisMuMuConfig* Config() const { return fConfig; }
+
+    void SetConfig(const AliAnalysisMuMuConfig& config);
+
+    void SetCentralitySelectionList(const char* centralitySelectionList);
+
+private:
+    AliAnalysisMuMu(const AliAnalysisMuMu& rhs); // not implemented on purpose
+    AliAnalysisMuMu& operator=(const AliAnalysisMuMu& rhs); // not implemented on purpose
+
+    Bool_t SetParticleNameFromFileName(const char* filename);
+
+    void ShowList(const char* title, const TString& list, const char separator=',') const;
+
+    TFile* ReOpen(const char* filename, const char* mode) const;
+
+    TString First(const TString& list) const;
+
+    void GetParametersFromMC(TString& fitType, const char* pathCentrPairCut, const char* spectraName, AliAnalysisMuMuBinning::Range* bin) const;
+    void GetParametersFromResult(TString& fitType, AliAnalysisMuMuJpsiResult* minvResult) const;
+
+    
+    void GetCollectionsFromAnySubdir(TDirectory& dir,
+                                    AliMergeableCollection*& oc,
+                                     AliCounterCollection*& cc,
+                                     AliAnalysisMuMuBinning*& bin);
+    
+    void GetFileNameAndDirectory(const char* filename);
+    
 private:
 
-  void SetNofInputParticles(AliAnalysisMuMuJpsiResult& r);
-
-  
-  TString fFilename; // file containing the result collections (of objects and counters) from AliAnalysisTaskMuMu
-  TString fDirectory; // directory, within fFilename, containing the actual objects
-  
-  AliCounterCollection* fCounterCollection; // collection of counters in file
-
-  AliAnalysisMuMuBinning* fBinning; // binning
-  
-  AliMergeableCollection* fMergeableCollection; // collection of objects in file
-
-  std::set<int> fRunNumbers; // run numbers
-  
-  TGraph* fCorrectionPerRun; // correction factor per run
-  
-  AliAnalysisMuMu* fAssociatedSimulation; // associated simulations (if any)
-  AliAnalysisMuMu* fAssociatedSimulation2; // second associated simulations (if any)
-  
-  TString fParticleName; // Name of the simulated particle in the associated simulations
-
-  AliAnalysisMuMuConfig* fConfig; // configuration
-  
-  ClassDef(AliAnalysisMuMu,13) // class to analysis results from AliAnalysisTaskMuMuXXX tasks
+    void SetNofInputParticles(AliAnalysisMuMuJpsiResult& r);
+
+
+    TString fFilename; // file containing the result collections (of objects and counters) from AliAnalysisTaskMuMu
+    TString fDirectory; // directory, within fFilename, containing the actual objects
+
+    AliCounterCollection* fCounterCollection; // collection of counters in file
+
+    AliAnalysisMuMuBinning* fBinning; // binning
+
+    AliMergeableCollection* fMergeableCollection; // collection of objects in file
+
+    std::set<int> fRunNumbers; // run numbers
+
+    TGraph* fCorrectionPerRun; // correction factor per run
+
+    AliAnalysisMuMu* fAssociatedSimulation; // associated simulations (if any)
+    AliAnalysisMuMu* fAssociatedSimulation2; // second associated simulations (if any)
+
+    TString fParticleName; // Name of the simulated particle in the associated simulations
+
+    AliAnalysisMuMuConfig* fConfig; // configuration
+
+    ClassDef(AliAnalysisMuMu,12) // class to analysis results from AliAnalysisTaskMuMuXXX tasks
 };
 
 #endif
diff --git a/PWG/muondep/AliAnalysisMuMuConfig.cxx b/PWG/muondep/AliAnalysisMuMuConfig.cxx
index 739038b..c31d9da 100644
--- a/PWG/muondep/AliAnalysisMuMuConfig.cxx
+++ b/PWG/muondep/AliAnalysisMuMuConfig.cxx
@@ -45,8 +45,8 @@ ClassImp(AliAnalysisMuMuConfig)
 
 namespace {
 
-  Bool_t GetKeyValue(const TString& str, const char separator, TString& key, TString& value)
-  {
+    Bool_t GetKeyValue(const TString& str, const char separator, TString& key, TString& value)
+    {
     /// Get a key value pair, separated by separator character
     key=value="";
     if ( !str.CountChar(separator) ) return kFALSE;
@@ -55,10 +55,10 @@ namespace {
     key.Remove(TString::kBoth,' ');
     value = str(index+1,str.Length()-index-1);
     return kTRUE;
-  }
-  
-  void DecodeRunRanges(const TString& runranges, std::set<int>& runs)
-  {
+    }
+
+    void DecodeRunRanges(const TString& runranges, std::set<int>& runs)
+    {
     /// From a string of form A-D,F,H,W-Y,Z return a set containing
     /// A,B,C,D,F,H,W,X,Y,Z
     TObjArray* ranges = runranges.Tokenize(",");
@@ -66,50 +66,50 @@ namespace {
     TIter next(ranges);
     
     while ( ( s = static_cast<TObjString*>(next())))
-    {
-      int first = s->String().Atoi();
-      int last = first;
-      
-      if ( s->String().Contains("-") )
-      {
-        TString sfirst,slast;
-        GetKeyValue(s->String(),'-',sfirst,slast);
-        last = slast.Atoi();
-        assert(first==sfirst.Atoi());
-      }
-      for (int i = first; i <= last; ++i )
-      {
-        runs.insert(i);
-      }
-    }
+        {
+        int first = s->String().Atoi();
+        int last = first;
+
+        if ( s->String().Contains("-") )
+            {
+            TString sfirst,slast;
+            GetKeyValue(s->String(),'-',sfirst,slast);
+            last = slast.Atoi();
+            assert(first==sfirst.Atoi());
+            }
+        for (int i = first; i <= last; ++i )
+            {
+            runs.insert(i);
+            }
+        }
     delete ranges;
-  }
-  
-  void PrintRunInfo(const std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string>& map)
-  {
-    if ( map.count(AliAnalysisMuMuConfig::kMBTriggerClassName) )
-    {
-      std::cout << "MB=" << map.find(AliAnalysisMuMuConfig::kMBTriggerClassName)->second << " ";
     }
-    if ( map.count(AliAnalysisMuMuConfig::kMULTriggerClassName) )
+
+    void PrintRunInfo(const std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string>& map)
     {
-      std::cout << "MUL=" << map.find(AliAnalysisMuMuConfig::kMULTriggerClassName)->second << " ";
-    }
+    if ( map.count(AliAnalysisMuMuConfig::kMBTriggerClassName) )
+        {
+        std::cout << "MB=" << map.find(AliAnalysisMuMuConfig::kMBTriggerClassName)->second << " ";
+        }
+    if ( map.count(AliAnalysisMuMuConfig::kMULTriggerClassName) )
+        {
+        std::cout << "MUL=" << map.find(AliAnalysisMuMuConfig::kMULTriggerClassName)->second << " ";
+        }
     if ( map.count(AliAnalysisMuMuConfig::kMSLTriggerClassName) )
-    {
-      std::cout << "MSL=" << map.find(AliAnalysisMuMuConfig::kMSLTriggerClassName)->second << " ";
-    }
+        {
+        std::cout << "MSL=" << map.find(AliAnalysisMuMuConfig::kMSLTriggerClassName)->second << " ";
+        }
     if ( map.count(AliAnalysisMuMuConfig::kMSHTriggerClassName) )
-    {
-      std::cout << "MSH=" << map.find(AliAnalysisMuMuConfig::kMSHTriggerClassName)->second << " ";
-    }
+        {
+        std::cout << "MSH=" << map.find(AliAnalysisMuMuConfig::kMSHTriggerClassName)->second << " ";
+        }
     if ( map.count(AliAnalysisMuMuConfig::kCentralityName) )
-    {
-      std::cout << "CENT=" << map.find(AliAnalysisMuMuConfig::kCentralityName)->second << " ";
-    }
+        {
+        std::cout << "CENT=" << map.find(AliAnalysisMuMuConfig::kCentralityName)->second << " ";
+        }
     std::cout << std::endl;
-  }
-  
+    }
+
 }
 
 const char* AliAnalysisMuMuConfig::DimuonTriggerKey() const { return "DimuonTrigger"; }
@@ -129,547 +129,547 @@ fOCDBPath("raw://"),
 fIsCompactGraphs(kFALSE),
 fPerRunInfo()
 {
-  // ctor
+    // ctor
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuConfig::~AliAnalysisMuMuConfig()
 {
-  // dtor
-  delete fMap;
+    // dtor
+    delete fMap;
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuConfig::AliAnalysisMuMuConfig(const AliAnalysisMuMuConfig& other)
 {
-  if ( &other != this )
-  {
+    if ( &other != this )
+    {
     fOCDBPath = other.fOCDBPath;
     fIsCompactGraphs = other.fIsCompactGraphs;
     if (other.fMap)
-    {
-      fMap = static_cast<TMap*>(other.fMap->Clone());
-    }
+        {
+        fMap = static_cast<TMap*>(other.fMap->Clone());
+        }
     fPerRunInfo = other.fPerRunInfo;
-  }
+    }
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuConfig& AliAnalysisMuMuConfig::operator=(const AliAnalysisMuMuConfig& other)
 {
-  if ( &other != this )
-  {
+    if ( &other != this )
+    {
     fOCDBPath = other.fOCDBPath;
     fIsCompactGraphs = other.fIsCompactGraphs;
     delete fMap;
     fMap = 0x0;
     if (other.fMap)
-    {
-      fMap = static_cast<TMap*>(other.fMap->Clone());
-    }
+        {
+        fMap = static_cast<TMap*>(other.fMap->Clone());
+        }
     fPerRunInfo = other.fPerRunInfo;
-  }
-  return *this;
+    }
+    return *this;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::Add(const char* key, const TString& line)
 {
-  /// Add a configuration element, in the form :
-  /// key : line
-  /// where line is "actual_value [sim] [real]
-  
-  UInt_t dataType(0);
-  
-  if ( !line.Contains("SIM",TString::kIgnoreCase) &&
-      !line.Contains("REAL",TString::kIgnoreCase) )
-  {
+    /// Add a configuration element, in the form :
+    /// key : line
+    /// where line is "actual_value [sim] [real]
+
+    UInt_t dataType(0);
+
+    if ( !line.Contains("SIM",TString::kIgnoreCase) &&
+        !line.Contains("REAL",TString::kIgnoreCase) )
+    {
     // no REAL or SIM keyword = REAL
     dataType |= kReal;
-  }
-  else if ( line.Contains("SIM",TString::kIgnoreCase) )
-  {
+    }
+    else if ( line.Contains("SIM",TString::kIgnoreCase) )
+    {
     dataType |= kSim;
     if ( line.Contains("REAL",TString::kIgnoreCase) )
-    {
-      dataType |= kReal;
+        {
+        dataType |= kReal;
+        }
     }
-  }
-  else if ( line.Contains("REAL",TString::kIgnoreCase) )
-  {
+    else if ( line.Contains("REAL",TString::kIgnoreCase) )
+    {
     dataType |= kReal;
-  }
-  
-  TObjArray* a = line.Tokenize(" ");
-  TString es = static_cast<TObjString*>(a->First())->String();
-  delete a;
-  
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  if (!list)
-  {
+    }
+
+    TObjArray* a = line.Tokenize(" ");
+    TString es = static_cast<TObjString*>(a->First())->String();
+    delete a;
+
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+    if (!list)
+    {
     list = new THashList;
     list->SetOwner(kTRUE);
     Map()->Add(new TObjString(key),list);
     
-  }
-  
-  TObjString* s = static_cast<TObjString*>(list->FindObject(es));
-  if ( !s )
-  {
+    }
+
+    TObjString* s = static_cast<TObjString*>(list->FindObject(es));
+    if ( !s )
+    {
     s = new TObjString(es);
     s->SetUniqueID(dataType);
     list->Add(s);
-  }
-  else
-  {
+    }
+    else
+    {
     s->SetUniqueID(dataType);
     s->String() = es;
-  }
+    }
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::Clear(Option_t*)
 {
-  /// Clear the internal map
-  if (fMap) fMap->DeleteAll();
+    /// Clear the internal map
+    if (fMap) fMap->DeleteAll();
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::First(const char* key, Bool_t simulation) const
 {
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  TIter next(list);
-  TObjString* s;
-  
-  UInt_t test(kReal);
-  
-  if ( simulation )
-  {
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+    TIter next(list);
+    TObjString* s;
+
+    UInt_t test(kReal);
+
+    if ( simulation )
+    {
     test = kSim;
-  }
+    }
 
-  while ( ( s = static_cast<TObjString*>(next())) )
-  {
-    if ( s->GetUniqueID() & test )
+    while ( ( s = static_cast<TObjString*>(next())) )
     {
-      return s->String();
+    if ( s->GetUniqueID() & test )
+        {
+        return s->String();
+        }
     }
-  }
-  return "";
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMBTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMBTriggerClassName)->second;
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMULTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMULTriggerClassName)->second;
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMSLTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMSLTriggerClassName)->second;
-  }
-  return "";
- 
+    }
+    return "";
+
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetMSHTriggerClassName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kMSHTriggerClassName)->second;
-  }
-  return "";
-  
+    }
+    return "";
+
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetCentralityName(Int_t runNumber) const
 {
-  if ( fPerRunInfo.count(runNumber) )
-  {
+    if ( fPerRunInfo.count(runNumber) )
+    {
     return (fPerRunInfo.find(runNumber)->second).find(kCentralityName)->second;
-  }
-  return "";
-  
+    }
+    return "";
+
 }
 
 #if 0
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::GetDimuonPaths(TObjArray& paths, Bool_t simulation) const
 {
-  /// Fill the paths array with the paths /event/trigger/paircut/centrality
-  
-  paths.Clear();
-  
-  TObjArray* triggerArray = GetListElements(DimuonTriggerKey(),simulation);
-  TObjArray* eventTypeArray = GetListElements(EventSelectionKey(),simulation);
-  TObjArray* pairCutArray = GetListElements(PairSelectionKey(),simulation);
-  TObjArray* centralityArray = GetListElements(CentralitySelectionKey(),simulation);
-  
-  TIter nextTrigger(triggerArray);
-  TIter nextEventType(eventTypeArray);
-  TIter nextPairCut(pairCutArray);
-  TIter nextCentrality(centralityArray);
-  
-  TObjString* trigger;
-  TObjString* eventType;
-  TObjString* pairCut;
-  TObjString* centrality;
-  
-  while ( ( trigger = static_cast<TObjString*>(nextTrigger())) )
-  {
+    /// Fill the paths array with the paths /event/trigger/paircut/centrality
+
+    paths.Clear();
+
+    TObjArray* triggerArray = GetListElements(DimuonTriggerKey(),simulation);
+    TObjArray* eventTypeArray = GetListElements(EventSelectionKey(),simulation);
+    TObjArray* pairCutArray = GetListElements(PairSelectionKey(),simulation);
+    TObjArray* centralityArray = GetListElements(CentralitySelectionKey(),simulation);
+
+    TIter nextTrigger(triggerArray);
+    TIter nextEventType(eventTypeArray);
+    TIter nextPairCut(pairCutArray);
+    TIter nextCentrality(centralityArray);
+
+    TObjString* trigger;
+    TObjString* eventType;
+    TObjString* pairCut;
+    TObjString* centrality;
+
+    while ( ( trigger = static_cast<TObjString*>(nextTrigger())) )
+    {
     nextEventType.Reset();
     while ( ( eventType = static_cast<TObjString*>(nextEventType())) )
-    {
-      nextPairCut.Reset();
-      while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) )
-      {
-        nextCentrality.Reset();
-        while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) )
         {
-          paths.Add(new TObjString(Form("/%s/%s/%s/%s/",eventType->String().Data(),
-                                        trigger->String().Data(),
-                                        centrality->String().Data(),
-                                        pairCut->String().Data())));
+        nextPairCut.Reset();
+        while ( ( pairCut = static_cast<TObjString*>(nextPairCut())) )
+            {
+            nextCentrality.Reset();
+            while ( ( centrality = static_cast<TObjString*>(nextCentrality()) ) )
+                {
+                paths.Add(new TObjString(Form("/%s/%s/%s/%s/",eventType->String().Data(),
+                                              trigger->String().Data(),
+                                              centrality->String().Data(),
+                                              pairCut->String().Data())));
+                }
+            }
         }
-      }
-    }
-  }
-  
-  delete triggerArray;
-  delete eventTypeArray;
-  delete pairCutArray;
-  delete centralityArray;
+    }
+
+    delete triggerArray;
+    delete eventTypeArray;
+    delete pairCutArray;
+    delete centralityArray;
 }
 #endif
 
 //_____________________________________________________________________________
 TObjArray* AliAnalysisMuMuConfig::GetListElements(const char* key, Bool_t simulation) const
 {
-  /// Get list as an array (to be deleted by the user)
-  
-  TObjArray* a = new TObjArray;
-  a->SetOwner(kTRUE);
-  
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  
-  TIter next(list);
-  TObjString* s;
-  TString rv;
-  UInt_t test(kReal);
-  
-  if ( simulation )
-  {
+    /// Get list as an array (to be deleted by the user)
+
+    TObjArray* a = new TObjArray;
+    a->SetOwner(kTRUE);
+
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+
+    TIter next(list);
+    TObjString* s;
+    TString rv;
+    UInt_t test(kReal);
+
+    if ( simulation )
+    {
     test = kSim;
-  }
-  
-  while ( ( s = static_cast<TObjString*>(next()) ) )
-  {
-    if ( s->GetUniqueID() & test )
+    }
+
+    while ( ( s = static_cast<TObjString*>(next()) ) )
     {
-      a->Add(new TObjString(*s));
+    if ( s->GetUniqueID() & test )
+        {
+        a->Add(new TObjString(*s));
+        }
     }
-  }
-  return a;
+    return a;
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetTriggerClassName(ETriggerType tt, Int_t runNumber) const
 {
-  // get the triggerclass to for a given trigger type and run number
-  
-  if ( tt == kMB )
-  {
+    // get the triggerclass to for a given trigger type and run number
+
+    if ( tt == kMB )
+    {
     return GetMBTriggerClassName(runNumber);
-  }
-  else if ( tt == kMUL )
-  {
+    }
+    else if ( tt == kMUL )
+    {
     return GetMULTriggerClassName(runNumber);
-  }
-  else if ( tt == kMSL)
-  {
+    }
+    else if ( tt == kMSL)
+    {
     return GetMSLTriggerClassName(runNumber);
-  }
-  else if ( tt == kMSH)
-  {
+    }
+    else if ( tt == kMSH)
+    {
     return GetMSHTriggerClassName(runNumber);
-  }
-  else
-  {
+    }
+    else
+    {
     AliError(Form("Unknown trigger type %d ???",tt));
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 TString AliAnalysisMuMuConfig::GetTriggerTypeName(ETriggerType tt)
 {
-  // get the name of the trigger type
-  if ( tt == kMB )
-  {
+    // get the name of the trigger type
+    if ( tt == kMB )
+    {
     return "MB";
-  }
-  else if ( tt == kMUL )
-  {
+    }
+    else if ( tt == kMUL )
+    {
     return "MUL";
-  }
-  else if ( tt == kMSL)
-  {
+    }
+    else if ( tt == kMSL)
+    {
     return "MSL";
-  }
-  else if ( tt == kMSH)
-  {
+    }
+    else if ( tt == kMSH)
+    {
     return "MSH";
-  }
-  return "";
+    }
+    return "";
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMuConfig::Has(const char* key, const char* value, Bool_t simulation) const
 {
-  THashList* list = static_cast<THashList*>(Map()->GetValue(key));
-  TIter next(list);
-  TObjString* s;
-  
-  UInt_t test(kReal);
-  
-  if ( simulation )
-  {
+    THashList* list = static_cast<THashList*>(Map()->GetValue(key));
+    TIter next(list);
+    TObjString* s;
+
+    UInt_t test(kReal);
+
+    if ( simulation )
+    {
     test = kSim;
-  }
-  
-  while ( ( s = static_cast<TObjString*>(next())) )
-  {
-    if ( ( s->GetUniqueID() & test ) && ( s->String() == value ) )
+    }
+
+    while ( ( s = static_cast<TObjString*>(next())) )
     {
-      return kTRUE;
+    if ( ( s->GetUniqueID() & test ) && ( s->String() == value ) )
+        {
+        return kTRUE;
+        }
     }
-  }
-  return kFALSE;
+    return kFALSE;
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMuConfig::HasRunInformation(std::set<int>& runs, Bool_t show) const
 {
-  /// Return true if we have run information for all the runs in the set.
-  /// if show=true, show that information for all those runs
-  
-  std::set<int>::size_type n(0);
-  
-  std::set<int>::const_iterator it;
-  std::map<int,std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> >::const_iterator mit;
-
-  for ( it = runs.begin(); it != runs.end(); ++it )
-  {
+    /// Return true if we have run information for all the runs in the set.
+    /// if show=true, show that information for all those runs
+
+    std::set<int>::size_type n(0);
+
+    std::set<int>::const_iterator it;
+    std::map<int,std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> >::const_iterator mit;
+
+    for ( it = runs.begin(); it != runs.end(); ++it )
+    {
     int runNumber = *it;
     
     mit = fPerRunInfo.find(runNumber);
     
     if ( mit != fPerRunInfo.end() )
-    {
-      ++n;
-      if ( show )
-      {
-        std::cout << Form("RUN %09d ",runNumber);
-        PrintRunInfo(mit->second);
-      }
-    }
+        {
+        ++n;
+        if ( show )
+            {
+            std::cout << Form("RUN %09d ",runNumber);
+            PrintRunInfo(mit->second);
+            }
+        }
     else
-    {
-      if ( show )
-      {
-        std::cout << "Missing information for run " << runNumber << std::endl;
-      }
+        {
+        if ( show )
+            {
+            std::cout << "Missing information for run " << runNumber << std::endl;
+            }
+        }
     }
-  }
-  
-  return n == runs.size();
+
+    return n == runs.size();
 }
 
 //_____________________________________________________________________________
 TMap* AliAnalysisMuMuConfig::Map() const
 {
-  /// Return (and initialize, if needed) the internal map
-  if (!fMap)
-  {
+    /// Return (and initialize, if needed) the internal map
+    if (!fMap)
+    {
     fMap = new TMap;
     fMap->SetOwnerKeyValue(kTRUE,kTRUE);
-  }
-  return fMap;
+    }
+    return fMap;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::ShowList(const char* key, Bool_t simulation) const
 {
-  /// Show the list for a given key
-
-  TObjArray* a = GetListElements(key,simulation);
-  TObjString* s;
-  
-  TIter next(a);
-  
-  while ( ( s = static_cast<TObjString*>(next()) ) )
-  {
+    /// Show the list for a given key
+
+    TObjArray* a = GetListElements(key,simulation);
+    TObjString* s;
+
+    TIter next(a);
+
+    while ( ( s = static_cast<TObjString*>(next()) ) )
+    {
     std::cout << "    " << s->String() << std::endl;
-  }
-  
-  delete a;
+    }
+
+    delete a;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::Print(Option_t* opt) const
 {
-  /// printout
-  /// Use opt = "REAL" to show only things relevant to real data
-  /// Use opt = "SIM" to show only things relevant to simulation
-  /// Use opt = "REAL SIM" or "" to show everything
-  
-  std::cout << "OCDBPath : " << fOCDBPath << std::endl;
-  std::cout << "Use compact graphs : " << fIsCompactGraphs << std::endl;
-  TString sopt(opt);
-  sopt.ToUpper();
-  
-  if ( sopt == "RAW")
-  {
+    /// printout
+    /// Use opt = "REAL" to show only things relevant to real data
+    /// Use opt = "SIM" to show only things relevant to simulation
+    /// Use opt = "REAL SIM" or "" to show everything
+
+    std::cout << "OCDBPath : " << fOCDBPath << std::endl;
+    std::cout << "Use compact graphs : " << fIsCompactGraphs << std::endl;
+    TString sopt(opt);
+    sopt.ToUpper();
+
+    if ( sopt == "RAW")
+    {
     TIter nextKey(Map());
     TObjString* key;
 
     while ( ( key = static_cast<TObjString*>(nextKey()) ) )
-    {
-      THashList* list = static_cast<THashList*>(Map()->GetValue(key->String()));
-      TIter next(list);
-      TObjString* s;
-      while ( ( s = static_cast<TObjString*>(next())))
-      {
-        std::cout << Form("%s [%u]",s->String().Data(),s->GetUniqueID()) << std::endl;
-      }
-    }
+        {
+        THashList* list = static_cast<THashList*>(Map()->GetValue(key->String()));
+        TIter next(list);
+        TObjString* s;
+        while ( ( s = static_cast<TObjString*>(next())))
+            {
+            std::cout << Form("%s [%u]",s->String().Data(),s->GetUniqueID()) << std::endl;
+            }
+        }
     return;
-  }
+    }
     
-  if (sopt.Length()==0)
-  {
+    if (sopt.Length()==0)
+    {
     sopt = "REAL SIM";
-  }
-  
-  TIter next(Map());
-  TObjString* key;
-  
-  while ( ( key = static_cast<TObjString*>(next()) ) )
-  {
+    }
+
+    TIter next(Map());
+    TObjString* key;
+
+    while ( ( key = static_cast<TObjString*>(next()) ) )
+    {
     std::cout << key->String() << ":" << std::endl;
     
     if ( sopt.Contains("REAL",TString::kIgnoreCase) )
-    {
-      std::cout << "  Real:" << std::endl;
-      ShowList(key->String(),kFALSE);
-    }
+        {
+        std::cout << "  Real:" << std::endl;
+        ShowList(key->String(),kFALSE);
+        }
     if ( sopt.Contains("SIM",TString::kIgnoreCase) )
-    {
-      std::cout << "  Sim:" << std::endl;
-      ShowList(key->String(),kTRUE);
+        {
+        std::cout << "  Sim:" << std::endl;
+        ShowList(key->String(),kTRUE);
+        }
     }
-  }
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::SetRunInfo(const TString& runranges, const TString& runinfo)
 {
-  /// Associate the run info (specified in string runinfo) to each of the runs
-  /// defined by the string runranges
-  
-  std::set<int> runs;
-  
-  DecodeRunRanges(runranges,runs);
-  
-  std::set<int>::const_iterator it;
-  
-  std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> mapForOneRun;
-  
-  TObjArray* info = runinfo.Tokenize(" ");
-  TIter next(info);
-  TObjString*s ;
-  while ( ( s = static_cast<TObjString*>(next())))
-  {
+    /// Associate the run info (specified in string runinfo) to each of the runs
+    /// defined by the string runranges
+
+    std::set<int> runs;
+
+    DecodeRunRanges(runranges,runs);
+
+    std::set<int>::const_iterator it;
+
+    std::map<AliAnalysisMuMuConfig::EPerRunInfo,std::string> mapForOneRun;
+
+    TObjArray* info = runinfo.Tokenize(" ");
+    TIter next(info);
+    TObjString*s ;
+    while ( ( s = static_cast<TObjString*>(next())))
+    {
     TString key,value;
     GetKeyValue(s->String(),'=',key,value);
     if (!key.CompareTo("MB",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMBTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMBTriggerClassName]=value;
+        }
     if (!key.CompareTo("MUL",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMULTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMULTriggerClassName]=value;
+        }
     if (!key.CompareTo("MSL",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMSLTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMSLTriggerClassName]=value;
+        }
     if (!key.CompareTo("MSH",TString::kIgnoreCase))
-    {
-      mapForOneRun[kMSHTriggerClassName]=value;
-    }
+        {
+        mapForOneRun[kMSHTriggerClassName]=value;
+        }
     if (!key.CompareTo("CENT",TString::kIgnoreCase))
-    {
-      mapForOneRun[kCentralityName]=value;
+        {
+        mapForOneRun[kCentralityName]=value;
+        }
     }
-  }
-  
-  for ( it = runs.begin(); it != runs.end(); ++it )
-  {
+
+    for ( it = runs.begin(); it != runs.end(); ++it )
+    {
     int runNumber = *it;
     fPerRunInfo[runNumber] = mapForOneRun;
-  }
-  
-  delete info;
+    }
+
+    delete info;
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::ReadFromFile(const char* inputfile)
 {
-  /// Read configuration from external file.
-  
-  TString filename = gSystem->ExpandPathName(inputfile);
-  std::ifstream in(filename.Data());
-  if (in.bad())
-  {
+    /// Read configuration from external file.
+
+    TString filename = gSystem->ExpandPathName(inputfile);
+    std::ifstream in(filename.Data());
+    if (in.bad())
+    {
     AliError(Form("Cannot read input file %s",filename.Data()));
     return;
-  }
-  
-  std::string line;
-  
-  std::vector<TString> selectionKeys;
-  
-  selectionKeys.push_back(DimuonTriggerKey());
-  selectionKeys.push_back(MuonTriggerKey());
-  selectionKeys.push_back(MinbiasTriggerKey());
-  selectionKeys.push_back(EventSelectionKey());
-  selectionKeys.push_back(PairSelectionKey());
-  selectionKeys.push_back(CentralitySelectionKey());
-  selectionKeys.push_back(FitTypeKey());
-  
-  // read per run info
-  while (std::getline(in,line))
-  {
+    }
+
+    std::string line;
+
+    std::vector<TString> selectionKeys;
+
+    selectionKeys.push_back(DimuonTriggerKey());
+    selectionKeys.push_back(MuonTriggerKey());
+    selectionKeys.push_back(MinbiasTriggerKey());
+    selectionKeys.push_back(EventSelectionKey());
+    selectionKeys.push_back(PairSelectionKey());
+    selectionKeys.push_back(CentralitySelectionKey());
+    selectionKeys.push_back(FitTypeKey());
+
+    // read per run info
+    while (std::getline(in,line))
+    {
     TString sline(line.c_str());
     if ( sline.BeginsWith("#") ) continue;
     if ( sline.BeginsWith("//") ) continue;
@@ -680,73 +680,73 @@ void AliAnalysisMuMuConfig::ReadFromFile(const char* inputfile)
     if (!GetKeyValue(sline, ':',left,right)) continue;
     
     if ( left.Atoi() )
-    {
-      // we assume left is a run range, so we define runinfo
-      SetRunInfo(left,right);
-    }
+        {
+        // we assume left is a run range, so we define runinfo
+        SetRunInfo(left,right);
+        }
     else if ( !left.CompareTo(OCDBPathKey(),TString::kIgnoreCase) )
-    {
-      fOCDBPath = right;
-      fOCDBPath.Remove(TString::kBoth,' ');
-    }
+        {
+        fOCDBPath = right;
+        fOCDBPath.Remove(TString::kBoth,' ');
+        }
     else if ( !left.CompareTo(CompactGraphKey(),TString::kIgnoreCase) )
-    {
-      right.Remove(TString::kBoth,' ');
-      if ( !right.CompareTo("yes",TString::kIgnoreCase) ||
-          !right.CompareTo("on",TString::kIgnoreCase) ||
-          !right.CompareTo("1",TString::kIgnoreCase) )
-      {
-        fIsCompactGraphs = kTRUE;
-      }
-      else
-      {
-        fIsCompactGraphs = kFALSE;
-      }
-    }
+        {
+        right.Remove(TString::kBoth,' ');
+        if ( !right.CompareTo("yes",TString::kIgnoreCase) ||
+            !right.CompareTo("on",TString::kIgnoreCase) ||
+            !right.CompareTo("1",TString::kIgnoreCase) )
+            {
+            fIsCompactGraphs = kTRUE;
+            }
+        else
+            {
+            fIsCompactGraphs = kFALSE;
+            }
+        }
     else {
-      
-      Bool_t found(kFALSE);
-      
-      for ( std::vector<TString>::size_type i = 0; i < selectionKeys.size(); ++i )
-      {
-        if ( ! left.CompareTo(selectionKeys[i],TString::kIgnoreCase) )
+
+        Bool_t found(kFALSE);
+
+        for ( std::vector<TString>::size_type i = 0; i < selectionKeys.size(); ++i )
         {
-          Add(selectionKeys[i],right);
-          found = kTRUE;
+        if ( ! left.CompareTo(selectionKeys[i],TString::kIgnoreCase) )
+            {
+            Add(selectionKeys[i],right);
+            found = kTRUE;
+            }
         }
-      }
 
-      if (!found)
-      {
+        if (!found)
+        {
         std::cerr << "Unable to decode line : " << std::endl;
         std::cerr << line << std::endl;
-      }
+        }
+    }
     }
-  }
 }
 
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuConfig::SetColorScheme()
 {
-  /// Set a few custom colors
-  
-  new TColor(AliAnalysisMuMuConfig::kBlue,4/255.0,44/255.0,87/255.0,"my blue");
-  new TColor(AliAnalysisMuMuConfig::kOrange,255/255.0,83/255.0,8/255.0,"my orange");
-  new TColor(AliAnalysisMuMuConfig::kGreen,152/255.0,202/255.0,52/255.0,"my green");
-  
-  gStyle->SetGridColor(AliAnalysisMuMuConfig::kBlue);
-  
-  gStyle->SetFrameLineColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetAxisColor(AliAnalysisMuMuConfig::kBlue,"xyz");
-  gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue,"xyz");
-  
-  gStyle->SetTitleColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetTitleTextColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue);
-  gStyle->SetStatTextColor(AliAnalysisMuMuConfig::kBlue);
-  
-  gStyle->SetOptStat(0);
+    /// Set a few custom colors
+
+    new TColor(AliAnalysisMuMuConfig::kBlue,4/255.0,44/255.0,87/255.0,"my blue");
+    new TColor(AliAnalysisMuMuConfig::kOrange,255/255.0,83/255.0,8/255.0,"my orange");
+    new TColor(AliAnalysisMuMuConfig::kGreen,152/255.0,202/255.0,52/255.0,"my green");
+
+    gStyle->SetGridColor(AliAnalysisMuMuConfig::kBlue);
+
+    gStyle->SetFrameLineColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetAxisColor(AliAnalysisMuMuConfig::kBlue,"xyz");
+    gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue,"xyz");
+
+    gStyle->SetTitleColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetTitleTextColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetLabelColor(AliAnalysisMuMuConfig::kBlue);
+    gStyle->SetStatTextColor(AliAnalysisMuMuConfig::kBlue);
+
+    gStyle->SetOptStat(0);
 }
 
 
diff --git a/PWG/muondep/AliAnalysisMuMuConfig.h b/PWG/muondep/AliAnalysisMuMuConfig.h
index cc4da2b..d5512ab 100644
--- a/PWG/muondep/AliAnalysisMuMuConfig.h
+++ b/PWG/muondep/AliAnalysisMuMuConfig.h
@@ -130,6 +130,8 @@ public:
   
   TObjArray* GetListElements(const char* type, Bool_t simulation) const;
 
+  void DefineDefaultsFromFile(const char* configfile);
+
 private:
   
   enum EDataType { kSim = 1<<0, kReal = 1<<1 };
diff --git a/PWG/muondep/AliAnalysisMuMuFnorm.cxx b/PWG/muondep/AliAnalysisMuMuFnorm.cxx
index 59f44d8..09eeb32 100644
--- a/PWG/muondep/AliAnalysisMuMuFnorm.cxx
+++ b/PWG/muondep/AliAnalysisMuMuFnorm.cxx
@@ -35,11 +35,13 @@
 #include "AliCounterCollection.h"
 #include "AliLog.h"
 #include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuConfig.h"
 #include "Riostream.h"
 #include "TAxis.h"
 #include "TCanvas.h"
 #include "TGraphErrors.h"
 #include "TH1F.h"
+#include "TH1.h"
 #include "TList.h"
 #include "TMap.h"
 #include "TMath.h"
@@ -53,12 +55,13 @@
 ClassImp(AliAnalysisMuMuFnorm)
 
 //_____________________________________________________________________________
-AliAnalysisMuMuFnorm::AliAnalysisMuMuFnorm(AliCounterCollection& cc,
+AliAnalysisMuMuFnorm::AliAnalysisMuMuFnorm(AliCounterCollection& cc,AliAnalysisMuMuConfig& cf,
                                            AliAnalysisMuMuFnorm::ETriggerType refTriggerType,
                                            const char* ocdbpath,
                                            Bool_t compactGraphs) :
 TObject(),
 fCounterCollection(cc),
+fConfig(cf),
 fMergeableCollection(0x0),
 fIsOwner(kTRUE),
 fOCDBPath(ocdbpath),
@@ -67,8 +70,6 @@ fIsCompactGraphs(compactGraphs),
 fReferenceTriggerType(refTriggerType)
 {
   // ctor
-  
-  
 }
 
 //_____________________________________________________________________________
@@ -95,73 +96,72 @@ void AliAnalysisMuMuFnorm::ComputeFnorm()
   ///   - scaler values corrected for pile-up
   ///   - scaler values corrected for pile-up and physics selection
 
-  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
-  const Bool_t trueFalse[] = { kTRUE, kFALSE };
-  
-  for ( Int_t i = 0; i < 4; ++i )
-  {
-    for ( Int_t pileup = 0; pileup < 2; ++pileup )
-    {
-      for ( Int_t ps = 0; ps < 2; ++ps )
-      {
-        ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
-      }
-    }
-  }
-
-  ComputeFnormOffline(1,kFALSE,0);
-  ComputeFnormOffline(1,kFALSE,1);
-  ComputeFnormOffline(1,kTRUE,1);
+//   const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+//   const Bool_t trueFalse[] = { kTRUE, kFALSE };
+//   // Call ComputeNofEvent for every combination possible
+//   for ( Int_t i = 0; i < 4; ++i )
+//   {
+//     for ( Int_t pileup = 0; pileup < 2; ++pileup )
+//     {
+//       for ( Int_t ps = 0; ps < 2; ++ps )
+//       {
+//         ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+//       }
+//     }
+//   }
+//   ComputeFnormOffline(1,kFALSE,0);
+//   ComputeFnormOffline(1,kFALSE,1);
+//   ComputeFnormOffline(1,kTRUE,1);
   
-  ComputeFnormOffline(2,kFALSE,0);
-  ComputeFnormOffline(2,kFALSE,1);
-  ComputeFnormOffline(2,kTRUE,1);
+//   ComputeFnormOffline(2,kFALSE,0);
+//   ComputeFnormOffline(2,kFALSE,1);
+//   ComputeFnormOffline(2,kTRUE,1);
 
-//  ComputeFnormOffline(2,kFALSE,2);
-//  ComputeFnormOffline(2,kTRUE,2);
+// //  ComputeFnormOffline(2,kFALSE,2);
+// //  ComputeFnormOffline(2,kTRUE,2);
 
-  ComputeFnormScalers(kFALSE,0);
-  ComputeFnormScalers(kTRUE,0);
-  ComputeFnormScalers(kTRUE,1);
-//  ComputeFnormScalers(kTRUE,2);
+//   ComputeFnormScalers(kFALSE,0);
+//   ComputeFnormScalers(kTRUE,0);
+//   ComputeFnormScalers(kTRUE,1);
+// //  ComputeFnormScalers(kTRUE,2);
 
-  WeightedMeanGraphs("Offline");
-  WeightedMeanGraphs("Scalers");
-  WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
+//   WeightedMeanGraphs("Offline");
+//   WeightedMeanGraphs("Scalers");
+//   WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
   
-  WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
+//   WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
   
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
 
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
-  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
+//   ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
   
-  ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
+//   ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
 
-//  for ( Int_t i = 0; i < 4; ++i )
-///  {
-    TString triggerEvents;
+// //  for ( Int_t i = 0; i < 4; ++i )
+// ///  {
+//     TString triggerEvents;
     
-//  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
-  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
+// //  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
+//   triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
   
-  MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
+//   MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
   
-    MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
-  MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
-//  }
+//     MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
+//   MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
+// //  }
 
-//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
-//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
+// //  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
+// //  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
 
-  ComputeResultsFromGraphs();
+//   ComputeResultsFromGraphs();
   
-  AliAnalysisMuMuResult* result = GetResult("Fnorm");
-  if (result)
-  {
-    result->Exclude("*");
-    result->Include("FnormBest2");
-  }
+//   AliAnalysisMuMuResult* result = GetResult("Fnorm");
+//   if (result)
+//   {
+//     result->Exclude("*");
+//     result->Include("FnormBest2");
+//   }
 }
 
 //_____________________________________________________________________________
@@ -179,7 +179,7 @@ void AliAnalysisMuMuFnorm::ComputeCorrectionFactors(Int_t eventSelectionCorrecte
     return;
   }
   
-  AliDebug(2,"");
+  AliDebug(2,"");// ??
   
   std::vector<double> vx;
   std::vector<double> vxerr;
@@ -193,7 +193,7 @@ void AliAnalysisMuMuFnorm::ComputeCorrectionFactors(Int_t eventSelectionCorrecte
   
   for ( Int_t i = 0; i < 4; ++i )
   {
-    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);
+    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);// Problem from here
     ComputePileUpGraph(triggerTypes[i],eventSelectionCorrected);
   }
   
@@ -259,6 +259,7 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
   TString name("FnormOffline");
   TString title("Computed using offline information");
   TString refInput = Form("0%s",GetTriggerTypeName(fReferenceTriggerType).Data());
+  printf("refInput = %s\n",refInput.Data() );
   
   if (nstep==1)
   {
@@ -309,7 +310,8 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     TString mbTrigger = GetTriggerClassName(kMB,runNumber);
     TString muonTrigger = GetTriggerClassName(kMSL,runNumber);
 //    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
-    
+    printf("mb trigger : %s\n", mbTrigger.Data() );
+
     if (!mbTrigger.Length())
     {
       AliError(Form("Cannot get MB trigger for run %d",runNumber));
@@ -330,9 +332,11 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     
     Double_t nofMBw0REF = GetSum(Form("%s&%s",mbTrigger.Data(),refInput.Data()),runNumber,eventSelectionCorrected);
     Double_t nofMBw0MSL = GetSum(Form("%s&0MSL",mbTrigger.Data()),runNumber,eventSelectionCorrected);
+    if(mbTrigger.Contains("CINT7-B-NOPF-MUFAST&0TVX")) nofMBw0REF = GetSum(Form("CINT7-B-NOPF-MUFAST&%s",refInput.Data()),runNumber,eventSelectionCorrected); //Specific to LHC15n 
+    if(mbTrigger.Contains("CINT7-B-NOPF-MUFAST&0TVX")) nofMBw0MSL = GetSum("CINT7-B-NOPF-MUFAST&0MSL",runNumber,eventSelectionCorrected); //Specific to LHC15n 
     
-    if ( !nofMBw0REF ) continue;
-    if ( !nofMBw0MSL && nstep == 2 ) continue;
+    // if ( !nofMBw0REF && nstep == 1) continue;
+    // if ( !nofMBw0MSL && nstep == 2 ) continue;
     
     Double_t purityMB(1.0);
     Double_t purityMBerror(0.0);
@@ -341,8 +345,10 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     {
       ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
       
-      TGraphErrors* gps = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
-      
+      TGraphErrors* gps= 0x0;
+      gps = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      if (!gps)printf("Could not found Correction%s%s \n",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data());
+
       GetValueAndErrorFromGraph(gps,runNumber,purityMB,purityMBerror);
     }
     
@@ -367,14 +373,14 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
     
     if ( nstep == 2 )
     {
-      value = (nofMB/nofMSLw0REF)*(nofMSL/nofMBw0MSL);
+      value =  nofMBw0MSL > 0.0 ? (nofMB/nofMSLw0REF)*(nofMSL/nofMBw0MSL) : 0.0; 
       
-      if ( runNumber == 196310 )
-      {
+      // if ( runNumber == 196310 )
+      // {
         AliDebug(1,Form("RUN %09d %d-%d-%d value=%e nofMB %e nofMSLw%s %e nofMSL %e nofMBw0MSL %e",
                         runNumber,nstep,pileUpCorrected,eventSelectionCorrected,
                         value,nofMB,refInput.Data(),nofMSLw0REF,nofMSL,nofMBw0MSL));
-      }
+      // }
       
       error = value*AliAnalysisMuMuResult::ErrorABCD(nofMB,TMath::Sqrt(nofMB),
                                                           nofMSLw0REF,TMath::Sqrt(nofMSLw0REF),
@@ -382,16 +388,15 @@ void AliAnalysisMuMuFnorm::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrect
                                                           nofMBw0MSL,TMath::Sqrt(nofMBw0MSL));
     }
     
-    if ( value > 0.0 )
-    {
+    // if ( value > 0.0 )
+    // {
       vx.push_back(1.0*runNumber);
       vxerr.push_back(0.5);
       vy.push_back(value);
       vyerr.push_back(error);
-    }
+    // }
   }
   
-    
   CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
 }
 
@@ -412,6 +417,9 @@ void AliAnalysisMuMuFnorm::ComputeFnormScalers(Bool_t pileUpCorrected,
   /// taken from graphs computed in other methods
   ///
   
+  TString centrality(fConfig.First(fConfig.CentralitySelectionKey()));
+
+
   TString name("FnormScalers");
   TString title("Computed using OCDB scalers");
   
@@ -468,14 +476,14 @@ void AliAnalysisMuMuFnorm::ComputeFnormScalers(Bool_t pileUpCorrected,
     
     if (eventSelectionCorrected>0)
     {
-      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
-      ComputeEventSelectionGraph(fReferenceTriggerType,eventSelectionCorrected);
-      
-      TGraphErrors* gpsMB  = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
-      TGraphErrors* gpsREF = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data()));
+      ComputePurityFactorForScalerGraph(kMB,eventSelectionCorrected,&centrality);
+      ComputePurityFactorForScalerGraph(fReferenceTriggerType,eventSelectionCorrected,&centrality);
       
-      GetValueAndErrorFromGraph(gpsMB,runNumber,purityMB,purityMBerror);
-      GetValueAndErrorFromGraph(gpsREF,runNumber,purityREF,purityREFerror);
+      TGraphErrors* gpsfactorMB  = GetGraph(Form("PurityFactorForScaler%s%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(kMB).Data(),centrality.Data()));
+      TGraphErrors* gpsfactorREF = GetGraph(Form("PurityFactorForScaler%s%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(fReferenceTriggerType).Data(),centrality.Data()));
+
+      GetValueAndErrorFromGraph(gpsfactorMB,runNumber,purityMB,purityMBerror);
+      GetValueAndErrorFromGraph(gpsfactorREF,runNumber,purityREF,purityREFerror);
     }
     
     if (purityMB<=0.0)
@@ -497,7 +505,9 @@ void AliAnalysisMuMuFnorm::ComputeFnormScalers(Bool_t pileUpCorrected,
     Double_t pileUpFactorError(0.0);
     
     if (pileUpCorrected)
-    {
+    { 
+      ComputePileUpGraph(kMB,eventSelectionCorrected);
+      
       TGraphErrors* gpu = GetGraph((Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data())));
       
       GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
@@ -672,7 +682,8 @@ void AliAnalysisMuMuFnorm::ComputePileUpGraph(ETriggerType tt, Int_t eventSelect
     {
       GetPurity(triggerClassName.Data(),runNumber,purity,purityError,eventSelectionCorrected);
     }
-    ts.GetPileUpFactor(runNumber,triggerClassName.Data(),purity,pileUpFactor,pileUpFactorError);
+    if(triggerClassName.Contains("CINT7-B-NOPF-MUFAST&0TVX")) ts.GetPileUpFactor(runNumber,"C0TVX-B-NOPF-CENTNOTRD",purity,pileUpFactor,pileUpFactorError); //specific to T0 in LHC15o.
+    else ts.GetPileUpFactor(runNumber,triggerClassName.Data(),purity,pileUpFactor,pileUpFactorError);
    
     vx.push_back(runNumber);
     vxerr.push_back(0.5);
@@ -715,7 +726,7 @@ void AliAnalysisMuMuFnorm::ComputeEventSelectionGraph(ETriggerType tt, Int_t eve
   
   const std::set<int>& runs = RunNumbers();
   
-  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+  // AliAnalysisTriggerScalers ts(runs,OCDBPath().Data()); //  quoi a sert ??
   
   for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
   {
@@ -745,6 +756,60 @@ void AliAnalysisMuMuFnorm::ComputeEventSelectionGraph(ETriggerType tt, Int_t eve
   CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
 }
 
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnorm::ComputePurityFactorForScalerGraph(ETriggerType tt, Int_t eventSelectionCorrected, TString* centrality)
+{
+  /// Compute the per-run graph of the scaler purity factor purity
+  /// for the given trigger
+  /// This factor is computed offline as FScal_purity = NTRIGG(PS,0-90%)/NTRIGG(All,All); Offline
+  
+  TString graphName(Form("PurityFactorForScaler%s%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(tt).Data(),centrality->Data()));
+  
+  if (GetGraph(graphName))
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+  
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+  
+  const std::set<int>& runs = RunNumbers();
+  
+  // AliAnalysisTriggerScalers ts(runs,OCDBPath().Data()); //  quoi a sert ??
+  
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+    
+    Double_t purityfactor, purityfactorError;
+    
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+    
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+
+    GetPurityFactor(triggerClassName,runNumber,purityfactor,purityfactorError,eventSelectionCorrected,centrality);
+    
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(purityfactor);
+    vyerr.push_back(purityfactorError);
+  }
+  
+  TString title(Form("Fraction of %s events accepted for %s by all events for trigger %s",
+    GetEventSelectionName(eventSelectionCorrected).Data(),centrality->Data(),GetTriggerTypeName(tt).Data()));
+  
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuFnorm::ComputeResultsFromGraphs()
@@ -819,7 +884,7 @@ void AliAnalysisMuMuFnorm::ComputeNofEvents(ETriggerType triggerType,
   TString graphName(Form("NofEvent%s%s%s",GetTriggerTypeName(triggerType).Data(),
                          pileUpCorrected ? "PU" : "",
                          GetEventSelectionName(eventSelectionCorrected).Data()));
-  
+  // Check if Compute has already been done
   if ( GetGraph(graphName) )
   {
     // compute it only once
@@ -1004,7 +1069,11 @@ void AliAnalysisMuMuFnorm::ComputeTriggerL0B(ETriggerType triggerType)
     
     TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
     
-    AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L0B",triggerClassName);
+    AliAnalysisTriggerScalerItem* item = 0x0;
+
+    if(triggerClassName.Contains("CINT7-B-NOPF-MUFAST&0TVX")) item=  ts.GetTriggerScaler(runNumber,"L0B","C0TVX-B-NOPF-CENTNOTRD"); //specific to T0 in LHC15o.
+    else item= ts.GetTriggerScaler(runNumber,"L0B",triggerClassName);
+
     if (!item) continue;
     
     vx.push_back(runNumber);
@@ -1083,18 +1152,16 @@ TGraphErrors* AliAnalysisMuMuFnorm::CreateAndAddGraph(const TString& name,
                                                       const std::vector<double>& vy,
                                                       const std::vector<double>& vyerr) const
 {
-  /// Creates a graph and adds it to our mergeable collection
+  /// Creates a graph and an histo and adds it to our mergeable collection
   
   TGraphErrors* g = new TGraphErrors(vx.size(),&vx[0],&vy[0],&vxerr[0],&vyerr[0]);
   g->SetName(name.Data());
   g->SetTitle(title.Data());
-  
   if  (fIsCompactGraphs)
   {
     AliAnalysisMuMuGraphUtil::Compact(*g);
   }
 
-  g->GetXaxis()->SetNoExponent();
 //  g->GetXaxis()->SetTitle("Run number");
 
   TPaveText* text = new TPaveText(0.70,0.70,0.89,0.89,"NDC");
@@ -1103,8 +1170,12 @@ TGraphErrors* AliAnalysisMuMuFnorm::CreateAndAddGraph(const TString& name,
   text->AddText(Form("Mean %e",g->GetMean(2)));
   text->AddText(Form("RMS  %e",g->GetRMS(2)));
   g->GetListOfFunctions()->Add(text);
+
+
   
   MC()->Adopt("/GRAPHS/",g);
+  TH1* h = GetGraphAsHisto(name);
+  MC()->Adopt("/GRAPHS/",h);
   return g;
 }
 
@@ -1219,6 +1290,58 @@ TGraphErrors* AliAnalysisMuMuFnorm::GetGraph(const char* name) const
 }
 
 //_____________________________________________________________________________
+TH1* AliAnalysisMuMuFnorm::GetGraphAsHisto(const char* name) const
+{
+  // shortcut method to give access to one graph and return it as an histo
+
+  TObject* o = MC()->GetObject(Form("/GRAPHS/%s",name));
+
+  if (!o) return 0x0;
+  if ( o->IsA() != TGraphErrors::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+
+  const std::set<int>& runs = RunNumbers();
+
+  TGraphErrors *g = static_cast<TGraphErrors*>(o->Clone());
+  TH1F * h =new TH1F(Form("%s_AsHisto",g->GetName()),Form("%s_AsHisto",g->GetName()),1,0.,1.);
+
+  Double_t y = 0.;
+  Double_t dy = 0.;
+
+  //Fill
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    GetValueAndErrorFromGraph(g,runNumber,y,dy);
+    // if(y==0.)
+    // {
+    //   printf("Error : no values for run %d\n",runNumber );
+    //   continue;
+    // }
+
+    Int_t bin = h->Fill(TString::Format("%d",runNumber).Data(),y);
+    h->SetBinError(bin,dy);
+  }
+
+  // Set range
+  int j=0;
+  for (int i = 1; i < h->GetEntries()+1; i++)
+  {
+    if(TString(h->GetXaxis()->GetBinLabel(i)).IsNull()) continue;
+    j++;
+  }
+  if(j == runs.size()) h->GetXaxis()->SetRange(1,j);
+
+  delete g;
+  return h;
+
+}
+
+//_____________________________________________________________________________
 void AliAnalysisMuMuFnorm::GetPurity(const char* triggerClassName, Int_t runNumber,
                                      Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const
 {
@@ -1239,7 +1362,7 @@ void AliAnalysisMuMuFnorm::GetPurity(const char* triggerClassName, Int_t runNumb
   
   if ( eventSelectionCorrected == 1 )
   {
-    ename = "PSALL";
+    ename = fConfig.First(fConfig.EventSelectionKey(),kFALSE).Data();
   }
   else if ( eventSelectionCorrected == 2 )
   {
@@ -1258,7 +1381,57 @@ void AliAnalysisMuMuFnorm::GetPurity(const char* triggerClassName, Int_t runNumb
   
   value = nps/nall;
   
-  error = AliAnalysisMuMuResult::ErrorAB(nall,TMath::Sqrt(nall),nps,TMath::Sqrt(nps));
+  error = value*AliAnalysisMuMuResult::ErrorAB(nall,TMath::Sqrt(nall),nps,TMath::Sqrt(nps));
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnorm::GetPurityFactor(TString triggerClassName, Int_t runNumber,
+                                     Double_t& value, Double_t& error, Int_t eventSelectionCorrected, TString * centrality) const
+{
+  /// Get the physics selection accept fraction for a given trigger
+  
+  value=error=0.0;
+
+  TString runCondition;
+  
+  if (runNumber>0)
+  {
+    runCondition.Form("/run:%d",runNumber);
+  }
+
+  TObjArray * centralityArray = centrality->Tokenize("_");
+  TObjString * centralityType = static_cast<TObjString*>(centralityArray->At(0));
+  
+  TString ename;
+  if ( eventSelectionCorrected == 1 ){
+    if (triggerClassName.Contains("CMUL")) ename = "PSMUL";
+    else ename = Form("%s",fConfig.First(fConfig.EventSelectionKey(),kFALSE).Data());
+  }
+  else if ( eventSelectionCorrected == 2 )ename = "OFFLINE1";
+  else {
+    value = 1.0;
+    return;
+  }
+
+  Double_t b1 = fCounterCollection.GetSum(Form("trigger:%s/event:%s%s/centrality:%s",
+                                                triggerClassName.Data(),ename.Data(),runCondition.Data(),centrality->Data()));
+  Double_t b1sq = b1*b1;
+  Double_t e1sq = b1;
+  
+  Double_t b2 = fCounterCollection.GetSum(Form("trigger:%s/event:ALL%s/centrality:%s",triggerClassName.Data(),runCondition.Data(),centralityType->String().Data()));
+  Double_t b2sq = b2*b2;
+  Double_t e2sq = b2;
+  
+  if ( b2 <= 0.0 ) return;
+  
+  value = b1/b2;
+  
+  //fully correlated bayasian
+  if (b1 != b2) {
+  error = TMath::Sqrt( TMath::Abs( ( (1. - 2.* b1 / b2) * e1sq  + b1sq * e2sq / b2sq ) / b2sq ) );
+  } 
+  else error = 0;
+
 }
 
 //_____________________________________________________________________________
@@ -1372,10 +1545,12 @@ Double_t AliAnalysisMuMuFnorm::GetSum(const char* triggerClassName,
                                       Int_t eventSelectionCorrected) const
 {
   TString condition(Form("trigger:%s/run:%d",triggerClassName,runNumber));
+  TString triggerName(triggerClassName);
   
   if (eventSelectionCorrected==1)
   {
-    condition += "/event:PSALL";
+    if(triggerName.Contains("CMSL") )condition += "/event:PSMSL";
+    else condition += Form("/event:%s",fConfig.First(fConfig.EventSelectionKey(),kFALSE).Data());
   }
   else if ( eventSelectionCorrected == 2 )
   {
@@ -1385,8 +1560,12 @@ Double_t AliAnalysisMuMuFnorm::GetSum(const char* triggerClassName,
   {
     condition += "/event:ALL";
   }
+
+  condition += Form("/centrality:%s",fConfig.First(fConfig.CentralitySelectionKey(),kFALSE).Data());
   
   Double_t n = fCounterCollection.GetSum(condition.Data());
+
+  printf("Sum of %s for %s = %f \n",triggerClassName,condition.Data(),n );
   
   if (n<=0)
   {
@@ -1488,13 +1667,21 @@ TString AliAnalysisMuMuFnorm::MBTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
-  {
-    return "CINT7-B-NOPF-ALLNOTRD";
-  }
-  return "";
+  // if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CINT7-B-NOPF-ALLNOTRD";
+  // }
+  // else if ( TriggerClassnameTest("CPBI2_B1-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CPBI2_B1-B-NOPF-ALLNOTRD";
+  // }
+  // return "";
+
+  TString triggerType(fConfig.First(fConfig.MinbiasTriggerKey(),kFALSE).Data());
+  return triggerType.Data();
 }
 
+
 //_____________________________________________________________________________
 TString AliAnalysisMuMuFnorm::MSHTriggerClassName(Int_t runNumber) const
 {
@@ -1516,18 +1703,22 @@ TString AliAnalysisMuMuFnorm::MSLTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
-  {
-      return "CMSL7-B-NOPF-MUON";
-  }
-//  else
-//    if ( TriggerClassnameTest("CMSL7-B-NOPF-ALLNOTRD",runNumber) )
-//  {
-//    return "CMSL7-B-NOPF-ALLNOTRD";
-//  }
-  return "";
+ //  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
+ //  {
+ //      return "CMSL7-B-NOPF-MUON";
+ //  }
+ // else
+ //   if ( TriggerClassnameTest("CPBI1MSL-B-NOPF-MUON",runNumber) )
+ // {
+ //   return "CPBI1MSL-B-NOPF-MUON";
+ // }
+ //  return "";
+
+ TString triggerType(fConfig.First(fConfig.MuonTriggerKey(),kFALSE).Data());
+  return triggerType.Data();
 }
 
+
 //_____________________________________________________________________________
 void AliAnalysisMuMuFnorm::MultiplyGraphs(const char* g1name, const char* g2name, const char* name)
 {
@@ -1596,16 +1787,24 @@ TString AliAnalysisMuMuFnorm::MULTriggerClassName(Int_t runNumber) const
 {
   /// FIXME : find a better way ?
   
-  if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
-  {
-    return "CMUL7-B-NOPF-ALLNOTRD";
-  }
-  else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
-  {
-    return "CMUL7-B-NOPF-MUON";
-  }
-  return "";
+  // if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
+  // {
+  //   return "CMUL7-B-NOPF-ALLNOTRD";
+  // }
+  // else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
+  // {
+  //   return "CMUL7-B-NOPF-MUON";
+  // }
+  // else if ( TriggerClassnameTest("CPBI1MUL-B-NOPF-MUON",runNumber) )
+  // {
+  //   return "CPBI1MUL-B-NOPF-MUON";
+  // }
+  // return "";
   
+  TString triggerType(fConfig.First(fConfig.DimuonTriggerKey(),kFALSE).Data());
+    return triggerType.Data();
+
+
 }
 
 //_____________________________________________________________________________
@@ -1725,7 +1924,7 @@ Bool_t AliAnalysisMuMuFnorm::TriggerClassnameTest(const char* triggerClassName,
 
 //_____________________________________________________________________________
 void
-AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char* graphName)
+AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char* graphName, AliMergeableCollection* oc)
 {
   /// Sum the graphs which name matches pattern
   /// Sum is made using a weighted mean (each element is weighted by the inverse
@@ -1740,28 +1939,43 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     slist = spattern.Tokenize(",");
     spattern = "";
   }
-  
-  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+
+  TList* objectList = 0x0;
+  if(oc) {
+    printf("Adding %s to the list...\n", "/FNORM/Offline/GRAPHS/");
+    objectList = oc->CreateListOfObjectNames("/FNORM/Offline/GRAPHS/");
+    printf("Adding %s to the list...\n", "/FNORM/Scaler/GRAPHS/");
+    objectList->Add(static_cast<TObject*>(oc->CreateListOfObjectNames("/FNORM/Scaler/GRAPHS/")));
+  }
+  else return;
+
+  if (!objectList){
+    printf("Cannot add list\n");
+    return;
+  }
+
   TIter next(objectList);
   TObjString* str(0x0);
   TObjArray selected;
   selected.SetOwner(kFALSE);
-  
+
+  printf("Selecting graphs ...\n");
   while ( ( str = static_cast<TObjString*>(next()) ) )
   {
-    TGraphErrors* g = GetGraph(str->String());
-    
+    TGraphErrors* g = static_cast<TGraphErrors*>(oc->GetObject(Form("/FNORM/Offline/GRAPHS/%s",str->String().Data())));
+    if (!g) g = static_cast<TGraphErrors*>(oc->GetObject(Form("/FNORM/Scaler/GRAPHS/%s",str->String().Data())));
     if (!g) continue;
-    
+
     TString name(g->GetName());
-    
+
     if ( spattern.Length() >0 && !name.Contains(spattern.Data()) ) continue;
-    
+    AliDebug(2,Form("name : %s !\n",name.Data() ));
+
     if ( slist && !slist->FindObject(name)) continue;
-    
+
     AliDebug(2,Form("Selected for sum : %s",name.Data()));
     
-    selected.Add(g);
+    selected.Add(g->Clone());
   }
   
   delete slist;
@@ -1775,24 +1989,28 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
   std::vector<double> vyerr;
   
   Int_t npts = static_cast<TGraphErrors*>(selected.First())->GetN();
+  if(npts==0 || npts==1) return;
   
+  printf("Computing mean ...\n");
+
   for ( Int_t ipoint = 0; ipoint < npts; ++ipoint )
   {
     Double_t x(0.0),xref(0.0),xerr(0.0);
     Double_t sum(0.0);
     Double_t sume2(0.0);
-    
+
+    // Loop on graphs
     for ( Int_t igraph = 0; igraph <= selected.GetLast(); ++igraph )
     {
       TGraphErrors* g = static_cast<TGraphErrors*>(selected.At(igraph));
-      
+
       if ( g->GetN() != npts )
       {
         AliError(Form("Graph %s does not have the expected %d points",g->GetName(),npts));
         continue;
       }
       Double_t runNumber;
-      
+
       if ( fIsCompactGraphs )
       {
         runNumber = TString(g->GetXaxis()->GetBinLabel(ipoint+1)).Atoi()*1.0;
@@ -1801,7 +2019,6 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
       {
         runNumber = g->GetX()[ipoint];
       }
-      
       if ( igraph == 0 )
       {
         xref = g->GetX()[ipoint];
@@ -1835,6 +2052,7 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     }
   }
   
+  printf("Changing titles ...\n");
   Int_t n = selected.GetEntries();
   
   TString name(graphName);
@@ -1847,7 +2065,9 @@ AliAnalysisMuMuFnorm::WeightedMeanGraphs(const char* patternOrList, const char*
     title = TString::Format("WeightMeanFnorm%s from %d individual graphs",patternOrList,n);
   }
   
+  printf("Creating graph ...\n");
   CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+
 }
 
 
diff --git a/PWG/muondep/AliAnalysisMuMuFnorm.h b/PWG/muondep/AliAnalysisMuMuFnorm.h
index d132c0b..2a2c3c9 100644
--- a/PWG/muondep/AliAnalysisMuMuFnorm.h
+++ b/PWG/muondep/AliAnalysisMuMuFnorm.h
@@ -18,9 +18,11 @@
 class TObjArray;
 class TGraphErrors;
 class TGraph;
+class TH1;
 class AliAnalysisMuMuResult;
 class AliCounterCollection;
 class AliMergeableCollection;
+class AliAnalysisMuMuConfig;
 
 class AliAnalysisMuMuFnorm : public TObject
 {
@@ -35,7 +37,7 @@ public:
     kMSH=4
   };
   
-  AliAnalysisMuMuFnorm(AliCounterCollection& cc,
+  AliAnalysisMuMuFnorm(AliCounterCollection& cc, AliAnalysisMuMuConfig& cf,
                        AliAnalysisMuMuFnorm::ETriggerType triggerType=AliAnalysisMuMuFnorm::kMUL,
                        const char* ocdbpath="raw://",
                        Bool_t compactGraphs=kFALSE);
@@ -58,6 +60,8 @@ public:
   void ComputePileUpGraph(ETriggerType tt, Int_t eventSelectionCorrected=0);
   
   void ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected);
+  
+  void ComputePurityFactorForScalerGraph(ETriggerType tt, Int_t eventSelectionCorrected, TString* centrality);
 
   void ComputeResultsFromGraphs();
 
@@ -76,8 +80,12 @@ public:
   //  void GetFnorm(Int_t runNumber, const char* eventSelection, Double_t& value, Double_t& error) const; // Not implemented
   
   TGraphErrors* GetGraph(const char* name) const;
+
+  TH1* GetGraphAsHisto(const char* name) const;
   
   void GetPurity(const char* triggerClassName, Int_t runNumber, Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const;
+  
+  void GetPurityFactor(TString triggerClassName, Int_t runNumber,Double_t& value, Double_t& error, Int_t eventSelectionCorrected, TString * centrality) const;
 
   void GetValueAndErrorFromGraph(TGraphErrors* graph,
                                  Int_t runNumber,
@@ -105,7 +113,7 @@ public:
 
   Bool_t TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const;
 
-  void WeightedMeanGraphs(const char* pattern, const char* name="");
+  void WeightedMeanGraphs(const char* pattern="", const char* name="", AliMergeableCollection* mc =0x0);
   
 private:
   
@@ -135,6 +143,7 @@ private:
 private:
   
   /*const*/ AliCounterCollection& fCounterCollection; // collection of trigger counters (not owner)
+  /*const*/ AliAnalysisMuMuConfig& fConfig; // collection of trigger counters (not owner)
   mutable AliMergeableCollection* fMergeableCollection; // collection of results, histograms, graphs (ownership is in fIsOwner)
   Bool_t fIsOwner; // whether we are the owner of the mergeable collection
   TString fOCDBPath; // OCDB to be used (raw:// by default)
diff --git a/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx b/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
new file mode 100644
index 0000000..2d33032
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuFnormBeta.cxx
@@ -0,0 +1,1857 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// AliAnalysisMuMuFnormBeta : class to encapsulate computation(s)
+/// of the normalisation factor used to get the equivalent
+/// number of MB events from the number of REF triggers
+///
+/// The computed objects are stored within a AliMergeableCollection
+/// with 3 subdirectories, dependinf on their type
+///
+/// /GRAPHS/
+/// /RESULTS/
+/// /HISTOS/
+///
+/// author: Laurent Aphecetche (Subatech) and Benjamin Audurier
+
+#include "AliAnalysisMuMuFnormBeta.h"
+
+#include "AliAnalysisMuMuGraphUtil.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisTriggerScalers.h"
+#include "AliCounterCollection.h"
+#include "AliLog.h"
+#include "AliMergeableCollection.h"
+#include "Riostream.h"
+#include "TAxis.h"
+#include "TCanvas.h"
+#include "TGraphErrors.h"
+#include "TH1F.h"
+#include "TList.h"
+#include "TMap.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "TObjString.h"
+#include "TPaveText.h"
+#include "TStyle.h"
+#include <cassert>
+#include <numeric>
+
+ClassImp(AliAnalysisMuMuFnormBeta)
+
+//_____________________________________________________________________________
+AliAnalysisMuMuFnormBeta::AliAnalysisMuMuFnormBeta(AliCounterCollection& cc,
+                                           AliAnalysisMuMuFnormBeta::ETriggerType refTriggerType,
+                                           const char* ocdbpath,
+                                           Bool_t compactGraphs) :
+TObject(),
+fCounterCollection(cc),
+fMergeableCollection(0x0),
+fIsOwner(kTRUE),
+fOCDBPath(ocdbpath),
+fResult(0x0),
+fIsCompactGraphs(compactGraphs),
+fReferenceTriggerType(refTriggerType)
+{
+  // ctor
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuFnormBeta::~AliAnalysisMuMuFnormBeta()
+{
+  // dtor
+  if ( fIsOwner )
+  {
+    delete fMergeableCollection;
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnorm()
+{
+  /// Compute the REF to CINT ratio(s)
+  ///
+  /// Using offline method
+  ///   - in one go CINT/REF
+  ///   - in two steps CINT/CMSL and CMSL/REF
+  ///
+  /// Using scaler method
+  ///   - bare scaler values
+  ///   - scaler values corrected for pile-up
+  ///   - scaler values corrected for pile-up and physics selection
+
+  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+  const Bool_t trueFalse[] = { kTRUE, kFALSE };
+  // Call ComputeNofEvent for every combination possible
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    for ( Int_t pileup = 0; pileup < 2; ++pileup )
+    {
+      for ( Int_t ps = 0; ps < 2; ++ps )
+      {
+        ComputeNofEvents(triggerTypes[i],trueFalse[pileup],ps);
+      }
+    }
+  }
+ cout << "Here ! "<< endl;
+  ComputeFnormOffline(1,kFALSE,0);
+  ComputeFnormOffline(1,kFALSE,1);
+  ComputeFnormOffline(1,kTRUE,1);
+
+  ComputeFnormOffline(2,kFALSE,0);
+  ComputeFnormOffline(2,kFALSE,1);
+  ComputeFnormOffline(2,kTRUE,1);
+
+//  ComputeFnormOffline(2,kFALSE,2);
+//  ComputeFnormOffline(2,kTRUE,2);
+
+  ComputeFnormScalers(kFALSE,0);
+  ComputeFnormScalers(kTRUE,0);
+  ComputeFnormScalers(kTRUE,1);
+//  ComputeFnormScalers(kTRUE,2);
+
+  WeightedMeanGraphs("Offline");
+  WeightedMeanGraphs("Scalers");
+  WeightedMeanGraphs("FnormOffline2PUPS,FnormOffline1PUPS","FnormOffline12PUPS");
+
+  WeightedMeanGraphs("FnormOffline2PUPS,FnormScalersPUPS","FnormBest2");
+
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormScalersPUPS");
+
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2");
+  ComputeGraphRelDif("FnormOffline2PUPS","FnormOffline2PS");
+
+  ComputeGraphRelDif("CorrectionPSMB","CorrectionPSREF");
+
+//  for ( Int_t i = 0; i < 4; ++i )
+///  {
+    TString triggerEvents;
+
+//  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(triggerTypes[i]).Data());
+  triggerEvents.Form("NofEvent%sPUPS",GetTriggerTypeName(fReferenceTriggerType).Data());
+
+  MultiplyGraphs(triggerEvents.Data(),"FnormBest2","NMBeqBest2");
+
+    MultiplyGraphs(triggerEvents.Data(),"FnormOffline2PUPS","NMBeqOffline2PUPS");
+  MultiplyGraphs(triggerEvents.Data(),"FnormScalersPUPS","NMBeqScalersPUPS");
+//  }
+
+//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2PUTS","NMBeqOffline2PUTS");
+//  MultiplyGraphs(Form("NofEvent%sPUTS",GetTriggerTypeName(fReferenceTriggerType).Data()),"FnormOffline2TS","NMBeqOffline2TS");
+
+  ComputeResultsFromGraphs();
+
+  AliAnalysisMuMuResult* result = GetResult("Fnorm");
+  if (result)
+  {
+    result->Exclude("*");
+    result->Include("FnormBest2");
+  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeCorrectionFactors(Int_t eventSelectionCorrected)
+{
+  /// Compute individual graphs for the correction factors (PS_REF, PS_CINT,
+  /// F_pile-up,PS_CINT/PS_REF) used in the computation of (some) Fnorm factors
+  ///
+
+  TString graphName(Form("CorrectionGlobal%s",GetEventSelectionName(eventSelectionCorrected).Data()));;
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we compute it only once
+    return;
+  }
+
+  AliDebug(2,"");// ??
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  std::vector<double> vyGlobal;
+  std::vector<double> vyGlobalErr;
+
+  const ETriggerType triggerTypes[] = { kMB, kMUL, kMSL, kMSH };
+
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    ComputeEventSelectionGraph(triggerTypes[i],eventSelectionCorrected);// Problem from here
+    ComputePileUpGraph(triggerTypes[i],eventSelectionCorrected);
+  }
+
+  TGraphErrors* gPSCINT = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(AliAnalysisMuMuFnormBeta::kMB).Data()));
+
+  TGraphErrors* gPSREF = GetGraph(Form("Correction%s%s", GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(fReferenceTriggerType).Data()));
+
+  TGraphErrors* gPU = GetGraph(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(AliAnalysisMuMuFnormBeta::kMB).Data()));
+
+  if ( !gPSCINT || !gPSREF || !gPU )
+  {
+    AliError("Did not get the relevant graphs. Cannot work");
+    return;
+  }
+
+  for ( Int_t i = 0; i < gPSCINT->GetN(); ++i )
+  {
+    Double_t x,y,yerr,yGlobal,yGlobalErr;
+
+    gPSCINT->GetPoint(i,x,y);
+
+    if ( fIsCompactGraphs )
+    {
+      x = TString(gPSCINT->GetXaxis()->GetBinLabel(i)).Atoi();
+    }
+
+    yGlobal = gPSCINT->GetY()[i] * gPU->GetY()[i] / gPSREF->GetY()[i];
+
+    yGlobalErr = yGlobal*AliAnalysisMuMuResult::ErrorABC(gPSCINT->GetY()[i],gPSCINT->GetEY()[i],
+                                                         gPSREF->GetY()[i],gPSREF->GetEY()[i],
+                                                         gPU->GetY()[i],gPU->GetEY()[i]);
+
+    y = gPSCINT->GetY()[i] / gPSREF->GetY()[i];
+    yerr = y * AliAnalysisMuMuResult::ErrorAB(gPSCINT->GetY()[i],gPSCINT->GetEY()[i],
+                                              gPSREF->GetY()[i],gPSREF->GetEY()[i]);
+
+    vx.push_back(x);
+    vxerr.push_back(gPSCINT->GetEX()[i]);
+
+    vyGlobal.push_back(yGlobal);
+    vyGlobalErr.push_back(yGlobalErr);
+
+    vy.push_back(y);
+    vyerr.push_back(yerr);
+  }
+
+  TString name(Form("Correction%sRatio",GetEventSelectionName(eventSelectionCorrected).Data()));
+  TString title(Form("%s_MB/%s_%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data(),
+                     GetEventSelectionName(eventSelectionCorrected).Data()));
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+
+  title = TString::Format("%s_MB x Fpile-up / %s_%s ",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data(),GetEventSelectionName(eventSelectionCorrected).Data());
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vyGlobal,vyGlobalErr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrected, Int_t eventSelectionCorrected)
+{
+  /// Compute MB to REF ratio using offline method, either in 1 or 2 steps
+
+  TString name("FnormOffline");
+  TString title("Computed using offline information");
+  TString refInput = Form("0%s",GetTriggerTypeName(fReferenceTriggerType).Data());
+
+  if (nstep==1)
+  {
+    name += "1";
+    title += Form(" in one step (CINT/CINT&%s)",refInput.Data());
+  }
+  else
+  {
+    name += "2";
+    title += Form(" in two steps (CMSL/CMSL&%s x CINT/CINT&0MSL)",refInput.Data());
+  }
+
+  if (pileUpCorrected)
+  {
+    name += "PU";
+    title += " with pile-up correction";
+  }
+  if (eventSelectionCorrected==1)
+  {
+    name += "PS";
+    title += " with (ps) purity corrections";
+  }
+  else if ( eventSelectionCorrected==2 )
+  {
+    name += "TS";
+    title += " with (ts) purity corrections";
+  }
+
+  if ( GetGraph(name) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,name);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString mbTrigger = GetTriggerClassName(kMB,runNumber);
+    TString muonTrigger = GetTriggerClassName(kMUL,runNumber);
+//    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
+
+    if (!mbTrigger.Length())
+    {
+      AliError(Form("Cannot get MB trigger for run %d",runNumber));
+      continue;
+    }
+
+    Double_t nofMB = GetSum(mbTrigger.Data(),runNumber,eventSelectionCorrected);
+    Double_t nofMSL(0.0);
+    Double_t nofMSLw0REF(0.0);
+
+    if ( nstep==2 )
+    {
+      nofMSL = GetSum(muonTrigger.Data(),runNumber,eventSelectionCorrected);
+      TString counterName = muonTrigger;
+      if ( fReferenceTriggerType != kMSL ) counterName += Form("&%s",refInput.Data());
+      nofMSLw0REF = GetSum(counterName,runNumber,eventSelectionCorrected);
+    }
+
+    Double_t nofMBw0REF = GetSum(Form("%s&%s",mbTrigger.Data(),refInput.Data()),runNumber,eventSelectionCorrected);
+    Double_t nofMBw0MSL = GetSum(Form("%s&0MSL",mbTrigger.Data()),runNumber,eventSelectionCorrected);
+
+    if ( !nofMBw0REF ) continue;
+    if ( !nofMBw0MSL && nstep == 2 ) continue;
+
+    Double_t purityMB(1.0);
+    Double_t purityMBerror(0.0);
+
+    if ( eventSelectionCorrected > 0 )
+    {
+      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
+
+      TGraphErrors* gps = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+
+      GetValueAndErrorFromGraph(gps,runNumber,purityMB,purityMBerror);
+    }
+
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+
+    if (pileUpCorrected)
+    {
+      ComputePileUpGraph(kMB,eventSelectionCorrected);
+
+      TGraphErrors* gpu = GetGraph(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+
+      GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
+
+      nofMB *= pileUpFactor;
+    }
+
+    double value = nofMBw0REF > 0.0 ? nofMB/nofMBw0REF : 0.0;
+    double error = value*AliAnalysisMuMuResult::ErrorABC(nofMB,TMath::Sqrt(nofMB),
+                                                              nofMBw0REF,TMath::Sqrt(nofMBw0REF),
+                                                              pileUpFactor,pileUpFactorError);
+
+    if ( nstep == 2 )
+    {
+      value = (nofMB/nofMSLw0REF)*(nofMSL/nofMBw0MSL);
+
+      if ( runNumber == 196310 )
+      {
+        AliDebug(1,Form("RUN %09d %d-%d-%d value=%e nofMB %e nofMSLw%s %e nofMSL %e nofMBw0MSL %e",
+                        runNumber,nstep,pileUpCorrected,eventSelectionCorrected,
+                        value,nofMB,refInput.Data(),nofMSLw0REF,nofMSL,nofMBw0MSL));
+      }
+
+      error = value*AliAnalysisMuMuResult::ErrorABCD(nofMB,TMath::Sqrt(nofMB),
+                                                          nofMSLw0REF,TMath::Sqrt(nofMSLw0REF),
+                                                          nofMSL,TMath::Sqrt(nofMSL),
+                                                          nofMBw0MSL,TMath::Sqrt(nofMBw0MSL));
+    }
+
+    if ( value > 0.0 )
+    {
+      vx.push_back(1.0*runNumber);
+      vxerr.push_back(0.5);
+      vy.push_back(value);
+      vyerr.push_back(error);
+    }
+  }
+
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeFnormScalers(Bool_t pileUpCorrected,
+                                               Int_t eventSelectionCorrected)
+{
+  /// Compute the MB to REF ratio using the scalers method (from OCDB)
+  ///
+  /// i.e. Fnorm = L0B(MB) x PS(MB) x Fpile-up / ( L0B(REF) x PS(REF) )
+  ///
+  /// where MB is the minbias trigger
+  /// REF is the fReferenceTrigger
+  /// and PS is the fraction of events selected by the physics selection
+  ///
+  /// The correction factor (the two PS and one Fpile-up) are
+  /// taken from graphs computed in other methods
+  ///
+
+  TString name("FnormScalers");
+  TString title("Computed using OCDB scalers");
+
+  if (pileUpCorrected)
+  {
+    name += "PU";
+    title += " with pile-up correction";
+  }
+  if (eventSelectionCorrected==1)
+  {
+    name += "PS";
+    title += " with (ps) purity corrections";
+  }
+  if (eventSelectionCorrected==2)
+  {
+    name += "TS";
+    title += " with (ts) purity corrections";
+  }
+
+  if ( GetGraph(name) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,name);
+
+  // insure we have all the graphs we need to work
+  ComputeTriggerL0B(kMB);
+  ComputeTriggerL0B(fReferenceTriggerType);
+
+  const std::set<int>& runs = RunNumbers();
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  Double_t purityREF(1.0);
+  Double_t purityMB(1.0);
+  Double_t purityREFerror(00);
+  Double_t purityMBerror(0.0);
+
+  // compute the per run values
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString mbTrigger = GetTriggerClassName(kMB,runNumber);
+//    TString refTrigger = GetTriggerClassName(fReferenceTriggerType,runNumber);
+
+    purityMB=purityREF=1.0;
+    purityMBerror=purityREFerror=0.0;
+
+    if (eventSelectionCorrected>0)
+    {
+      ComputeEventSelectionGraph(kMB,eventSelectionCorrected);
+      ComputeEventSelectionGraph(fReferenceTriggerType,eventSelectionCorrected);
+
+      TGraphErrors* gpsMB  = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data()));
+      TGraphErrors* gpsREF = GetGraph(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(fReferenceTriggerType).Data()));
+
+      GetValueAndErrorFromGraph(gpsMB,runNumber,purityMB,purityMBerror);
+      GetValueAndErrorFromGraph(gpsREF,runNumber,purityREF,purityREFerror);
+    }
+
+    if (purityMB<=0.0)
+    {
+      AliError(Form("Got purity=%e for MB for run %9d",purityMB,runNumber));
+      continue;
+    }
+
+    TGraphErrors* gl0bMB = GetGraph(Form("L0B%s",GetTriggerTypeName(kMB).Data()));
+    TGraphErrors* gl0bREF = GetGraph(Form("L0B%s",GetTriggerTypeName(fReferenceTriggerType).Data()));
+
+    Double_t L0bMB,L0bMBError;
+    Double_t L0bREF,L0bREFError;
+
+    GetValueAndErrorFromGraph(gl0bMB,runNumber,L0bMB,L0bMBError);
+    GetValueAndErrorFromGraph(gl0bREF,runNumber,L0bREF,L0bREFError);
+
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+
+    if (pileUpCorrected)
+    {
+      TGraphErrors* gpu = GetGraph((Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(kMB).Data())));
+
+      GetValueAndErrorFromGraph(gpu,runNumber,pileUpFactor,pileUpFactorError);
+    }
+
+    Double_t value;
+    Double_t error;
+
+    ScalerFnorm(value,error,
+                L0bREF,purityREF,purityREFerror,
+                L0bMB,purityMB,purityMBerror,
+                pileUpFactor,pileUpFactorError);
+
+    if ( value > 0.0 )
+    {
+      vx.push_back(1.0*runNumber);
+      vxerr.push_back(0.5);
+      vy.push_back(value);
+      vyerr.push_back(error);
+    }
+  }
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeGraphRelDif(const char* a, const char* b) const
+{
+  // compute dispersion of b versus a
+  //
+  // computed differences graphs are put into the GRAPHS/ directory
+  // computed differences results are put into the HISTOS/ directory
+
+  TString name(Form("RelDif%svs%s",b,a));
+
+  if ( GetGraph(name) )
+  {
+    // insure we compute it only once
+    return;
+  }
+
+  AliDebug(2,name);
+
+  TGraphErrors* ga = static_cast<TGraphErrors*>(MC()->GetObject(Form("/GRAPHS/%s",a)));
+  TGraphErrors* gb = static_cast<TGraphErrors*>(MC()->GetObject(Form("/GRAPHS/%s",b)));
+
+  if (!ga)
+  {
+    AliError(Form("Cannot get graph for %s",a));
+    return;
+  }
+
+  if (!gb)
+  {
+    AliError(Form("Cannot get graph for %s",b));
+    return;
+  }
+
+  if ( ga->GetN() != gb->GetN() )
+  {
+    AliError(Form("Cannot work with different number of points in the graphs : %d vs %d",
+                  ga->GetN(),gb->GetN()));
+    return;
+  }
+
+  TString title(Form("%s-%s (RelDif,%%)",b,a));
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  for ( Int_t i = 0; i < ga->GetN(); ++i )
+  {
+    Double_t xa,xb,ya,yb;
+
+    ga->GetPoint(i,xa,ya);
+    gb->GetPoint(i,xb,yb);
+
+    if ( xa != xb )
+    {
+      AliError(Form("Incompatible graphs : got xa=%e and xb=%e",xa,xb));
+      return;
+    }
+
+    Double_t newvalue = 0.0;
+
+    if ( TMath::Abs(xa) > 1E-12 )
+    {
+      newvalue = 100.0*( yb - ya ) / ya;
+    }
+
+    Double_t yerr = newvalue*AliAnalysisMuMuResult::ErrorAB(ya,ga->GetEY()[i],
+                                                            yb,gb->GetEY()[i]);
+
+    if ( fIsCompactGraphs )
+    {
+      xa = TString(ga->GetXaxis()->GetBinLabel(i+1)).Atoi()*1.0;
+    }
+
+    vx.push_back(xa);
+    vxerr.push_back(0.5);
+    vy.push_back(newvalue);
+    vyerr.push_back(yerr);
+
+  }
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+
+  // FIXME : fill here an histogram from the graph to get the
+  // weight of 1/e2 ?
+  //  h->Fill(newvalue,1.0/(yerr*yerr));
+  //  MC()->Adopt("/HISTOS/",h);
+
+  //  AliAnalysisMuMuResult* r = GetRunIntegratedResult(*g,"FnormDispersion");
+  //  if (r)
+  //  {
+  //    if (!dispersion)
+  //    {
+  //      dispersion = new AliAnalysisMuMuResult("FnormDispersion");
+  //    }
+  //    dispersion->AdoptSubResult(r);
+  //    if ( !TString(g->GetName()).BeginsWith("Fnorm") )
+  //    {
+  //      dispersion->Exclude(r->Alias());
+  //    }
+  //  }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputePileUpGraph(ETriggerType tt, Int_t eventSelectionCorrected)
+{
+  /// Compute the per-run graph of pile-up factor
+
+  TString graphName(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(tt).Data()));
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    Double_t pileUpFactor(1.0);
+    Double_t pileUpFactorError(0.0);
+    Double_t purity(1.0);
+    Double_t purityError(0.0);
+
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+
+    if (eventSelectionCorrected)
+    {
+      GetPurity(triggerClassName.Data(),runNumber,purity,purityError,eventSelectionCorrected);
+    }
+    ts.GetPileUpFactor(runNumber,triggerClassName.Data(),purity,pileUpFactor,pileUpFactorError);
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(pileUpFactor);
+    vyerr.push_back(pileUpFactorError);
+  }
+
+  TString title(Form("Pile-up correction factor for trigger %s",GetTriggerTypeName(tt).Data()));
+
+  if (eventSelectionCorrected)
+  {
+    title += "( L0BRate corrected by event selection";
+    title += GetEventSelectionName(eventSelectionCorrected);
+    title += " accept fraction)";
+  }
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected)
+{
+  /// Compute the per-run graph of physics selection accept fraction
+  /// for the given trigger
+
+  TString graphName(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(tt).Data()));
+
+  if (GetGraph(graphName))
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    Double_t purity, purityError;
+
+    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+
+    if ( triggerClassName.Length()==0 )
+    {
+      AliError(Form("Unknown trigger type %d",tt));
+      return;
+    }
+
+    GetPurity(triggerClassName.Data(),runNumber,purity,purityError,eventSelectionCorrected);
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    vy.push_back(purity);
+    vyerr.push_back(purityError);
+  }
+
+  TString title(Form("Fraction of events accepted by the event selection %s for trigger %s",GetTriggerTypeName(tt).Data(),
+                     GetEventSelectionName(eventSelectionCorrected).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeResultsFromGraphs()
+{
+  // Compute one single value for each graph, by weighting by the fraction
+  // of events in each run
+  // do this for certain groups of graphs
+
+  TObjArray groups;
+  groups.SetOwner(kTRUE);
+
+  groups.Add(new TObjString("Fnorm"));
+  groups.Add(new TObjString("NMBeq"));
+  groups.Add(new TObjString("Correction"));
+  groups.Add(new TObjString("RelDif"));
+
+  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+
+  TIter nextGroup(&groups);
+  TObjString* grp;
+
+  TIter next(objectList);
+  TObjString* str(0x0);
+
+  while ( ( grp = static_cast<TObjString*>(nextGroup()) ) )
+  {
+    TString oname(Form("/RESULTS/%s",grp->String().Data()));
+
+    if ( MC()->GetObject(oname) )
+    {
+      // delete if we have it already so we can replace it
+      MC()->Remove(oname);
+    }
+
+    AliAnalysisMuMuResult* result = new AliAnalysisMuMuResult(grp->String());
+
+    MC()->Adopt("/RESULTS/",result);
+
+    next.Reset();
+
+    while ( ( str = static_cast<TObjString*>(next()) ) )
+    {
+      if ( ! ( str->String().BeginsWith(grp->String() ) ) ) continue;
+
+      TGraphErrors* g = GetGraph(str->String());
+
+      if (!g) continue;
+
+      AliAnalysisMuMuResult* sub = GetRunIntegratedResult(*g);
+
+      if ( !sub )
+      {
+        AliError(Form("Could not get result for graph %s",g->GetName()));
+      }
+      if ( sub )
+      {
+        result->AdoptSubResult(sub);
+      }
+    }
+  }
+
+  delete objectList;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeNofEvents(ETriggerType triggerType,
+                                            Bool_t pileUpCorrected,
+                                            Int_t eventSelectionCorrected)
+{
+  /// Compute trigger fractions
+
+  TString graphName(Form("NofEvent%s%s%s",GetTriggerTypeName(triggerType).Data(),
+                         pileUpCorrected ? "PU" : "",
+                         GetEventSelectionName(eventSelectionCorrected).Data()));
+  // Check if Compute has already been done
+  if ( GetGraph(graphName) )
+  {
+    // compute it only once
+    return;
+  }
+
+  ComputeCorrectionFactors(eventSelectionCorrected);
+
+  TString gpsname(Form("Correction%s%s",GetEventSelectionName(eventSelectionCorrected).Data(),GetTriggerTypeName(triggerType).Data()));
+  TString gpuname(Form("CorrectionPU%s%s",GetEventSelectionName(eventSelectionCorrected).Data(), GetTriggerTypeName(triggerType).Data()));
+
+  TGraphErrors* gPS = GetGraph(gpsname);
+
+  if (!gPS)
+  {
+    AliError(Form("Could not find %s",gpsname.Data()));
+    return;
+  }
+
+  TGraphErrors* gPU = GetGraph(gpuname);
+
+  if (!gPU)
+  {
+    AliError(Form("Could not find %s",gpuname.Data()));
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  Int_t i(0);
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    if ( triggerClassName.Length() )
+    {
+      Double_t n = GetSum(triggerClassName,runNumber,0);
+
+      vx.push_back(runNumber);
+      vxerr.push_back(0.5);
+
+      assert(runNumber==TMath::Nint(gPU->GetX()[i]));
+
+      Double_t y(n);
+      Double_t y1(1.0);
+      Double_t y2(1.0);
+      Double_t e1(0);
+      Double_t e2(0);
+
+      if ( pileUpCorrected )
+      {
+        y1 = gPU->GetY()[i];
+        e1 = gPU->GetEY()[i];
+      }
+
+      if ( eventSelectionCorrected > 0 )
+      {
+        y2 = gPS->GetY()[i];
+        e2 = gPS->GetEY()[i];
+      }
+
+      y *= y1*y2;
+
+      AliDebug(2,Form("RUN %09d n %e y1 %e y2 %e y% e",runNumber,n,y1,y2,y));
+
+      Double_t yerr = y*AliAnalysisMuMuResult::ErrorABC( n, TMath::Sqrt(n),
+                                                        y1, e1,
+                                                        y2, e2);
+
+      vy.push_back(y);
+      vyerr.push_back(yerr);
+
+      ++i;
+    }
+  }
+
+  TString title(Form("Number of event of trigger %s",GetTriggerTypeName(triggerType).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeTriggerFractions(ETriggerType triggerType,
+                                                   Bool_t physicsSelectionCorrected)
+{
+  /// Compute trigger fractions
+
+  TString graphName(Form("Fractions%s%s",GetTriggerTypeName(triggerType).Data(),physicsSelectionCorrected ? "PS" : ""));
+
+  if ( GetGraph(graphName) )
+  {
+    // compute it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  const std::set<int>& runs = RunNumbers();
+
+  Double_t n(0.0);
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    if ( triggerClassName.Length() )
+    {
+      n += GetSum(triggerClassName,runNumber,physicsSelectionCorrected);
+    }
+  }
+
+  if ( n <= 0.0 )
+  {
+    AliWarning(Form("Got zero trigger for %s",GetTriggerTypeName(triggerType).Data()));
+    return;
+  }
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+    Double_t y = GetSum(triggerClassName,runNumber,physicsSelectionCorrected);
+    vy.push_back(y/n);
+    vyerr.push_back( (y/n) * AliAnalysisMuMuResult::ErrorAB( y,TMath::Sqrt(y),
+                                                        n, TMath::Sqrt(n)));
+  }
+
+
+  TString title(Form("Fraction of event of trigger %s",GetTriggerTypeName(triggerType).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ComputeTriggerL0B(ETriggerType triggerType)
+{
+  /// Compute trigger L0B
+
+  std::vector<double> vx;
+  std::vector<double> vxerr;
+  std::vector<double> vy;
+  std::vector<double> vyerr;
+
+  TString graphName(Form("L0B%s",GetTriggerTypeName(triggerType).Data()));
+
+  if ( GetGraph(graphName) )
+  {
+    // insure we're computing it only once
+    return;
+  }
+
+  AliDebug(2,graphName);
+
+  const std::set<int>& runs = RunNumbers();
+
+  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+
+  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+  {
+    Int_t runNumber = *it;
+
+    TString triggerClassName = GetTriggerClassName(triggerType,runNumber);
+
+    AliAnalysisTriggerScalerItem* item = ts.GetTriggerScaler(runNumber,"L0B",triggerClassName);
+    if (!item) continue;
+
+    vx.push_back(runNumber);
+    vxerr.push_back(0.5);
+
+    Double_t y = item->Value();
+
+    vy.push_back(y);
+
+    vyerr.push_back( TMath::Sqrt(y) );
+  }
+
+  TString title(Form("L0B of trigger %s",GetTriggerTypeName(triggerType).Data()));
+
+  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+}
+
+////_____________________________________________________________________________
+//void AliAnalysisMuMuFnormBeta::ComputeTSGraph(ETriggerType tt)
+//{
+//  /// Compute the per-run graph of physics selection accept fraction x track
+//  /// accept fraction for the given trigger
+//
+//  TString graphName(Form("CorrectionTS%s",GetTriggerTypeName(tt).Data()));
+//
+//  if (GetGraph(graphName))
+//  {
+//    // insure we're computing it only once
+//    return;
+//  }
+//
+//  AliDebug(1,graphName);
+//
+//  std::vector<double> vx;
+//  std::vector<double> vxerr;
+//  std::vector<double> vy;
+//  std::vector<double> vyerr;
+//
+//  const std::set<int>& runs = RunNumbers();
+//
+//  AliAnalysisTriggerScalers ts(runs,OCDBPath().Data());
+//
+//  for ( std::set<int>::const_iterator it = runs.begin(); it != runs.end(); ++it )
+//  {
+//    Int_t runNumber = *it;
+//
+//    Double_t purity, purityError;
+//
+//    TString triggerClassName = GetTriggerClassName(tt,runNumber);
+//
+//    if ( triggerClassName.Length()==0 )
+//    {
+//      AliError(Form("Unknown trigger type %d",tt));
+//      return;
+//    }
+//
+//    GetPurity(triggerClassName.Data(),runNumber,purity,purityError,"OFFLINE1");
+//
+//    vx.push_back(runNumber);
+//    vxerr.push_back(0.5);
+//    vy.push_back(purity);
+//    vyerr.push_back(purityError);
+//  }
+//
+//  TString title(Form("Fraction of events accepted by the physics selection x track selection for trigger %s",GetTriggerTypeName(tt).Data()));
+//
+//  CreateAndAddGraph(graphName,title,vx,vxerr,vy,vyerr);
+//}
+//
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuFnormBeta::CreateAndAddGraph(const TString& name,
+                                                      const TString& title,
+                                                      const std::vector<double>& vx,
+                                                      const std::vector<double>& vxerr,
+                                                      const std::vector<double>& vy,
+                                                      const std::vector<double>& vyerr) const
+{
+  /// Creates a graph and adds it to our mergeable collection
+
+  TGraphErrors* g = new TGraphErrors(vx.size(),&vx[0],&vy[0],&vxerr[0],&vyerr[0]);
+  g->SetName(name.Data());
+  g->SetTitle(title.Data());
+
+  if  (fIsCompactGraphs)
+  {
+    AliAnalysisMuMuGraphUtil::Compact(*g);
+  }
+
+  g->GetXaxis()->SetNoExponent();
+//  g->GetXaxis()->SetTitle("Run number");
+
+  TPaveText* text = new TPaveText(0.70,0.70,0.89,0.89,"NDC");
+  text->SetBorderSize(0);
+  text->SetFillColor(0);
+  text->AddText(Form("Mean %e",g->GetMean(2)));
+  text->AddText(Form("RMS  %e",g->GetRMS(2)));
+  g->GetListOfFunctions()->Add(text);
+
+  MC()->Adopt("/GRAPHS/",g);
+  return g;
+}
+
+//_____________________________________________________________________________
+AliMergeableCollection* AliAnalysisMuMuFnormBeta::DetachMC()
+{
+  // let go the ownership of our mergeable collection
+  fIsOwner = kFALSE;
+  return fMergeableCollection;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::DrawWith2Scales(const char* graphName1, const char* graphName2)
+{
+  TGraphErrors* g1 = static_cast<TGraphErrors*>(GetGraph(graphName1)->Clone());
+  TGraphErrors* g2 = static_cast<TGraphErrors*>(GetGraph(graphName2)->Clone());
+
+  if ( g1 && g2 )
+  {
+    gStyle->SetOptTitle(0);
+
+    AliAnalysisMuMuGraphUtil gu;
+
+    TCanvas* c = gu.DrawWith2Scales(*g1,*g2);
+    c->Draw();
+
+    for ( Int_t i = 0; i < 2; ++i )
+    {
+      c->cd(i);
+      gPad->SetLeftMargin(0.15);
+      gPad->SetRightMargin(0.15);
+    }
+
+    c->Update();
+
+    //    TGraphErrors* g = new TGraphErrors(g1->GetN());
+    //
+    //    Double_t check(0.0);
+    //
+    //    for ( Int_t i = 0; i < g->GetN(); ++i )
+    //    {
+    //      Double_t y = g1->GetY()[i]*g2->GetY()[i];
+    //
+    //      check += g2->GetY()[i];
+    //
+    //      g->SetPoint(i,g2->GetX()[i],y);
+    //      g->SetPointError(i,g2->GetEX()[i],
+    //                       y*AliAnalysisMuMuResult::ErrorAB(g1->GetY()[i],g1->GetEY()[i],
+    //                                                        g2->GetY()[i],g2->GetEY()[i]));
+    //    }
+    //
+    //    new TCanvas;
+    //
+    //    g->Draw("ap");
+    //
+    //    AliInfo(Form("check: %e g mean %e rms %e",check,g->GetMean(2),g->GetRMS(2)));
+
+    /*
+
+    // g1 vs g2
+
+    TGraphErrors* g = new TGraphErrors(g1->GetN());
+
+    for ( Int_t i = 0; i < g->GetN(); ++i )
+    {
+      g->SetPoint(i,g2->GetY()[i],g1->GetY()[i]);
+      g->SetPointError(i,g2->GetEY()[i],g1->GetEY()[i]);
+    }
+
+    new TCanvas;
+
+    g->Draw("ap");
+
+    AliInfo(Form("g mean %e rms %e",g->GetMean(2),g->GetRMS(2)));
+
+     */
+
+  }
+
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetEventSelectionName(Int_t eventSelectionCorrected) const
+{
+  if ( eventSelectionCorrected == 1 )
+  {
+    return "PS";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    return "TS";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuFnormBeta::GetGraph(const char* name) const
+{
+  // shortcut method to give access to one graph
+
+  TObject* o = MC()->GetObject(Form("/GRAPHS/%s",name));
+
+  if (!o) return 0x0;
+
+  if ( o->IsA() != TGraphErrors::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+
+  return static_cast<TGraphErrors*>(o);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::GetPurity(const char* triggerClassName, Int_t runNumber,
+                                     Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const
+{
+  /// Get the physics selection accept fraction for a given trigger
+
+  value=error=0.0;
+
+  TString runCondition;
+
+  if (runNumber>0)
+  {
+    runCondition.Form("/run:%d",runNumber);
+  }
+
+  Double_t nall = fCounterCollection.GetSum(Form("trigger:%s/event:ALL%s",triggerClassName,runCondition.Data()));
+
+  TString ename;
+
+  if ( eventSelectionCorrected == 1 )
+  {
+    ename = "PSALL";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    ename = "OFFLINE1";
+  }
+  else
+  {
+    value = 1.0;
+    return;
+
+  }
+  Double_t nps = fCounterCollection.GetSum(Form("trigger:%s/event:%s%s",
+                                                triggerClassName,ename.Data(),runCondition.Data()));
+
+  if ( nall <= 0.0 ) return;
+
+  value = nps/nall;
+
+  error = AliAnalysisMuMuResult::ErrorAB(nall,TMath::Sqrt(nall),nps,TMath::Sqrt(nps));
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuResult* AliAnalysisMuMuFnormBeta::GetResult(const char* name) const
+{
+  // shortcut method to give access to one result
+
+  TObject* o = MC()->GetObject(Form("/RESULTS/%s",name));
+
+  if (!o) return 0x0;
+
+  if ( o->IsA() != AliAnalysisMuMuResult::Class() )
+  {
+    AliError(Form("Object %s is not of the expected type",o->GetName()));
+    return 0x0;
+  }
+
+  return static_cast<AliAnalysisMuMuResult*>(o);
+}
+
+//______________________________________________________________________________
+AliAnalysisMuMuResult* AliAnalysisMuMuFnormBeta::GetRunIntegratedResult(const TGraphErrors& g, const char* basename)
+{
+  /// get one value +- error for this graph (weighting the run-by-run values
+  /// by the fraction of the number of triggers in that run)
+  /// also the rms is computed.
+
+  Bool_t physicsSelectionCorrected(kFALSE);
+
+  if ( TString(g.GetName()).Contains("PS") )
+  {
+    physicsSelectionCorrected=kTRUE;
+  }
+
+  ComputeTriggerFractions(fReferenceTriggerType,physicsSelectionCorrected);
+
+  TString fname(Form("Fractions%s%s",GetTriggerTypeName(fReferenceTriggerType).Data(),physicsSelectionCorrected ? "PS" : ""));
+
+  TGraphErrors* gTriggerFractions = GetGraph(fname);
+
+  StdoutToAliDebug(2,std::cout << g.GetName() << std::endl; g.Print(););
+
+  if (!gTriggerFractions)
+  {
+    AliError(Form("Did not find graph for %s",fname.Data()));
+    return 0x0;
+  }
+
+  Double_t mean = g.GetY()[0];
+  Int_t n = g.GetN();
+
+  Double_t errorOnMean = g.GetEY()[0];
+  Double_t rms = 0.0;
+
+  if ( n > 1 )
+  {
+    mean = errorOnMean = 0.0;
+    Double_t d(0.0);
+    Double_t v1(0.0);
+    Double_t v2(0.0);
+
+    for ( Int_t i = 0; i < n; ++i )
+    {
+      Double_t y = g.GetY()[i];
+
+      Double_t weight = gTriggerFractions->GetY()[i]; // sum of weight should be 1.0
+
+      AliDebug(2,Form("%s i %3d y %e weight %e",g.GetName(),i,y,weight));
+
+      mean += y * weight;
+
+      v1 += weight;
+      v2 += weight*weight;
+    }
+
+    mean /= v1;
+
+    for ( Int_t i = 0; i < n; ++i )
+    {
+      Double_t weight = gTriggerFractions->GetY()[i]; // sum of weight should be 1.0
+      Double_t y = g.GetY()[i];
+
+      d += (y-mean)*(y-mean)*weight;
+    }
+
+    AliDebug(2,Form("v1=%e v2=%e d=%e",v1,v2,d));
+
+    if ( v1 <= 0) return 0x0;
+
+    errorOnMean = TMath::Sqrt((1.0/v1)*(1.0/(n-1))*d);
+
+    rms = TMath::Sqrt( (v1/(v1*v1-v2))*d );
+  }
+
+  AliAnalysisMuMuResult* result = new AliAnalysisMuMuResult(g.GetName(),g.GetTitle());
+
+  result->Set(basename,mean,errorOnMean,rms);
+
+  if ( TString(g.GetName()) == "FnormScalersPUPS" )
+  {
+    AliDebug(1,Form("mean %e errorOnMean %e rms %e",mean,errorOnMean,rms));
+    StdoutToAliDebug(1,result->Print("full"));
+  }
+
+  return result;
+}
+
+//_____________________________________________________________________________
+Double_t AliAnalysisMuMuFnormBeta::GetSum(const char* triggerClassName,
+                                      Int_t runNumber,
+                                      Int_t eventSelectionCorrected) const
+{
+  TString condition(Form("trigger:%s/run:%d",triggerClassName,runNumber));
+
+  if (eventSelectionCorrected==1)
+  {
+    condition += "/event:PSALL";
+  }
+  else if ( eventSelectionCorrected == 2 )
+  {
+    condition += "/event:OFFLINE1";
+  }
+  else
+  {
+    condition += "/event:ALL";
+  }
+
+  Double_t n = fCounterCollection.GetSum(condition.Data());
+
+  if (n<=0)
+  {
+    AliError(Form("Got no count for %s for run %d (physicsSelected:%d)",triggerClassName,runNumber,eventSelectionCorrected));
+    return 0;
+  }
+
+  return n;
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetTriggerClassName(ETriggerType tt, Int_t runNumber) const
+{
+  // get the triggerclass to for a given trigger type and run number
+
+  if ( tt == kMB )
+  {
+    return MBTriggerClassName(runNumber);
+  }
+  else if ( tt == kMUL )
+  {
+    return MULTriggerClassName(runNumber);
+  }
+  else if ( tt == kMSL)
+  {
+    return MSLTriggerClassName(runNumber);
+  }
+  else if ( tt == kMSH)
+  {
+    return MSHTriggerClassName(runNumber);
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::GetTriggerTypeName(ETriggerType tt) const
+{
+  // get the name of the trigger type
+  if ( tt == kMB )
+  {
+    return "MB";
+  }
+  else if ( tt == kMUL )
+  {
+    return "MUL";
+  }
+  else if ( tt == kMSL)
+  {
+    return "MSL";
+  }
+  else if ( tt == kMSH)
+  {
+    return "MSH";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::GetValueAndErrorFromGraph(TGraphErrors* graph,
+                                                     Int_t runNumber,
+                                                     Double_t& value,
+                                                     Double_t& error) const
+{
+  /// get (value,error) corresponding to run=runNumber.
+  /// Works both for compact and non-compact graphs
+
+  value = TMath::Limits<Double_t>::Max();
+  error = 0.0;
+
+  if (!graph) return;
+
+  TAxis* axis = graph->GetXaxis();
+
+  for ( Int_t i = 0; i < graph->GetN(); ++i )
+  {
+    Int_t rbin = TMath::Nint(graph->GetX()[i]);
+    Int_t rlabel = TString(axis->GetBinLabel(i+1)).Atoi();
+    if ( rbin == runNumber || rlabel == runNumber )
+    {
+      value = graph->GetY()[i];
+      error = graph->GetEY()[i];
+    }
+  }
+}
+
+//_____________________________________________________________________________
+AliMergeableCollection* AliAnalysisMuMuFnormBeta::MC() const
+{
+  // get our mergeable collection
+  if (!fMergeableCollection)
+  {
+    fMergeableCollection = new AliMergeableCollection("Fnorm",Form("MB to %s trigger normalization results",GetTriggerTypeName(fReferenceTriggerType).Data()));
+  }
+  return fMergeableCollection;
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MBTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CINT7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CINT7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CPBI2_B1-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CPBI2_B1-B-NOPF-ALLNOTRD";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MSHTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CMSH7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CMSH7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CMSH7-B-NOPF-MUON",runNumber) )
+  {
+    return "CMSH7-B-NOPF-MUON";
+  }
+  return "";
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MSLTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CMSL7-B-NOPF-MUON",runNumber) )
+  {
+      return "CMSL7-B-NOPF-MUON";
+  }
+ else
+   if ( TriggerClassnameTest("CPBI1MSL-B-NOPF-MUON",runNumber) )
+ {
+   return "CPBI1MSL-B-NOPF-MUON";
+ }
+  return "";
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::MultiplyGraphs(const char* g1name, const char* g2name, const char* name)
+{
+  /// Make a new graph = g1*g2
+  std::vector<double> vx;
+  std::vector<double> vy;
+  std::vector<double> vxerr;
+  std::vector<double> vyerr;
+
+  TGraphErrors* g1 = GetGraph(g1name);
+  TGraphErrors* g2 = GetGraph(g2name);
+
+  if (!g1)
+  {
+    AliError(Form("Could not get graph %s",g1name));
+    return;
+  }
+
+  if (!g2)
+  {
+    AliError(Form("Could not get graph %s",g2name));
+    return;
+  }
+
+  if ( g1->GetN() != g2->GetN() )
+  {
+    AliError(Form("Could not multiply incompatible graphs %d pts vs %d pts",g1->GetN(),g2->GetN()));
+    return;
+  }
+
+  for ( Int_t i = 0; i < g1->GetN(); ++i )
+  {
+    if ( g1->GetX()[i] != g2->GetX()[i] )
+    {
+      AliError(Form("Incompatible bin %d : %e vs %e",i,g1->GetX()[i],g2->GetX()[i]));
+      return;
+    }
+
+    vx.push_back(g1->GetX()[i]);
+    vxerr.push_back(g1->GetEX()[i]);
+
+    Double_t y = g1->GetY()[i]*g2->GetY()[i];
+    Double_t yerr = y*AliAnalysisMuMuResult::ErrorAB( g1->GetY()[i], g1->GetEY()[i],
+                                                     g2->GetY()[i], g2->GetEY()[i]);
+
+    vy.push_back(y);
+    vyerr.push_back(yerr);
+  }
+
+  TString gname(name);
+
+  if ( gname.Length() == 0 )
+  {
+    gname = g1->GetName();
+    gname += "x";
+    gname += g2->GetName();
+  }
+
+  TString title(Form("Product of %s by %s",g1->GetName(),g2->GetName()));
+
+  CreateAndAddGraph(gname,title,vx,vxerr,vy,vyerr);
+}
+
+//_____________________________________________________________________________
+TString AliAnalysisMuMuFnormBeta::MULTriggerClassName(Int_t runNumber) const
+{
+  /// FIXME : find a better way ?
+
+  if ( TriggerClassnameTest("CMUL7-B-NOPF-ALLNOTRD",runNumber) )
+  {
+    return "CMUL7-B-NOPF-ALLNOTRD";
+  }
+  else if ( TriggerClassnameTest("CMUL7-B-NOPF-MUON",runNumber) )
+  {
+    return "CMUL7-B-NOPF-MUON";
+  }
+  else if ( TriggerClassnameTest("CPBI1MUL-B-NOPF-MUON",runNumber) )
+  {
+    return "CPBI1MUL-B-NOPF-MUON";
+  }
+  return "";
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::Print(Option_t* opt) const
+{
+  if ( fMergeableCollection )
+  {
+    fMergeableCollection->Print(opt);
+  }
+}
+
+//_____________________________________________________________________________
+std::set<int> AliAnalysisMuMuFnormBeta::RunNumbers() const
+{
+  // Extract the run numbers from our counter collection
+
+  std::set<int> runset;
+
+  TString sruns = fCounterCollection.GetKeyWords("run");
+  TObjArray* runs = sruns.Tokenize(",");
+
+  TIter next(runs);
+  TObjString* s;
+
+  while ( ( s = static_cast<TObjString*>(next())) )
+  {
+    runset.insert(s->String().Atoi());
+  }
+  delete runs;
+
+  return runset;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ScalerFnorm(Double_t& value, Double_t& error,
+                                       Double_t L0bREF, Double_t purityREF, Double_t purityREFerror,
+                                       Double_t L0bMB, Double_t purityMB, Double_t purityMBerror,
+                                       Double_t pileUpFactor, Double_t pileUpFactorError)
+{
+  /// Compute the MB to REF ratio and its associated error
+
+  value = error = 0.0;
+
+  value = L0bREF*purityREF;
+
+  if (!value) return;
+
+  value = L0bMB*purityMB*pileUpFactor/value;
+
+  error = value*AliAnalysisMuMuResult::ErrorABCDE(L0bREF,TMath::Sqrt(L0bREF),
+                                                  purityREF,purityREFerror,
+                                                  L0bMB,TMath::Sqrt(L0bMB),
+                                                  purityMB,purityMBerror,
+                                                  pileUpFactor,pileUpFactorError);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuFnormBeta::ShowFnorm(const TObjArray& a) const
+{
+  /// Print and plot Fnorm values
+  TIter next(&a);
+  TGraphErrors* g;
+
+  while ( ( g = static_cast<TGraphErrors*>(next()) ) )
+  {
+    g->SetTitle(Form("Fnorm %s",g->GetTitle()));
+
+    new TCanvas(Form("c%s",g->GetName()));
+
+    if (fIsCompactGraphs)
+    {
+      AliAnalysisMuMuGraphUtil::Compact(*g);
+    }
+    else
+    {
+      g->GetXaxis()->SetNoExponent();
+    }
+    g->Draw("lpa");
+
+    Double_t y(0.0);
+    Double_t yerr(0.0);
+
+    for ( Int_t i = 0; i < g->GetN(); ++i )
+    {
+      y += g->GetY()[i];
+      Double_t e = ( y != 0.0  ? g->GetEY()[i]/y : 0.0);
+
+      yerr += e*e;
+    }
+
+    y /= (g->GetN());
+    yerr = TMath::Sqrt(yerr)*y;
+
+    AliInfo(Form("%30s graph %e +- %e (%5.2f %%) RMS %e",g->GetName(),
+                 y,yerr,yerr*100/y,g->GetRMS(2)));
+
+  }
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuFnormBeta::TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const
+{
+  /// Check if we have counts for that trigger,run combination
+
+  TString runs = fCounterCollection.GetKeyWords("run");
+
+  if ( !runs.Contains(Form("%d",runNumber)) ) return kFALSE;
+
+  TString triggers = fCounterCollection.GetKeyWords("trigger");
+
+  if (!triggers.Contains(triggerClassName)) return kFALSE;
+
+  Double_t n = fCounterCollection.GetSum(Form("trigger:%s/run:%d",triggerClassName,runNumber));
+
+  return ( n > 0.0 );
+}
+
+//_____________________________________________________________________________
+void
+AliAnalysisMuMuFnormBeta::WeightedMeanGraphs(const char* patternOrList, const char* graphName)
+{
+  /// Sum the graphs which name matches pattern
+  /// Sum is made using a weighted mean (each element is weighted by the inverse
+  /// of its error squared)
+
+  TString spattern(patternOrList);
+  TObjArray* slist(0x0);
+
+  if ( spattern.CountChar(',') )
+  {
+    // it's not a pattern but a list...
+    slist = spattern.Tokenize(",");
+    spattern = "";
+  }
+
+  TList* objectList = MC()->CreateListOfObjectNames("/GRAPHS/");
+  TIter next(objectList);
+  TObjString* str(0x0);
+  TObjArray selected;
+  selected.SetOwner(kFALSE);
+
+  while ( ( str = static_cast<TObjString*>(next()) ) )
+  {
+    TGraphErrors* g = GetGraph(str->String());
+
+    if (!g) continue;
+
+    TString name(g->GetName());
+
+    if ( spattern.Length() >0 && !name.Contains(spattern.Data()) ) continue;
+
+    if ( slist && !slist->FindObject(name)) continue;
+
+    AliDebug(2,Form("Selected for sum : %s",name.Data()));
+
+    selected.Add(g);
+  }
+
+  delete slist;
+  delete objectList;
+
+  if (selected.GetLast()<0) return;
+
+  std::vector<double> vx;
+  std::vector<double> vy;
+  std::vector<double> vxerr;
+  std::vector<double> vyerr;
+
+  Int_t npts = static_cast<TGraphErrors*>(selected.First())->GetN();
+
+  for ( Int_t ipoint = 0; ipoint < npts; ++ipoint )
+  {
+    Double_t x(0.0),xref(0.0),xerr(0.0);
+    Double_t sum(0.0);
+    Double_t sume2(0.0);
+
+    for ( Int_t igraph = 0; igraph <= selected.GetLast(); ++igraph )
+    {
+      TGraphErrors* g = static_cast<TGraphErrors*>(selected.At(igraph));
+
+      if ( g->GetN() != npts )
+      {
+        AliError(Form("Graph %s does not have the expected %d points",g->GetName(),npts));
+        continue;
+      }
+      Double_t runNumber;
+
+      if ( fIsCompactGraphs )
+      {
+        runNumber = TString(g->GetXaxis()->GetBinLabel(ipoint+1)).Atoi()*1.0;
+      }
+      else
+      {
+        runNumber = g->GetX()[ipoint];
+      }
+
+      if ( igraph == 0 )
+      {
+        xref = g->GetX()[ipoint];
+        x = runNumber;
+        xerr = g->GetEX()[ipoint];
+      }
+      else
+      {
+        if ( xref != g->GetX()[ipoint] )
+        {
+          AliError(Form("Cannot sum graphs with different axis : get %e and expected %e : %s vs %s",xref,x,selected.At(0)->GetName(),g->GetName()));
+          return;
+        }
+      }
+
+      Double_t e2 = g->GetEY()[ipoint]*g->GetEY()[ipoint];
+
+      if ( e2 != 0.0 )
+      {
+        sum += g->GetY()[ipoint]/e2;
+        sume2 += 1.0/e2;
+      }
+    }
+
+    if (sume2 != 0.0)
+    {
+      vx.push_back(x);
+      vxerr.push_back(xerr);
+      vy.push_back(sum/sume2);
+      vyerr.push_back(TMath::Sqrt(1/sume2));
+    }
+  }
+
+  Int_t n = selected.GetEntries();
+
+  TString name(graphName);
+  TString title(Form("Weighted mean from %d individual graphs",n));
+
+  if ( strlen(graphName) == 0)
+  {
+    name = TString::Format("WeightMeanFnorm%s",patternOrList);
+    name.ReplaceAll(",","_");
+    title = TString::Format("WeightMeanFnorm%s from %d individual graphs",patternOrList,n);
+  }
+
+  CreateAndAddGraph(name,title,vx,vxerr,vy,vyerr);
+}
diff --git a/PWG/muondep/AliAnalysisMuMuFnormBeta.h b/PWG/muondep/AliAnalysisMuMuFnormBeta.h
new file mode 100644
index 0000000..1281bba
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuFnormBeta.h
@@ -0,0 +1,148 @@
+#ifndef ALIANALYSISMUMUFNORMBETA_H
+#define ALIANALYSISMUMUFNORMBETA_H
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+#ifndef ROOT_TObject
+#  include "TObject.h"
+#endif
+
+#ifndef ROOT_TString
+#  include "TString.h"
+#endif
+
+#include <set>
+#include <vector>
+
+class TObjArray;
+class TGraphErrors;
+class TGraph;
+class AliAnalysisMuMuResult;
+class AliCounterCollection;
+class AliMergeableCollection;
+
+class AliAnalysisMuMuFnormBeta : public TObject
+{
+
+public:
+
+  enum ETriggerType
+  {
+    kMB=1,
+    kMUL=2,
+    kMSL=3,
+    kMSH=4
+  };
+
+  AliAnalysisMuMuFnormBeta(AliCounterCollection& cc,
+                       AliAnalysisMuMuFnormBeta::ETriggerType triggerType=AliAnalysisMuMuFnormBeta::kMUL,
+                       const char* ocdbpath="raw://",
+                       Bool_t compactGraphs=kFALSE);
+
+  virtual ~AliAnalysisMuMuFnormBeta();
+
+  void ComputeFnorm();
+
+  void ComputeCorrectionFactors(Int_t eventSelectionCorrected);
+
+  void ComputeFnormOffline(Int_t nstep, Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+
+  void ComputeFnormScalers(Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+  void ComputeGraphRelDif(const char* a, const char* b) const;
+
+  void ComputeNofEvents(ETriggerType triggerType, Bool_t pileUpCorrected, Int_t eventSelectionCorrected);
+
+  void ComputePileUpGraph(ETriggerType tt, Int_t eventSelectionCorrected=0);
+
+  void ComputeEventSelectionGraph(ETriggerType tt, Int_t eventSelectionCorrected);
+
+  void ComputeResultsFromGraphs();
+
+  void ComputeTriggerFractions(ETriggerType triggerType, Bool_t physicsSelectionCorrected);
+
+  void ComputeTriggerL0B(ETriggerType tt);
+
+  //  void ComputeTSGraph(ETriggerType tt); // Commented out in the implementation file
+
+  AliMergeableCollection* DetachMC();
+
+  void DrawWith2Scales(const char* graphName1, const char* graphName2);
+
+  TString GetEventSelectionName(Int_t eventSelectionCorrected) const;
+
+  //  void GetFnorm(Int_t runNumber, const char* eventSelection, Double_t& value, Double_t& error) const; // Not implemented
+
+  TGraphErrors* GetGraph(const char* name) const;
+
+  void GetPurity(const char* triggerClassName, Int_t runNumber, Double_t& value, Double_t& error, Int_t eventSelectionCorrected) const;
+
+  void GetValueAndErrorFromGraph(TGraphErrors* graph,
+                                 Int_t runNumber,
+                                 Double_t& value,
+                                 Double_t& error) const;
+
+  AliAnalysisMuMuResult* GetResult(const char* name) const;
+
+  AliAnalysisMuMuResult* GetRunIntegratedResult(const TGraphErrors& g, const char* basename="Fnorm");
+
+  AliMergeableCollection* MC() const;
+
+  void MultiplyGraphs(const char* g1, const char* g2, const char* name="");
+
+  TString OCDBPath() const { return fOCDBPath; }
+
+  void Print(Option_t* opt="") const;
+
+  void ScalerFnorm(Double_t& value, Double_t& error,
+                   Double_t L0bCMUL7, Double_t purityCMUL7, Double_t purityCMUL7error,
+                   Double_t L0bCINT7, Double_t purityCINT7, Double_t purityCINT7error,
+                   Double_t pileUpFactor, Double_t pileUpFactorError);
+
+  void ShowFnorm(const TObjArray& a) const;
+
+  Bool_t TriggerClassnameTest(const char* triggerClassName, Int_t runNumber) const;
+
+  void WeightedMeanGraphs(const char* pattern, const char* name="");
+
+private:
+
+  AliAnalysisMuMuFnormBeta(const AliAnalysisMuMuFnormBeta& rhs); // not implemented on purpose
+  AliAnalysisMuMuFnormBeta& operator=(const AliAnalysisMuMuFnormBeta& rhs); // not implemented on purpose
+
+  TGraphErrors* CreateAndAddGraph(const TString& name,
+                                  const TString& title,
+                                  const std::vector<double>& vx,
+                                  const std::vector<double>& vxerr,
+                                  const std::vector<double>& vy,
+                                  const std::vector<double>& vyerr) const;
+
+  Double_t GetSum(const char* triggerClassName, Int_t runNumber, Int_t eventSelectionCorrected) const;
+
+  TString GetTriggerClassName(ETriggerType tt, Int_t runNumber) const;
+
+  TString GetTriggerTypeName(ETriggerType tt) const;
+
+  std::set<int> RunNumbers() const;
+
+  TString MBTriggerClassName(Int_t runNumber) const;
+  TString MSLTriggerClassName(Int_t runNumber) const;
+  TString MULTriggerClassName(Int_t runNumber) const;
+  TString MSHTriggerClassName(Int_t runNumber) const;
+
+private:
+
+  /*const*/ AliCounterCollection& fCounterCollection; // collection of trigger counters (not owner)
+  mutable AliMergeableCollection* fMergeableCollection; // collection of results, histograms, graphs (ownership is in fIsOwner)
+  Bool_t fIsOwner; // whether we are the owner of the mergeable collection
+  TString fOCDBPath; // OCDB to be used (raw:// by default)
+  mutable AliAnalysisMuMuResult* fResult; // combined result of the various computations
+  Bool_t fIsCompactGraphs; // whether the graph produced should be compact
+  ETriggerType fReferenceTriggerType; // reference trigger to get the weighting factors
+
+  ClassDef(AliAnalysisMuMuFnormBeta,0) // class to compute MB to MUON trigger normalization factor
+};
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx b/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
index 16b1af2..c117631 100644
--- a/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
+++ b/PWG/muondep/AliAnalysisMuMuJpsiResult.cxx
@@ -59,7 +59,7 @@ ClassImp(AliAnalysisMuMuJpsiResult)
 
 
 namespace {
-  
+
   //____________________________________________________________________________
   const std::map<std::string,Double_t>& MassMap()
   {
@@ -69,9 +69,9 @@ namespace {
     // can decide on our particle naming
     if (massMap.empty())
     {
-      massMap["JPsi"] = 3.096916e+00;
-      massMap["PsiP"] = 3.68609e+00;
-      massMap["Upsilon"] = 9.46030e+00;
+      massMap["JPsi"]         = 3.096916e+00;
+      massMap["PsiP"]         = 3.68609e+00;
+      massMap["Upsilon"]      = 9.46030e+00;
       massMap["UpsilonPrime"] = 1.00233e+01;
     }
     return massMap;
@@ -88,18 +88,18 @@ namespace {
     value = str(index+1,str.Length()-index-1);
     return kTRUE;
   }
-    
-  const TString kKeyFunc = "Func";
-  const TString kKeyRange = "Range";
-  const TString kKeyRebin = "Rebin";
-  const TString kFitRangeLow = "FitRangeLow";
+
+  const TString kKeyFunc      = "Func";
+  const TString kKeyRange     = "Range";
+  const TString kKeyRebin     = "Rebin";
+  const TString kFitRangeLow  = "FitRangeLow";
   const TString kFitRangeHigh = "FitRangeHigh";
-  const TString kKeyCount = "Count";
+  const TString kKeyCount     = "Count";
   const TString kKeyHistoType = "HistoType";
-  const TString kKeyTails = "Tails";
-  const TString kKeySPsiP = "FSigmaPsiP"; //Factor to fix the psi' sigma to sigmaJPsi*SigmaPsiP (Usually factor SigmaPsiP = 1, 0.9 and 1.1)
-  const TString kKeyMinvRS = "MinvRS"; // FIXME: not very correct since "MinvRS" is in AliAnalysisMuMu::GetParametersFromResult
-  
+  const TString kKeyTails     = "Tails";
+  const TString kKeySPsiP     = "FSigmaPsiP"; //Factor to fix the psi' sigma to sigmaJPsi*SigmaPsiP (Usually factor SigmaPsiP = 1, 0.9 and 1.1)
+  const TString kKeyMinvRS    = "MinvRS"; // FIXME: not very correct since "MinvRS" is in AliAnalysisMuMu::GetParametersFromResult
+
 }
 
 //_____________________________________________________________________________
@@ -144,14 +144,14 @@ fParticle(particle),
 fMinvRS("")
 {
   SetHisto(h);
-  
+
   DecodeFitType(fitType);
-  
+
   TString name(fFitFunction);
   if ( !name.Contains("PSICB2") && !name.Contains("PSINA60NEW") && !name.Contains("PSICOUNT") ) //To avoid adding things to the name of simu results
   {
     Bool_t isMPt = kFALSE;
-    
+
     if ( name.BeginsWith("PSI") ) name.ReplaceAll("PSIPSIPRIME","");
     else if ( name.BeginsWith("MPT") )
     {
@@ -173,14 +173,14 @@ fMinvRS("")
     }
   }
   SetName(name.Data());
-  
+
   Int_t rebin = TMath::Nint(GetValue(kKeyRebin));
-  
+
   if (rebin>0)
   {
     fHisto->Rebin(rebin);
   }
-  
+
   if ( fHisto->GetEntries()<100 && !TString(GetName()).Contains(kKeyCount) )
   {
     // not enough statistics to perform a fit.
@@ -243,14 +243,14 @@ fMinvRS(rhs.fMinvRS)
   if ( rhs.fHisto )
   {
     fHisto = static_cast<TH1*>(rhs.fHisto->Clone());
-  }  
+  }
 }
 
 //_____________________________________________________________________________
 AliAnalysisMuMuJpsiResult& AliAnalysisMuMuJpsiResult::operator=(const AliAnalysisMuMuJpsiResult& rhs)
 {
   /// Assignment operator
-  
+
   if (this!=&rhs)
   {
     static_cast<AliAnalysisMuMuResult&>(*this) = static_cast<const AliAnalysisMuMuResult&>(rhs);
@@ -260,7 +260,7 @@ AliAnalysisMuMuJpsiResult& AliAnalysisMuMuJpsiResult::operator=(const AliAnalysi
     {
       fHisto = static_cast<TH1*>(rhs.fHisto->Clone());
     }
-    
+
     fNofRuns = rhs.NofRuns();
     fNofTriggers = rhs.NofTriggers();
     fBin = rhs.Bin();
@@ -276,7 +276,7 @@ AliAnalysisMuMuJpsiResult& AliAnalysisMuMuJpsiResult::operator=(const AliAnalysi
     fMinvRS = rhs.fMinvRS;
 
   }
-  
+
   return *this;
 }
 
@@ -295,24 +295,24 @@ void AliAnalysisMuMuJpsiResult::AttachFunctionsToHisto(TF1* signal, TF1* bck, TF
   if (signal)
   {
     signal->SetLineColor(1);
-    signal->SetNpx(1000);
+    signal->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(signal);
   }
 
   if ( bck )
   {
     bck->SetLineColor(2);
-    bck->SetNpx(1000);
+    bck->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(bck);
   }
-  
+
   if ( total )
   {
     total->SetLineColor(4);
-    total->SetNpx(1000);
+    total->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(total);
   }
-  
+
   TLine* l1 = new TLine(xmin,0,xmin,fHisto->GetMaximum()*0.8);
   TLine* l2 = new TLine(xmax,0,xmax,fHisto->GetMaximum()*0.8);
   l1->SetLineColor(6);
@@ -332,28 +332,28 @@ void AliAnalysisMuMuJpsiResult::AttachFunctionsToHisto(TF1* signal1, TF1* signal
     signal1->SetNpx(1000);
     fHisto->GetListOfFunctions()->Add(signal1);
   }
-  
+
   if (signal2)
   {
     signal2->SetLineColor(3);
-    signal2->SetNpx(1000);
+    signal2->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(signal2);
   }
-  
+
   if ( bck )
   {
     bck->SetLineColor(2);
-    bck->SetNpx(1000);
+    bck->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(bck);
   }
-  
+
   if ( total )
   {
     total->SetLineColor(4);
-    total->SetNpx(1000);
+    total->SetNpx(8000);
     fHisto->GetListOfFunctions()->Add(total);
   }
-  
+
   TLine* l1 = new TLine(xmin,0,xmin,fHisto->GetMaximum()*0.8);
   TLine* l2 = new TLine(xmax,0,xmax,fHisto->GetMaximum()*0.8);
   l1->SetLineColor(6);
@@ -382,7 +382,7 @@ TObject* AliAnalysisMuMuJpsiResult::Clone(const char* /*newname*/) const
 Bool_t AliAnalysisMuMuJpsiResult::Correct(const AliAnalysisMuMuJpsiResult& other, const char* particle, const char* subResultName)
 {
   /// Assuming other has an AccxEff entry, correct this value by AccxEff of other
-  
+
   if ( HasValue(Form("Nof%s",particle)) )
   {
     if (!other.HasValue(Form("AccEff%s",particle),subResultName))
@@ -390,19 +390,19 @@ Bool_t AliAnalysisMuMuJpsiResult::Correct(const AliAnalysisMuMuJpsiResult& other
       AliError(Form("Cannot correct as I do not find the AccEff%s value (subResultName=%s)!",particle,subResultName));
       return kFALSE;
     }
-    
+
     Double_t acc = other.GetValue(Form("AccEff%s",particle),subResultName);
     Double_t value = 0.0;
-    
+
     if ( acc > 0 ) value = GetValue(Form("Nof%s",particle)) / acc;
-    
+
     Double_t error = ErrorAB( GetValue(Form("Nof%s",particle)),
                               GetErrorStat(Form("Nof%s",particle)),
                               other.GetValue(Form("AccEff%s",particle),subResultName),
                               other.GetErrorStat(Form("AccEff%s",particle),subResultName) );
-                                    
+
     Set(Form("CorrNof%s",particle),value,error*value);
-    
+
     return kTRUE;
   }
   else
@@ -423,32 +423,32 @@ void AliAnalysisMuMuJpsiResult::Draw(Option_t* opt)
 Double_t AliAnalysisMuMuJpsiResult::CountParticle(const TH1& hminv, const char* particle, Double_t sigma)
 {
   /// Count the number of entries in an invariant mass range
-  
+
   const std::map<std::string,Double_t>& m = MassMap();
-  
+
   std::map<std::string,Double_t>::const_iterator it = m.find(particle);
-  
+
   if ( it == m.end() )
   {
     AliErrorClass(Form("Don't know the mass of particle %s",particle));
     return 0.0;
   }
-  
+
   Double_t mass = it->second;
-  
+
   if ( sigma < 0 )
   {
     AliDebugClass(1,Form("Oups. Got a sigma of %e for particle %s !",sigma,particle));
     return hminv.Integral();
   }
-  
+
   const TAxis* x = hminv.GetXaxis();
 
   Int_t b1 = x->FindFixBin(mass-sigma);
   Int_t b2 = x->FindFixBin(mass+sigma);
-  
+
   AliDebugClass(1,Form("hminv getentries %e integral %e",hminv.GetEntries(),hminv.Integral(b1,b2)));
-  
+
   return hminv.Integral(b1,b2);
 }
 
@@ -456,7 +456,7 @@ Double_t AliAnalysisMuMuJpsiResult::CountParticle(const TH1& hminv, const char*
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundLin(Double_t *x, Double_t *par)
 {
   // Linear function for Bkg 2 params
-  
+
   if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
   {
     TF1::RejectPoint();
@@ -466,10 +466,52 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundLin(Double_t *x, Double
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2(Double_t *x, Double_t *par)
+{
+  // Linear function for Bkg 2 params
+
+  if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
+  {
+    TF1::RejectPoint();
+    return 0.;
+  }
+  else TF1::RejectPoint(kFALSE);
+  return (par[0]*x[0] + par[1] )/(par[2]*x[0]*x[0] + par[3]*x[0] + par[4]) ;
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3(Double_t *x, Double_t *par)
+{
+  // Linear function for Bkg 7 params
+
+  if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
+  {
+    TF1::RejectPoint();
+    return 0.;
+  }
+  else TF1::RejectPoint(kFALSE);
+  return (  par[0]*x[0]*x[0] + x[0]*par[1] + par[2]  )/( par[3]*x[0]*x[0]*x[0]+ par[4]*x[0]*x[0] + par[5]*x[0] + par[6]) ;
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3V2(Double_t *x, Double_t *par)
+{
+  // Linear function for Bkg 6 params
+
+  if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
+  {
+    TF1::RejectPoint();
+    return 0.;
+  }
+  else TF1::RejectPoint(kFALSE);
+  return (  par[0]*x[0]*x[0] + x[0]*par[1] + par[2]  )/( (par[3] + x[0])*(par[4] + x[0])*(par[5] + x[0])) ;
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2(Double_t *x, Double_t *par)
 {
   // pol2 3 params
-  
+
   if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
   {
     TF1::RejectPoint();
@@ -482,7 +524,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2(Double_t *x, Doubl
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol3(Double_t *x, Double_t *par)
 {
   // pol2 4 params
-  
+
   if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
   {
     TF1::RejectPoint();
@@ -495,7 +537,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol3(Double_t *x, Doubl
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4(Double_t *x, Double_t *par)
 {
   // pol2 5 params
-  
+
   if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
   {
     TF1::RejectPoint();
@@ -508,7 +550,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4(Double_t *x, Doubl
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp(Double_t *x, Double_t *par)
 {
   // pol2 x exp : 4 params
-  
+
   if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
   {
     TF1::RejectPoint();
@@ -522,7 +564,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp(Double_t *x, Do
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp(Double_t *x, Double_t *par)
 {
   // pol4 x exp : 6 params
-  
+
   if (fRejectFitPoints &&  x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
   {
     TF1::RejectPoint();
@@ -538,17 +580,33 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp(Double_t *x, Do
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG(Double_t *x, Double_t *par)
 {
   // gaussian variable width : 4 params
-  
+
   if (fRejectFitPoints && x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
   {
     TF1::RejectPoint();
     return 0.;
   }
+  else TF1::RejectPoint(kFALSE);
   Double_t sigma = par[2]+par[3]*((x[0]-par[1])/par[1]);
   return par[0]*TMath::Exp(-(x[0]-par[1])*(x[0]-par[1])/(2.*sigma*sigma));
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2(Double_t *x, Double_t *par)
+{
+  // gaussian variable width : 5 params
+
+  if (fRejectFitPoints && x[0] > fFitRejectRangeLow && x[0] < fFitRejectRangeHigh )
+  {
+    TF1::RejectPoint();
+    return 0.;
+  }
+  else TF1::RejectPoint(kFALSE);
+  Double_t sigma = par[2] + par[3]*((x[0]-par[1])/par[1]) + par[4]*((x[0]-par[1])/par[1])*((x[0]-par[1])/par[1]);
+  return par[0]*TMath::Exp(-(x[0]-par[1])*(x[0]-par[1])/(2.*sigma*sigma));
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended(Double_t *x,Double_t *par)
 {
   // Extended Crystal Ball : 7 parameters
@@ -560,33 +618,33 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended(Double_
   // par[4] = n
   // par[5] = alpha'
   // par[6] = n'
-  
+
   Double_t t = (x[0]-par[1])/par[2];
   if (par[3] < 0) t = -t;
-  
+
   Double_t absAlpha = fabs((Double_t)par[3]);
   Double_t absAlpha2 = fabs((Double_t)par[5]);
-  
+
   if (t >= -absAlpha && t < absAlpha2) // gaussian core
   {
     return par[0]*(exp(-0.5*t*t));
   }
-  
+
   if (t < -absAlpha) //left tail
   {
     Double_t a =  TMath::Power(par[4]/absAlpha,par[4])*exp(-0.5*absAlpha*absAlpha);
     Double_t b = par[4]/absAlpha - absAlpha;
     return par[0]*(a/TMath::Power(b - t, par[4]));
   }
-  
+
   if (t >= absAlpha2) //right tail
   {
-    
+
     Double_t c =  TMath::Power(par[6]/absAlpha2,par[6])*exp(-0.5*absAlpha2*absAlpha2);
     Double_t d = par[6]/absAlpha2 - absAlpha2;
     return par[0]*(c/TMath::Power(d + t, par[6]));
   }
-  
+
   return 0. ;
 }
 
@@ -607,16 +665,16 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionNA60New(Double_t *x,Double_t *par
   // par[9] = alphaLeft
   // par[10] = alphaRight
 
-  
+
   const Double_t t = (x[0]-par[1])/par[2];
-  
+
   Double_t sigmaRatio(0.);
   if( t < par[9] ) sigmaRatio = ( 1.0 + TMath::Power( par[3]*(par[9]-t), par[4]-par[5]*TMath::Sqrt(par[9] - t) ) );
   else if( t >= par[9] && t < par[10] ) sigmaRatio = 1;
   else if( t >= par[10] ) sigmaRatio = ( 1.0 + TMath::Power( par[6]*(t-par[10]), par[7]-par[8]*TMath::Sqrt(t - par[10]) ) );
-  
+
   return par[0]*TMath::Exp( -(1/2.)*TMath::Power(t/sigmaRatio,2.));
-  
+
 }
 
 //____________________________________________________________________________
@@ -624,9 +682,9 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG(Double_t *x, D
 {
   /// 2 NA60 (new) + pol2 x exp
   /// width of the second NA60 related to the first (free) one.
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[15],
     3.68609+(par[5]-3.096916)/3.096916*3.68609,
@@ -644,13 +702,85 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG(Double_t *x, D
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG2(Double_t *x, Double_t *par)
+{
+  /// 2 NA60 (new) + pol2 x exp
+  /// width of the second NA60 related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[11] = {
+    par[16],
+    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+    par[7]*SPsiPFactor, // /3.096916*3.68609
+    par[8],
+    par[9],
+    par[10],
+    par[11],
+    par[12],
+    par[13],
+    par[14],
+    par[15],
+  };
+  return FitFunctionBackgroundVWG2(x, par) + FitFunctionNA60New(x, &par[5]) + FitFunctionNA60New(x, par2);
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol1Pol2(Double_t *x, Double_t *par)
+{
+  /// 2 NA60 (new) + pol2 x exp
+  /// width of the second NA60 related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[11] = {
+    par[16],
+    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+    par[7]*SPsiPFactor, // /3.096916*3.68609
+    par[8],
+    par[9],
+    par[10],
+    par[11],
+    par[12],
+    par[13],
+    par[14],
+    par[15],
+  };
+  return FitFunctionBackgroundPol1Pol2(x, par) + FitFunctionNA60New(x, &par[5]) + FitFunctionNA60New(x, par2);
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol2Pol3(Double_t *x, Double_t *par)
+{
+  /// 2 NA60 (new) + pol2 x exp
+  /// width of the second NA60 related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[11] = {
+    par[18],
+    3.68609+(par[8]-3.096916)/3.096916*3.68609,
+    par[9]*SPsiPFactor, // /3.096916*3.68609
+    par[10],
+    par[11],
+    par[12],
+    par[13],
+    par[14],
+    par[15],
+    par[16],
+    par[17],
+  };
+  return FitFunctionBackgroundPol2Pol3(x, par) + FitFunctionNA60New(x, &par[7]) + FitFunctionNA60New(x, par2);
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol2Exp(Double_t *x, Double_t *par)
 {
   /// 2 NA60 (new) + pol2 x exp
   /// width of the second NA60 related to the first (free) one.
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[15],
     3.68609+(par[5]-3.096916)/3.096916*3.68609,
@@ -673,9 +803,9 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol4Exp(Double_t *
 {
   /// 2 NA60 (new) + pol4 x exp
   /// width of the second NA60 related to the first (free) one.
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[17],
     3.68609+(par[7]-3.096916)/3.096916*3.68609,
@@ -697,9 +827,9 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Lin(Double_t *x, Doubl
 {
   /// 2 extended crystal balls + Pol1
   /// width of the second CB related to the first (free) one.
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[7] = {
     par[9],
     3.68609+(par[3]-3.096916)/3.096916*3.68609,
@@ -713,59 +843,119 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Lin(Double_t *x, Doubl
 }
 
 //____________________________________________________________________________
-Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp(Double_t *x, Double_t *par)
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol1Pol2(Double_t *x, Double_t *par)
 {
-  /// 2 extended crystal balls + pol2 x exp
+  /// 2 extended crystal balls + Pol1
   /// width of the second CB related to the first (free) one.
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[7] = {
-    par[11],
-    3.68609+(par[5]-3.096916)/3.096916*3.68609,
-    par[6]*SPsiPFactor, // /3.096916*3.68609,
-    par[7],
+    par[12],
+    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+    par[7]*SPsiPFactor, // /3.096916*3.68609,
     par[8],
     par[9],
-    par[10]
+    par[10],
+    par[11]
   };
-  return FitFunctionBackgroundPol2Exp(x, par) + FitFunctionSignalCrystalBallExtended(x, &par[4]) + FitFunctionSignalCrystalBallExtended(x, par2);
+  return FitFunctionBackgroundPol1Pol2(x, par)   + FitFunctionSignalCrystalBallExtended(x, &par[5]) + FitFunctionSignalCrystalBallExtended(x, par2);
 }
 
-////____________________________________________________________________________
-//Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp(Double_t *x, Double_t *par)
-//{
-//  /// 2 extended crystal balls + pol2 x exp
-//  /// width of the second CB related to the first (free) one.
-//
-//  Double_t par2[7] = {
-//    par[12],
-//    3.68609+(par[6]-3.096916)/3.096916*3.68609,
-//    par[7]/3.096916*3.68609,
-//    par[8],
-//    par[9],
-//    par[10],
-//    par[11]
-//  };
-//  return FitFunctionBackgroundPol2Exp(x, par) + FitFunctionSignalCrystalBallExtended(x, &par[5]) + FitFunctionSignalCrystalBallExtended(x, par2);
-//}
-
 //____________________________________________________________________________
-Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol4Exp(Double_t *x, Double_t *par)
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Pol3(Double_t *x, Double_t *par)
 {
-  /// 2 extended crystal balls + pol4 x exp
+  /// 2 extended crystal balls + Pol1
   /// width of the second CB related to the first (free) one.
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[7] = {
-    par[13],
-    3.68609+(par[7]-3.096916)/3.096916*3.68609,
-    par[8]*SPsiPFactor, // /3.096916*3.68609,
-    par[9],
+    par[14],
+    3.68609+(par[8]-3.096916)/3.096916*3.68609,
+    par[9]*SPsiPFactor, // /3.096916*3.68609,
     par[10],
     par[11],
-    par[12]
+    par[12],
+    par[13]
+  };
+  return FitFunctionBackgroundPol2Pol3(x, par)   + FitFunctionSignalCrystalBallExtended(x, &par[7]) + FitFunctionSignalCrystalBallExtended(x, par2);
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Pol3V2(Double_t *x, Double_t *par)
+{
+  /// 2 extended crystal balls + Pol2/pol3
+  /// width of the second CB related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[7] = {
+    par[13],
+    3.68609+(par[7]-3.096916)/3.096916*3.68609,
+    par[9]*SPsiPFactor, // /3.096916*3.68609,
+    par[9],
+    par[10],
+    par[11],
+    par[12]
+  };
+  return FitFunctionBackgroundPol2Pol3V2(x, par)   + FitFunctionSignalCrystalBallExtended(x, &par[6]) + FitFunctionSignalCrystalBallExtended(x, par2);
+}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp(Double_t *x, Double_t *par)
+{
+  /// 2 extended crystal balls + pol2 x exp
+  /// width of the second CB related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[7] = {
+    par[11],
+    3.68609+(par[5]-3.096916)/3.096916*3.68609,
+    par[6]*SPsiPFactor, // /3.096916*3.68609,
+    par[7],
+    par[8],
+    par[9],
+    par[10]
+  };
+  return FitFunctionBackgroundPol2Exp(x, par) + FitFunctionSignalCrystalBallExtended(x, &par[4]) + FitFunctionSignalCrystalBallExtended(x, par2);
+}
+
+////____________________________________________________________________________
+//Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp(Double_t *x, Double_t *par)
+//{
+//  /// 2 extended crystal balls + pol2 x exp
+//  /// width of the second CB related to the first (free) one.
+//
+//  Double_t par2[7] = {
+//    par[12],
+//    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+//    par[7]/3.096916*3.68609,
+//    par[8],
+//    par[9],
+//    par[10],
+//    par[11]
+//  };
+//  return FitFunctionBackgroundPol2Exp(x, par) + FitFunctionSignalCrystalBallExtended(x, &par[5]) + FitFunctionSignalCrystalBallExtended(x, par2);
+//}
+
+//____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol4Exp(Double_t *x, Double_t *par)
+{
+  /// 2 extended crystal balls + pol4 x exp
+  /// width of the second CB related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[7] = {
+    par[13],
+    3.68609+(par[7]-3.096916)/3.096916*3.68609,
+    par[8]*SPsiPFactor, // /3.096916*3.68609,
+    par[9],
+    par[10],
+    par[11],
+    par[12]
   };
   return FitFunctionBackgroundPol4Exp(x, par) + FitFunctionSignalCrystalBallExtended(x, &par[6]) + FitFunctionSignalCrystalBallExtended(x, par2);
 }
@@ -775,7 +965,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol4Exp(Double_t *x, D
 //{
 //  /// 2 extended crystal balls + pol4 x exp
 //  /// width of the second CB related to the first (free) one.
-//  
+//
 //  Double_t par2[7] = {
 //    par[14],
 //    3.68609+(par[8]-3.096916)/3.096916*3.68609,
@@ -793,9 +983,9 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG(Double_t *x, Doubl
 {
   /// 2 extended crystal balls + VWG
   /// width of the second CB related to the first (free) one.
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[7] = {
     par[11],
     3.68609+(par[5]-3.096916)/3.096916*3.68609,
@@ -809,13 +999,33 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG(Double_t *x, Doubl
 }
 
 //____________________________________________________________________________
+Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG2(Double_t *x, Double_t *par)
+{
+  /// 2 extended crystal balls + VWG2
+  /// width of the second CB related to the first (free) one.
+
+  Double_t SPsiPFactor = GetValue(kKeySPsiP);
+
+  Double_t par2[7] = {
+    par[12],
+    3.68609+(par[6]-3.096916)/3.096916*3.68609,
+    par[7]*SPsiPFactor, // /3.096916*3.68609,
+    par[8],
+    par[9],
+    par[10],
+    par[11]
+  };
+  return FitFunctionBackgroundVWG2(x, par) + FitFunctionSignalCrystalBallExtended(x, &par[5]) + FitFunctionSignalCrystalBallExtended(x, par2);
+}
+
+//____________________________________________________________________________
 Double_t AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWGINDEPTAILS(Double_t *x, Double_t *par)
 {
   /// 2 extended crystal balls + pol2 x exp
   /// The tail parameters are independent but the sPsiP and mPsiP are fixed to the one of the JPsi
-  
+
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[7] = {
     par[11],
     3.68609+(par[5]-3.096916)/3.096916*3.68609,
@@ -867,7 +1077,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2Lin(Double_t *x, Doubl
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -881,8 +1091,8 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2Lin(Double_t *x, Doubl
     par[9],
     par[10]
   };
-  
-  
+
+
   return alphaCB2VWG(x,par)*par[12] + alphaCB2VWG(x,par2)*par[15] + (1. - alphaCB2VWG(x,par) - alphaCB2VWG(x,par2))*FitFunctionBackgroundPol2(x,&par[13]);
 }
 
@@ -899,7 +1109,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2(Double_t *x, D
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -913,8 +1123,8 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2(Double_t *x, D
     par[9],
     par[10]
   };
-  
-  
+
+
   return alphaCB2VWG(x,par)*par[12] + alphaCB2VWG(x,par2)*par[16] + (1. - alphaCB2VWG(x,par) - alphaCB2VWG(x,par2))*FitFunctionBackgroundPol2(x,&par[13]);
 }
 
@@ -923,7 +1133,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2EXP(Double_t *x
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -937,8 +1147,8 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2EXP(Double_t *x
     par[9],
     par[10]
   };
-  
-  
+
+
   return alphaCB2VWG(x,par)*par[12] + alphaCB2VWG(x,par2)*par[17] + (1. - alphaCB2VWG(x,par) - alphaCB2VWG(x,par2))*FitFunctionBackgroundPol2Exp(x,&par[13]);
 }
 
@@ -947,7 +1157,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2POL2EXPPOL2(Double_t *
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -961,8 +1171,8 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2POL2EXPPOL2(Double_t *
     par[9],
     par[10]
   };
-  
-  
+
+
   return alphaCB2POL2EXP(x,par)*par[12] + alphaCB2POL2EXP(x,par2)*par[16] + (1. - alphaCB2POL2EXP(x,par) - alphaCB2POL2EXP(x,par2))*FitFunctionBackgroundPol2(x,&par[13]);
 
 }
@@ -972,7 +1182,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2POL2EXPPOL2EXP(Double_
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -986,10 +1196,10 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2POL2EXPPOL2EXP(Double_
     par[9],
     par[10]
   };
-  
-  
+
+
   return alphaCB2POL2EXP(x,par)*par[12] + alphaCB2POL2EXP(x,par2)*par[17] + (1. - alphaCB2POL2EXP(x,par) - alphaCB2POL2EXP(x,par2))*FitFunctionBackgroundPol2Exp(x,&par[13]);
-  
+
 }
 
 //____________________________________________________________________________
@@ -997,7 +1207,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWVWGPOL2(Double_t *
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[15] = {
     par[0],
     par[1],
@@ -1017,7 +1227,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWVWGPOL2(Double_t *
   };
 
   return alphaNA60NEWVWG(x,par)*par[16] + alphaNA60NEWVWG(x,par2)*par[20] + (1. - alphaNA60NEWVWG(x,par) - alphaNA60NEWVWG(x,par2))*FitFunctionBackgroundPol2(x,&par[17]);
-  
+
 }
 
 //____________________________________________________________________________
@@ -1025,7 +1235,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWVWGPOL2EXP(Double_
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[15] = {
     par[0],
     par[1],
@@ -1043,10 +1253,10 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWVWGPOL2EXP(Double_
     par[13],
     par[14],
   };
-  
-  
+
+
   return alphaNA60NEWVWG(x,par)*par[16] + alphaNA60NEWVWG(x,par2)*par[21] + (1. - alphaNA60NEWVWG(x,par) - alphaNA60NEWVWG(x,par2))*FitFunctionBackgroundPol2Exp(x,&par[17]);
-  
+
 }
 
 //____________________________________________________________________________
@@ -1054,7 +1264,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2(Double
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[15] = {
     par[0],
     par[1],
@@ -1071,10 +1281,10 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2(Double
     par[12],
     par[13],
     par[14],
-  };  
-  
+  };
+
   return alphaNA60NEWPOL2EXP(x,par)*par[16] + alphaNA60NEWPOL2EXP(x,par2)*par[20] + (1. - alphaNA60NEWPOL2EXP(x,par) - alphaNA60NEWPOL2EXP(x,par2))*FitFunctionBackgroundPol2(x,&par[17]);
-  
+
 }
 
 //____________________________________________________________________________
@@ -1082,7 +1292,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2EXP(Dou
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[15] = {
     par[0],
     par[1],
@@ -1099,10 +1309,10 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2EXP(Dou
     par[12],
     par[13],
     par[14],
-  };  
-  
+  };
+
   return alphaNA60NEWPOL2EXP(x,par)*par[16] + alphaNA60NEWPOL2EXP(x,par2)*par[21] + (1. - alphaNA60NEWPOL2EXP(x,par) - alphaNA60NEWPOL2EXP(x,par2))*FitFunctionBackgroundPol2Exp(x,&par[17]);
-  
+
 }
 
 //____________________________________________________________________________
@@ -1110,7 +1320,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL3(Double_t *x, D
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -1124,8 +1334,8 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL3(Double_t *x, D
     par[9],
     par[10]
   };
-  
-  
+
+
   return alphaCB2VWG(x,par)*par[12] + alphaCB2VWG(x,par2)*par[17] + (1. - alphaCB2VWG(x,par) - alphaCB2VWG(x,par2))*FitFunctionBackgroundPol2(x,&par[13]);
 }
 
@@ -1134,7 +1344,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL4(Double_t *x, D
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -1148,8 +1358,8 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL4(Double_t *x, D
     par[9],
     par[10]
   };
-  
-  
+
+
   return alphaCB2VWG(x,par)*par[12] + alphaCB2VWG(x,par2)*par[18] + (1. - alphaCB2VWG(x,par) - alphaCB2VWG(x,par2))*FitFunctionBackgroundPol4(x,&par[13]);
 }
 
@@ -1158,7 +1368,7 @@ Double_t AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2INDEPTAILS(Doub
 {
   // Fit function for Jpsi(Psip) mean pt with alphaJpsi and alphaPsiP with independent tails
   Double_t SPsiPFactor = GetValue(kKeySPsiP);
-  
+
   Double_t par2[11] = {
     par[0],
     par[1],
@@ -1189,25 +1399,25 @@ void AliAnalysisMuMuJpsiResult::FitPSICB2()
 {
   /// Fit using 1 extended crystal balls (pure signal)
   TString particleName(GetParticle());
-  
+
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue(Form("al%s",particleName.Data()));
   Double_t nLow = GetValue(Form("nl%s",particleName.Data()));
   Double_t alphaUp = GetValue(Form("au%s",particleName.Data()));
   Double_t nUp = GetValue(Form("nu%s",particleName.Data()));
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   TString msg;
-  
+
   if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
   if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
   if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
   if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
-  
+
   AliDebug(1,Form("Fit with jpsi CB2 %s",msg.Data()));
-  
+
   // Extended Crystal Ball : 7 parameters
   //
   // par[0] = Normalization
@@ -1217,44 +1427,44 @@ void AliAnalysisMuMuJpsiResult::FitPSICB2()
   // par[4] = n
   // par[5] = alpha'
   // par[6] = n'
-  
+
   TF1* fitTotal = new TF1("signal",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fitRangeLow,fitRangeHigh,7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  
+
   fitTotal->SetParNames(Form("k%s",particleName.Data()),Form("m%s",particleName.Data()),Form("s%s",particleName.Data()),Form("al%s",particleName.Data()),
   //                                 0                                1                              2                                 3
                         Form("nl%s",particleName.Data()),Form("au%s",particleName.Data()),Form("nu%s",particleName.Data()));
   //                                   4                                 5                              6
-  
+
   fitTotal->SetParameter(0, fHisto->GetMaximum()); // norm
-  
+
   if (particleName.Contains("JPsi"))
   {
     fitTotal->SetParameter(1, 3.1);
     fitTotal->SetParLimits(1, 3.08, 3.2);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else if (particleName.Contains("PsiP"))
   {
     fitTotal->SetParameter(1, 3.7);
     fitTotal->SetParLimits(1, 3.63, 3.72);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else AliError(Form("Could not set initial fit parameters for particle %s: The fit might not converge",particleName.Data()));
-  
+
   SetParameter(fitTotal,3,alphaLow,0.9,0.1,10.0);
   SetParameter(fitTotal,4,nLow,5.0,0.0,10.0);
   SetParameter(fitTotal,5,alphaUp,2.0,0.1,10.0);
   SetParameter(fitTotal,6,nUp,3.0,0.0,10.0);
-  
+
 //  fitTotal->FixParameter(3, alphaLow);
 //  fitTotal->FixParameter(4, nLow);
 //  fitTotal->FixParameter(5, alphaUp);
 //  fitTotal->FixParameter(6, nUp);
-  
-  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERI","");
-  
+
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERL","");
+
   // Check parameters...
   if (
       StrongCorrelation(fitResult,fitTotal,3,4,2) ||
@@ -1266,91 +1476,94 @@ void AliAnalysisMuMuJpsiResult::FitPSICB2()
       )
   {
     // try again...
-    fitResult = fHisto->Fit(fitTotal,"SERI","");
+    fitResult = fHisto->Fit(fitTotal,"SERL","");
   }
-  
+
   TF1* signal = new TF1("signal",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","SignalCB2");
-  
+
   signal->SetParameters(fitTotal->GetParameter(0),fitTotal->GetParameter(1),fitTotal->GetParameter(2),fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6));
 
   Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
+
   Set(Form("m%s",particleName.Data()),fitTotal->GetParameter(1),fitTotal->GetParError(1));
   Set(Form("s%s",particleName.Data()),fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  
+
   Set(Form("al%s",particleName.Data()),fitTotal->GetParameter(3),fitTotal->GetParError(3));
   Set(Form("nl%s",particleName.Data()),fitTotal->GetParameter(4),fitTotal->GetParError(4));
   Set(Form("au%s",particleName.Data()),fitTotal->GetParameter(5),fitTotal->GetParError(5));
   Set(Form("nu%s",particleName.Data()),fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  
+
   AttachFunctionsToHisto(signal,0x0,fitTotal,fitRangeLow,fitRangeHigh);
-  
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = fitTotal->Integral(a,b)/fHisto->GetBinWidth(1);
   double nerr = fitTotal->IntegralError(a,b)/fHisto->GetBinWidth(1);
-  
+
   Set(Form("Nof%s",particleName.Data()),njpsi,nerr);
-  
+
   double m = GetValue(Form("m%s",particleName.Data()));
   double s = GetValue(Form("s%s",particleName.Data()));
   double al = GetValue(Form("al%s",particleName.Data()));
   double au = GetValue(Form("au%s",particleName.Data()));
-  
+
   double njpsiCore = fitTotal->Integral(m-al*s,m+au*s)/fHisto->GetBinWidth(1);
   double nerrCore = fitTotal->IntegralError(m-al*s,m+au*s)/fHisto->GetBinWidth(1);
-  
+
   double njpsiTailL = fitTotal->Integral(a,m-al*s)/fHisto->GetBinWidth(1);
   double nerrTailL = fitTotal->IntegralError(a,m-al*s)/fHisto->GetBinWidth(1);
-  
+
   double njpsiTailR = fitTotal->Integral(m+au*s,b)/fHisto->GetBinWidth(1);
   double nerrTailR = fitTotal->IntegralError(m+au*s,b)/fHisto->GetBinWidth(1);
-  
+
   Set(Form("Nof%sCore",particleName.Data()),njpsiCore,nerrCore);
   Set(Form("Nof%sTailL",particleName.Data()),njpsiTailL,nerrTailL);
   Set(Form("Nof%sTailR",particleName.Data()),njpsiTailR,nerrTailR);
-  
+
+  // new TCanvas;
+  // fHisto->DrawCopy();
+
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuJpsiResult::FitPSINA60NEW()
 {
   /// Fit using 1 new NA60 (pure signal)
-  
+
   TString particleName(GetParticle());
-  
+
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t p1Left = GetValue(Form("p1L%s",particleName.Data()));
   Double_t p2Left = GetValue(Form("p2L%s",particleName.Data()));
   Double_t p3Left = GetValue(Form("p3L%s",particleName.Data()));
   Double_t p1Right = GetValue(Form("p1R%s",particleName.Data()));
   Double_t p2Right = GetValue(Form("p2R%s",particleName.Data()));
   Double_t p3Right = GetValue(Form("p3R%s",particleName.Data()));
-  
+
   Double_t alphaLeft = GetValue(Form("aL%s",particleName.Data()));
   Double_t alphaRight = GetValue(Form("aR%s",particleName.Data()));
-  
-  
+
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   TString msg;
-  
+
   if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
   if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
   if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
   if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
   if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
   if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
-  
+
   if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
   if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
-  
+
   AliDebug(1,Form("Fit with jpsi NA60 new %s",msg.Data()));
-  
+
   // New NA60 : 11 parameters
   //
   // par[0] = Normalization
@@ -1364,66 +1577,66 @@ void AliAnalysisMuMuJpsiResult::FitPSINA60NEW()
   // par[8] = p3Right
   // par[9] = alphaLeft
   // par[10] = alphaRight
-  
+
   TF1* fitTotal = new TF1("fitSignal",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fitRangeLow,fitRangeHigh,11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
-  
+
   fitTotal->SetParNames(Form("k%s",particleName.Data()),Form("m%s",particleName.Data()),Form("s%s",particleName.Data()),Form("p1L%s",particleName.Data()),
         //                                 0                                1                              2                                 3
                         Form("p2L%s",particleName.Data()),Form("p3L%s",particleName.Data()),Form("p1R%s",particleName.Data()),Form("p2R%s",particleName.Data()),
         //                                   4                                 5                              6                            7
                         Form("p3R%s",particleName.Data()),Form("aL%s",particleName.Data()),Form("aR%s",particleName.Data()));
         //                                   8                                 9                              10
-  
+
   fitTotal->SetParameter(0, fHisto->GetMaximum()); // norm
-  
+
   if (particleName.Contains("JPsi"))
   {
     fitTotal->SetParameter(1, 3.1);
     fitTotal->SetParLimits(1, 3.08, 3.2);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else if (particleName.Contains("PsiP"))
   {
     fitTotal->SetParameter(1, 3.7);
     fitTotal->SetParLimits(1, 3.63, 3.72);
     fitTotal->SetParameter(2, 0.08);
-    fitTotal->SetParLimits(2, 0.05, 0.15);
+    fitTotal->SetParLimits(2, 0.03, 0.2);
   }
   else AliError(Form("Could not set initial fit parameters for particle %s: The fit might not converge",particleName.Data()));
-  
+
   SetParameter(fitTotal,3,p1Left,0.02,0.001,2.0);
   SetParameter(fitTotal,4,p2Left,0.4,0.2,0.6);
   SetParameter(fitTotal,5,p3Left,0.2,0.05,0.4);
   SetParameter(fitTotal,6,p1Right,0.2,0.001,0.4);
   SetParameter(fitTotal,7,p2Right,1.0,0.0,1.4);
   SetParameter(fitTotal,8,p3Right,0.02,0.005,0.4);
-  
+
   SetParameter(fitTotal,9,alphaLeft,0.0,-1.5,1.5);
   SetParameter(fitTotal,10,alphaRight,2.3,2.0,2.5);
-  
+
 //  fitTotal->SetParameter(3, 0.2);
 //  fitTotal->SetParameter(4, 2.0);
 //  fitTotal->SetParameter(5, 1.);
 //  fitTotal->SetParameter(6, 0.1);
 //  fitTotal->SetParameter(7, 2.4);
 //  fitTotal->SetParameter(8, 1.1);
-//  
+//
 //  fitTotal->SetParameter(9, 1.0);
 //  fitTotal->SetParameter(10, 1.0);
-  
+
 //  SetParameter(fitTotal,3,p1Left,0.1,-1.E5,1.E5);
 //  SetParameter(fitTotal,4,p2Left,1.6,-1.E5,1.E5);
 //  SetParameter(fitTotal,5,p3Left,0.06,-1.E5,1.E5);
 //  SetParameter(fitTotal,6,p1Right,0.1,-1.E5,1.E5);
 //  SetParameter(fitTotal,7,p2Right,1.5,-1.E5,1.E5);
 //  SetParameter(fitTotal,8,p3Right,0.1,-1.E5,1.E5);
-//  
+//
 //  SetParameter(fitTotal,9,alphaLeft,1.,-1.E8,1.E5);
 //  SetParameter(fitTotal,10,alphaRight,1.0,-1.E5,1.E5);
-  
-  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERI","");
-  
+
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,"SERL","");
+
   // Check parameters...
 //  if (
 //      StrongCorrelation(fitResult,fitTotal,3,4,2) ||
@@ -1438,64 +1651,372 @@ void AliAnalysisMuMuJpsiResult::FitPSINA60NEW()
 //    fitResult = fHisto->Fit(fitTotal,"SER","");
 //  }
   TF1* signal = new TF1("signal",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","SignalNA60New");
-  
+
   signal->SetParameters(fitTotal->GetParameter(0),fitTotal->GetParameter(1),fitTotal->GetParameter(2),fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6),fitTotal->GetParameter(7),fitTotal->GetParameter(8),fitTotal->GetParameter(9));
   signal->SetParameter(10,fitTotal->GetParameter(10));
-  
+
   Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
+
   Set(Form("m%s",particleName.Data()),fitTotal->GetParameter(1),fitTotal->GetParError(1));
   Set(Form("s%s",particleName.Data()),fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  
+
   Set(Form("p1L%s",particleName.Data()),fitTotal->GetParameter(3),fitTotal->GetParError(3));
   Set(Form("p2L%s",particleName.Data()),fitTotal->GetParameter(4),fitTotal->GetParError(4));
   Set(Form("p3L%s",particleName.Data()),fitTotal->GetParameter(5),fitTotal->GetParError(5));
   Set(Form("p1R%s",particleName.Data()),fitTotal->GetParameter(6),fitTotal->GetParError(6));
   Set(Form("p2R%s",particleName.Data()),fitTotal->GetParameter(7),fitTotal->GetParError(7));
   Set(Form("p3R%s",particleName.Data()),fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  
+
   Set(Form("aL%s",particleName.Data()),fitTotal->GetParameter(9),fitTotal->GetParError(9));
   Set(Form("aR%s",particleName.Data()),fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  
+
   AttachFunctionsToHisto(signal,0x0,fitTotal,fitRangeLow,fitRangeHigh);
-  
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = fitTotal->Integral(a,b)/fHisto->GetBinWidth(1);
   double nerr = fitTotal->IntegralError(a,b)/fHisto->GetBinWidth(1);
-  
+
   Set(Form("Nof%s",particleName.Data()),njpsi,nerr);
 }
 
+// //_____________________________________________________________________________
+// void AliAnalysisMuMuJpsiResult::FitPSICB2VWG()
+// {
+//     /// Fit using 1 extended crystal ball (signal) + variable width gaussian (background)
+//     //Refresh
+//     fHisto->GetListOfFunctions()->Delete();
+//     //Check if values given in MuMuConfig
+//     Double_t alphaLow = GetValue("alJPsi");
+//     Double_t nLow = GetValue("nlJPsi");
+//     Double_t alphaUp = GetValue("auJPsi");
+//     Double_t nUp = GetValue("nuJPsi");
+//     Double_t fitRangeLow = GetValue(kFitRangeLow);
+//     Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+//     TString msg;
+//     //Output Message
+//     if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+//     if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+//     if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+//     if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+
+//     AliDebug(1,Form("Fit with jpsi VWG %s",msg.Data()));
+
+//     //  std::cout << "Tails parameters: " << msg.Data() << std::endl;
+//     //Create pointer and configure signal+bck fit functions
+//     TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalOneCB2VWG,fitRangeLow,fitRangeHigh,11,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
+
+//     fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
+//     //                        0      1       2       3       4      5      6
+//                           "alJPsi","nlJPsi","auJPsi","nuJPsi");
+//     //                         7        8        9        10
+
+
+//     // Create pointer for bck function
+//     TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+//     const char* fitOption = "SERLI"; //We can add NO to avoid plotting
+
+// //#if 0
+// //    bck->SetParameter(0,fHisto->GetMaximum());
+// //    bck->SetParameter(1,3);
+// //    bck->SetParameter(2,10);
+// //    bck->SetParameter(3,10);
+// //
+// //    bck->SetParLimits(1, 0., 100.);
+// //    bck->SetParLimits(2, 0., 100.);
+// //    bck->SetParLimits(3, 0., 100.);
+// //
+// //    SetFitRejectRange(2.7,3.5);
+// //
+// //    fHisto->Fit(bck,fitOption,"");
+// //
+// //    for ( Int_t i = 0; i < 4; ++i )
+// //        {
+// //        Double_t a,b;
+// //        bck->GetParLimits(i,a,b);
+// //        fitTotal->SetParameter(i,bck->GetParameter(i));
+// //        fitTotal->SetParLimits(i,a,b);
+// //        }
+// //#endif
+//     // Create pointer for bck fitting
+//     TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+//     // To set first parameter
+//     Int_t bin = fHisto->FindBin(0.26);
+//     // Setting parameters
+//     bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//     // Reject region ot J/Psi
+//     SetFitRejectRange(2.7,4.0);
+//     // Store fit results in a TFitResult
+//     TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
+//     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+//     // if success a new fit is proceed
+//     if ( static_cast<int>(fitResultInit) )
+//         {
+//         bin = fHisto->FindBin(0.82);
+//         bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//         fitResultInit = fHisto->Fit(bckInit,"SRL");
+//         }
+//     else if ( bckInit->GetParameter(0) < 0 )
+//         {
+//         bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+//         }
+//     // ??
+//     SetFitRejectRange();
+//     // Set bck paramaters from precedent fit to fitTotal
+//     for ( Int_t i = 0; i < 4; ++i )
+//         {
+//         fitTotal->SetParameter(i, bckInit->GetParameter(i));
+//         }
+
+//     // Set J/Psi parameters to FitTotal
+//     bin = fHisto->FindBin(3.09);
+//     fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm
+
+//     fitTotal->SetParameter(5, 3.1); // mean
+//     fitTotal->SetParLimits(5, 3.0, 3.2);
+
+//     fitTotal->SetParameter(6, 0.08); // sigma
+//     fitTotal->SetParLimits(6, 0.05, 0.09);
+//     // Set parameters from MuMuConfig if present
+//     if ( IsValidValue(alphaLow) )
+//         {
+//         fitTotal->FixParameter(7, alphaLow);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(7,0.9);
+//         fitTotal->SetParLimits(7,0.1,10.0);
+//         }
+
+//     if ( IsValidValue(nLow) )
+//         {
+//         fitTotal->FixParameter(8, nLow);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(8,5.0);
+//         fitTotal->SetParLimits(8,0.0,10.0);
+//         }
+
+//     if ( IsValidValue(alphaUp) )
+//         {
+//         fitTotal->FixParameter(9, alphaUp);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(9, 2.0);
+//         fitTotal->SetParLimits(9,0.1,10.0);
+//         }
+
+//     if ( IsValidValue(nUp) )
+//         {
+//         fitTotal->FixParameter(10, nUp);
+//         }
+//     else
+//         {
+//         fitTotal->SetParameter(10,3.0);
+//         fitTotal->SetParLimits(10,0.0,10.0);
+//         }
+
+
+//     SetFitRejectRange();
+
+//     //  std::cout << fitTotal->GetParameter(0) << std::endl; //Just a xcheck
+
+//     TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+//     //  std::cout << fitTotal->GetParameter(0) << " ?= " << fitResult->Parameter(0) << std::endl; //Just a xcheck
+//     // Output message
+//     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+//     //  std::cout << fitTotal->GetParameter(0) << std::endl; //Just a xcheck
+//     // Refit in case of error on kVWG to high
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
+//             {
+//             std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+
+//             fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+//             }
+
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Refit in case of KkVWG to low
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         std::cout << "//-------Refitting again (setting kVWG=kVWG*2)" << std::endl;
+
+//         fitTotal->SetParameter(0, fHisto->GetMaximum()*2.); // kVWG
+
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Idem
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+
+//         fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+//         std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+//         }
+//     // Set parameters to fit Total and fit with it
+//     if ( static_cast<int>(fitResult) )
+//         {
+//         for ( Int_t i = 0; i < 4; ++i )
+//             {
+//             fitTotal->SetParameter(i, bckInit->GetParameter(i));
+//             }
+//         fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+//         if ( static_cast<int>(fitResult) ) std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+//         }
+
+//     delete bckInit;
+//     // Set things ...
+//     Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+//     Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+//     Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+//     Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+//     // Create JPsi function and set parameters
+//     TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+//     signalJPsi->SetParameters(fitTotal->GetParameter(4),
+//                               fitTotal->GetParameter(5),
+//                               fitTotal->GetParameter(6),
+//                               fitTotal->GetParameter(7),
+//                               fitTotal->GetParameter(8),
+//                               fitTotal->GetParameter(9),
+//                               fitTotal->GetParameter(10));
+//     // Set bck parameter
+//     bck->SetParameters(fitTotal->GetParameter(0),
+//                        fitTotal->GetParameter(1),
+//                        fitTotal->GetParameter(2),
+//                        fitTotal->GetParameter(3));
+
+//     // Set value + error for each parameters
+//     Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+//     Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+//     Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+//     Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+//     Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+
+//     Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+//     Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+//     Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+//     Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+
+//     SetFitRejectRange();
+
+//     AttachFunctionsToHisto(signalJPsi,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+//     Double_t cbParameters[7];
+//     Double_t covarianceMatrix[7][7];
+
+//     for ( int ix = 0; ix < 7; ++ix )
+//         {
+//         cbParameters[ix] = fitTotal->GetParameter(ix+4);
+//         }
+
+//     for ( int iy = 0; iy < 7; ++iy )
+//         {
+//         for ( int ix = 0; ix < 7; ++ix )
+//             {
+//             covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+//             }
+//         }
+
+//     Double_t a = fHisto->GetXaxis()->GetXmin();
+//     Double_t b = fHisto->GetXaxis()->GetXmax();
+//     double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+//     double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+//     Set("NofJPsi",njpsi,nerr);
+
+//     double m = GetValue("mJPsi");
+//     double s = GetValue("sJPsi");
+//     double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+//     double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+//     Set("NofJPsi3s",njpsi3s,nerr3s);
+
+//     //Computation of bin significance and signal over background
+
+//     Double_t bkgParameters[4];
+//     Double_t bkgcovarianceMatrix[4][4];
+
+//     for ( int ix = 0; ix < 4; ++ix )
+//         {
+//         bkgParameters[ix] = fitTotal->GetParameter(ix);
+//         }
+
+//     for ( int iy = 0; iy < 4; ++iy )
+//         {
+//         for ( int ix = 0; ix < 4; ++ix )
+//             {
+//             bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+//             }
+//         }
+
+//     double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+//     double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+//     double sOverB3s = njpsi3s / nbck3s;
+//     double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+//     Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+//     double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+//     double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+//                                 TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+//     Set("Significance3s",sig,sigErr);
+
+// }
+
+
+
 //_____________________________________________________________________________
 void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 {
   /// Fit using 2 extended crystal balls (signal) + variable width gaussian (background)
-  
+
   fHisto->GetListOfFunctions()->Delete();
-  
+
+  const char* fitOption = "SERL"; //We can add NO to avoid plotting
+  const char* fitOptionBg = "SER"; //We can add NO to avoid plotting
+
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
-  Double_t alphaLow = GetValue("alJPsi");
-  Double_t nLow = GetValue("nlJPsi");
-  Double_t alphaUp = GetValue("auJPsi");
-  Double_t nUp = GetValue("nuJPsi");
-  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t alphaLow     = GetValue("alJPsi");
+  Double_t nLow         = GetValue("nlJPsi");
+  Double_t alphaUp      = GetValue("auJPsi");
+  Double_t nUp          = GetValue("nuJPsi");
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  Double_t paramSPsiP = GetValue("FSigmaPsiP");
-  
+  Double_t paramSPsiP   = GetValue("FSigmaPsiP");
+
   TString msg;
-  
+
   if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
-  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
-  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
-  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+  if (IsValidValue(nLow)) msg     += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg  += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg      += TString::Format("nUp=%e ",nUp);
   //__________
 
-  
+
   AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
-  
+
 
   //__________ Define the function to fit the spectrum, and the background just for plotting
   TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,12,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
@@ -1509,84 +2030,46 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
 
-  const char* fitOption = "SER"; //We can add NO to avoid plotting
-
   //___________
 
-#if 0
-
-  bck->SetParameter(0,fHisto->GetMaximum());
-  bck->SetParameter(1,3);
-  bck->SetParameter(2,10);
-  bck->SetParameter(3,10);
-
-  bck->SetParLimits(1, 0., 100.);
-  bck->SetParLimits(2, 0., 100.);
-  bck->SetParLimits(3, 0., 100.);
-  
-  SetFitRejectRange(2.7,3.5);
-  
-  fHisto->Fit(bck,fitOption,"");
-  
-  for ( Int_t i = 0; i < 4; ++i )
-  {
-    Double_t a,b;
-    bck->GetParLimits(i,a,b);
-    fitTotal->SetParameter(i,bck->GetParameter(i));
-    fitTotal->SetParLimits(i,a,b);
-  }
-#endif
-
-//    Int_t minBin = fHisto->FindBin(fitRangeLow);
-//    Int_t maxBin = fHisto->FindBin(fitRangeHigh);
-//
-//    for ( Int_t i = minBin ; i <= maxBin ; i++ )
-//    {
-//      if ( fHisto->GetBinContent(i) < 4 )
-//      {
-//        fHisto->SetBinContent(i,0.);
-//        fHisto->SetBinError(i,0.);
-//      }
-//    }
-
 
   //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.8,10.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
 
   Int_t bin = fHisto->FindBin(0.26);
 
   bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
 //  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
 
-  SetFitRejectRange(2.7,4.0);
+  SetFitRejectRange(2.6,3.4);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
 
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
-  
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG",fitOptionBg);
   //___________
 
   SetFitRejectRange();
   //____________
-  
+
 
   //__________ Set initial parameters in fitting function
   for ( Int_t i = 0; i < 4; ++i )
   {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
   }
-  
+
   bin = fHisto->FindBin(3.09);
   fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm
-  
+
   fitTotal->SetParameter(5, 3.15); // mean
-  fitTotal->SetParLimits(5, 2.95, 3.25);
-  
+  fitTotal->SetParLimits(5, 2.95, 3.2);
+
   fitTotal->SetParameter(6, 0.08); // sigma
-  fitTotal->SetParLimits(6, 0.05, 0.09);
-  
+  fitTotal->SetParLimits(6, 0.03, 0.2);
+
   if ( IsValidValue(alphaLow) )
   {
     fitTotal->FixParameter(7, alphaLow);
@@ -1594,19 +2077,19 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
   else
   {
     fitTotal->SetParameter(7,0.9);
-    fitTotal->SetParLimits(7,0.1,10.0);
+    fitTotal->SetParLimits(7,0.8,1.2);
   }
-  
-  if ( IsValidValue(nLow) ) 
+
+  if ( IsValidValue(nLow) )
   {
     fitTotal->FixParameter(8, nLow);
   }
   else
   {
-    fitTotal->SetParameter(8,5.0);
-    fitTotal->SetParLimits(8,0.0,10.0);
+    fitTotal->SetParameter(8,3.0);
+    fitTotal->SetParLimits(8,1.0,5.0);
   }
-  
+
   if ( IsValidValue(alphaUp) )
   {
     fitTotal->FixParameter(9, alphaUp);
@@ -1614,35 +2097,35 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
   else
   {
     fitTotal->SetParameter(9, 2.0);
-    fitTotal->SetParLimits(9,0.1,10.0);
+    fitTotal->SetParLimits(9,1.0,3.0);
   }
-  
+
   if ( IsValidValue(nUp) )
   {
-    fitTotal->FixParameter(10, nUp);    
+    fitTotal->FixParameter(10, nUp);
   }
   else
   {
-    fitTotal->SetParameter(10,3.0);
-    fitTotal->SetParLimits(10,0.0,10.0);
+    fitTotal->SetParameter(10,2.0);
+    fitTotal->SetParLimits(10,1.0,2.3);
   }
-  
+
   bin = fHisto->FindBin(3.68);
   fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+  fitTotal->SetParLimits(11, 0.,fHisto->GetBinContent(bin));
   //______________
 
-  
+
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
-  
+
   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   //___________
-  
+
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,11,3);
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,11,3);
   //___________
 
 
@@ -1654,7 +2137,7 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
 
   Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
   Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  
+
   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
   signalJPsi->SetParameters(fitTotal->GetParameter(4),
                      fitTotal->GetParameter(5),
@@ -1663,7 +2146,7 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
                      fitTotal->GetParameter(8),
                      fitTotal->GetParameter(9),
                      fitTotal->GetParameter(10));
-  
+
   TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
   signalPsiP->SetParameters(fitTotal->GetParameter(11),
                         3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
@@ -1672,40 +2155,40 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
                         fitTotal->GetParameter(8),
                         fitTotal->GetParameter(9),
                         fitTotal->GetParameter(10));
-  
+
   bck->SetParameters(fitTotal->GetParameter(0),
                      fitTotal->GetParameter(1),
                      fitTotal->GetParameter(2),
                      fitTotal->GetParameter(3));
-  
-  
+
+
   Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
   Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
   Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
   Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
   Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  
+
   Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
   Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
   Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
   Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  
+
   Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
 
 
   SetFitRejectRange();
-  
+
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
-  
-  
+
+
   Double_t cbParameters[7];
   Double_t covarianceMatrix[7][7];
-  
+
   for ( int ix = 0; ix < 7; ++ix )
   {
     cbParameters[ix] = fitTotal->GetParameter(ix+4);
   }
-  
+
   for ( int iy = 0; iy < 7; ++iy )
   {
     for ( int ix = 0; ix < 7; ++ix )
@@ -1713,32 +2196,32 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
       covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
     }
   }
-  
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
   double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
 
   Set("NofJPsi",njpsi,nerr);
-  
+
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
   double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   Set("NofJPsi3s",njpsi3s,nerr3s);
   //_____________________________
-  
-  
+
+
   //_____Computation of bin significance and signal over background
   Double_t bkgParameters[4];
   Double_t bkgcovarianceMatrix[4][4];
-  
+
   for ( int ix = 0; ix < 4; ++ix )
   {
     bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
-  
+
   for ( int iy = 0; iy < 4; ++iy )
   {
     for ( int ix = 0; ix < 4; ++ix )
@@ -1746,894 +2229,2632 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG()
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
   }
-  
+
   double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
   double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   double sOverB3s = njpsi3s / nbck3s;
   double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
-  
+
   Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
-  
+
   double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
   double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
                                TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
-  
+
   Set("Significance3s",sig,sigErr);
   //__________________________
 
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWGINDEPTAILS()
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWG2()
 {
-  /// Fit using 2 extended crystal balls with independent tails (signal) + variable width gaussian (background)
-  // Was used as a test of the Psi' tails effect, since it was negligible is not used anymore
-  
+  /// Fit using 2 extended crystal balls (signal) + variable width gaussian (background)
+
   fHisto->GetListOfFunctions()->Delete();
-  
-  Double_t alphaLow = GetValue("alJPsi");
-  Double_t nLow = GetValue("nlJPsi");
-  Double_t alphaUp = GetValue("auJPsi");
-  Double_t nUp = GetValue("nuJPsi");
-  
-  Double_t alphaLowP = GetValue("alPsiP");
-  Double_t nLowP = GetValue("nlPsiP");
-  Double_t alphaUpP = GetValue("auPsiP");
-  Double_t nUpP = GetValue("nuPsiP");
-  
-  Double_t fitRangeLow = GetValue(kFitRangeLow);
+
+  const char* fitOption = "SERL"; //We can add NO to avoid plotting
+  const char* fitOptionBg = "SER"; //We can add NO to avoid plotting
+
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow     = GetValue("alJPsi");
+  Double_t nLow         = GetValue("nlJPsi");
+  Double_t alphaUp      = GetValue("auJPsi");
+  Double_t nUp          = GetValue("nuJPsi");
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
-  Double_t paramSPsiP = GetValue("FSigmaPsiP");
-  
+  Double_t paramSPsiP   = GetValue("FSigmaPsiP");
+
   TString msg;
-  
+
   if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
-  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
-  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
-  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
-  
-  if (IsValidValue(alphaLowP)) msg += TString::Format("alphaLowP=%e ",alphaLowP);
-  if (IsValidValue(nLowP)) msg += TString::Format("nLowP=%e ",nLowP);
-  if (IsValidValue(alphaUpP)) msg += TString::Format("alphaUpP=%e ",alphaUpP);
-  if (IsValidValue(nUpP)) msg += TString::Format("nUpP=%e ",nUpP);
-  
+  if (IsValidValue(nLow)) msg     += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg  += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg      += TString::Format("nUp=%e ",nUp);
+  //__________
+
+
   AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
+
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG2,fitRangeLow,fitRangeHigh,13,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG2");
+
+  fitTotal->SetParNames("kVWG2","mVWG2","s1VWG2","s2VWG2","gVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi");
+//                        0        1       2        3        4      5      6        7       8           9       10
+  fitTotal->SetParName(11, "nuJPsi");
+//                            11
+  fitTotal->SetParName(12, "kPsiP");
+//                            12
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG2");
+  //___________
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2,1.8,6.,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG2");
+  Int_t bin = fHisto->FindBin(0.26);
+  bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3,1.0);
+
+  SetFitRejectRange(2.5,3.4);
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   
-  // Add fit with indep tails
-  
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWGINDEPTAILS,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWGINDEPTAILS");
-  
-  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
-  //                        0      1       2       3       4      5      6
-                        "alJPsi","nlJPsi","auJPsi","nuJPsi");
-  //                       7        8        9        10
-//  fitTotal->SetParName(11, "kPsiP");
-//  //                            11
-//  fitTotal->SetParName(12, "mPsiP");
-//  //                            12
-//  fitTotal->SetParName(13, "sPsiP");
-//  //                            13
-//  fitTotal->SetParName(14, "alPsiP");
-//  //                            14
-//  fitTotal->SetParName(15, "nlPsiP");
-//  //                            15
-//  fitTotal->SetParName(16, "auPsiP");
-//  //                            16
-//  fitTotal->SetParName(17, "nuPsiP");
-//  //                            17
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG2",fitOptionBg);// Further attempts to fit bkg if the first one fails
+  SetFitRejectRange();
+  //____________
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 5; ++i ) fitTotal->SetParameter(i, bckInit->GetParameter(i));
+ 
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(5, fHisto->GetBinContent(bin)); // norm
+
+  fitTotal->SetParameter(6, 3.15); // mean
+  fitTotal->SetParLimits(6, 2.95, 3.2);
   
-  fitTotal->SetParName(11, "kPsiP");
-  //                            11
-   fitTotal->SetParName(12, "alPsiP");
-  //                            12
-  fitTotal->SetParName(13, "nlPsiP");
-  //                            13
-  fitTotal->SetParName(14, "auPsiP");
-  //                            14
-  fitTotal->SetParName(15, "nuPsiP");
-  //                            15
-  
-  
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
-  
-  const char* fitOption = "SERI";
-  
-#if 0
-  bck->SetParameter(0,fHisto->GetMaximum());
-  bck->SetParameter(1,3);
-  bck->SetParameter(2,10);
-  bck->SetParameter(3,10);
-  
-  bck->SetParLimits(1, 0., 100.);
-  bck->SetParLimits(2, 0., 100.);
-  bck->SetParLimits(3, 0., 100.);
-  
-  SetFitRejectRange(2.7,3.5);
-  
-  fHisto->Fit(bck,fitOption,"");
-  
-  for ( Int_t i = 0; i < 4; ++i )
+  fitTotal->SetParameter(7, 0.08); // sigma
+  fitTotal->SetParLimits(7, 0.03, 0.2);
+
+  if ( IsValidValue(alphaLow) ) {
+    fitTotal->FixParameter(8, alphaLow);
+  } else {
+    fitTotal->SetParameter(8,0.9);
+    fitTotal->SetParLimits(8,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) ) {
+    fitTotal->FixParameter(9, nLow);
+  } else {
+    fitTotal->SetParameter(9,5.0);
+    fitTotal->SetParLimits(9,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) ) {
+    fitTotal->FixParameter(10, alphaUp);
+  } else {
+    fitTotal->SetParameter(10, 2.0);
+    fitTotal->SetParLimits(10,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) ) {
+    fitTotal->FixParameter(11, nUp);
+  } else {
+    fitTotal->SetParameter(11,3.0);
+    fitTotal->SetParLimits(11,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(12, fHisto->GetBinContent(bin)*0.2); //kPsi'
+  // fitTotal->SetParLimits(12, 0.,fHisto->GetBinContent(bin));
+  //______________
+
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,12,4);
+  //___________
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("sJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(5),
+                     fitTotal->GetParameter(6),
+                     fitTotal->GetParameter(7),
+                     fitTotal->GetParameter(8),
+                     fitTotal->GetParameter(9),
+                     fitTotal->GetParameter(10),
+                     fitTotal->GetParameter(11));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(12),
+                        3.68609+(fitTotal->GetParameter(6)-3.096916)/3.096916*3.68609,
+                        fitTotal->GetParameter(7)*paramSPsiP, // /3.096916*3.68609,
+                        fitTotal->GetParameter(8),
+                        fitTotal->GetParameter(9),
+                        fitTotal->GetParameter(10),
+                        fitTotal->GetParameter(11));
+
+  bck->SetParameters(fitTotal->GetParameter(0),
+                     fitTotal->GetParameter(1),
+                     fitTotal->GetParameter(2),
+                     fitTotal->GetParameter(3),
+                     fitTotal->GetParameter(4));
+
+
+  Set("kVWG2",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("mVWG2",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("s1VWG2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("s2VWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("gVWG2",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("kJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+
+  Set("alJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("nlJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("auJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("nuJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+
+  Set("kPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+
+  SetFitRejectRange();
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
   {
-    Double_t a,b;
-    bck->GetParLimits(i,a,b);
-    fitTotal->SetParameter(i,bck->GetParameter(i));
-    fitTotal->SetParLimits(i,a,b);
+    cbParameters[ix] = fitTotal->GetParameter(ix+5);
   }
-#endif
-  
-  Int_t bin = fHisto->FindBin(fitRangeLow);
-  fitTotal->SetParameter(0, fHisto->GetBinContent(bin)); // kVWG
-  fitTotal->SetParameter(1, 1.9); // mVWG
-  
-  fitTotal->SetParameter(2, 0.5); // sVWG1
-  fitTotal->SetParLimits(2, 0., 100.);
-  
-  fitTotal->SetParameter(3, 0.3); // sVWG2
-  fitTotal->SetParLimits(3, 0., 100.);
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+5,iy+5);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[5];
+  Double_t bkgcovarianceMatrix[5][5];
+
+  for ( int ix = 0; ix < 5; ++ix ){
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 5; ++iy ){
+    for ( int ix = 0; ix < 5; ++ix ) {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________________________
   
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL1POL2()
+{
+  /// Fit using 2 extended crystal balls (signal) + POL1/POL2 (background)
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  const char* fitOption = "SERLI";
+  const char* fitOptionBg = "SERI";
+
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow     = GetValue("alJPsi");
+  Double_t nLow         = GetValue("nlJPsi");
+  Double_t alphaUp      = GetValue("auJPsi");
+  Double_t nUp          = GetValue("nuJPsi");
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+  Double_t paramSPsiP   = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow)) msg     += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg  += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg      += TString::Format("nUp=%e ",nUp);
+  //__________
+
+
+  AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
+
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol1Pol2,fitRangeLow,fitRangeHigh,13,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol1Pol2");
+
+  fitTotal->SetParNames("a","b","a'","b'","c'","kJPsi","mJPsi","sJPsi",
+//                        0  1   2    3    4      5      6       7
+                        "alJPsi","nlJPsi","auJPsi");
+//                         8        9        10
+  fitTotal->SetParName(11, "nuJPsi");
+  //                          11
+  fitTotal->SetParName(12, "kPsiP");
+//                            12
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
+
+  //___________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,1.7,6.,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
+
+  Int_t bin = fHisto->FindBin(0.70);
+  // Int_t bin = fHisto->FindBin(1.2); // just after a low mass pick
+  // Int_t bin = fHisto->FindBin(0.40);
+
+  bckInit->SetParameters(0.,bin,0.,1.,1.);
+  bckInit->SetParLimits(0,-200,50);
+  bckInit->SetParLimits(2,-50,2000);
+  bckInit->SetParLimits(3,-300,100);
+  bckInit->FixParameter(4, 1.);
+
+  SetFitRejectRange(2.6,3.4);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+  // CheckRoots(fitResultInit,bckInit,2,bckInit->GetParameter(2),bckInit->GetParameter(3),bckInit->GetParameter(4),0.,fitOptionBg);
+
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol1Pol2",fitOptionBg);
+  //___________
+
+
+  SetFitRejectRange();
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 5; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    if(i==4)fitTotal->FixParameter(i, 1.);
+  }
+  // fitTotal->SetParLimits(0,-200,50);
+  // fitTotal->SetParLimits(2,-50,2000);
+  // fitTotal->SetParLimits(3,-300,100);
+
   bin = fHisto->FindBin(3.09);
-  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
-  
-  fitTotal->SetParameter(5, 3.1); // mean
-  fitTotal->SetParLimits(5, 3.0, 3.2);
-  
-  fitTotal->SetParameter(6, 0.08); // sigma
-  fitTotal->SetParLimits(6, 0.03, 0.15);
-  
+  fitTotal->SetParameter(5, fHisto->GetBinContent(bin)); // norm
+
+  fitTotal->SetParameter(6, 3.15); // mean
+  fitTotal->SetParLimits(6, 2.95, 3.2);
+
+  fitTotal->SetParameter(7, 0.08); // sigma
+  fitTotal->SetParLimits(7, 0.05, 0.09);
+
   if ( IsValidValue(alphaLow) )
   {
-    fitTotal->FixParameter(7, alphaLow);
+    fitTotal->FixParameter(8, alphaLow);
   }
   else
   {
-    fitTotal->SetParameter(7,0.9);
-    fitTotal->SetParLimits(7,0.1,10.0);
+    fitTotal->SetParameter(8,0.9);
+    fitTotal->SetParLimits(8,0.1,10.0);
   }
-  
+
   if ( IsValidValue(nLow) )
   {
-    fitTotal->FixParameter(8, nLow);
+    fitTotal->FixParameter(9, nLow);
   }
   else
   {
-    fitTotal->SetParameter(8,5.0);
-    fitTotal->SetParLimits(8,0.0,10.0);
+    fitTotal->SetParameter(9,5.0);
+    fitTotal->SetParLimits(9,0.0,10.0);
   }
-  
+
   if ( IsValidValue(alphaUp) )
   {
-    fitTotal->FixParameter(9, alphaUp);
+    fitTotal->FixParameter(10, alphaUp);
   }
   else
   {
-    fitTotal->SetParameter(9, 2.0);
-    fitTotal->SetParLimits(9,0.1,10.0);
+    fitTotal->SetParameter(10, 2.0);
+    fitTotal->SetParLimits(10,0.1,10.0);
   }
-  
+
   if ( IsValidValue(nUp) )
   {
-    fitTotal->FixParameter(10, nUp);
+    fitTotal->FixParameter(11, nUp);
   }
   else
   {
-    fitTotal->SetParameter(10,3.0);
-    fitTotal->SetParLimits(10,0.0,10.0);
+    fitTotal->SetParameter(11,3.0);
+    fitTotal->SetParLimits(11,0.0,10.0);
   }
-  
+
   bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
-  
-//  fitTotal->SetParameter(12, 3.7); // mean PsiP
-//  fitTotal->SetParLimits(12, 3.6, 3.71);
-//  
-//  fitTotal->SetParameter(13, 0.08/3.096916*3.68609); // sigma PsiP
-//  fitTotal->SetParLimits(13, 0.03/3.096916*3.68609, 0.15/3.096916*3.68609);
-  
-  if ( IsValidValue(alphaLowP) )
-  {
-    fitTotal->FixParameter(12, alphaLowP);
-  }
-  else
-  {
-    fitTotal->SetParameter(12,0.9);
-    fitTotal->SetParLimits(12,0.1,10.0);
-  }
-  
-  if ( IsValidValue(nLowP) )
-  {
-    fitTotal->FixParameter(13, nLowP);
-  }
-  else
-  {
-    fitTotal->SetParameter(13,5.0);
-    fitTotal->SetParLimits(13,0.0,10.0);
-  }
-  
-  if ( IsValidValue(alphaUpP) )
-  {
-    fitTotal->FixParameter(14, alphaUpP);
-  }
-  else
+  fitTotal->SetParameter(12, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(12, 0.,fHisto->GetBinContent(bin));
+  //______________
+
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+  // CheckRoots(fitResult,fitTotal,2,fitTotal->GetParameter(2),fitTotal->GetParameter(3),fitTotal->GetParameter(4),0.,fitOption);
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,12,4);
+  // CheckRoots(fitResult,fitTotal,2,fitTotal->GetParameter(2),fitTotal->GetParameter(3),fitTotal->GetParameter(4),0.,fitOption);
+  // if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,12,4);
+  //___________
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("sJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(5),
+                     fitTotal->GetParameter(6),
+                     fitTotal->GetParameter(7),
+                     fitTotal->GetParameter(8),
+                     fitTotal->GetParameter(9),
+                     fitTotal->GetParameter(10),
+                     fitTotal->GetParameter(11));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(12),
+                        3.68609+(fitTotal->GetParameter(6)-3.096916)/3.096916*3.68609,
+                        fitTotal->GetParameter(7)*paramSPsiP, // /3.096916*3.68609,
+                        fitTotal->GetParameter(8),
+                        fitTotal->GetParameter(9),
+                        fitTotal->GetParameter(10),
+                        fitTotal->GetParameter(11));
+
+  bck->SetParameters(fitTotal->GetParameter(0),
+                     fitTotal->GetParameter(1),
+                     fitTotal->GetParameter(2),
+                     fitTotal->GetParameter(3),
+                     fitTotal->GetParameter(4));
+
+
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("a'",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("b'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("c'",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("kJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+
+  Set("alJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("nlJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("auJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("nuJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+
+  Set("kPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+
+  SetFitRejectRange();
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
   {
-    fitTotal->SetParameter(14, 2.0);
-    fitTotal->SetParLimits(14,0.1,10.0);
+    cbParameters[ix] = fitTotal->GetParameter(ix+5);
   }
-  
-  if ( IsValidValue(nUpP) )
+
+  for ( int iy = 0; iy < 7; ++iy )
   {
-    fitTotal->FixParameter(15, nUpP);
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+5,iy+5);
+    }
   }
-  else
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[5];
+  Double_t bkgcovarianceMatrix[5][5];
+
+  for ( int ix = 0; ix < 5; ++ix )
   {
-    fitTotal->SetParameter(15,3.0);
-    fitTotal->SetParLimits(15,0.0,10.0);
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
-  
-  //  SetFitRejectRange();
-  
-  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
-  
-  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
-  
-  if ( static_cast<int>(fitResult) )
+
+  for ( int iy = 0; iy < 5; ++iy )
   {
-    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
-    {
-      std::cout << "//-------Refitting again (setting Psi'norm= Psi'norm/2)" << std::endl;
-      
-      fitTotal->SetParameter(11, fHisto->GetBinContent(bin)/2.);
-    }
-    
-    if ( fitTotal->GetParameter(0) <= fitTotal->GetParError(0) ) //kVWG
+    for ( int ix = 0; ix < 5; ++ix )
     {
-      std::cout << "//-------Refitting again (setting VWG norm= VWG norm /2)" << std::endl;
-      bin = fHisto->FindBin(fitRangeLow);
-      
-      fitTotal->SetParameter(0, fHisto->GetBinContent(bin)/2.);
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
-    
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
-    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
   }
 
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________________________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2POL3()
+{
+  /// Fit using 2 extended crystal balls (signal) + Pol2/Pol3 (background)
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  const char* fitOption = "SERL"; //We can add NO to avoid plotting
+  const char* fitOptionBg = "SRL"; //We can add NO to avoid plotting
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow     = GetValue("alJPsi");
+  Double_t nLow         = GetValue("nlJPsi");
+  Double_t alphaUp      = GetValue("auJPsi");
+  Double_t nUp          = GetValue("nuJPsi");
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+  Double_t paramSPsiP   = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow))     msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp))  msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp))      msg += TString::Format("nUp=%e ",nUp);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime POL2/POL3 %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Pol3,fitRangeLow,fitRangeHigh,15,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol2Pol3");
+
+  fitTotal->SetParNames("a","b","c","a'","b'","c'","d'","kJPsi","mJPsi","sJPsi","alJPsi");
+//                        0  1   2   3    4    5    6    7         8      9       10
+  fitTotal->SetParName(11,"nlJPsi");
+  //                         11
+  fitTotal->SetParName(12,"auJPsi");
+  //                         12
+  fitTotal->SetParName(13,"nuJPsi");
+  //                         13
+  fitTotal->SetParName(14,"kPsiP");
+//                            14
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,fitRangeLow,fitRangeHigh,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
+  //___________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,1.9,6.,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
+
+  Int_t bin = fHisto->FindBin(0.7);
+  bckInit->SetParameters(0.,1.,bin,0.,0.,1.,1.);
+  bckInit->FixParameter(6.,1);
+
+  // bckInit->SetParLimits(0.,-30,30);
+  // bckInit->SetParLimits(1.,-10,10);
+  // bckInit->SetParLimits(2.,-10,100);
+  bckInit->SetParLimits(3.,-10,10);
+  bckInit->SetParLimits(4.,-10,10);
+  bckInit->SetParLimits(5.,-30,30);
+
+  SetFitRejectRange(2.5,3.6);
   
-  if ( static_cast<int>(fitResult) )
-  {
-    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
-    {
-      std::cout << "//-------Refitting again (setting Psi'norm=0)" << std::endl;
-      
-      fitTotal->FixParameter(11, 0.);
-    }
-    
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
-    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Pol3",fitOptionBg); // Further attempts to fit bkg if the first one fails
+  SetFitRejectRange();
+  //____________
+  // new TCanvas;
+  // fHisto->DrawCopy();
+  // return;
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 7; ++i ) {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    if(i==6) fitTotal->FixParameter(6, 1.);
   }
-  
-  if ( static_cast<int>(fitResult) )
-  {
-    std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
-    
-    fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
-    
-    fitResult = fHisto->Fit(fitTotal,fitOption,"");
-    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(7, fHisto->GetBinContent(bin)); // norm
+
+  fitTotal->SetParameter(8, 3.15); // mean
+  fitTotal->SetParLimits(8, 2.95, 3.2);
+
+  fitTotal->SetParameter(9, 0.08); // sigma
+  fitTotal->SetParLimits(9, 0.05, 0.09);
+
+  if ( IsValidValue(alphaLow) ) {
+    fitTotal->FixParameter(10, alphaLow);
+  } else {
+    fitTotal->SetParameter(10,0.9);
+    fitTotal->SetParLimits(10,0.1,10.0);
   }
-  
-  if ( static_cast<int>(fitResult) )
-  {
-    std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+
+  if ( IsValidValue(nLow) ) {
+    fitTotal->FixParameter(11, nLow);
+  } else {
+    fitTotal->SetParameter(11,5.0);
+    fitTotal->SetParLimits(11,0.0,10.0);
   }
-  
-  
+
+  if ( IsValidValue(alphaUp) ) {
+    fitTotal->FixParameter(12, alphaUp);
+  } else {
+    fitTotal->SetParameter(12, 2.0);
+    fitTotal->SetParLimits(12,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) ) {
+    fitTotal->FixParameter(13, nUp);
+  } else {
+    fitTotal->SetParameter(13,3.0);
+    fitTotal->SetParLimits(13,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(14, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  // fitTotal->SetParLimits(14, 0.,1.5*fHisto->GetBinContent(bin));
+  //______________
+
+  //_____________Fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,14,6); // Further attempts to fit if the first one fails
+  //___________
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
-  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  
-  Set("mPsiP",3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,fitTotal->GetParError(5)/3.096916*3.68609);
-  Set("sPsiP",fitTotal->GetParameter(6)*paramSPsiP,fitTotal->GetParError(6)*paramSPsiP);
-  
-  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalJPsi->SetParameters(fitTotal->GetParameter(4),
-                        fitTotal->GetParameter(5),
-                        fitTotal->GetParameter(6),
-                        fitTotal->GetParameter(7),
-                        fitTotal->GetParameter(8),
-                        fitTotal->GetParameter(9),
-                        fitTotal->GetParameter(10));
-  
+
+  Set("mJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("sJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+
+   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(7),
+                     fitTotal->GetParameter(8),
+                     fitTotal->GetParameter(9),
+                     fitTotal->GetParameter(10),
+                     fitTotal->GetParameter(11),
+                     fitTotal->GetParameter(12),
+                     fitTotal->GetParameter(13));
+
   TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalPsiP->SetParameters(fitTotal->GetParameter(11),
-                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
-                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
-                            fitTotal->GetParameter(12),
-                            fitTotal->GetParameter(13),
-                            fitTotal->GetParameter(14),
-                            fitTotal->GetParameter(15));
-  
+  signalPsiP->SetParameters(fitTotal->GetParameter(14),
+                        3.68609+(fitTotal->GetParameter(8)-3.096916)/3.096916*3.68609,
+                        fitTotal->GetParameter(9)*paramSPsiP, // /3.096916*3.68609,
+                        fitTotal->GetParameter(10),
+                        fitTotal->GetParameter(11),
+                        fitTotal->GetParameter(12),
+                        fitTotal->GetParameter(13));
+
   bck->SetParameters(fitTotal->GetParameter(0),
                      fitTotal->GetParameter(1),
                      fitTotal->GetParameter(2),
-                     fitTotal->GetParameter(3));
-  
-  
-  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
-  
-  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  
-  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
-  Set("alPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
-  Set("nlPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
-  Set("auPsiP",fitTotal->GetParameter(14),fitTotal->GetParError(14));
-  Set("nuPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
- 
-  
-  
-//  SetFitRejectRange();
+                     fitTotal->GetParameter(3),
+                     fitTotal->GetParameter(4),
+                     fitTotal->GetParameter(5),
+                     fitTotal->GetParameter(6));
+
+
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("c",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("a'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("b'",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("c'",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("d'",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("kJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+
+  Set("alJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("nlJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("auJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("nuJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+  Set("kPsiP",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+
+
+  SetFitRejectRange();
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix ) cbParameters[ix] = fitTotal->GetParameter(ix+7);
+
+  for ( int iy = 0; iy < 7; ++iy ) {
+    for ( int ix = 0; ix < 7; ++ix ) {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+7,iy+7);
+    }
+  }
+
+  Double_t a   = fHisto->GetXaxis()->GetXmin();
+  Double_t b   = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr  = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m       = GetValue("mJPsi");
+  double s       = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s  = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[7];
+  Double_t bkgcovarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix ) bkgParameters[ix] = fitTotal->GetParameter(ix);
+
+  for ( int iy = 0; iy < 7; ++iy ) {
+    for ( int ix = 0; ix < 7; ++ix ) {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+  
+  double nbck3s      = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr   = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+  
+  double sOverB3s    = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig    = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________________________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2POL3V2()
+{
+  /// Fit using 2 extended crystal balls (signal) + Pol2/Pol3 (background)
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  const char* fitOption = "SERLI"; //We can add NO to avoid plotting
+  const char* fitOptionBg = "SRL"; //We can add NO to avoid plotting
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow     = GetValue("alJPsi");
+  Double_t nLow         = GetValue("nlJPsi");
+  Double_t alphaUp      = GetValue("auJPsi");
+  Double_t nUp          = GetValue("nuJPsi");
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+  Double_t paramSPsiP   = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow))     msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp))  msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp))      msg += TString::Format("nUp=%e ",nUp);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime POL2/POL3 %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Pol3V2,fitRangeLow,fitRangeHigh,14,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol2Pol3V2");
+
+  fitTotal->SetParNames("a","b","c","a'","b'","c'","kJPsi","mJPsi","sJPsi","alJPsi");
+//                        0  1   2   3    4    5     6       7         8      9       
+  fitTotal->SetParName(10,"nlJPsi");
+  //                         10
+  fitTotal->SetParName(11,"auJPsi");
+  //                         11
+  fitTotal->SetParName(12,"nuJPsi");
+  //                         12
+  fitTotal->SetParName(13,"kPsiP");
+//                            13
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3V2,fitRangeLow,fitRangeHigh,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3V2");
+  //___________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3V2,1.7,8.,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3V2");
+
+  Int_t bin = fHisto->FindBin(0.7);
+  bckInit->SetParameters(0.,0.,bin,1.,0.,0.);
+
+  SetFitRejectRange(2.2,3.7);
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Pol3V2",fitOptionBg); // Further attempts to fit bkg if the first one fails
+  SetFitRejectRange();
+  //____________
+  
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 6; ++i ) fitTotal->SetParameter(i, bckInit->GetParameter(i));
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(6, fHisto->GetBinContent(bin)); // norm
+
+  fitTotal->SetParameter(7, 3.15); // mean
+  fitTotal->SetParLimits(7, 2.95, 3.2);
+
+  fitTotal->SetParameter(8, 0.08); // sigma
+  fitTotal->SetParLimits(8, 0.05, 0.09);
+
+  if ( IsValidValue(alphaLow) ) {
+    fitTotal->FixParameter(9, alphaLow);
+  } else {
+    fitTotal->SetParameter(9,0.9);
+    fitTotal->SetParLimits(9,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) ) {
+    fitTotal->FixParameter(10, nLow);
+  } else {
+    fitTotal->SetParameter(10,5.0);
+    fitTotal->SetParLimits(10,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) ) {
+    fitTotal->FixParameter(11, alphaUp);
+  } else {
+    fitTotal->SetParameter(11, 2.0);
+    fitTotal->SetParLimits(11,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) ) {
+    fitTotal->FixParameter(12, nUp);
+  } else {
+    fitTotal->SetParameter(12,3.0);
+    fitTotal->SetParLimits(12,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(13, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(13, 0.,1.5*fHisto->GetBinContent(bin));
+  //______________
+
+  //_____________Fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+
+  if ( static_cast<int>(fitResult) /*||  static_cast<int>(fitResult->CovMatrixStatus())!=3*/ ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,13,5); // Further attempts to fit if the first one fails
+  //___________
+
+   new TCanvas;
+  fHisto->DrawCopy();
+  return;
+
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("sJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+
+   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(6),
+                     fitTotal->GetParameter(7),
+                     fitTotal->GetParameter(8),
+                     fitTotal->GetParameter(9),
+                     fitTotal->GetParameter(10),
+                     fitTotal->GetParameter(11),
+                     fitTotal->GetParameter(12));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(13),
+                        3.68609+(fitTotal->GetParameter(7)-3.096916)/3.096916*3.68609,
+                        fitTotal->GetParameter(8)*paramSPsiP, // /3.096916*3.68609,
+                        fitTotal->GetParameter(9),
+                        fitTotal->GetParameter(10),
+                        fitTotal->GetParameter(11),
+                        fitTotal->GetParameter(12));
+
+  bck->SetParameters(fitTotal->GetParameter(0),
+                     fitTotal->GetParameter(1),
+                     fitTotal->GetParameter(2),
+                     fitTotal->GetParameter(3),
+                     fitTotal->GetParameter(4),
+                     fitTotal->GetParameter(5));
+
+
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("c",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("a'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("b'",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("c'",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+
+  Set("kJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+
+  Set("alJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("nlJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("auJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("nuJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+  Set("kPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+
+  SetFitRejectRange();
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix ) cbParameters[ix] = fitTotal->GetParameter(ix+6);
+
+  for ( int iy = 0; iy < 7; ++iy ) {
+    for ( int ix = 0; ix < 7; ++ix ) {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+6,iy+6);
+    }
+  }
+
+  Double_t a   = fHisto->GetXaxis()->GetXmin();
+  Double_t b   = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr  = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m       = GetValue("mJPsi");
+  double s       = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s  = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[6];
+  Double_t bkgcovarianceMatrix[6][6];
+
+  for ( int ix = 0; ix < 6; ++ix ) bkgParameters[ix] = fitTotal->GetParameter(ix);
+
+  for ( int iy = 0; iy < 6; ++iy ) {
+    for ( int ix = 0; ix < 6; ++ix ) {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
   
+  double nbck3s      = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr   = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+  
+  double sOverB3s    = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig    = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________________________
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2VWGINDEPTAILS()
+{
+  /// Fit using 2 extended crystal balls with independent tails (signal) + variable width gaussian (background)
+  // Was used as a test of the Psi' tails effect, since it was negligible is not used anymore
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  Double_t alphaLow = GetValue("alJPsi");
+  Double_t nLow = GetValue("nlJPsi");
+  Double_t alphaUp = GetValue("auJPsi");
+  Double_t nUp = GetValue("nuJPsi");
+
+  Double_t alphaLowP = GetValue("alPsiP");
+  Double_t nLowP = GetValue("nlPsiP");
+  Double_t alphaUpP = GetValue("auPsiP");
+  Double_t nUpP = GetValue("nuPsiP");
+
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+
+  if (IsValidValue(alphaLowP)) msg += TString::Format("alphaLowP=%e ",alphaLowP);
+  if (IsValidValue(nLowP)) msg += TString::Format("nLowP=%e ",nLowP);
+  if (IsValidValue(alphaUpP)) msg += TString::Format("alphaUpP=%e ",alphaUpP);
+  if (IsValidValue(nUpP)) msg += TString::Format("nUpP=%e ",nUpP);
+
+  AliDebug(1,Form("Fit with jpsi + psiprime VWG %s",msg.Data()));
+
+  // Add fit with indep tails
+
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWGINDEPTAILS,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWGINDEPTAILS");
+
+  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
+  //                        0      1       2       3       4      5      6
+                        "alJPsi","nlJPsi","auJPsi","nuJPsi");
+  //                       7        8        9        10
+//  fitTotal->SetParName(11, "kPsiP");
+//  //                            11
+//  fitTotal->SetParName(12, "mPsiP");
+//  //                            12
+//  fitTotal->SetParName(13, "sPsiP");
+//  //                            13
+//  fitTotal->SetParName(14, "alPsiP");
+//  //                            14
+//  fitTotal->SetParName(15, "nlPsiP");
+//  //                            15
+//  fitTotal->SetParName(16, "auPsiP");
+//  //                            16
+//  fitTotal->SetParName(17, "nuPsiP");
+//  //                            17
+
+  fitTotal->SetParName(11, "kPsiP");
+  //                            11
+   fitTotal->SetParName(12, "alPsiP");
+  //                            12
+  fitTotal->SetParName(13, "nlPsiP");
+  //                            13
+  fitTotal->SetParName(14, "auPsiP");
+  //                            14
+  fitTotal->SetParName(15, "nuPsiP");
+  //                            15
+
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+  const char* fitOption = "SERI";
+
+#if 0
+  bck->SetParameter(0,fHisto->GetMaximum());
+  bck->SetParameter(1,3);
+  bck->SetParameter(2,10);
+  bck->SetParameter(3,10);
+
+  bck->SetParLimits(1, 0., 100.);
+  bck->SetParLimits(2, 0., 100.);
+  bck->SetParLimits(3, 0., 100.);
+
+  SetFitRejectRange(2.7,3.5);
+
+  fHisto->Fit(bck,fitOption,"");
+
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    Double_t a,b;
+    bck->GetParLimits(i,a,b);
+    fitTotal->SetParameter(i,bck->GetParameter(i));
+    fitTotal->SetParLimits(i,a,b);
+  }
+#endif
+
+  Int_t bin = fHisto->FindBin(fitRangeLow);
+  fitTotal->SetParameter(0, fHisto->GetBinContent(bin)); // kVWG
+  fitTotal->SetParameter(1, 1.9); // mVWG
+
+  fitTotal->SetParameter(2, 0.5); // sVWG1
+  fitTotal->SetParLimits(2, 0., 100.);
+
+  fitTotal->SetParameter(3, 0.3); // sVWG2
+  fitTotal->SetParLimits(3, 0., 100.);
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
+
+  fitTotal->SetParameter(5, 3.1); // mean
+  fitTotal->SetParLimits(5, 3.0, 3.2);
+
+  fitTotal->SetParameter(6, 0.08); // sigma
+  fitTotal->SetParLimits(6, 0.03, 0.15);
+
+  if ( IsValidValue(alphaLow) )
+  {
+    fitTotal->FixParameter(7, alphaLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(7,0.9);
+    fitTotal->SetParLimits(7,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) )
+  {
+    fitTotal->FixParameter(8, nLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(8,5.0);
+    fitTotal->SetParLimits(8,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) )
+  {
+    fitTotal->FixParameter(9, alphaUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(9, 2.0);
+    fitTotal->SetParLimits(9,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) )
+  {
+    fitTotal->FixParameter(10, nUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(10,3.0);
+    fitTotal->SetParLimits(10,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+
+//  fitTotal->SetParameter(12, 3.7); // mean PsiP
+//  fitTotal->SetParLimits(12, 3.6, 3.71);
+//
+//  fitTotal->SetParameter(13, 0.08/3.096916*3.68609); // sigma PsiP
+//  fitTotal->SetParLimits(13, 0.03/3.096916*3.68609, 0.15/3.096916*3.68609);
+
+  if ( IsValidValue(alphaLowP) )
+  {
+    fitTotal->FixParameter(12, alphaLowP);
+  }
+  else
+  {
+    fitTotal->SetParameter(12,0.9);
+    fitTotal->SetParLimits(12,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLowP) )
+  {
+    fitTotal->FixParameter(13, nLowP);
+  }
+  else
+  {
+    fitTotal->SetParameter(13,5.0);
+    fitTotal->SetParLimits(13,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUpP) )
+  {
+    fitTotal->FixParameter(14, alphaUpP);
+  }
+  else
+  {
+    fitTotal->SetParameter(14, 2.0);
+    fitTotal->SetParLimits(14,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUpP) )
+  {
+    fitTotal->FixParameter(15, nUpP);
+  }
+  else
+  {
+    fitTotal->SetParameter(15,3.0);
+    fitTotal->SetParLimits(15,0.0,10.0);
+  }
+
+  //  SetFitRejectRange();
+
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+
+  if ( static_cast<int>(fitResult) )
+  {
+    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
+    {
+      std::cout << "//-------Refitting again (setting Psi'norm= Psi'norm/2)" << std::endl;
+
+      fitTotal->SetParameter(11, fHisto->GetBinContent(bin)/2.);
+    }
+
+    if ( fitTotal->GetParameter(0) <= fitTotal->GetParError(0) ) //kVWG
+    {
+      std::cout << "//-------Refitting again (setting VWG norm= VWG norm /2)" << std::endl;
+      bin = fHisto->FindBin(fitRangeLow);
+
+      fitTotal->SetParameter(0, fHisto->GetBinContent(bin)/2.);
+    }
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  }
+
+
+  if ( static_cast<int>(fitResult) )
+  {
+    if ( fitTotal->GetParameter(11) <= fitTotal->GetParError(11) ) //kPsi'
+    {
+      std::cout << "//-------Refitting again (setting Psi'norm=0)" << std::endl;
+
+      fitTotal->FixParameter(11, 0.);
+    }
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  }
+
+  if ( static_cast<int>(fitResult) )
+  {
+    std::cout << "//-------Refitting again (setting kVWG=kVWG/2)" << std::endl;
+
+    fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
+
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  }
+
+  if ( static_cast<int>(fitResult) )
+  {
+    std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+  }
+
+
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+
+  Set("mPsiP",3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,fitTotal->GetParError(5)/3.096916*3.68609);
+  Set("sPsiP",fitTotal->GetParameter(6)*paramSPsiP,fitTotal->GetParError(6)*paramSPsiP);
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(4),
+                        fitTotal->GetParameter(5),
+                        fitTotal->GetParameter(6),
+                        fitTotal->GetParameter(7),
+                        fitTotal->GetParameter(8),
+                        fitTotal->GetParameter(9),
+                        fitTotal->GetParameter(10));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(11),
+                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14),
+                            fitTotal->GetParameter(15));
+
+  bck->SetParameters(fitTotal->GetParameter(0),
+                     fitTotal->GetParameter(1),
+                     fitTotal->GetParameter(2),
+                     fitTotal->GetParameter(3));
+
+
+  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+
+  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+
+  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("alPsiP",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("nlPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+  Set("auPsiP",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("nuPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+
+
+
+//  SetFitRejectRange();
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2EXP()
+{
+  /// Fit using 2 extended crystal balls (signal) + pol2 x exp (background)
+  /// 13 parameters
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow = GetValue("alJPsi");
+  Double_t nLow = GetValue("nlJPsi");
+  Double_t alphaUp = GetValue("auJPsi");
+  Double_t nUp = GetValue("nuJPsi");
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime Pol2 x Exp %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp,fitRangeLow,fitRangeHigh,12,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol2Exp");
+
+  fitTotal->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","alJPsi",
+  //                      0      1       2     3      4      5       6       7
+                        "nlJPsi","auJPsi","nuJPsi");
+  //                          8       9        10
+  fitTotal->SetParName(11,"kPsiP");
+  //                            11
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
+  //__________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
+
+  Int_t bin = fHisto->FindBin(0.26);
+
+  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin)/3.,100.,0.05);//fHisto->GetBinContent(bin)
+
+  SetFitRejectRange(2.7,4.0);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SRL");
+  //___________
+
+  SetFitRejectRange();
+  //____________
+
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+  }
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
+
+  fitTotal->SetParameter(5, 3.1);
+  fitTotal->SetParLimits(5, 3.07, 3.2);
+  fitTotal->SetParameter(6, 0.08);
+  fitTotal->SetParLimits(6, 0.05, 0.15);
+
+  if ( IsValidValue(alphaLow) )
+  {
+    fitTotal->FixParameter(7, alphaLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(7,0.9);
+    fitTotal->SetParLimits(7,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) )
+  {
+    fitTotal->FixParameter(8, nLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(8,5.0);
+    fitTotal->SetParLimits(8,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) )
+  {
+    fitTotal->FixParameter(9, alphaUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(9, 2.0);
+    fitTotal->SetParLimits(9,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) )
+  {
+    fitTotal->FixParameter(10, nUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(10,3.0);
+    fitTotal->SetParLimits(10,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+
+  const char* fitOption = "SERLI";
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,11,3);
+  //___________
+
+
+  delete bckInit; //Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(4),
+                            fitTotal->GetParameter(5),
+                            fitTotal->GetParameter(6),
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(11),
+                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10));
+
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    bck->SetParameter(i, fitTotal->GetParameter(i));
+  }
+
+//  Set("kPol2Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("exp",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+
+  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+
+  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[4];
+  Double_t bkgcovarianceMatrix[4][4];
+
+  for ( int ix = 0; ix < 4; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 4; ++iy )
+  {
+    for ( int ix = 0; ix < 4; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                              TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //__________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL4EXP()
+{
+  /// Fit using 2 extended crystal balls (signal) + pol4 x exp (background)
+  /// 15 parameters
+  // Not used in pA Jpsi analysis: too many parameters for correct convergence (Error matrix not pos. def.)
+
+  fHisto->GetListOfFunctions()->Delete();
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t alphaLow = GetValue("alJPsi");
+  Double_t nLow = GetValue("nlJPsi");
+  Double_t alphaUp = GetValue("auJPsi");
+  Double_t nUp = GetValue("nuJPsi");
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  TString msg;
+
+  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
+  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
+  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
+  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime Pol4 x Exp %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol4Exp,fitRangeLow,fitRangeHigh,14,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol4Exp");
+
+  fitTotal->SetParNames("pol0","pol1","pol2","pol3","pol4","exp","kJPsi",
+  //                      0       1      2      3     4       5     6
+                        "mJPsi","sJPsi","alJPsi","nlJPsi");
+  //                       7      8       9         10
+  fitTotal->SetParName(11,"auJPsi");
+  //                        11
+  fitTotal->SetParName(12,"nuJPsi");
+  //                         12
+  fitTotal->SetParName(13,"kPsiP");
+  //                         13
+
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,fitRangeLow,fitRangeHigh,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
+  //__________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,1.6,7.,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
+
+  Int_t bin = fHisto->FindBin(1.6);
+
+  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin),fHisto->GetBinContent(bin)/2.,-fHisto->GetBinContent(bin)/10.,fHisto->GetBinContent(bin)/100.,-2.);
+
+  SetFitRejectRange(2.6,4.0);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SRL");
+  //___________
+
+  SetFitRejectRange();
+  //____________
+
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 6; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+  }
+
+  bin = fHisto->FindBin(3.09);
+  fitTotal->SetParameter(6, fHisto->GetBinContent(bin)); // norm(kJPsi)
+
+  fitTotal->SetParameter(7, 3.1); // mean
+  fitTotal->SetParLimits(7, 3.0, 3.2);
+
+  fitTotal->SetParameter(8, 0.08); // sigma
+  fitTotal->SetParLimits(8, 0.03, 0.15);
+
+  if ( IsValidValue(alphaLow) )
+  {
+    fitTotal->FixParameter(9, alphaLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(9,0.9);
+    fitTotal->SetParLimits(9,0.1,10.0);
+  }
+
+  if ( IsValidValue(nLow) )
+  {
+    fitTotal->FixParameter(10, nLow);
+  }
+  else
+  {
+    fitTotal->SetParameter(10,5.0);
+    fitTotal->SetParLimits(10,0.0,10.0);
+  }
+
+  if ( IsValidValue(alphaUp) )
+  {
+    fitTotal->FixParameter(11, alphaUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(11, 2.0);
+    fitTotal->SetParLimits(11,0.1,10.0);
+  }
+
+  if ( IsValidValue(nUp) )
+  {
+    fitTotal->FixParameter(12, nUp);
+  }
+  else
+  {
+    fitTotal->SetParameter(12,3.0);
+    fitTotal->SetParLimits(12,0.0,10.0);
+  }
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(13, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  fitTotal->SetParLimits(13, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+
+  const char* fitOption = "SERI";
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,13,4);
+  //___________
+
+
+  delete bckInit; //Delete the initial background funtion
+
+
+  //___________Set parameters and fit functions to store in the result
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("mJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("sJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalJPsi->SetParameters(fitTotal->GetParameter(6),
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
+  signalPsiP->SetParameters(fitTotal->GetParameter(13),
+                            3.68609+(fitTotal->GetParameter(7)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(8)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12));
+
+  for ( Int_t i = 0; i < 7; ++i )
+  {
+    bck->SetParameter(i, fitTotal->GetParameter(i));
+  }
+
+  Set("alJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("nlJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("auJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("nuJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+//  Set("kPol4Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("pol3",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("pol4",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("exp",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+
+  Set("kJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("kPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+
+
+  AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
+
+  Double_t cbParameters[7];
+  Double_t covarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
+  {
+    cbParameters[ix] = fitTotal->GetParameter(ix+6);
+  }
+
+  for ( int iy = 0; iy < 7; ++iy )
+  {
+    for ( int ix = 0; ix < 7; ++ix )
+    {
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+6,iy+6);
+    }
+  }
+
+  Double_t a = fHisto->GetXaxis()->GetXmin();
+  Double_t b = fHisto->GetXaxis()->GetXmax();
+  double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
+  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi",njpsi,nerr);
+
+  double m = GetValue("mJPsi");
+  double s = GetValue("sJPsi");
+  double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  Set("NofJPsi3s",njpsi3s,nerr3s);
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[6];
+  Double_t bkgcovarianceMatrix[6][6];
+
+  for ( int ix = 0; ix < 6; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 6; ++iy )
+  {
+    for ( int ix = 0; ix < 6; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                              TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //_____________________________
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
+{
+  /// Fit using 2 NA60(new) (signal) + variable width gaussian (background)
+
+  fHisto->GetListOfFunctions()->Delete();
+  const char* fitOption = "SERLI";
+  const char* fitOptionBg = "SRL";
+
+
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t p1Left = GetValue("p1LJPsi");
+  Double_t p2Left = GetValue("p2LJPsi");
+  Double_t p3Left = GetValue("p3LJPsi");
+  Double_t p1Right = GetValue("p1RJPsi");
+  Double_t p2Right = GetValue("p2RJPsi");
+  Double_t p3Right = GetValue("p3RJPsi");
+
+  Double_t alphaLeft = GetValue("aLJPsi");
+  Double_t alphaRight = GetValue("aRJPsi");
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
+  Double_t fitRangeLow = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+
+  TString msg;
+
+  if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
+  if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
+  if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
+  if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
+  if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
+  if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
+
+  if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
+  if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and VWG %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewVWG");
+
+  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
+  //                       0      1      2       3       4       5       6
+                        "p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
+  //                        7         8         9        10
+  fitTotal->SetParName(11, "p2RJPsi");
+  //                           11
+  fitTotal->SetParName(12, "p3RJPsi");
+  //                           12
+  fitTotal->SetParName(13, "aLJPsi");
+  //                           13
+  fitTotal->SetParName(14, "aRJPsi");
+  //                           14
+  fitTotal->SetParName(15, "kPsiP");
+  //                           15
+
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+  //__________
+
+
+  //__________ Fit background only for initial parameters
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
+
+  Int_t bin = fHisto->FindBin(0.26);
+
+  bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
+
+  SetFitRejectRange(2.7,4.0);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
+  std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
+
+  //___________ Further attempts to fit bkg if the first one fails
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG",fitOptionBg);
+  //___________
+
+  SetFitRejectRange();
+  //____________
+
+
+  //__________ Set initial parameters in fitting function
+  for ( Int_t i = 0; i < 4; ++i )
+  {
+    fitTotal->SetParameter(i, bckInit->GetParameter(i));
+  }
+
+
+  fitTotal->SetParameter(5, 3.1); // mean
+  fitTotal->SetParLimits(5, 3.0, 3.2);
+
+  fitTotal->SetParameter(6, 0.08); // sigma
+  fitTotal->SetParLimits(6, 0.03, 0.2);
+
+  fitTotal->FixParameter(7, p1Left);
+  fitTotal->FixParameter(8, p2Left);
+  fitTotal->FixParameter(9, p3Left);
+  fitTotal->FixParameter(10, p1Right);
+  fitTotal->FixParameter(11, p2Right);
+  fitTotal->FixParameter(12, p3Right);
+
+  fitTotal->FixParameter(13, alphaLeft);
+  fitTotal->FixParameter(14, alphaRight);
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(15, fHisto->GetBinContent(bin)*0.8); //kPsi'
+  // fitTotal->SetParLimits(15, 0.,fHisto->GetBinContent(bin));
+
+  //_____________First fit attempt
+  TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
+
+  std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  //___________
+
+  //___________ Further attempts to fit if the first one fails
+  if ( static_cast<int>(fitResult) ||  (!static_cast<int>(fitResult)&&static_cast<int>(fitResult->CovMatrixStatus())!=3) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,15,3);
+  //___________
+
+  delete bckInit;//Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalJPsi->SetParameters(fitTotal->GetParameter(4),
+                            fitTotal->GetParameter(5),
+                            fitTotal->GetParameter(6),
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13));
+
+  signalJPsi->SetParameter(10,fitTotal->GetParameter(14));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalPsiP->SetParameters(fitTotal->GetParameter(15),
+                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(7),
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13));
+
+  signalPsiP->SetParameter(10,fitTotal->GetParameter(14));
+
+  bck->SetParameter(0,fitTotal->GetParameter(0));
+  bck->SetParameter(1,fitTotal->GetParameter(1));
+  bck->SetParameter(2,fitTotal->GetParameter(2));
+  bck->SetParameter(3,fitTotal->GetParameter(3));
+
+  Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+
+  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("kPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+
+  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+
+  Set("p1LJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("p2LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("p3LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("p1RJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("p2RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p3RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+
+  Set("aLJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+  Set("aRJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
-  
-  
-  Double_t cbParameters[7];
-  Double_t covarianceMatrix[7][7];
-  
-  for ( int ix = 0; ix < 7; ++ix )
+
+  Double_t na60Parameters[11];
+  Double_t covarianceMatrix[11][11];
+
+  for ( int ix = 0; ix < 11; ++ix )
   {
-    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+    na60Parameters[ix] = fitTotal->GetParameter(ix+4);
   }
-  
-  for ( int iy = 0; iy < 7; ++iy )
+
+  for ( int iy = 0; iy < 11; ++iy )
   {
-    for ( int ix = 0; ix < 7; ++ix )
+    for ( int ix = 0; ix < 11; ++ix )
     {
       covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
     }
   }
-  
+
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
-  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+  double nerr = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
   Set("NofJPsi",njpsi,nerr);
-  
+
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
-  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
   Set("NofJPsi3s",njpsi3s,nerr3s);
+
+  //_____________________________
+
+
+  //_____Computation of bin significance and signal over background
+  Double_t bkgParameters[4];
+  Double_t bkgcovarianceMatrix[4][4];
+
+  for ( int ix = 0; ix < 4; ++ix )
+  {
+    bkgParameters[ix] = fitTotal->GetParameter(ix);
+  }
+
+  for ( int iy = 0; iy < 4; ++iy )
+  {
+    for ( int ix = 0; ix < 4; ++ix )
+    {
+      bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
+    }
+  }
+
+  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
+  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
+
+  Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
+
+  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+  double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
+                              TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
+
+  Set("Significance3s",sig,sigErr);
+  //___________________
+
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL2EXP()
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG2()
 {
-  /// Fit using 2 extended crystal balls (signal) + pol2 x exp (background)
-  /// 13 parameters
-  
-  fHisto->GetListOfFunctions()->Delete();
+  /// Fit using 2 NA60(new) (signal) + variable width gaussian (background)
 
-  //__________ Get tails parameters, fitting range and SigmaPsiP
-  Double_t alphaLow = GetValue("alJPsi");
-  Double_t nLow = GetValue("nlJPsi");
-  Double_t alphaUp = GetValue("auJPsi");
-  Double_t nUp = GetValue("nuJPsi");
-  Double_t fitRangeLow = GetValue(kFitRangeLow);
-  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
-  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+  fHisto->GetListOfFunctions()->Delete();
+  const char* fitOption = "SERL";
+  const char* fitOptionBg = "SR";
   
-  TString msg;
   
-  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
-  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
-  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
-  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
-  //__________
+  //__________ Get tails parameters, fitting range and SigmaPsiP
+  Double_t p1Left       = GetValue("p1LJPsi");
+  Double_t p2Left       = GetValue("p2LJPsi");
+  Double_t p3Left       = GetValue("p3LJPsi");
+  Double_t p1Right      = GetValue("p1RJPsi");
+  Double_t p2Right      = GetValue("p2RJPsi");
+  Double_t p3Right      = GetValue("p3RJPsi");
   
-  AliDebug(1,Form("Fit with jpsi + psiprime Pol2 x Exp %s",msg.Data()));
+  Double_t alphaLeft    = GetValue("aLJPsi");
+  Double_t alphaRight   = GetValue("aRJPsi");
   
-  //__________ Define the function to fit the spectrum, and the background just for plotting
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol2Exp,fitRangeLow,fitRangeHigh,12,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol2Exp");
+  Double_t paramSPsiP   = GetValue("FSigmaPsiP");
   
-  fitTotal->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","alJPsi",
-  //                      0      1       2     3      4      5       6       7
-                        "nlJPsi","auJPsi","nuJPsi");
-  //                          8       9        10
-  fitTotal->SetParName(11,"kPsiP");
-  //                            11
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
   
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  //__________
+  TString msg;
   
+  if (IsValidValue(p1Left)) msg     += TString::Format("p1L=%e ",p1Left);
+  if (IsValidValue(p2Left)) msg     += TString::Format("p2L=%e ",p2Left);
+  if (IsValidValue(p3Left)) msg     += TString::Format("p3L=%e ",p3Left);
+  if (IsValidValue(p1Right)) msg    += TString::Format("p1R=%e ",p1Right);
+  if (IsValidValue(p2Right)) msg    += TString::Format("p2R=%e ",p2Right);
+  if (IsValidValue(p3Right)) msg    += TString::Format("p3R=%e ",p3Right);
   
+  if (IsValidValue(alphaLeft)) msg  += TString::Format("aL=%e ",alphaLeft);
+  if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
+  //__________
+
+  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and VWG %s",msg.Data()));
+
+  //__________ Define the function to fit the spectrum, and the background just for plotting
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG2,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewVWG2");
+
+  fitTotal->SetParNames("kVWG","mVWG","s1VWG2","s2VWG2","gVWG2","kJPsi","mJPsi","sJPsi","p1LJPsi","p2LJPsi","p3LJPsi");
+  //                       0      1      2       3       4       5       6      7         8         9        10
+  fitTotal->SetParName(11, "p1RJPsi");
+  //                           11
+  fitTotal->SetParName(12, "p2RJPsi");
+  //                           12
+  fitTotal->SetParName(13, "p3RJPsi");
+  //                           13
+  fitTotal->SetParName(14, "aLJPsi");
+  //                           14
+  fitTotal->SetParName(15, "aRJPsi");
+  //                           15
+  fitTotal->SetParName(16, "kPsiP");
+  //                           16
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG2");
+  //__________
+
+
   //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG2,1.9,5.,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG2");
+
   Int_t bin = fHisto->FindBin(0.26);
-  
-  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin)/3.,100.,0.05);//fHisto->GetBinContent(bin)
-  
-  SetFitRejectRange(2.7,4.0);
-  
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
-  
+
+  bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3,0.);
+
+  SetFitRejectRange(2.6,4.0);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
-  
+
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG2",fitOptionBg);
   //___________
-  
+
   SetFitRejectRange();
   //____________
-  
 
   //__________ Set initial parameters in fitting function
-  for ( Int_t i = 0; i < 4; ++i )
+  for ( Int_t i = 0; i < 5; ++i )
   {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
   }
 
-  bin = fHisto->FindBin(3.09);
-  fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // norm(kJPsi)
-  
-  fitTotal->SetParameter(5, 3.1);
-  fitTotal->SetParLimits(5, 3.07, 3.2);
-  fitTotal->SetParameter(6, 0.08);
-  fitTotal->SetParLimits(6, 0.05, 0.15);
-  
-  if ( IsValidValue(alphaLow) )
-  {
-    fitTotal->FixParameter(7, alphaLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(7,0.9);
-    fitTotal->SetParLimits(7,0.1,10.0);
-  }
-  
-  if ( IsValidValue(nLow) )
-  {
-    fitTotal->FixParameter(8, nLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(8,5.0);
-    fitTotal->SetParLimits(8,0.0,10.0);
-  }
-  
-  if ( IsValidValue(alphaUp) )
-  {
-    fitTotal->FixParameter(9, alphaUp);
-  }
-  else
-  {
-    fitTotal->SetParameter(9, 2.0);
-    fitTotal->SetParLimits(9,0.1,10.0);
-  }
-  
-  if ( IsValidValue(nUp) )
-  {
-    fitTotal->FixParameter(10, nUp);
-  }
-  else
-  {
-    fitTotal->SetParameter(10,3.0);
-    fitTotal->SetParLimits(10,0.0,10.0);
-  }
-  
-  bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(11, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(11, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
-  
-  const char* fitOption = "SER";
-  
+  fitTotal->SetParameter(6, 3.1); // mean
+  fitTotal->SetParLimits(6, 3.0, 3.2);
+
+  fitTotal->SetParameter(7, 0.08); // sigma
+  fitTotal->SetParLimits(7, 0.03, 0.2);
+
+  fitTotal->FixParameter(8, p1Left);
+  fitTotal->FixParameter(9, p2Left);
+  fitTotal->FixParameter(10, p3Left);
+  fitTotal->FixParameter(11, p1Right);
+  fitTotal->FixParameter(12, p2Right);
+  fitTotal->FixParameter(13, p3Right);
+
+  fitTotal->FixParameter(14, alphaLeft);
+  fitTotal->FixParameter(15, alphaRight);
+
+  bin = fHisto->FindBin(3.67);
+  fitTotal->SetParameter(16, fHisto->GetBinContent(bin)*0.2); //kPsi'
+  // fitTotal->SetParLimits(16, 0.,1.1*fHisto->GetBinContent(bin));
+
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
-  
+
   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   //___________
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,11,3);
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,16,4);
   //___________
-  
 
-  delete bckInit; //Delete the initial background funtion
+  delete bckInit;//Delete the initial background funtion
 
   //___________Set parameters and fit functions to store in the result
-  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
-  Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
-  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  
-  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalJPsi->SetParameters(fitTotal->GetParameter(4),
-                            fitTotal->GetParameter(5),
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalJPsi->SetParameters(fitTotal->GetParameter(5),
                             fitTotal->GetParameter(6),
                             fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
-                            fitTotal->GetParameter(10));
-  
-  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalPsiP->SetParameters(fitTotal->GetParameter(11),
-                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
-                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
-                            fitTotal->GetParameter(7),
-                            fitTotal->GetParameter(8),
-                            fitTotal->GetParameter(9),
-                            fitTotal->GetParameter(10));
-  
-  for ( Int_t i = 0; i < 4; ++i )
-  {
-    bck->SetParameter(i, fitTotal->GetParameter(i));
-  }
-  
-//  Set("kPol2Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("exp",fitTotal->GetParameter(3),fitTotal->GetParError(3));
-  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  
-  Set("alJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("nlJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  Set("auJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("nuJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  
-  Set("kPsiP",fitTotal->GetParameter(11),fitTotal->GetParError(11));
-  
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14));
+
+  signalJPsi->SetParameter(10,fitTotal->GetParameter(15));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalPsiP->SetParameters(fitTotal->GetParameter(16),
+                            3.68609+(fitTotal->GetParameter(6)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(7)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(8),
+                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(10),
+                            fitTotal->GetParameter(11),
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14));
+
+  signalPsiP->SetParameter(10,fitTotal->GetParameter(15));
+
+  bck->SetParameter(0,fitTotal->GetParameter(0));
+  bck->SetParameter(1,fitTotal->GetParameter(1));
+  bck->SetParameter(2,fitTotal->GetParameter(2));
+  bck->SetParameter(3,fitTotal->GetParameter(3));
+  bck->SetParameter(4,fitTotal->GetParameter(4));
+
+  Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("s1VWG2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("s2VWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("gVWG2",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+
+  Set("kJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("kPsiP",fitTotal->GetParameter(16),fitTotal->GetParError(16));
+
+  Set("mJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("sJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+
+  Set("p1LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("p2LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("p3LJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("p1RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p2RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("p3RJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+  Set("aLJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("aRJPsi",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
-  
-  Double_t cbParameters[7];
-  Double_t covarianceMatrix[7][7];
-  
-  for ( int ix = 0; ix < 7; ++ix )
+
+  Double_t na60Parameters[11];
+  Double_t covarianceMatrix[11][11];
+
+  for ( int ix = 0; ix < 11; ++ix )
   {
-    cbParameters[ix] = fitTotal->GetParameter(ix+4);
+    na60Parameters[ix] = fitTotal->GetParameter(ix+5);
   }
-  
-  for ( int iy = 0; iy < 7; ++iy )
+
+  for ( int iy = 0; iy < 11; ++iy )
   {
-    for ( int ix = 0; ix < 7; ++ix )
+    for ( int ix = 0; ix < 11; ++ix )
     {
-      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+5,iy+5);
     }
   }
-  
-  Double_t a = fHisto->GetXaxis()->GetXmin();
-  Double_t b = fHisto->GetXaxis()->GetXmax();
+
+  Double_t a   = fHisto->GetXaxis()->GetXmin();
+  Double_t b   = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
-  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+  double nerr  = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
   Set("NofJPsi",njpsi,nerr);
-  
-  double m = GetValue("mJPsi");
-  double s = GetValue("sJPsi");
+
+  double m       = GetValue("mJPsi");
+  double s       = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
-  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+  double nerr3s  = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
   Set("NofJPsi3s",njpsi3s,nerr3s);
   //_____________________________
-  
-  
+
+
   //_____Computation of bin significance and signal over background
-  Double_t bkgParameters[4];
-  Double_t bkgcovarianceMatrix[4][4];
-  
-  for ( int ix = 0; ix < 4; ++ix )
+  Double_t bkgParameters[5];
+  Double_t bkgcovarianceMatrix[5][5];
+
+  for ( int ix = 0; ix < 5; ++ix )
   {
     bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
-  
-  for ( int iy = 0; iy < 4; ++iy )
+
+  for ( int iy = 0; iy < 5; ++iy )
   {
-    for ( int ix = 0; ix < 4; ++ix )
+    for ( int ix = 0; ix < 5; ++ix )
     {
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
   }
+
+  double nbck3s      = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
+  double nbck3sErr   = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
   
-  double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
-  double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
-  double sOverB3s = njpsi3s / nbck3s;
+  double sOverB3s    = njpsi3s / nbck3s;
   double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
-  
+
   Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
-  
-  double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
+
+  double sig    = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
   double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
-  
-  Set("Significance3s",sig,sigErr);
-  //__________
 
+  Set("Significance3s",sig,sigErr);
+  //___________________
+  
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMECB2POL4EXP()
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL1POL2()
 {
-  /// Fit using 2 extended crystal balls (signal) + pol4 x exp (background)
-  /// 15 parameters
-  // Not used in pA Jpsi analysis: too many parameters for correct convergence (Error matrix not pos. def.)
-  
+  /// Fit using 2 NA60(new) (signal) + POL1/POL2 (background)
+
   fHisto->GetListOfFunctions()->Delete();
 
+  const char* fitOption = "SERLI";
+  const char* fitOptionBg = "SRLI";
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
-  Double_t alphaLow = GetValue("alJPsi");
-  Double_t nLow = GetValue("nlJPsi");
-  Double_t alphaUp = GetValue("auJPsi");
-  Double_t nUp = GetValue("nuJPsi");
+  Double_t p1Left = GetValue("p1LJPsi");
+  Double_t p2Left = GetValue("p2LJPsi");
+  Double_t p3Left = GetValue("p3LJPsi");
+  Double_t p1Right = GetValue("p1RJPsi");
+  Double_t p2Right = GetValue("p2RJPsi");
+  Double_t p3Right = GetValue("p3RJPsi");
+
+  Double_t alphaLeft = GetValue("aLJPsi");
+  Double_t alphaRight = GetValue("aRJPsi");
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
-  Double_t paramSPsiP = GetValue("FSigmaPsiP");
-  
+
   TString msg;
-  
-  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
-  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
-  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
-  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
+
+  if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
+  if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
+  if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
+  if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
+  if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
+  if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
+
+  if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
+  if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
   //__________
-  
-  AliDebug(1,Form("Fit with jpsi + psiprime Pol4 x Exp %s",msg.Data()));
-  
+
+  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and pol1/pol2 %s",msg.Data()));
+
   //__________ Define the function to fit the spectrum, and the background just for plotting
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2Pol4Exp,fitRangeLow,fitRangeHigh,14,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2Pol4Exp");
-  
-  fitTotal->SetParNames("pol0","pol1","pol2","pol3","pol4","exp","kJPsi",
-  //                      0       1      2      3     4       5     6
-                        "mJPsi","sJPsi","alJPsi","nlJPsi");
-  //                       7      8       9         10
-  fitTotal->SetParName(11,"auJPsi");
-  //                        11
-  fitTotal->SetParName(12,"nuJPsi");
-  //                         12
-  fitTotal->SetParName(13,"kPsiP");
-  //                         13
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol1Pol2,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewPol1Pol2");
+
+  fitTotal->SetParNames("a","b","a'","b'","c'","kJPsi","mJPsi","sJPsi",
+  //                     0   1   2    3    4      5       6       7
+                        "p1LJPsi","p2LJPsi","p3LJPsi");
+  //                        8         9         10
+  fitTotal->SetParName(11, "p1RJPsi");
+  //                           11
+  fitTotal->SetParName(12, "p2RJPsi");
+  //                           12
+  fitTotal->SetParName(13, "p3RJPsi");
+  //                           13
+  fitTotal->SetParName(14, "aLJPsi");
+  //                           14
+  fitTotal->SetParName(15, "aRJPsi");
+  //                           15
+  fitTotal->SetParName(16, "kPsiP");
+  //                           16
+
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
+  //___________
+
 
-  
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,fitRangeLow,fitRangeHigh,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
-  //__________
-  
-  
   //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,1.6,7.,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
-  
-  Int_t bin = fHisto->FindBin(1.6);
-  
-  bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin),fHisto->GetBinContent(bin)/2.,-fHisto->GetBinContent(bin)/10.,fHisto->GetBinContent(bin)/100.,-2.);
-  
-  SetFitRejectRange(2.6,4.0);
-  
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
-  
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol1Pol2,1.7,6.,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol1Pol2");
+  Int_t bin = fHisto->FindBin(0.70);
+
+
+  bckInit->SetParameters(0.,bin,0.,1.,1.);
+  bckInit->SetParLimits(0,-200,50);
+  bckInit->SetParLimits(2,-50,2000);
+  bckInit->SetParLimits(3,-300,100);
+  bckInit->FixParameter(4, 1.);
+
+  SetFitRejectRange(2.6,3.5);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
-  
+
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SR");
-  //___________
-  
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol1Pol2",fitOptionBg);
   SetFitRejectRange();
   //____________
 
-  
   //__________ Set initial parameters in fitting function
-  for ( Int_t i = 0; i < 6; ++i )
-  {
+  for ( Int_t i = 0; i < 5; ++i ) {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    if(i==4)fitTotal->FixParameter(i, 1.);
   }
 
-  bin = fHisto->FindBin(3.09);
-  fitTotal->SetParameter(6, fHisto->GetBinContent(bin)); // norm(kJPsi)
-  
-  fitTotal->SetParameter(7, 3.1); // mean
-  fitTotal->SetParLimits(7, 3.0, 3.2);
-  
-  fitTotal->SetParameter(8, 0.08); // sigma
-  fitTotal->SetParLimits(8, 0.03, 0.15);
-  
-  if ( IsValidValue(alphaLow) )
-  {
-    fitTotal->FixParameter(9, alphaLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(9,0.9);
-    fitTotal->SetParLimits(9,0.1,10.0);
-  }
-  
-  if ( IsValidValue(nLow) )
-  {
-    fitTotal->FixParameter(10, nLow);
-  }
-  else
-  {
-    fitTotal->SetParameter(10,5.0);
-    fitTotal->SetParLimits(10,0.0,10.0);
-  }
-  
-  if ( IsValidValue(alphaUp) )
-  {
-    fitTotal->FixParameter(11, alphaUp);
-  }
-  else
-  {
-    fitTotal->SetParameter(11, 2.0);
-    fitTotal->SetParLimits(11,0.1,10.0);
-  }
-  
-  if ( IsValidValue(nUp) )
-  {
-    fitTotal->FixParameter(12, nUp);
-  }
-  else
-  {
-    fitTotal->SetParameter(12,3.0);
-    fitTotal->SetParLimits(12,0.0,10.0);
-  }
+  fitTotal->SetParameter(6, 3.1); // mean
+  fitTotal->SetParLimits(6, 3.0, 3.2);
 
-  bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(13, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(13, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
+  fitTotal->SetParameter(7, 0.08); // sigma
+  fitTotal->SetParLimits(7, 0.03, 0.2);
 
-  const char* fitOption = "SERI";
+  fitTotal->FixParameter(8, p1Left);
+  fitTotal->FixParameter(9, p2Left);
+  fitTotal->FixParameter(10, p3Left);
+  fitTotal->FixParameter(11, p1Right);
+  fitTotal->FixParameter(12, p2Right);
+  fitTotal->FixParameter(13, p3Right);
+
+  fitTotal->FixParameter(14, alphaLeft);
+  fitTotal->FixParameter(15, alphaRight);
+
+  bin = fHisto->FindBin(3.68);
+  fitTotal->SetParameter(16, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  // fitTotal->SetParLimits(16, 0.,fHisto->GetBinContent(bin));
 
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
-  
+
   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   //___________
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,13,4);
-  //___________
-
-
-  delete bckInit; //Delete the initial background funtion
-  
-  
-  //___________Set parameters and fit functions to store in the result
-  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
-  Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
-  Set("mJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("sJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  
-  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalJPsi->SetParameters(fitTotal->GetParameter(6),
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,16,4);
+  //___________
+
+  delete bckInit;//Delete the initial background funtion
+
+  //___________Set parameters and fit functions to store in the result
+  TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalJPsi->SetParameters(fitTotal->GetParameter(5),
+                            fitTotal->GetParameter(6),
                             fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
-                            fitTotal->GetParameter(12));
-  
-  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionSignalCrystalBallExtended,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),7,"AliAnalysisMuMuJpsiResult","FitFunctionSignalCrystalBallExtended");
-  signalPsiP->SetParameters(fitTotal->GetParameter(13),
-                            3.68609+(fitTotal->GetParameter(7)-3.096916)/3.096916*3.68609,
-                            fitTotal->GetParameter(8)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14));
+
+  signalJPsi->SetParameter(10,fitTotal->GetParameter(15));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalPsiP->SetParameters(fitTotal->GetParameter(16),
+                            3.68609+(fitTotal->GetParameter(6)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(7)*paramSPsiP, // /3.096916*3.68609,
+                            fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
-                            fitTotal->GetParameter(12));
-  
-  for ( Int_t i = 0; i < 7; ++i )
-  {
-    bck->SetParameter(i, fitTotal->GetParameter(i));
-  }
-  
-  Set("alJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("nlJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  Set("auJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
-  Set("nuJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
-  
-//  Set("kPol4Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("pol3",fitTotal->GetParameter(3),fitTotal->GetParError(3));
-  Set("pol4",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  Set("exp",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  
-  Set("kJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  Set("kPsiP",fitTotal->GetParameter(13),fitTotal->GetParError(13));
-  
-  
-  
+                            fitTotal->GetParameter(12),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14));
+
+  signalPsiP->SetParameter(10,fitTotal->GetParameter(15));
+
+  bck->SetParameter(0,fitTotal->GetParameter(0));
+  bck->SetParameter(1,fitTotal->GetParameter(1));
+  bck->SetParameter(2,fitTotal->GetParameter(2));
+  bck->SetParameter(3,fitTotal->GetParameter(3));
+  bck->SetParameter(4,fitTotal->GetParameter(4));
+
+  Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
+  Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
+  Set("FitNDF",fitTotal->GetNDF(),0.0);
+
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("a'",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("b'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+
+  Set("kJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("kPsiP",fitTotal->GetParameter(16),fitTotal->GetParError(16));
+
+  Set("mJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+  Set("sJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+
+  Set("p1LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("p2LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+  Set("p3LJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("p1RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p2RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("p3RJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+
+  Set("aLJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("aRJPsi",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
-  
-  Double_t cbParameters[7];
-  Double_t covarianceMatrix[7][7];
-  
-  for ( int ix = 0; ix < 7; ++ix )
-  {
-    cbParameters[ix] = fitTotal->GetParameter(ix+6);
-  }
-  
-  for ( int iy = 0; iy < 7; ++iy )
+
+  Double_t na60Parameters[11];
+  Double_t covarianceMatrix[11][11];
+
+  for ( int ix = 0; ix < 11; ++ix ) na60Parameters[ix] = fitTotal->GetParameter(ix+5);
+
+  for ( int iy = 0; iy < 11; ++iy )
   {
-    for ( int ix = 0; ix < 7; ++ix )
+    for ( int ix = 0; ix < 11; ++ix )
     {
-      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+6,iy+6);
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+5,iy+5);
     }
   }
-  
-  Double_t a = fHisto->GetXaxis()->GetXmin();
-  Double_t b = fHisto->GetXaxis()->GetXmax();
+
+
+  Double_t a   = fHisto->GetXaxis()->GetXmin();
+  Double_t b   = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
-  double nerr = signalJPsi->IntegralError(a,b,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+  double nerr  = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
   Set("NofJPsi",njpsi,nerr);
-  
+
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
-  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&cbParameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+  double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
+
   Set("NofJPsi3s",njpsi3s,nerr3s);
   //_____________________________
-  
-  
+
+
   //_____Computation of bin significance and signal over background
-  Double_t bkgParameters[6];
-  Double_t bkgcovarianceMatrix[6][6];
-  
-  for ( int ix = 0; ix < 6; ++ix )
-  {
-    bkgParameters[ix] = fitTotal->GetParameter(ix);
-  }
-  
-  for ( int iy = 0; iy < 6; ++iy )
+  Double_t bkgParameters[5];
+  Double_t bkgcovarianceMatrix[5][5];
+
+  for ( int ix = 0; ix < 5; ++ix )bkgParameters[ix] = fitTotal->GetParameter(ix);
+
+  for ( int iy = 0; iy < 5; ++iy )
   {
-    for ( int ix = 0; ix < 6; ++ix )
+    for ( int ix = 0; ix < 5; ++ix )
     {
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
   }
-  
+
   double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
   double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   double sOverB3s = njpsi3s / nbck3s;
   double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
-  
+
   Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
-  
+
   double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
   double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
-  
+
   Set("Significance3s",sig,sigErr);
-  //_____________________________
-  
+  //___________________
+
 }
 
 //_____________________________________________________________________________
-void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
+void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2POL3()
 {
-  /// Fit using 2 NA60(new) (signal) + variable width gaussian (background)
-  
+  /// Fit using 2 NA60(new) (signal) + POL2/POL3 (background)
+
   fHisto->GetListOfFunctions()->Delete();
-  
+
+  const char* fitOption = "SERL";
+  const char* fitOptionBg = "SRL";
+
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
@@ -2641,244 +4862,256 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
   Double_t p1Right = GetValue("p1RJPsi");
   Double_t p2Right = GetValue("p2RJPsi");
   Double_t p3Right = GetValue("p3RJPsi");
-  
+
   Double_t alphaLeft = GetValue("aLJPsi");
   Double_t alphaRight = GetValue("aRJPsi");
-  
+
   Double_t paramSPsiP = GetValue("FSigmaPsiP");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   TString msg;
-  
+
   if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
   if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
   if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
   if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
   if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
   if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
-  
+
   if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
   if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
   //__________
-  
-  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and VWG %s",msg.Data()));
-  
+
+  AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and pol2/pol3 %s",msg.Data()));
+
   //__________ Define the function to fit the spectrum, and the background just for plotting
-  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewVWG,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewVWG");
-  
-  fitTotal->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi",
-  //                       0      1      2       3       4       5       6
-                        "p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
-  //                        7         8         9        10
-  fitTotal->SetParName(11, "p2RJPsi");
+  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol2Pol3,fitRangeLow,fitRangeHigh,19,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewPol2Pol3");
+
+  fitTotal->SetParNames("a","b","c","a'","b'","c'","d'","kJPsi","mJPsi","sJPsi",
+  //                     0   1   2   3    4    5    6      7      8       9
+                        "p1LJPsi");
+  //                        10
+  fitTotal->SetParName(11, "p2LJPsi");
   //                           11
-  fitTotal->SetParName(12, "p3RJPsi");
+  fitTotal->SetParName(12, "p3LJPsi");
   //                           12
-  fitTotal->SetParName(13, "aLJPsi");
+  fitTotal->SetParName(13, "p1RJPsi");
   //                           13
-  fitTotal->SetParName(14, "aRJPsi");
+  fitTotal->SetParName(14, "p2RJPsi");
   //                           14
-  fitTotal->SetParName(15, "kPsiP");
+  fitTotal->SetParName(15, "p3RJPsi");
   //                           15
-  
-  
-  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
-  
-  //__________
-  
+  fitTotal->SetParName(16, "aLJPsi");
+  //                           16
+  fitTotal->SetParName(17, "aRJPsi");
+  //                           17
+  fitTotal->SetParName(18, "kPsiP");
+  //                           18
+
+  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,fitRangeLow,fitRangeHigh,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
+
 
   //__________ Fit background only for initial parameters
-  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundVWG,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundVWG");
-  
-  Int_t bin = fHisto->FindBin(0.26);
-  
-  bckInit->SetParameters(fHisto->GetBinContent(bin),2.,0.5,0.3);
-  
-  SetFitRejectRange(2.7,4.0);
-  
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
-  
+  TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Pol3,1.9,6.,7,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Pol3");
+
+  Int_t bin = fHisto->FindBin(0.7);
+
+  bckInit->SetParameters(0.,0.,bin,0.,0.,1.,1.);
+  bckInit->FixParameter(6.,1);
+
+  // bckInit->SetParLimits(0.,-30,30);
+  // bckInit->SetParLimits(1.,-10,10);
+  // bckInit->SetParLimits(2.,-10,100);
+  bckInit->SetParLimits(3.,-10,10);
+  bckInit->SetParLimits(4.,-10,10);
+  bckInit->SetParLimits(5.,-30,30);
+
+//  bckInit->SetParLimits(0,fHisto->GetBinContent(bin)*0.5,fHisto->GetBinContent(bin)*10);
+
+  SetFitRejectRange(2.2,3.5);
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOptionBg);
+
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
-  
-  //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundVWG","SR");
-  //___________
-  
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Pol3",fitOptionBg);
+
   SetFitRejectRange();
   //____________
-
   
+  // new TCanvas,
+  // fHisto->DrawCopy();
+  // return;
+
   //__________ Set initial parameters in fitting function
-  for ( Int_t i = 0; i < 4; ++i )
-  {
+  for ( Int_t i = 0; i < 7; ++i ) {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
+    if(i==6)fitTotal->FixParameter(i, 1.);
   }
-  
-  
-  fitTotal->SetParameter(5, 3.1); // mean
-  fitTotal->SetParLimits(5, 3.0, 3.2);
-  
-  fitTotal->SetParameter(6, 0.08); // sigma
-  fitTotal->SetParLimits(6, 0.05, 0.15);
-  
-  fitTotal->FixParameter(7, p1Left);
-  fitTotal->FixParameter(8, p2Left);
-  fitTotal->FixParameter(9, p3Left);
-  fitTotal->FixParameter(10, p1Right);
-  fitTotal->FixParameter(11, p2Right);
-  fitTotal->FixParameter(12, p3Right);
-  
-  fitTotal->FixParameter(13, alphaLeft);
-  fitTotal->FixParameter(14, alphaRight);
-  
+
+  fitTotal->SetParameter(8, 3.1); // mean
+  fitTotal->SetParLimits(8, 3.0, 3.2);
+
+  fitTotal->SetParameter(9, 0.08); // sigma
+  fitTotal->SetParLimits(9, 0.03, 0.2);
+
+  fitTotal->FixParameter(10, p1Left);
+  fitTotal->FixParameter(11, p2Left);
+  fitTotal->FixParameter(12, p3Left);
+  fitTotal->FixParameter(13, p1Right);
+  fitTotal->FixParameter(14, p2Right);
+  fitTotal->FixParameter(15, p3Right);
+
+  fitTotal->FixParameter(16, alphaLeft);
+  fitTotal->FixParameter(17, alphaRight);
+
   bin = fHisto->FindBin(3.68);
-  fitTotal->SetParameter(15, fHisto->GetBinContent(bin)*0.5); //kPsi'
-  fitTotal->SetParLimits(15, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
-  
-  const char* fitOption = "SERI";
-  
+  fitTotal->SetParameter(18, fHisto->GetBinContent(bin)*0.5); //kPsi'
+  // fitTotal->SetParLimits(18, fHisto->GetBinContent(bin)*0.1,fHisto->GetBinContent(bin)*1.5);
+
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
-  
   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   //___________
-  
+
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,15,3);
-  //___________
-  
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,18,6);
   delete bckInit;//Delete the initial background funtion
 
-
   //___________Set parameters and fit functions to store in the result
   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
-  
-  signalJPsi->SetParameters(fitTotal->GetParameter(4),
-                            fitTotal->GetParameter(5),
-                            fitTotal->GetParameter(6),
-                            fitTotal->GetParameter(7),
+
+  signalJPsi->SetParameters(fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
                             fitTotal->GetParameter(9),
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
                             fitTotal->GetParameter(12),
-                            fitTotal->GetParameter(13));
-  
-  signalJPsi->SetParameter(10,fitTotal->GetParameter(14));
-  
-  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
-  
-  signalPsiP->SetParameters(fitTotal->GetParameter(15),
-                            3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
-                            fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
-                            fitTotal->GetParameter(7),
-                            fitTotal->GetParameter(8),
-                            fitTotal->GetParameter(9),
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14),
+                            fitTotal->GetParameter(15),
+                            fitTotal->GetParameter(16));
+
+  signalJPsi->SetParameter(10,fitTotal->GetParameter(17));
+
+  TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","FitFunctionNA60New");
+
+  signalPsiP->SetParameters(fitTotal->GetParameter(18),
+                            3.68609+(fitTotal->GetParameter(8)-3.096916)/3.096916*3.68609,
+                            fitTotal->GetParameter(9)*paramSPsiP, // /3.096916*3.68609,
                             fitTotal->GetParameter(10),
                             fitTotal->GetParameter(11),
                             fitTotal->GetParameter(12),
-                            fitTotal->GetParameter(13));
-  
-  signalPsiP->SetParameter(10,fitTotal->GetParameter(14));
-  
+                            fitTotal->GetParameter(13),
+                            fitTotal->GetParameter(14),
+                            fitTotal->GetParameter(15),
+                            fitTotal->GetParameter(16));
+
+  signalPsiP->SetParameter(10,fitTotal->GetParameter(17));
+
   bck->SetParameter(0,fitTotal->GetParameter(0));
   bck->SetParameter(1,fitTotal->GetParameter(1));
   bck->SetParameter(2,fitTotal->GetParameter(2));
   bck->SetParameter(3,fitTotal->GetParameter(3));
-  
+  bck->SetParameter(4,fitTotal->GetParameter(4));
+  bck->SetParameter(5,fitTotal->GetParameter(5));
+  bck->SetParameter(6,fitTotal->GetParameter(6));
+
   Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
-  Set("kVWG",fitTotal->GetParameter(0),fitTotal->GetParError(0));
-  Set("mVWG",fitTotal->GetParameter(1),fitTotal->GetParError(1));
-  Set("sVWG1",fitTotal->GetParameter(2),fitTotal->GetParError(2));
-  Set("sVWG2",fitTotal->GetParameter(3),fitTotal->GetParError(3));
-  
-  Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
-  Set("kPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
-  
-  Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  
-  Set("p1LJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
-  Set("p2LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  Set("p3LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
-  Set("p1RJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
-  Set("p2RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
-  Set("p3RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
-  
-  Set("aLJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
-  Set("aRJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
-  
+
+  Set("a",fitTotal->GetParameter(0),fitTotal->GetParError(0));
+  Set("b",fitTotal->GetParameter(1),fitTotal->GetParError(1));
+  Set("c",fitTotal->GetParameter(2),fitTotal->GetParError(2));
+  Set("a'",fitTotal->GetParameter(3),fitTotal->GetParError(3));
+  Set("b'",fitTotal->GetParameter(4),fitTotal->GetParError(4));
+  Set("c''",fitTotal->GetParameter(5),fitTotal->GetParError(5));
+  Set("d'",fitTotal->GetParameter(6),fitTotal->GetParError(6));
+
+  Set("kJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
+  Set("kPsiP",fitTotal->GetParameter(18),fitTotal->GetParError(18));
+
+  Set("mJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
+  Set("sJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
+
+  Set("p1LJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
+  Set("p2LJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
+  Set("p3LJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
+  Set("p1RJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
+  Set("p2RJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
+  Set("p3RJPsi",fitTotal->GetParameter(15),fitTotal->GetParError(15));
+
+  Set("aLJPsi",fitTotal->GetParameter(16),fitTotal->GetParError(16));
+  Set("aRJPsi",fitTotal->GetParameter(17),fitTotal->GetParError(17));
+
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
-  
+
   Double_t na60Parameters[11];
   Double_t covarianceMatrix[11][11];
-  
+
   for ( int ix = 0; ix < 11; ++ix )
   {
-    na60Parameters[ix] = fitTotal->GetParameter(ix+4);
+    na60Parameters[ix] = fitTotal->GetParameter(ix+7);
   }
-  
+
   for ( int iy = 0; iy < 11; ++iy )
   {
     for ( int ix = 0; ix < 11; ++ix )
     {
-      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
+      covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+7,iy+7);
     }
   }
 
-  
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
   double nerr = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   Set("NofJPsi",njpsi,nerr);
-  
+
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
   double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   Set("NofJPsi3s",njpsi3s,nerr3s);
-  
+
   //_____________________________
 
-  
+
   //_____Computation of bin significance and signal over background
-  Double_t bkgParameters[4];
-  Double_t bkgcovarianceMatrix[4][4];
-  
-  for ( int ix = 0; ix < 4; ++ix )
+  Double_t bkgParameters[7];
+  Double_t bkgcovarianceMatrix[7][7];
+
+  for ( int ix = 0; ix < 7; ++ix )
   {
     bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
-  
-  for ( int iy = 0; iy < 4; ++iy )
+
+  for ( int iy = 0; iy < 7; ++iy )
   {
-    for ( int ix = 0; ix < 4; ++ix )
+    for ( int ix = 0; ix < 7; ++ix )
     {
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
   }
-  
+
   double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
   double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   double sOverB3s = njpsi3s / nbck3s;
   double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
-  
+
   Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
-  
+
   double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
   double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
-  
+
   Set("Significance3s",sig,sigErr);
   //___________________
 
@@ -2888,9 +5121,9 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWVWG()
 void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
 {
   /// Fit using 2 NA60(new) (signal) + pol2 x exp (background)
-  
+
   fHisto->GetListOfFunctions()->Delete();
-  
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
@@ -2898,38 +5131,38 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
   Double_t p1Right = GetValue("p1RJPsi");
   Double_t p2Right = GetValue("p2RJPsi");
   Double_t p3Right = GetValue("p3RJPsi");
-  
+
   Double_t alphaLeft = GetValue("aLJPsi");
   Double_t alphaRight = GetValue("aRJPsi");
-  
-  Double_t paramSPsiP = GetValue("FSigmaPsiP");  
-  
+
+  Double_t paramSPsiP = GetValue("FSigmaPsiP");
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   TString msg;
-  
+
   if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
   if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
   if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
   if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
   if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
   if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
-  
+
   if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
   if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
   //__________
-  
+
   AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and pol4 x exp %s",msg.Data()));
-  
+
   //__________ Define the function to fit the spectrum, and the background just for plotting
   TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol2Exp,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewPol2Exp");
-  
+
   fitTotal->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi",
   //                      0      1       2      3     4      5       6
                         "p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
   //                        7         8         9        10
-                      
+
   fitTotal->SetParName(11, "p2RJPsi");
   //                           11
   fitTotal->SetParName(12, "p3RJPsi");
@@ -2940,33 +5173,33 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
   //                           14
   fitTotal->SetParName(15, "kPsiP");
   //                           15
-  
-  
+
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
+
   //__________
 
 
   //__________ Fit background only for initial parameters
   TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,1.7,6.,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
+
   Int_t bin = fHisto->FindBin(0.26);
-  
+
   bckInit->SetParameters(fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin)/3.,100.,0.05);//fHisto->GetBinContent(bin)
-  
+
   SetFitRejectRange(2.7,4.0);
-  
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
-  
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
 
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol2Exp","SRL");
   //___________
-  
+
   SetFitRejectRange();
   //____________
-  
+
 
   //__________ Set initial parameters in fitting function
   for ( Int_t i = 0; i < 4; ++i )
@@ -2976,20 +5209,20 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
 
   bin = fHisto->FindBin(3.09);
   fitTotal->SetParameter(4, fHisto->GetBinContent(bin)); // kJPsi
-  
+
   fitTotal->SetParameter(5, 3.1); // mean
   fitTotal->SetParLimits(5, 3.0, 3.2);
-  
+
   fitTotal->SetParameter(6, 0.08); // sigma
   fitTotal->SetParLimits(6, 0.05, 0.15);
-  
+
   fitTotal->FixParameter(7, p1Left);
   fitTotal->FixParameter(8, p2Left);
   fitTotal->FixParameter(9, p3Left);
   fitTotal->FixParameter(10, p1Right);
   fitTotal->FixParameter(11, p2Right);
   fitTotal->FixParameter(12, p3Right);
-  
+
   fitTotal->FixParameter(13, alphaLeft);
   fitTotal->FixParameter(14, alphaRight);
 
@@ -3007,15 +5240,15 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
   //___________
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,15,3);
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,15,3);
   //___________
 
   delete bckInit;//Delete the initial background funtion
 
-  
+
   //___________Set parameters and fit functions to store in the result
   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","SignalNA60New");
-  
+
   signalJPsi->SetParameters(fitTotal->GetParameter(4),
                             fitTotal->GetParameter(5),
                             fitTotal->GetParameter(6),
@@ -3026,11 +5259,11 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
                             fitTotal->GetParameter(11),
                             fitTotal->GetParameter(12),
                             fitTotal->GetParameter(13));
-  
+
   signalJPsi->SetParameter(10,fitTotal->GetParameter(14));
-  
+
   TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","SignalNA60New");
-  
+
   signalPsiP->SetParameters(fitTotal->GetParameter(15),
                             3.68609+(fitTotal->GetParameter(5)-3.096916)/3.096916*3.68609,
                             fitTotal->GetParameter(6)*paramSPsiP, // /3.096916*3.68609,
@@ -3041,51 +5274,51 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
                             fitTotal->GetParameter(11),
                             fitTotal->GetParameter(12),
                             fitTotal->GetParameter(13));
-  
+
   signalPsiP->SetParameter(10,fitTotal->GetParameter(14));
-  
+
   for ( Int_t i = 0; i < 4; ++i )
   {
     bck->SetParameter(i, fitTotal->GetParameter(i));
   }
 
-  
+
   Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
+
 //  Set("kPol2Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
   Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
   Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
   Set("pol2",fitTotal->GetParameter(2),fitTotal->GetParError(2));
   Set("exp",fitTotal->GetParameter(3),fitTotal->GetParError(3));
-  
+
   Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
   Set("kPsiP",fitTotal->GetParameter(15),fitTotal->GetParError(15));
-  
+
   Set("mJPsi",fitTotal->GetParameter(5),fitTotal->GetParError(5));
   Set("sJPsi",fitTotal->GetParameter(6),fitTotal->GetParError(6));
-  
+
   Set("p1LJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
   Set("p2LJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
   Set("p3LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
   Set("p1RJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
   Set("p2RJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
   Set("p3RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
-  
+
   Set("aLJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
   Set("aRJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
-  
+
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
-  
+
   Double_t na60Parameters[11];
   Double_t covarianceMatrix[11][11];
-  
+
   for ( int ix = 0; ix < 11; ++ix )
   {
     na60Parameters[ix] = fitTotal->GetParameter(ix+4);
   }
-  
+
   for ( int iy = 0; iy < 11; ++iy )
   {
     for ( int ix = 0; ix < 11; ++ix )
@@ -3093,33 +5326,33 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
       covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+4,iy+4);
     }
   }
-  
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
   double nerr = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   Set("NofJPsi",njpsi,nerr);
-  
+
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
   double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   Set("NofJPsi3s",njpsi3s,nerr3s);
-  
+
   //_____________________________
-  
+
 
   //_____Computation of bin significance and signal over background
   Double_t bkgParameters[4];
   Double_t bkgcovarianceMatrix[4][4];
-  
+
   for ( int ix = 0; ix < 4; ++ix )
   {
     bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
-  
+
   for ( int iy = 0; iy < 4; ++iy )
   {
     for ( int ix = 0; ix < 4; ++ix )
@@ -3127,19 +5360,19 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL2EXP()
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
   }
-  
+
   double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
   double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   double sOverB3s = njpsi3s / nbck3s;
   double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
-  
+
   Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
-  
+
   double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
   double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
-  
+
   Set("Significance3s",sig,sigErr);
   //_____________________________
 
@@ -3150,9 +5383,9 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
 {
   /// Fit using 2 NA60(new) (signal) + pol4 x exp (background)
   // Not used in pA Jpsi analysis: too many parameters for correct convergence (Error matrix not pos. def.)
-  
+
   fHisto->GetListOfFunctions()->Delete();
-  
+
   //__________ Get tails parameters, fitting range and SigmaPsiP
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
@@ -3160,38 +5393,38 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
   Double_t p1Right = GetValue("p1RJPsi");
   Double_t p2Right = GetValue("p2RJPsi");
   Double_t p3Right = GetValue("p3RJPsi");
-  
+
   Double_t alphaLeft = GetValue("aLJPsi");
   Double_t alphaRight = GetValue("aRJPsi");
-  
+
   Double_t paramSPsiP = GetValue("FSigmaPsiP");
-    
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   TString msg;
-  
+
   if (IsValidValue(p1Left)) msg += TString::Format("p1L=%e ",p1Left);
   if (IsValidValue(p2Left)) msg += TString::Format("p2L=%e ",p2Left);
   if (IsValidValue(p3Left)) msg += TString::Format("p3L=%e ",p3Left);
   if (IsValidValue(p1Right)) msg += TString::Format("p1R=%e ",p1Right);
   if (IsValidValue(p2Right)) msg += TString::Format("p2R=%e ",p2Right);
   if (IsValidValue(p3Right)) msg += TString::Format("p3R=%e ",p3Right);
-  
+
   if (IsValidValue(alphaLeft)) msg += TString::Format("aL=%e ",alphaLeft);
   if (IsValidValue(alphaRight)) msg += TString::Format("aR=%e ",alphaRight);
   //__________
-  
+
   AliDebug(1,Form("Fit with jpsi + psiprime NA60 new and pol4 x exp %s",msg.Data()));
-  
+
   //__________ Define the function to fit the spectrum, and the background just for plotting
   TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoNA60NewPol4Exp,fitRangeLow,fitRangeHigh,18,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoNA60NewPol4Exp");
-  
+
   fitTotal->SetParNames("pol0","pol1","pol2","pol3","pol4","exp","kJPsi",
   //                        0    1       2      3      4     5      6
                         "mJPsi","sJPsi","p1LJPsi","p2LJPsi");
-  //                       7       8       9       10                      
-  
+  //                       7       8       9       10
+
   fitTotal->SetParName(11, "p3LJPsi");
   //                           11
   fitTotal->SetParName(12, "p1RJPsi");
@@ -3206,74 +5439,74 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
   //                           16
   fitTotal->SetParName(17, "kPsiP");
   //                           17
-  
-  
+
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,fitRangeLow,fitRangeHigh,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
   //________
 
-  
+
   //__________ Fit background only for initial parameters
   TF1* bckInit = new TF1("bckInit",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4Exp,1.6,7.,6,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4Exp");
-  
+
   Int_t bin = fHisto->FindBin(1.6);
-  
+
   bckInit->SetParameters(-fHisto->GetBinContent(bin),fHisto->GetBinContent(bin),-fHisto->GetBinContent(bin)/2.,fHisto->GetBinContent(bin)/10.,fHisto->GetBinContent(bin)/100.,-2.);
-  
+
   SetFitRejectRange(2.6,4.0);
-  
-  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR");
-  
+
+  TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SRL");
+
   std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   //___________
-  
+
   //___________ Further attempts to fit bkg if the first one fails
-  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SR");
+  if ( static_cast<int>(fitResultInit) ) ProcessBkgFit(fitResultInit,bckInit,"FitFunctionBackgroundPol4Exp","SRL");
   //___________
-  
+
   SetFitRejectRange();
   //____________
 
-  
+
   //__________ Set initial parameters in fitting function
   for ( Int_t i = 0; i < 6; ++i )
   {
     fitTotal->SetParameter(i, bckInit->GetParameter(i));
   }
-  
+
   bin = fHisto->FindBin(3.09);
   fitTotal->SetParameter(6, fHisto->GetBinContent(bin)); // kJPsi
-  
+
   fitTotal->SetParameter(7, 3.1); // mean
   fitTotal->SetParLimits(7, 3.0, 3.2);
-  
+
   fitTotal->SetParameter(8, 0.08); // sigma
   fitTotal->SetParLimits(8, 0.05, 0.15);
-  
+
   fitTotal->FixParameter(9, p1Left);
   fitTotal->FixParameter(10, p2Left);
   fitTotal->FixParameter(11, p3Left);
   fitTotal->FixParameter(12, p1Right);
   fitTotal->FixParameter(13, p2Right);
   fitTotal->FixParameter(14, p3Right);
-  
+
   fitTotal->FixParameter(15, alphaLeft);
   fitTotal->FixParameter(16, alphaRight);
-  
+
   bin = fHisto->FindBin(3.68);
   fitTotal->SetParameter(17, fHisto->GetBinContent(bin)*0.5); //kPsi'
   fitTotal->SetParLimits(17, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin));
-  
+
   const char* fitOption = "SERI";
-  
+
   //_____________First fit attempt
   TFitResultPtr fitResult = fHisto->Fit(fitTotal,fitOption,"");
-  
+
   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
   //___________
 
   //___________ Further attempts to fit if the first one fails
-  if ( static_cast<int>(fitResult) ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,17,4);
+  if ( static_cast<int>(fitResult) ||  static_cast<int>(fitResult->CovMatrixStatus())!=3 ) ProcessMinvFit(fitResult,fitTotal,bckInit,fitOption,17,4);
   //___________
 
   delete bckInit;//Delete the initial background funtion
@@ -3281,7 +5514,7 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
 
   //___________Set parameters and fit functions to store in the result
   TF1* signalJPsi = new TF1("signalJPsi",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","SignalNA60New");
-  
+
   signalJPsi->SetParameters(fitTotal->GetParameter(6),
                             fitTotal->GetParameter(7),
                             fitTotal->GetParameter(8),
@@ -3292,11 +5525,11 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
                             fitTotal->GetParameter(13),
                             fitTotal->GetParameter(14),
                             fitTotal->GetParameter(15));
-  
+
   signalJPsi->SetParameter(10,fitTotal->GetParameter(16));
-  
+
   TF1* signalPsiP = new TF1("signalPsiP",this,&AliAnalysisMuMuJpsiResult::FitFunctionNA60New,fHisto->GetXaxis()->GetXmin(),fHisto->GetXaxis()->GetXmax(),11,"AliAnalysisMuMuJpsiResult","SignalNA60New");
-  
+
   signalPsiP->SetParameters(fitTotal->GetParameter(17),
                             3.68609+(fitTotal->GetParameter(7)-3.096916)/3.096916*3.68609,
                             fitTotal->GetParameter(8)*paramSPsiP, // /3.096916*3.68609,
@@ -3307,19 +5540,19 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
                             fitTotal->GetParameter(13),
                             fitTotal->GetParameter(14),
                             fitTotal->GetParameter(15));
-  
+
   signalPsiP->SetParameter(10,fitTotal->GetParameter(16));
-  
+
   for ( Int_t i = 0; i < 6; ++i )
   {
     bck->SetParameter(i, fitTotal->GetParameter(i));
   }
 
-  
+
   Set("FitResult",static_cast<int>(fitResult)*1.0,0.0);
   Set("FitChi2PerNDF",fitTotal->GetChisquare()/fitTotal->GetNDF(),0.0);
   Set("FitNDF",fitTotal->GetNDF(),0.0);
-  
+
 //  Set("kPol4Exp",fitTotal->GetParameter(0),fitTotal->GetParError(0));
   Set("pol0",fitTotal->GetParameter(0),fitTotal->GetParError(0));
   Set("pol1",fitTotal->GetParameter(1),fitTotal->GetParError(1));
@@ -3327,33 +5560,33 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
   Set("pol3",fitTotal->GetParameter(3),fitTotal->GetParError(3));
   Set("pol4",fitTotal->GetParameter(4),fitTotal->GetParError(4));
   Set("exp",fitTotal->GetParameter(5),fitTotal->GetParError(5));
-  
+
   Set("kJPsi",fitTotal->GetParameter(4),fitTotal->GetParError(4));
   Set("kPsiP",fitTotal->GetParameter(17),fitTotal->GetParError(17));
-  
+
   Set("mJPsi",fitTotal->GetParameter(7),fitTotal->GetParError(7));
   Set("sJPsi",fitTotal->GetParameter(8),fitTotal->GetParError(8));
-  
+
   Set("p1LJPsi",fitTotal->GetParameter(9),fitTotal->GetParError(9));
   Set("p2LJPsi",fitTotal->GetParameter(10),fitTotal->GetParError(10));
   Set("p3LJPsi",fitTotal->GetParameter(11),fitTotal->GetParError(11));
   Set("p1RJPsi",fitTotal->GetParameter(12),fitTotal->GetParError(12));
   Set("p2RJPsi",fitTotal->GetParameter(13),fitTotal->GetParError(13));
   Set("p3RJPsi",fitTotal->GetParameter(14),fitTotal->GetParError(14));
-  
+
   Set("aLJPsi",fitTotal->GetParameter(15),fitTotal->GetParError(15));
   Set("aRJPsi",fitTotal->GetParameter(16),fitTotal->GetParError(16));
-  
+
   AttachFunctionsToHisto(signalJPsi,signalPsiP,bck,fitTotal,fitRangeLow,fitRangeHigh);
-  
+
   Double_t na60Parameters[11];
   Double_t covarianceMatrix[11][11];
-  
+
   for ( int ix = 0; ix < 11; ++ix )
   {
     na60Parameters[ix] = fitTotal->GetParameter(ix+6);
   }
-  
+
   for ( int iy = 0; iy < 11; ++iy )
   {
     for ( int ix = 0; ix < 11; ++ix )
@@ -3361,33 +5594,33 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
       covarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix+6,iy+6);
     }
   }
-  
+
   Double_t a = fHisto->GetXaxis()->GetXmin();
   Double_t b = fHisto->GetXaxis()->GetXmax();
   double njpsi = signalJPsi->Integral(a,b)/fHisto->GetBinWidth(1);
   double nerr = signalJPsi->IntegralError(a,b,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   Set("NofJPsi",njpsi,nerr);
-  
+
   double m = GetValue("mJPsi");
   double s = GetValue("sJPsi");
   double njpsi3s = signalJPsi->Integral(m-3*s,m+3*s)/fHisto->GetBinWidth(1);
   double nerr3s = signalJPsi->IntegralError(m-3*s,m+3*s,&na60Parameters[0],&covarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   Set("NofJPsi3s",njpsi3s,nerr3s);
-  
+
   //_____________________________
-  
+
 
   //_____Computation of bin significance and signal over background
   Double_t bkgParameters[6];
   Double_t bkgcovarianceMatrix[6][6];
-  
+
   for ( int ix = 0; ix < 6; ++ix )
   {
     bkgParameters[ix] = fitTotal->GetParameter(ix);
   }
-  
+
   for ( int iy = 0; iy < 6; ++iy )
   {
     for ( int ix = 0; ix < 6; ++ix )
@@ -3395,19 +5628,19 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
       bkgcovarianceMatrix[ix][iy] = (fitResult->GetCovarianceMatrix())(ix,iy);
     }
   }
-  
+
   double nbck3s = bck->Integral(m-3.*s,m+3.*s)/fHisto->GetBinWidth(1);
   double nbck3sErr = bck->IntegralError(m-3.*s,m+3.*s,&bkgParameters[0],&bkgcovarianceMatrix[0][0])/fHisto->GetBinWidth(1);
-  
+
   double sOverB3s = njpsi3s / nbck3s;
   double sOverB3sErr = sOverB3s*TMath::Sqrt(TMath::Power(nerr3s/njpsi3s,2.) + TMath::Power(nbck3sErr/nbck3s,2.));
-  
+
   Set("SignalOverBkg3s",sOverB3s,sOverB3sErr);
-  
+
   double sig = njpsi3s/TMath::Sqrt(njpsi3s + nbck3s);
   double sigErr = TMath::Sqrt( TMath::Power((1. - (1./2.)*njpsi3s/(njpsi3s + nbck3s) )*nerr3s/TMath::Sqrt(njpsi3s + nbck3s),2.) +
                               TMath::Power(njpsi3s*nbck3sErr/(2.*TMath::Power(njpsi3s + nbck3s,3./2.)),2.) );
-  
+
   Set("Significance3s",sig,sigErr);
   //_____________________________
 
@@ -3416,14 +5649,14 @@ void AliAnalysisMuMuJpsiResult::FitPSIPSIPRIMENA60NEWPOL4EXP()
 //_____________________________________________________________________________
 void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
 {
-  //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2 
+  //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -3434,24 +5667,24 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
 //  TString msg;
-//  
+//
 //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
 //  if (IsValidValue(nLow)) msg += TString::Format("nLow=%e ",nLow);
 //  if (IsValidValue(alphaUp)) msg += TString::Format("alphaUp=%e ",alphaUp);
 //  if (IsValidValue(nUp)) msg += TString::Format("nUp=%e ",nUp);
-//  
+//
 //  AliDebug(1,Form("Mean pt fit with jpsi + psiprime (CB2),Bkg VWG and Pol2 for Bkg <pt> %s",msg.Data()));
-//  
+//
 //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
-//    
+//
 //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
 
-  
+
 //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -3460,24 +5693,24 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate(); // Recalculates the error for low stat bins
 
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(3.,1.,0.);
-  
+
   bck->SetParLimits(0, 0.,5.0);
-  
+
   SetFitRejectRange(2.7,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
-  
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2VWGPOL2");
-  
+
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
   fitMeanpt->SetParName(12,"<pt>JPsi");
@@ -3485,7 +5718,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
   fitMeanpt->SetParName(14,"<pt>BG1");
   fitMeanpt->SetParName(15,"<pt>BG2");
   fitMeanpt->SetParName(16,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -3498,28 +5731,28 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
   fitMeanpt->FixParameter(9,alphaUp);
   fitMeanpt->FixParameter(10,nUp);
   fitMeanpt->FixParameter(11,kPsiP);
-  
+
   fitMeanpt->SetParameter(12, 3.);
   fitMeanpt->SetParLimits(12, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 3; ++i )
   {
     fitMeanpt->SetParameter(i + 13, bck->GetParameter(i));
   }
-  
-  
+
+
   Double_t psipPtLim = 10.;
-  
+
   fitMeanpt->SetParameter(16, 3.);
   fitMeanpt->SetParLimits(16, 0.,psipPtLim);
 
 
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 3; ++i )
@@ -3527,7 +5760,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
 
@@ -3539,18 +5772,18 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(13),fitMeanpt->GetParameter(14),fitMeanpt->GetParameter(15));
 
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(12),fitMeanpt->GetParError(12));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -3558,12 +5791,12 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -3574,10 +5807,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -3590,8 +5823,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -3600,9 +5833,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -3631,27 +5864,27 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
 //    }
 //  }
   //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
+
   bck->SetParameters(3.,-2.,0.4,-0.0);
-  
+
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,10.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
-  
-  
+
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2EXP,fitRangeLow,fitRangeHigh,18,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2VWGPOL2EXP");
-  
+
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
   fitMeanpt->SetParName(12,"<pt>JPsi");
@@ -3660,7 +5893,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
   fitMeanpt->SetParName(15,"<pt>BG2");
   fitMeanpt->SetParName(16,"<pt>BGEXP");
   fitMeanpt->SetParName(17,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -3673,15 +5906,15 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
   fitMeanpt->FixParameter(9,alphaUp);
   fitMeanpt->FixParameter(10,nUp);
   fitMeanpt->FixParameter(11,kPsiP);
-  
+
   fitMeanpt->SetParameter(12, 3.);
   fitMeanpt->SetParLimits(12, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 4; ++i )
   {
     fitMeanpt->SetParameter(i + 13, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -3690,17 +5923,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(17, 3.);
   Double_t psipPtLim = 10.;
   fitMeanpt->SetParLimits(17, 0.,psipPtLim);
-  
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 4; ++i )
@@ -3708,7 +5941,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   else if ( fitMeanpt->GetParameter(17) <= fitMeanpt->GetParError(17) || fitMeanpt->GetParError(17) >= 0.75*fitMeanpt->GetParameter(17) || (fitMeanpt->GetParameter(17)/psipPtLim > 0.9) )
@@ -3719,29 +5952,29 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   if ( static_cast<int>(fitResult) && (fitMeanpt->GetParameter(13) <= fitMeanpt->GetParError(13) || fitMeanpt->GetParError(13) >= 0.75*fitMeanpt->GetParameter(13)) )
   {
     fitMeanpt->SetParameter(13, 2.);
-    
+
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(13),fitMeanpt->GetParameter(14),fitMeanpt->GetParameter(15),fitMeanpt->GetParameter(16));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(12),fitMeanpt->GetParError(12));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(17),fitMeanpt->GetParError(17));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -3749,12 +5982,12 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t pol0 = GetValue("pol0");
   Double_t pol1 = GetValue("pol1");
   Double_t pol2 = GetValue("pol2");
@@ -3765,10 +5998,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -3781,8 +6014,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -3791,9 +6024,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -3822,26 +6055,26 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
 //    }
 //  }
   //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(3.,1.,0.);
-  
+
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,8.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
-  
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2POL2EXPPOL2,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2POL2EXPPOL2");
-  
+
   fitMeanpt->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
   fitMeanpt->SetParName(12,"<pt>JPsi");
@@ -3849,7 +6082,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
   fitMeanpt->SetParName(14,"<pt>BG1");
   fitMeanpt->SetParName(15,"<pt>BG2");
   fitMeanpt->SetParName(16,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,pol0);
   fitMeanpt->FixParameter(1,pol1);
   fitMeanpt->FixParameter(2,pol2);
@@ -3862,15 +6095,15 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
   fitMeanpt->FixParameter(9,alphaUp);
   fitMeanpt->FixParameter(10,nUp);
   fitMeanpt->FixParameter(11,kPsiP);
-  
+
   fitMeanpt->SetParameter(12, 3.);
   fitMeanpt->SetParLimits(12, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 3; ++i )
   {
     fitMeanpt->SetParameter(i + 13, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -3879,17 +6112,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(16, 3.);
   Double_t psipPtLim = 10.;
   fitMeanpt->SetParLimits(16, 0.,psipPtLim);
-  
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 3; ++i )
@@ -3897,7 +6130,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
 
@@ -3909,20 +6142,20 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(13),fitMeanpt->GetParameter(14),fitMeanpt->GetParameter(15));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(12),fitMeanpt->GetParError(12));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -3930,12 +6163,12 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t pol0 = GetValue("pol0");
   Double_t pol1 = GetValue("pol1");
   Double_t pol2 = GetValue("pol2");
@@ -3946,10 +6179,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -3962,8 +6195,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -3972,9 +6205,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -4003,25 +6236,25 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
 //    }
 //  }
   //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
+
   bck->SetParameters(3.,-1.,0.4,-0.1);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,10.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
-  
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2POL2EXPPOL2EXP,fitRangeLow,fitRangeHigh,18,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2POL2EXPPOL2EXP");
-  
+
   fitMeanpt->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
   fitMeanpt->SetParName(12,"<pt>JPsi");
@@ -4030,7 +6263,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
   fitMeanpt->SetParName(15,"<pt>BG2");
   fitMeanpt->SetParName(16,"<pt>BGEXP");
   fitMeanpt->SetParName(17,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,pol0);
   fitMeanpt->FixParameter(1,pol1);
   fitMeanpt->FixParameter(2,pol2);
@@ -4043,15 +6276,15 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
   fitMeanpt->FixParameter(9,alphaUp);
   fitMeanpt->FixParameter(10,nUp);
   fitMeanpt->FixParameter(11,kPsiP);
-  
+
   fitMeanpt->SetParameter(12, 3.);
   fitMeanpt->SetParLimits(12, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 4; ++i )
   {
     fitMeanpt->SetParameter(i + 13, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -4060,18 +6293,18 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(17, 3.);
   Double_t psipPtLim = 10.;
   fitMeanpt->SetParLimits(17, 0.,psipPtLim);
 
-  
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 4; ++i )
@@ -4079,7 +6312,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
 
@@ -4091,29 +6324,29 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
 
   if ( static_cast<int>(fitResult) && (fitMeanpt->GetParameter(13) <= fitMeanpt->GetParError(13) || fitMeanpt->GetParError(13) >= 0.75*fitMeanpt->GetParameter(13)) )
   {
     fitMeanpt->SetParameter(13, 2.);
-    
+
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
 
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(13),fitMeanpt->GetParameter(14),fitMeanpt->GetParameter(15),fitMeanpt->GetParameter(16));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(12),fitMeanpt->GetParError(12));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(17),fitMeanpt->GetParError(17));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -4121,17 +6354,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
   Double_t p3Left = GetValue("p3LJPsi");
   Double_t p1Right = GetValue("p1RJPsi");
   Double_t p2Right = GetValue("p2RJPsi");
   Double_t p3Right = GetValue("p3RJPsi");
-  
+
   Double_t alphaLeft = GetValue("aLJPsi");
   Double_t alphaRight = GetValue("aRJPsi");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -4142,10 +6375,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -4158,8 +6391,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -4168,9 +6401,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -4199,24 +6432,24 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
 //    }
 //  }
   //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(3.,1.,0.);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,8.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
-  
-  
+
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWVWGPOL2,fitRangeLow,fitRangeHigh,21,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2NA60NEWVWGPOL2");
 
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
@@ -4230,7 +6463,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
   fitMeanpt->SetParName(18,"<pt>BG1");
   fitMeanpt->SetParName(19,"<pt>BG2");
   fitMeanpt->SetParName(20,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -4247,11 +6480,11 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
   fitMeanpt->FixParameter(13,alphaLeft);
   fitMeanpt->FixParameter(14,alphaRight);
   fitMeanpt->FixParameter(15,kPsiP);
-  
+
   fitMeanpt->SetParameter(16, 3.);
   fitMeanpt->SetParLimits(16, 1.0,5.);
 
-  
+
   for ( Int_t i = 0; i < 3; ++i )
   {
 //    TString name(GetName());
@@ -4265,7 +6498,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
 //    else
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -4274,18 +6507,18 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(20, 3.);
   Double_t psipPtLim = 10.;
   fitMeanpt->SetParLimits(20, 0.,psipPtLim);
-  
-  
+
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 3; ++i )
@@ -4293,7 +6526,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   if ( static_cast<int>(fitResult)&& (fitMeanpt->GetParameter(20) <= fitMeanpt->GetParError(20) || fitMeanpt->GetParError(20) >= 0.75*fitMeanpt->GetParameter(20) || (fitMeanpt->GetParameter(20)/psipPtLim > 0.9)) )
@@ -4304,20 +6537,20 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(17),fitMeanpt->GetParameter(18),fitMeanpt->GetParameter(19));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(20),fitMeanpt->GetParError(20));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -4325,17 +6558,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
   Double_t p3Left = GetValue("p3LJPsi");
   Double_t p1Right = GetValue("p1RJPsi");
   Double_t p2Right = GetValue("p2RJPsi");
   Double_t p3Right = GetValue("p3RJPsi");
-  
+
   Double_t alphaLeft = GetValue("aLJPsi");
   Double_t alphaRight = GetValue("aRJPsi");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -4346,10 +6579,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -4362,8 +6595,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -4372,9 +6605,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -4405,22 +6638,22 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
   //_____________
 
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
+
   bck->SetParameters(2.5,-1.,0.2,-0.05);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,10.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWVWGPOL2EXP,fitRangeLow,fitRangeHigh,22,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2NA60NEWVWGPOL2EXP");
-  
+
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
   fitMeanpt->SetParName(11,"p2RJPsi");
   fitMeanpt->SetParName(12,"p3RJPsi");
@@ -4433,7 +6666,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
   fitMeanpt->SetParName(19,"<pt>BG2");
   fitMeanpt->SetParName(20,"<pt>BGEXP");
   fitMeanpt->SetParName(21,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -4450,10 +6683,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
   fitMeanpt->FixParameter(13,alphaLeft);
   fitMeanpt->FixParameter(14,alphaRight);
   fitMeanpt->FixParameter(15,kPsiP);
-  
+
   fitMeanpt->SetParameter(16, 3.);
   fitMeanpt->SetParLimits(16, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 4; ++i )
   {
 //    TString name(GetName());
@@ -4462,24 +6695,24 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
 //      fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)/2.);
 //      fitMeanpt->SetParameter(16, 4.);
 ////      if (fitMeanpt->GetParameter(3) < 2.e-06) fitMeanpt->FixParameter(3,3e-4);
-//      
+//
 //    }
 //    else
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i));
 //    fitMeanpt->SetParameter(i + 17, bck->GetParameter(i));
   }
-  
+
   fitMeanpt->SetParameter(21, 3.);
   Double_t psipPtLim = 10.;
   fitMeanpt->SetParLimits(21, 0.,psipPtLim);
 
-  
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 4; ++i )
@@ -4487,7 +6720,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   if ( static_cast<int>(fitResult)&& (fitMeanpt->GetParameter(21) <= fitMeanpt->GetParError(21) || fitMeanpt->GetParError(21) >= 0.75*fitMeanpt->GetParameter(21) || (fitMeanpt->GetParameter(21)/psipPtLim > 0.9)) )
@@ -4498,29 +6731,29 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   if ( static_cast<int>(fitResult) && (fitMeanpt->GetParameter(17) <= fitMeanpt->GetParError(17) || fitMeanpt->GetParError(17) >= 0.75*fitMeanpt->GetParameter(13)) )
   {
     fitMeanpt->SetParameter(17, 2.);
-    
+
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
 
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(17),fitMeanpt->GetParameter(18),fitMeanpt->GetParameter(19),fitMeanpt->GetParameter(20));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(21),fitMeanpt->GetParError(21));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -4528,17 +6761,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
   Double_t p3Left = GetValue("p3LJPsi");
   Double_t p1Right = GetValue("p1RJPsi");
   Double_t p2Right = GetValue("p2RJPsi");
   Double_t p3Right = GetValue("p3RJPsi");
-  
+
   Double_t alphaLeft = GetValue("aLJPsi");
   Double_t alphaRight = GetValue("aRJPsi");
-  
+
   Double_t pol0 = GetValue("pol0");
   Double_t pol1 = GetValue("pol1");
   Double_t pol2 = GetValue("pol2");
@@ -4549,10 +6782,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -4565,8 +6798,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -4575,9 +6808,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -4606,25 +6839,25 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
 //    }
 //  }
   //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(3.,1.,0.);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,8.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
 
-  
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2,fitRangeLow,fitRangeHigh,21,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2");
-  
+
   fitMeanpt->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
   fitMeanpt->SetParName(11,"p2RJPsi");
   fitMeanpt->SetParName(12,"p3RJPsi");
@@ -4636,7 +6869,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
   fitMeanpt->SetParName(18,"<pt>BG1");
   fitMeanpt->SetParName(19,"<pt>BG2");
   fitMeanpt->SetParName(20,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,pol0);
   fitMeanpt->FixParameter(1,pol1);
   fitMeanpt->FixParameter(2,pol2);
@@ -4652,17 +6885,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
   fitMeanpt->FixParameter(12,p3Right);
   fitMeanpt->FixParameter(13,alphaLeft);
   fitMeanpt->FixParameter(14,alphaRight);
-  
+
   fitMeanpt->FixParameter(15,kPsiP);
-  
+
   fitMeanpt->SetParameter(16, 3.);
   fitMeanpt->SetParLimits(16, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 3; ++i )
   {
     fitMeanpt->SetParameter(i + 17, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -4671,20 +6904,20 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(20, 3.);
   Double_t psipPtLim = 10.;
   fitMeanpt->SetParLimits(20, 0.,psipPtLim);
-  
-  
+
+
   //  TProfile::Approximate();
-  
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 3; ++i )
@@ -4692,7 +6925,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   if ( static_cast<int>(fitResult) && (fitMeanpt->GetParameter(20) <= fitMeanpt->GetParError(20) || fitMeanpt->GetParError(20) >= 0.75*fitMeanpt->GetParameter(20) || (fitMeanpt->GetParameter(20)/psipPtLim > 0.9)) )
@@ -4703,20 +6936,20 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(17),fitMeanpt->GetParameter(18),fitMeanpt->GetParameter(19));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(20),fitMeanpt->GetParError(20));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -4724,17 +6957,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t p1Left = GetValue("p1LJPsi");
   Double_t p2Left = GetValue("p2LJPsi");
   Double_t p3Left = GetValue("p3LJPsi");
   Double_t p1Right = GetValue("p1RJPsi");
   Double_t p2Right = GetValue("p2RJPsi");
   Double_t p3Right = GetValue("p3RJPsi");
-  
+
   Double_t alphaLeft = GetValue("aLJPsi");
   Double_t alphaRight = GetValue("aRJPsi");
-  
+
   Double_t pol0 = GetValue("pol0");
   Double_t pol1 = GetValue("pol1");
   Double_t pol2 = GetValue("pol2");
@@ -4745,10 +6978,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -4761,8 +6994,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -4771,9 +7004,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -4802,25 +7035,25 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
 //    }
 //  }
 //  //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
+
   bck->SetParameters(2.8,-0.5,0.2,0.05);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,10.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
-  SetFitRejectRange();  
-  
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
+  SetFitRejectRange();
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2EXP,fitRangeLow,fitRangeHigh,22,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2EXP");
-  
+
   fitMeanpt->SetParNames("pol0","pol1","pol2","exp","kJPsi","mJPsi","sJPsi","p1LJPsi","p2LJPsi","p3LJPsi","p1RJPsi");
   fitMeanpt->SetParName(11,"p2RJPsi");
   fitMeanpt->SetParName(12,"p3RJPsi");
@@ -4833,7 +7066,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
   fitMeanpt->SetParName(19,"<pt>BG2");
   fitMeanpt->SetParName(20,"<pt>BGEXP");
   fitMeanpt->SetParName(21,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,pol0);
   fitMeanpt->FixParameter(1,pol1);
   fitMeanpt->FixParameter(2,pol2);
@@ -4849,17 +7082,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
   fitMeanpt->FixParameter(12,p3Right);
   fitMeanpt->FixParameter(13,alphaLeft);
   fitMeanpt->FixParameter(14,alphaRight);
-  
+
   fitMeanpt->FixParameter(15,kPsiP);
-  
+
   fitMeanpt->SetParameter(16, 3.);
   fitMeanpt->SetParLimits(16, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 4; ++i )
   {
     fitMeanpt->SetParameter(i + 17, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -4868,18 +7101,18 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(21, 3.);
   Double_t psipPtLim = 10.;
   fitMeanpt->SetParLimits(21, 0.,psipPtLim);
 
-  
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 4; ++i )
@@ -4887,7 +7120,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   if ( static_cast<int>(fitResult) && (fitMeanpt->GetParameter(21) <= fitMeanpt->GetParError(21) || fitMeanpt->GetParError(21) >= 0.75*fitMeanpt->GetParameter(21) || (fitMeanpt->GetParameter(21)/psipPtLim > 0.9)) )
@@ -4898,28 +7131,28 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP()
       fitMeanpt->SetParameter(i + 17, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   if ( static_cast<int>(fitResult) && (fitMeanpt->GetParameter(17) <= fitMeanpt->GetParError(17) || fitMeanpt->GetParError(17) >= 0.75*fitMeanpt->GetParameter(13)) )
   {
     fitMeanpt->SetParameter(17, 2.);
-    
+
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(17),fitMeanpt->GetParameter(18),fitMeanpt->GetParameter(19),fitMeanpt->GetParameter(20));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(21),fitMeanpt->GetParError(21));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -4927,12 +7160,12 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -4943,10 +7176,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -4959,8 +7192,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -4969,9 +7202,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -5000,26 +7233,26 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
 //    }
 //  }
   //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol3,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol3");
-  
+
   bck->SetParameters(3.,1.,-0.4,0.05);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,8.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.3,4.0);
-  
-  p->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  p->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
-  
-  
+
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL3,fitRangeLow,fitRangeHigh,18,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2VWGPOL3");
-  
+
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
   fitMeanpt->SetParName(12,"<pt>JPsi");
@@ -5028,7 +7261,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
   fitMeanpt->SetParName(15,"<pt>BG2");
   fitMeanpt->SetParName(16,"<pt>BG3");
   fitMeanpt->SetParName(17,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -5041,15 +7274,15 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
   fitMeanpt->FixParameter(9,alphaUp);
   fitMeanpt->FixParameter(10,nUp);
   fitMeanpt->FixParameter(11,kPsiP);
-  
+
   fitMeanpt->SetParameter(12, 3.);
   fitMeanpt->SetParLimits(12, 1.0,5.);
-  
+
   for ( Int_t i = 0; i < 4; ++i )
   {
     fitMeanpt->SetParameter(i + 13, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -5058,17 +7291,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(17, 3.);
   fitMeanpt->SetParLimits(17, 0.,10.);
 
-  
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 4; ++i )
@@ -5076,7 +7309,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   if ( static_cast<int>(fitResult) && (fitMeanpt->GetParameter(17) <= fitMeanpt->GetParError(17) || fitMeanpt->GetParError(17) >= 0.75*fitMeanpt->GetParameter(17)) )
@@ -5087,20 +7320,20 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(13),fitMeanpt->GetParameter(14),fitMeanpt->GetParameter(15),fitMeanpt->GetParameter(16));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(12),fitMeanpt->GetParError(12));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(17),fitMeanpt->GetParError(17));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -5108,12 +7341,12 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTLIN()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -5124,10 +7357,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTLIN()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -5140,36 +7373,36 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTLIN()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundLin,fitRangeLow,fitRangeHigh,2,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundLin");
-  
+
   bck->SetParameters(3.,0.);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 2.0,4.0);
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,4,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
   //
   //  bck->SetParameters(1,0,0,0);
-  
+
   SetFitRejectRange(2.0,4.0);
-  
-  fHisto->Fit(bck,"SERI","",fitRangeLow,fitRangeHigh);
-  
+
+  fHisto->Fit(bck,"SERIL+","",fitRangeLow,fitRangeHigh);
+
   SetFitRejectRange();
-  
-  
-  
+
+
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2Lin,fitRangeLow,fitRangeHigh,16,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2Lin");
-  
+
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
   fitMeanpt->SetParName(12,"<pt>JPsi");
   fitMeanpt->SetParName(13,"<pt>BG0");
   fitMeanpt->SetParName(14,"<pt>BG1");
   fitMeanpt->SetParName(15,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -5182,15 +7415,15 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTLIN()
   fitMeanpt->FixParameter(9,alphaUp);
   fitMeanpt->FixParameter(10,nUp);
   fitMeanpt->FixParameter(11,kPsiP);
-  
+
   fitMeanpt->SetParameter(12, 3.);
   fitMeanpt->SetParLimits(12, 2.0,4.);
-  
+
   for ( Int_t i = 0; i < 2; ++i )
   {
     fitMeanpt->SetParameter(i + 13, bck->GetParameter(i));
   }
-  
+
   //  fitMeanpt->SetParameter(13, 3.);
   //  fitMeanpt->SetParLimits(13, 0.5,10.);
   //
@@ -5199,27 +7432,27 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTLIN()
   //
   //  fitMeanpt->SetParameter(15, 0.1);
   //  //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(15, 3.);
   fitMeanpt->SetParLimits(15, 0.5,6.);
-  
-  
+
+
   //  TProfile::Approximate();
-  
+
   const char* fitOption = "SERI"; //+";
-  
+
   TFitResultPtr fitResult = fHisto->Fit(fitMeanpt,fitOption,"");
-  
+
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(13),fitMeanpt->GetParameter(14));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(12),fitMeanpt->GetParError(12));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(15),fitMeanpt->GetParError(15));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -5227,17 +7460,17 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWGINDEPTAILS_BKGMPTPOL2()
 {
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t alphaLowP = GetValue("alPsiP");
   Double_t nLowP = GetValue("nlPsiP");
   Double_t alphaUpP = GetValue("auPsiP");
   Double_t nUpP = GetValue("nuPsiP");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -5250,10 +7483,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWGINDEPTAILS_BKGMPTPOL2()
 //  Double_t sPsiP = GetValue("sPsiP");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -5266,12 +7499,12 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWGINDEPTAILS_BKGMPTPOL2()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //  TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2Exp,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2Exp");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
-  
+
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL2INDEPTAILS,fitRangeLow,fitRangeHigh,21,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2VWGPOL2INDEPTAILS");
-  
+
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
 //  fitMeanpt->SetParName(12,"mPsiP");
@@ -5285,7 +7518,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWGINDEPTAILS_BKGMPTPOL2()
   fitMeanpt->SetParName(18,"<pt>BG1");//14
   fitMeanpt->SetParName(19,"<pt>BG2");//15
   fitMeanpt->SetParName(20,"<pt>PsiP");//16
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -5304,38 +7537,38 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWGINDEPTAILS_BKGMPTPOL2()
   fitMeanpt->FixParameter(13,nLowP);
   fitMeanpt->FixParameter(14,alphaUpP);
   fitMeanpt->FixParameter(15,nUpP);
-  
+
   fitMeanpt->SetParameter(16, 3.);
   fitMeanpt->SetParLimits(16, 2.,3.);
-  
+
   fitMeanpt->SetParameter(17, 1.);
   //  fitMeanpt->SetParLimits(13, 0.01,1.5);
-  
+
   fitMeanpt->SetParameter(18, 0.2);
   //  fitMeanpt->SetParLimits(14, 0.1,0.2);
-  
+
   fitMeanpt->SetParameter(19, 0.1);
   //  fitMeanpt->SetParLimits(15, 0.,1.);
-  
+
   fitMeanpt->SetParameter(20, 3.);
   fitMeanpt->SetParLimits(20, 2.5,8.);
-  
-  
-  
+
+
+
   const char* fitOption = "SERI"; //+";
-  
+
   TFitResultPtr fitResult = fHisto->Fit(fitMeanpt,fitOption,"");
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
+
   bck->SetParameters(fitMeanpt->GetParameter(17),fitMeanpt->GetParameter(18),fitMeanpt->GetParameter(19));
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(20),fitMeanpt->GetParError(20));
-  
+
 }
 
 //_____________________________________________________________________________
@@ -5344,12 +7577,12 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol4
   //Fit mean dimuon mean pt to get Jpsi mean pt using the CB2 signal parameters, VWG for the Bkg, Jpsi mpt = cte and Bkg mpt = pol2
   fHisto->GetListOfFunctions()->Delete();
-  
+
   Double_t alphaLow = GetValue("alJPsi");
   Double_t nLow = GetValue("nlJPsi");
   Double_t alphaUp = GetValue("auJPsi");
   Double_t nUp = GetValue("nuJPsi");
-  
+
   Double_t kVWG = GetValue("kVWG");
   Double_t mVWG = GetValue("mVWG");
   Double_t sVWG1 = GetValue("sVWG1");
@@ -5360,10 +7593,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
   Double_t sJPsi = GetValue("sJPsi");
   Double_t NofJPsi = GetValue("NofJPsi");
   Double_t ErrStatNofJPsi = GetErrorStat("NofJPsi");
-  
+
   Double_t fitRangeLow = GetValue(kFitRangeLow);
   Double_t fitRangeHigh = GetValue(kFitRangeHigh);
-  
+
   //  TString msg;
   //
   //  if (IsValidValue(alphaLow)) msg += TString::Format("alphaLow=%e ",alphaLow);
@@ -5376,8 +7609,8 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
   //  TF1* fitTotal = new TF1("signal+bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionTotalTwoCB2VWG,fitRangeLow,fitRangeHigh,17,"AliAnalysisMuMuJpsiResult","FitFunctionTotalTwoCB2VWG");
   //
   //TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol2,fitRangeLow,fitRangeHigh,3,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol2");
-  
-  
+
+
   //  TString resultName(Form("MEANPTFIT_%salphalow=%5.2fnlow=%5.2falphaup=%5.2fnup=%5.2f",fitName.Data(),par[7],par[8],par[9],par[10]));
   TProfile* p(0x0);
   if ( fHisto->IsA() == TProfile::Class() ) p = static_cast<TProfile*>(fHisto);
@@ -5386,9 +7619,9 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
     AliError("Mean pt histo has to be a TProfile");
     return;
   }
-  
+
   TProfile::Approximate();
-  
+
   //_____________
 //  Int_t minBin = p->FindBin(fitRangeLow);
 //  Int_t maxBin = p->FindBin(fitRangeHigh);
@@ -5417,21 +7650,21 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
 //    }
 //  }
   //_____________
-  
+
   TF1* bck = new TF1("bck",this,&AliAnalysisMuMuJpsiResult::FitFunctionBackgroundPol4,fitRangeLow,fitRangeHigh,5,"AliAnalysisMuMuJpsiResult","FitFunctionBackgroundPol4");
-  
+
   bck->SetParameters(3.,-0.5,-0.5,1.5,-0.01);
   bck->SetParLimits(0, 0.,5.0);
 //  bck->SetParLimits(0, 1.,8.0);
-  
+
   SetFitRejectRange(2.7,4.0);
-  
+
   p->Fit(bck,"SER","");
-  
+
   SetFitRejectRange();
 
   TF1* fitMeanpt = new TF1("fitMeanpt",this,&AliAnalysisMuMuJpsiResult::FitFunctionMeanPtS2CB2VWGPOL4,fitRangeLow,fitRangeHigh,19,"AliAnalysisMuMuJpsiResult","FitFunctionMeanPtS2CB2VWGPOL4");
-  
+
   fitMeanpt->SetParNames("kVWG","mVWG","sVWG1","sVWG2","kJPsi","mJPsi","sJPsi","alJPsi","nlJPsi","auJPsi","nuJPsi");
   fitMeanpt->SetParName(11,"kPsiP");
   fitMeanpt->SetParName(12,"<pt>JPsi");
@@ -5441,7 +7674,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
   fitMeanpt->SetParName(16,"<pt>BG3");
   fitMeanpt->SetParName(17,"<pt>BG4");
   fitMeanpt->SetParName(18,"<pt>PsiP");
-  
+
   fitMeanpt->FixParameter(0,kVWG);
   fitMeanpt->FixParameter(1,mVWG);
   fitMeanpt->FixParameter(2,sVWG1);
@@ -5454,10 +7687,10 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
   fitMeanpt->FixParameter(9,alphaUp);
   fitMeanpt->FixParameter(10,nUp);
   fitMeanpt->FixParameter(11,kPsiP);
-  
+
   fitMeanpt->SetParameter(12, 3.);
   fitMeanpt->SetParLimits(12, 2.0,4.);
-  
+
   for ( Int_t i = 0; i < 5; ++i )
   {
     fitMeanpt->SetParameter(i + 13, bck->GetParameter(i));
@@ -5465,13 +7698,13 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
 
   fitMeanpt->SetParameter(18, 3.);
   fitMeanpt->SetParLimits(18, 0.,10.);
-     
+
   const char* fitOption = "SERI"; //+";//SER
-  
+
   TFitResultPtr fitResult = p->Fit(fitMeanpt,fitOption,"");
-  
+
   std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
-  
+
   if ( static_cast<int>(fitResult) )
   {
     for ( Int_t i = 0; i < 5; ++i )
@@ -5479,7 +7712,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.9);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
   else if ( fitMeanpt->GetParameter(18) <= fitMeanpt->GetParError(18) || fitMeanpt->GetParError(18) >= 0.75*fitMeanpt->GetParameter(18) )
@@ -5490,7 +7723,7 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
       fitMeanpt->SetParameter(i + 13, bck->GetParameter(i)*0.6);
     }
     fitResult = p->Fit(fitMeanpt,fitOption,"");
-    
+
     std::cout << "FitResultt=" << static_cast<int>(fitResult) << std::endl;
   }
 
@@ -5498,24 +7731,24 @@ void AliAnalysisMuMuJpsiResult::FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4()
   {
     bck->SetParameter(i, fitMeanpt->GetParameter(i+13));
   }
-  
+
   AttachFunctionsToHisto(0x0,bck,fitMeanpt,fitRangeLow,fitRangeHigh);//
-  
+
   Set("NofJPsi",NofJPsi,ErrStatNofJPsi);
   Set("MeanPtJPsi",fitMeanpt->GetParameter(12),fitMeanpt->GetParError(12));
   Set("MeanPtPsiP",fitMeanpt->GetParameter(16),fitMeanpt->GetParError(16));
- 
+
 }
 
 //_____________________________________________________________________________
 Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
 {
   // Add a fit to this result
-  
+
   if ( !fHisto ) return kFALSE;
 
   TH1* histo = static_cast<TH1*>(fHisto->Clone(fitType));
-  
+
   AliAnalysisMuMuJpsiResult* r = new AliAnalysisMuMuJpsiResult(GetParticle(),*histo,fitType);
 
   if ( !r->IsValid() )
@@ -5523,19 +7756,19 @@ Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
     delete r;
     return kFALSE;
   }
-  
+
   TMethodCall callEnv;
 
   TString fittingMethod(r->GetFitFunctionMethodName().Data());
-  
+
   std::cout << "+Using fitting method " << fittingMethod.Data() << "..." << std::endl;
   std::cout << "" << std::endl;
-  
+
   callEnv.InitWithPrototype(IsA(),fittingMethod.Data(),"");
-  
+
   if (callEnv.IsValid())
   {
-    callEnv.Execute(r);
+    callEnv.Execute(r);// here fit Method ("fit<SOMETHING>") is called and the fit is proceed.
   }
   else
   {
@@ -5543,7 +7776,7 @@ Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
     delete r;
     return kFALSE;
   }
-  
+
 //  Float_t lpar[] = { -1.0, -1.0, -1.0, -1.0 }; // free tails by default
 //
 //  Bool_t ok(kTRUE);
@@ -5553,23 +7786,23 @@ Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
 //    if ( extra.Length() )
 //    {
 //      AliDebug(1,Form("sFitType=%s",fitType));
-//      
+//
 //      sscanf(extra,"ALPHALOW%fNLOW%fALPHAUP%fNUP%f",
 //             &lpar[0],&lpar[1],&lpar[2],&lpar[3]);
-//      
+//
 //      AliDebug(1,Form("PSILOW ALPHALOW=%f NLOW=%f ALPHAUP=%f NUP=%f",lpar[0],lpar[1],lpar[2],lpar[3]));
 //    }
-//    
+//
 //    if ( lpar[0] == 0.0 && lpar[1] == 0.0 && lpar[0] == 0.0 && lpar[1] == 0.0 )
 //    {
 //      AliError("Cannot work with zero tails !");
 //      ok = kFALSE;
 //    }
 //  }
-  
+
 //  if ( ok == kTRUE )
 //  {
-//    
+//
 //    if ( fitFunction=="PSICB2" )
 //    {
 //      r = FitPSICB2(*hminv,fitMinvMin,fitMinvMax);
@@ -5602,9 +7835,9 @@ Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
 //      Double_t n = CountParticle(*hminv,"Jpsi");
 //      r->Set("NofJPsi",n,TMath::Sqrt(n));
 //    }
-//  
+//
 //  }
-  
+
   if ( r->IsValid() )
   {
     StdoutToAliDebug(1,r->Print(););
@@ -5621,7 +7854,7 @@ Bool_t AliAnalysisMuMuJpsiResult::AddFit(const char* fitType)
     delete r;
     r=0x0;
   }
-  
+
   return (r!=0x0);
 }
 
@@ -5644,7 +7877,7 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
   /// except from the func key, all the other ones have default values
   /// if the key is different from func,rebin,range,histoType it is assumed
   /// to be the value for a parameter of the fit function.
-  
+
   TString resultName("");
 
   // default values
@@ -5655,15 +7888,15 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
   Double_t fitMinvMin=2.0;
   Double_t fitMinvMax=5.0;
   Double_t paramSPsiP= 3.68609/3.096916;
-  
+
   TString sFitType(fitType);
-  
+
   if (!sFitType.Contains(kKeyFunc,TString::kIgnoreCase)) return;
-  
+
   TObjArray* parts = sFitType.Tokenize(":");
   TObjString* str;
   TIter next(parts);
-  
+
   while ( ( str = static_cast<TObjString*>(next()) ) )
   {
     TString key,value;
@@ -5673,7 +7906,7 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
       AliErrorClass(Form("Invalid key=value pair %s",str->String().Data()));
       continue;
     }
-    
+
     if ( key.CompareTo(kKeyFunc,TString::kIgnoreCase) == 0 )
     {
       fitFunction = value;
@@ -5687,7 +7920,7 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
         fitMinvMin = xmin.Atof();
         fitMinvMax = xmax.Atof();
         AliInfoClass(Form("xmin=%e xmax=%e",fitMinvMin,fitMinvMax));
-        
+
         resultName += "_";
         resultName += xmin.Data();
         resultName += "-";
@@ -5699,14 +7932,12 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
         continue;
       }
     }
-    else if ( key.CompareTo(kKeyRebin,TString::kIgnoreCase) == 0 )
-    {
-      rebin = value.Atoi();
-    }
+    else if ( key.CompareTo(kKeyRebin,TString::kIgnoreCase) == 0 )rebin = value.Atoi();
+
     else if ( key.CompareTo(kKeyHistoType,TString::kIgnoreCase) == 0 ) //FIXME::Is really necesary to save the histoType? I think I dont use it
     {
       histoType = value;
-   
+
       if ( histoType.CompareTo("minv",TString::kIgnoreCase) == 0 ) Set(kKeyHistoType,0.,0.0); //histoType=0 means minv histo
       else if ( histoType.CompareTo("mpt",TString::kIgnoreCase) == 0 ) Set(kKeyHistoType,1.,0.0); //histoType=1 means mpt histo
       else if ( histoType.CompareTo("minv&mpt",TString::kIgnoreCase) == 0 ) Set(kKeyHistoType,2.,0.0); //histoType=1 means combined fit minv and mpt
@@ -5715,7 +7946,7 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
         AliErrorClass(Form("Improper histoType specification %s",value.Data()));
         continue;
       }
-     
+
     }
     else if ( key.CompareTo(kKeyTails,TString::kIgnoreCase) == 0 )
     {
@@ -5729,18 +7960,12 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
         continue;
       }
     }
-    else if ( key.CompareTo(kKeySPsiP,TString::kIgnoreCase) == 0 )
-    {
-      paramSPsiP = value.Atof();
-    }
-    else if ( key.CompareTo(kKeyMinvRS,TString::kIgnoreCase) == 0 )
-    {
-      fMinvRS = value.Data();
-    }
-    else
-    {
-      Set(key.Data(),value.Atof(),0.0);
-    }
+    else if ( key.CompareTo(kKeySPsiP,TString::kIgnoreCase) == 0 )paramSPsiP = value.Atof();
+
+    else if ( key.CompareTo(kKeyMinvRS,TString::kIgnoreCase) == 0 )fMinvRS = value.Data();
+
+    else Set(key.Data(),value.Atof(),0.0);
+
   }
 
   if ( fitFunction.CountChar('-') )
@@ -5750,7 +7975,7 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
   }
   else
   {
-  
+
     fFitFunction = fitFunction;
 
     Set(kKeySPsiP,paramSPsiP,0.0);
@@ -5758,7 +7983,7 @@ void AliAnalysisMuMuJpsiResult::DecodeFitType(const char* fitType)
     Set(kFitRangeLow,fitMinvMin,0.0);
     Set(kFitRangeHigh,fitMinvMax,0.0);
   }
-  
+
   delete parts;
 }
 
@@ -5786,14 +8011,14 @@ Long64_t AliAnalysisMuMuJpsiResult::Merge(TCollection* list)
   /// Note that the merging is to be understood here as an weighted mean operation
   ///
   /// FIXME ! (compared to base class Merge, should only Minv merging ?)
-  
+
   AliError("Implement me !");
   if (!list) return 0;
-  
+
   if (list->IsEmpty()) return 1;
-  
+
   return 0;
-  
+
 }
 
 //_____________________________________________________________________________
@@ -5808,7 +8033,7 @@ Int_t AliAnalysisMuMuJpsiResult::NofRuns() const
 Int_t AliAnalysisMuMuJpsiResult::NofTriggers() const
 {
   /// Get the number of triggers
-  
+
   if ( !Mother() ) return fNofTriggers;
   else return Mother()->NofTriggers();
 }
@@ -5822,7 +8047,7 @@ void AliAnalysisMuMuJpsiResult::Print(Option_t* opt) const
                                       NofRuns(),
                                       NofTriggers(),
                                       fBin.AsString().Data());
-  
+
   AliAnalysisMuMuResult::Print(opt);
 }
 
@@ -5831,19 +8056,19 @@ void AliAnalysisMuMuJpsiResult::PrintValue(const char* key, const char* opt, Dou
                                            Double_t rms) const
 {
   /// exclude the particles with zero stat
-  
+
   const std::map<std::string,Double_t>& m = MassMap();
 
   for( std::map<std::string,Double_t>::const_iterator it = m.begin(); it != m.end(); ++it )
   {
     TString particle(it->first.c_str());
-    
+
     if (TString(key).Contains(particle.Data()))
     {
       if ( GetValue("Nof%s",particle.Data()) <= 0.0 ) return;
     }
   }
-  
+
   AliAnalysisMuMuResult::PrintValue(key,opt,value,errorStat,rms);
 
 }
@@ -5852,47 +8077,45 @@ void AliAnalysisMuMuJpsiResult::PrintValue(const char* key, const char* opt, Dou
 void AliAnalysisMuMuJpsiResult::PrintParticle(const char* particle, const char* opt) const
 {
   /// Print all information about one particule type
-  
+
   Double_t npart = GetValue(Form("Nof%s",particle));
   if (npart<=0) return;
-  
-  
+
+
   std::cout << opt << Form("\t%s",particle) << std::endl;
-  
+
   //  Double_t npartError = GetErrorStat(Form("Nof%s",particle));
 //  std::cout << opt << Form("\t\t%20s %9.2f +- %5.2f","Count",npart,npartError) << std::endl;
-  
+
   TIter next(Keys());
   TObjString* key;
-  
+
   while ( ( key = static_cast<TObjString*>(next()) ) )
   {
     if ( !key->String().Contains(particle) ) continue;
-    
+
     PrintValue(key->String(),opt,GetValue(key->String()),GetErrorStat(key->String()),GetRMS(key->String()));
-  } 
+  }
 }
 
 //________________________
 void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fitTotal, TF1* bckInit, const char* fitOption, Int_t iParKPsip, Int_t iLastParBkg)
 {
   // If a Minv fit fails this algorithm changes some initial parameters to get the fit converged
-
+  
   Int_t bin(0);
-  if ( static_cast<int>(fitResult) )
-  {
-    if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip)) || (fitResult->CovMatrixStatus() != 3)) //kPsi'
-    {
-      std::cout << "//------- Setting Psi'norm= Psi' norm*0.2" << std::endl;
+
+  if ( static_cast<int>(fitResult) || static_cast<int>(fitResult->CovMatrixStatus())!=3 /*|| static_cast<int>(fitResult->CovMatrixStatus())!=2*/)
+  {   
+    if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip))) { //kPsi'
+      std::cout << "//------- Setting Psi'norm= Psi' norm*0.8" << std::endl;
       bin = fHisto->FindBin(3.68);
-      fitTotal->SetParLimits(iParKPsip, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin)*0.7); // we further restrict the range of psi' norm
-      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.2);
+      // fitTotal->SetParLimits(iParKPsip, 0.,fHisto->GetBinContent(bin)*1.5); // we further restrict the range of psi' norm
+      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.8);
     }
 
-    if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
-    {
-      std::cout << "//------- Setting kVWG=MAX/2" << std::endl;
-
+    if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) ) {
+      std::cout << "//------- Setting p0=MAX/2" << std::endl;
       fitTotal->SetParameter(0, fHisto->GetMaximum()/2.); // kVWG
     }
 
@@ -5900,72 +8123,85 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
     fitResult = fHisto->Fit(fitTotal,fitOption,"");
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
-  }
-
-  if ( static_cast<int>(fitResult) )
-  {
-      if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip))  || (fitResult->CovMatrixStatus() != 3) ) //kPsi'
-      {
-        std::cout << "//------- Setting Psi'norm= Psi' norm*0.1)" << std::endl;
-        bin = fHisto->FindBin(3.68);
-        fitTotal->SetParLimits(iParKPsip, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin)*0.5); // we further restrict the range of psi' norm
-        fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.1);
-      }
 
-      if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
-      {
-        std::cout << "//------- Setting kVWG=MAX*2)" << std::endl;
+    //Check if there are poles somewhere/
+    if(iLastParBkg == 6 )CheckRoots(fitResult,fitTotal,3,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6),fitOption);
+    if(iLastParBkg == 5 )CheckRoots(fitResult,fitTotal,2,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),0.,fitOption);
+   }
 
-        fitTotal->SetParameter(0, fHisto->GetMaximum()*2.); // kVWG
-      }
+  if ( static_cast<int>(fitResult) || static_cast<int>(fitResult->CovMatrixStatus())!=3 /*|| static_cast<int>(fitResult->CovMatrixStatus())!=2*/)
+  { 
+    if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip))  ){ //kPsi'
+      std::cout << "//------- Setting Psi'norm= Psi' norm*0.5)" << std::endl;
+      bin = fHisto->FindBin(3.68);
+      // fitTotal->SetParLimits(iParKPsip, 0.,fHisto->GetBinContent(bin)*0.9); // we further restrict the range of psi' norm
+      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.5);
+    }
+    if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) ) {
+      std::cout << "//------- Setting p0=MAX/2)" << std::endl;
+      fitTotal->SetParameter(0, fHisto->GetMaximum()*2.); // kVWG
+    }
 
     std::cout << "//======== Refitting again =======\\" << std::endl;
     fitResult = fHisto->Fit(fitTotal,fitOption,"");
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+     //Check if there are poles somewhere/
+    if(iLastParBkg == 6 )CheckRoots(fitResult,fitTotal,3,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6),fitOption) ;
+    if(iLastParBkg == 5 )CheckRoots(fitResult,fitTotal,2,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),0.,fitOption);
   }
 
-  if ( static_cast<int>(fitResult) )
-  {
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3 /*|| static_cast<int>(fitResult->CovMatrixStatus())!=2*/) {
+    std::cout << "//======== Refitting bkg again (setting range rejected 2.5-3.7, and fit range 1.7-4.5)" << std::endl;
+
+    SetFitRejectRange(2.5,3.7);
+    TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOption,"",1.7,4.5);
+    SetFitRejectRange();
+
+    for ( Int_t i = 0; i < iLastParBkg+1 ; ++i ) fitTotal->SetParameter(i, bckInit->GetParameter(i)); //set initial background parameters
 
-    std::cout << "//======== Refitting bkg again (setting range rejected 2.7-3.5, and fit range 1.7-5)" << std::endl;
+    fitResult = fHisto->Fit(fitTotal,fitOption,"");
+    std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+    std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
 
-    SetFitRejectRange(2.7,3.5);
+     //Check if there are poles somewhere/
+    if(iLastParBkg == 6 )CheckRoots(fitResult,fitTotal,3,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6),fitOption) ;
+    if(iLastParBkg == 5 )CheckRoots(fitResult,fitTotal,2,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),0.,fitOption);
+  }
 
-    TFitResultPtr fitResultInit = fHisto->Fit(bckInit,"SR","",1.7,5.);
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3 /*|| static_cast<int>(fitResult->CovMatrixStatus())!=2*/) {
+    std::cout << "//======== Refitting bkg again (setting range rejected 2.5-3.5, and fit range 1.5-5)" << std::endl;
 
+    SetFitRejectRange(2.5,3.5);
+    TFitResultPtr fitResultInit = fHisto->Fit(bckInit,fitOption,"",1.5,5.);
     SetFitRejectRange();
 
-    for ( Int_t i = 0; i < iLastParBkg+1 ; ++i )
-    {
-      fitTotal->SetParameter(i, bckInit->GetParameter(i));
-    }
+    for ( Int_t i = 0; i < iLastParBkg+1 ; ++i ) fitTotal->SetParameter(i, bckInit->GetParameter(i)); //set initial background parameters
 
     fitResult = fHisto->Fit(fitTotal,fitOption,"");
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+
+    if(iLastParBkg == 6 )CheckRoots(fitResult,fitTotal,3,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6),fitOption) ;
+    if(iLastParBkg == 5 )CheckRoots(fitResult,fitTotal,2,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),0.,fitOption);
   }
 
-  if ( static_cast<int>(fitResult) )
-  {
-    for ( Int_t i = 0; i < iLastParBkg+1 ; ++i )
-    {
-      fitTotal->SetParameter(i, bckInit->GetParameter(i));
-    }
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.)
+  { 
 
-    if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip))  || (fitResult->CovMatrixStatus() != 3) ) //kPsi'
-    {
-      std::cout << "//------- Setting Psi'norm= Psi' norm*0.1)" << std::endl;
+    for ( Int_t i = 0; i < iLastParBkg+1 ; ++i ) fitTotal->SetParameter(i, bckInit->GetParameter(i));
+
+    if ( (0.5*fitTotal->GetParameter(iParKPsip) <= fitTotal->GetParError(iParKPsip))  ) { //kPsi'
+      std::cout << "//------- Setting Psi'norm= Psi' norm*0.3)" << std::endl;
       bin = fHisto->FindBin(3.68);
-      fitTotal->SetParLimits(iParKPsip, fHisto->GetBinContent(bin)*0.01,fHisto->GetBinContent(bin)*0.4); // we further restrict the range of psi' norm
-      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.1);
+      // fitTotal->SetParLimits(iParKPsip, 0.,fHisto->GetBinContent(bin)*0.7); // we further restrict the range of psi' norm
+      fitTotal->SetParameter(iParKPsip, fHisto->GetBinContent(bin)*0.3);
     }
 
-    if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) )
-    {
-      std::cout << "//-------Setting kVWG=MAX*0.6)" << std::endl;
-
-      fitTotal->SetParLimits(0,bckInit->GetParameter(0)*0.1,bckInit->GetParameter(0)*10.);
+    if ( 0.5*fitTotal->GetParameter(0) <= fitTotal->GetParError(0) ){
+      std::cout << "//-------Setting p0=MAX*0.6)" << std::endl;
+      // fitTotal->SetParLimits(0,bckInit->GetParameter(0)*0.1,bckInit->GetParameter(0)*1.5);
       fitTotal->SetParameter(0, fHisto->GetMaximum()*0.6); // kVWG
     }
 
@@ -5974,9 +8210,21 @@ void AliAnalysisMuMuJpsiResult::ProcessMinvFit(TFitResultPtr& fitResult, TF1* fi
     std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
     std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
 
-    if ( static_cast<int>(fitResult) ) std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
+    if(iLastParBkg == 6 )CheckRoots(fitResult,fitTotal,3,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),fitTotal->GetParameter(6),fitOption) ;
+    if(iLastParBkg == 5 )CheckRoots(fitResult,fitTotal,2,fitTotal->GetParameter(3),fitTotal->GetParameter(4),fitTotal->GetParameter(5),0.,fitOption);
   }
 
+  // if ( !static_cast<int>(fitResult) && static_cast<int>(fitResult->CovMatrixStatus())!=3.){
+  //   // change fit option if the only problem is the error calculation
+  //   std::cout << "//------- Erro estimation problem, changing fit option" << std::endl;
+  //   std::cout << "//======== Refitting again =======\\" << std::endl;
+
+  //   fitResult = fHisto->Fit(fitTotal,Form("%sM",fitOption),"");
+  //   std::cout << "FitResult=" << static_cast<int>(fitResult) << std::endl;
+  //   std::cout << "CovMatrixStatus=" << fitResult->CovMatrixStatus() << std::endl;
+  // }
+
+  if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.) std::cout << "//-------Cannot fit properly, try something else..." << std::endl;
 }
 
 //________________________
@@ -5989,26 +8237,21 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
   TArrayD* initPars(0x0);
 
   Int_t bin = fHisto->FindBin(0.82); // We change the bin from where we get the initial value for 1st parameter
-  if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundVWG") )
-  {
+  if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundVWG")|| !sbkgFuncName.CompareTo("FitFunctionBackgroundVWG2") ) {
     nParsBkg = 4;
     initPars = new TArrayD(nParsBkg);
     initPars->AddAt(fHisto->GetBinContent(bin),0);
     initPars->AddAt(2.,1);
     initPars->AddAt(0.5,2);
     initPars->AddAt(0.3,3);
-  }
-  else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Exp") )
-  {
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Exp") ) {
     nParsBkg = 4;
     initPars = new TArrayD(nParsBkg);
     initPars->AddAt(fHisto->GetBinContent(bin),0);
     initPars->AddAt(-fHisto->GetBinContent(bin)/3.,1);
     initPars->AddAt(100.,2);
     initPars->AddAt(0.05,3);
-  }
-  else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol4Exp") )
-  {
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol4Exp") ) {
     nParsBkg = 6;
     bin = fHisto->FindBin(1.6);
     bckInit->SetParameters(0.,1.,1.,1.,2.,0.5);
@@ -6025,29 +8268,66 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
 //    initPars->AddAt(1.,3);
 //    initPars->AddAt(2.,4);
 //    initPars->AddAt(0.5,5);
-  }
-  else
-  {
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol1Pol2") ) {
+    nParsBkg = 4;
+    initPars = new TArrayD(nParsBkg);
+
+    initPars->AddAt(0,0);
+    initPars->AddAt(fHisto->GetBinContent(bin),1);
+    initPars->AddAt(0.,2);
+    initPars->AddAt(1.,3);
+    // initPars->AddAt(1,4);
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Pol3V2") ) {
+    bin = fHisto->FindBin(1.5);
+    nParsBkg = 6;
+    initPars = new TArrayD(nParsBkg);
+    initPars->AddAt(0.9,0);
+    initPars->AddAt(-9,1);
+    initPars->AddAt(bin,2);
+    initPars->AddAt(1,3);
+    initPars->AddAt(-6,4);
+    initPars->AddAt(9,5);
+  } else if ( !sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Pol3") ) {
+    bin = fHisto->FindBin(1.5);
+    nParsBkg = 6;
+    initPars = new TArrayD(nParsBkg);
+    initPars->AddAt(0.9,0);
+    initPars->AddAt(-9,1);
+    initPars->AddAt(bin,2);
+    initPars->AddAt(1,3);
+    initPars->AddAt(-6,4);
+    initPars->AddAt(9,5);
+  } else {
     AliError("Unrecognized Background function");
     return;
   }
 
+  if(!sbkgFuncName.CompareTo("FitFunctionBackgroundPol2Pol3")){
+    for (int i = 0; i < 5; ++i) {
+      if(CheckRoots(fitResultInit,bckInit,3,bckInit->GetParameter(3),bckInit->GetParameter(4),bckInit->GetParameter(5),bckInit->GetParameter(6),fitOption)) continue;
+      printf("attempt to remove pole n %d\n", i+1 );
+    }
+  }
+
+  if(!sbkgFuncName.CompareTo("FitFunctionBackgroundPol1Pol2") ){
+    for (int i = 0; i < 5; ++i){
+      if(CheckRoots(fitResultInit,bckInit,2,bckInit->GetParameter(3),bckInit->GetParameter(4),bckInit->GetParameter(5),0.,fitOption)) continue;
+      printf("attempt to remove pole n %d\n", i+1 );
+    }
+  }
 
-  if ( static_cast<int>(fitResultInit) )
-  {
+  if ( static_cast<int>(fitResultInit) ) {
 
     std::cout << "//------- Resetting default initial parameters" << std::endl;
 
-    for ( Int_t i = 0 ; i < nParsBkg ; i++ )
-    {
+    for ( Int_t i = 0 ; i < nParsBkg ; i++ ) {
       Double_t par = initPars->At(i);
       if ( i == 0 ) par =2*par + 1.;
       bckInit->SetParameter(i,par);
     }
 
     std::cout << "//======== Fitting background again =======\\" << std::endl;
-    fitResultInit = fHisto->Fit(bckInit,"SR");
-
+    fitResultInit = fHisto->Fit(bckInit,fitOption);
     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   }
 
@@ -6055,55 +8335,47 @@ void AliAnalysisMuMuJpsiResult::ProcessBkgFit(TFitResultPtr &fitResultInit, TF1*
   {
     // Same initial parameters but change the fitting range
 
-    std::cout << "//------- Changing fitting range to (1.7,5.0)" << std::endl;
+    std::cout << "//------- Changing fitting range to (1.5,5.0)" << std::endl;
 
-    for ( Int_t i = 0 ; i < nParsBkg ; i++ )
-    {
-      bckInit->SetParameter(i,initPars->At(i));
-    }
+    for ( Int_t i = 0 ; i < nParsBkg ; i++ ) bckInit->SetParameter(i,initPars->At(i));
     SetFitRejectRange(2.8,3.4);
 
     std::cout << "//======== Fitting background again =======\\" << std::endl;
-    fitResultInit = fHisto->Fit(bckInit,"SR","",1.5,5.);
+    fitResultInit = fHisto->Fit(bckInit,fitOption,"",1.5,5.);
 
     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   }
 
-  if ( static_cast<int>(fitResultInit) )
-  {
+  if ( static_cast<int>(fitResultInit) ) {
     // Chage first initial parameter and change the fitting range
     std::cout << "Fitting background again" << std::endl;
 
-    for ( Int_t i = 0 ; i < nParsBkg ; i++ )
-    {
+    for ( Int_t i = 0 ; i < nParsBkg ; i++ ) {
       Double_t par = initPars->At(i);
       if ( i == 0 ) par =2*par + 1.;
       bckInit->SetParameter(i,par);
     }
-    SetFitRejectRange(2.7,3.5);
+    SetFitRejectRange(2.7,4.0);
 
     std::cout << "//======== Fitting background again =======\\" << std::endl;
-    fitResultInit = fHisto->Fit(bckInit,"SR","",2.0,5.);
-
+    fitResultInit = fHisto->Fit(bckInit,fitOption,"",1.5,5.);
     std::cout << "FitResultBkgInit=" << static_cast<int>(fitResultInit) << std::endl;
   }
 
-  if ( static_cast<int>(fitResultInit) )
-  {
+  if ( static_cast<int>(fitResultInit) ) {
     std::cout << std::endl;
     std::cout << "Cannot fit background properly, try something else" << std::endl;
     std::cout << std::endl;
   }
 
   delete initPars;
-
 }
 
 //_____________________________________________________________________________
 void AliAnalysisMuMuJpsiResult::SetBin(const AliAnalysisMuMuBinning::Range& bin)
 {
   /// Set the bin
-  
+
   if (!Mother()) fBin = bin;
   else Mother()->SetBin(bin);
 }
@@ -6128,7 +8400,7 @@ void AliAnalysisMuMuJpsiResult::SetHisto(const TH1& h)
 {
   /// Set the spectrum to be fitted.
   static UInt_t n(0);
-  
+
   delete fHisto;
   fHisto = static_cast<TH1*>(h.Clone(Form("AliAnalysisMuMuJpsiResultHisto%u",n++)));
   fHisto->SetDirectory(0);
@@ -6138,7 +8410,7 @@ void AliAnalysisMuMuJpsiResult::SetHisto(const TH1& h)
 void AliAnalysisMuMuJpsiResult::SetNofInputParticles(const TH1& hminv)
 {
   /// Set the number of input particle from the invariant mass spectra
-  
+
   static const char* particleNames[] = { "JPsi" , "PsiP", "Upsilon","UpsilonPrime" };
 
   const std::map<std::string,Double_t>& m = MassMap();
@@ -6157,7 +8429,7 @@ void AliAnalysisMuMuJpsiResult::SetNofInputParticles(const TH1& hminv)
     Double_t n = CountParticle(hminv,particleNames[i],sigma);
 
     AliDebug(1,Form("i=%d particle %s n %e",i,particleNames[i],n));
-    
+
     if ( n > 0 )
     {
       SetNofInputParticles(particleNames[i],TMath::Nint(n));
@@ -6170,37 +8442,38 @@ void AliAnalysisMuMuJpsiResult::SetNofInputParticles(const char* particle, int n
 {
   /// Set the number of input particles (so it is a MC result)
   /// and (re)compute the AccxEff values
-  
+
   Set(Form("NofInput%s",particle),n,TMath::Sqrt(n));
-  
+
   if (n<=0)
   {
     Set(Form("AccEff%s",particle),0,0);
     return;
   }
-  
-  Double_t npart = GetValue(Form("Nof%s",particle));
+
+  Double_t npart     = GetValue(Form("Nof%s",particle));
   Double_t npartErr  = GetErrorStat(Form("Nof%s",particle));
-  Double_t ninput = GetValue(Form("NofInput%s",particle));
+  Double_t ninput    = GetValue(Form("NofInput%s",particle));
   Double_t ninputErr = GetErrorStat(Form("NofInput%s",particle));
-  
+
   Set(Form("AccEff%s",particle),
       npart/ninput,
       (npart/ninput)*ErrorAB(npart,npartErr,ninput,ninputErr));
-  
+
   TIter next(SubResults());
   AliAnalysisMuMuJpsiResult* r;
-  
+
   while ( ( r = static_cast<AliAnalysisMuMuJpsiResult*>(next())) )
   {
     r->Set(Form("NofInput%s",particle),n,TMath::Sqrt(n));
 
     npart = r->GetValue(Form("Nof%s",particle));
     npartErr = r->GetErrorStat(Form("Nof%s",particle));
-    
+
     r->Set(Form("AccEff%s",particle),
            npart/ninput,
            (npart/ninput)*ErrorAB(npart,npartErr,ninput,ninputErr));
+    printf("AccEff : %f \n", npart/ninput);
 
   }
 }
@@ -6225,7 +8498,7 @@ void AliAnalysisMuMuJpsiResult::SetParameter(TF1* func, Int_t npar, Double_t fix
                                              Double_t min, Double_t max) const
 {
   /// Fix one parameter or set its initial value and limits
-  
+
   if ( IsValidValue(fix) )
   {
     func->FixParameter(npar, fix);
@@ -6238,6 +8511,117 @@ void AliAnalysisMuMuJpsiResult::SetParameter(TF1* func, Int_t npar, Double_t fix
 }
 
 //_____________________________________________________________________________
+Bool_t AliAnalysisMuMuJpsiResult::CheckRoots(TFitResultPtr &fitResult, TF1* fitFunction, Int_t deg, Double_t a, Double_t b, Double_t c, Double_t d,const char* fitOption  )
+{
+  /// Check if there is no roots founs in the x axis inside the fit range. If there are some, refit again.
+  /// Meant to work for polynomial ratio background function.
+
+  if(!fitFunction){
+    AliError("Cannot check roots without functons ...");
+    return kFALSE;
+  }
+
+  Double_t fitRangeLow  = GetValue(kFitRangeLow);
+  Double_t fitRangeHigh = GetValue(kFitRangeHigh);
+  Double_t epsilon      = 2.;
+
+  if(deg == 2) {
+    Double_t delta = b*b -4*a*c;
+    if(delta <= 0.) return kTRUE;
+    Double_t x1 = (-b - TMath::Sqrt(delta ))/(2.*a);
+    Double_t x2 = (-b + TMath::Sqrt(delta ))/(2.*a);
+    if ((fitRangeLow < x1 && x1 < fitRangeHigh )){
+       printf(" !!!!!! Roots founded at %f !!!!!! \n",x1);
+       fitFunction->SetParameters(2,a+a*epsilon);
+       fitResult = fHisto->Fit(fitFunction,fitOption,"");
+       printf("fit Result       = %d\n",static_cast<int>(fitResult) );
+       printf("Covariant matrix = %d\n",static_cast<int>(fitResult->CovMatrixStatus()) );
+       return kFALSE;
+    }
+    if ((fitRangeLow < x2 && x2 < fitRangeHigh )){
+       printf(" !!!!!! Roots founded at %f !!!!!! \n",x2);
+       fitFunction->SetParameters(2,a+a*epsilon);
+       fitResult = fHisto->Fit(fitFunction,fitOption,"");
+       printf("fit Result       = %d\n",static_cast<int>(fitResult) );
+       printf("Covariant matrix = %d\n",static_cast<int>(fitResult->CovMatrixStatus()) );
+       return kFALSE;
+    }
+  }
+
+  if(deg == 3 && a != 0.) {
+    // Cardan methods, see https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Cardan
+
+    Double_t p = -b*b/(3.*a*a) + c/a;
+    // printf("p =%f\n",p );
+    Double_t q =b/(27.*a) * (2.*b*b/a/a -9*c/a ) +d/a;
+    // printf("q =%f\n",q );
+    Double_t delta = -(4*p*p*p + 27*q*q);
+    // printf("delta =%f\n",delta );
+
+    Double_t z1 = 0.5*(-q - TMath::Sqrt(-0.037*delta));
+    // printf("z1 =%f\n",z1 );
+    Double_t z2 = 0.5*(-q + TMath::Sqrt(-0.037*delta));
+    // printf("z2 =%f\n",z2 );
+
+    Double_t r1 = z1/TMath::Abs(z1)*TMath::Power(TMath::Abs(z1),0.33) ;
+    // printf("r1 =%f\n",r1 );
+    Double_t r2 = z2/TMath::Abs(z2)*TMath::Power(TMath::Abs(z2),0.33) ;
+    // printf("r2 =%f\n",r2 );
+
+    Double_t R1 =0.;
+    Double_t R2 =0.;
+    Double_t R3 =0.;
+
+    if( delta < 0) R1 = r1 + r2 -0.333*b/a;
+    else if(delta == 0){
+      R1 = 3*q/p -0.333*b/a;
+      R2 = -1.5*q*p -0.333*b/a;
+      R3 = -1.5*q*p -0.333*b/a;
+    }
+    else if(delta > 0.){
+      R1 = 2*TMath::Sqrt(-0.333*p)*TMath::Cos(0.333*TMath::ACos(-0.5*q*TMath::Sqrt(-27/p/p/p) + 0.*0.666*3.14)) -0.333*b/a;
+      // R2 = 2*TMath::Sqrt(-0.333*p)*TMath::Cos(0.333*TMath::ACos(-0.5*q*TMath::Sqrt(-27/p/p/p) + 1.*0.666*3.14)) -0.333*b/a;
+      // R3 = 2*TMath::Sqrt(-0.333*p)*TMath::Cos(0.333*TMath::ACos(-0.5*q*TMath::Sqrt(-27/p/p/p) + 2.*0.666*3.14)) -0.333*b/a;
+    }
+
+    if (fitRangeLow < R1  && R1 < fitRangeHigh){
+      printf(" !!!!!! Roots founded at %f !!!!!! \n", R1);
+      fitFunction->SetParameter(3,a+a*epsilon);
+      printf("Parameter 3 = %f \n",fitFunction->GetParameter(3) );
+      fitResult = fHisto->Fit(fitFunction,fitOption,"");
+      printf("fit Result       = %d\n",static_cast<int>(fitResult) );
+      printf("Covariant matrix = %d\n",static_cast<int>(fitResult->CovMatrixStatus()) );
+      // if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.) return kFALSE;
+      return kFALSE;
+    }
+    if (fitRangeLow < R2  && R2 < fitRangeHigh){
+      printf(" !!!!!! Roots founded at %f !!!!!! \n", R2);
+      fitFunction->SetParameter(3,a+a*epsilon);
+      printf("Parameter 3 = %f \n",fitFunction->GetParameter(3) );
+      fitResult = fHisto->Fit(fitFunction,fitOption,"");
+      printf("fit Result = %d\n",static_cast<int>(fitResult) );
+      printf("Covariant matrix = %d\n",static_cast<int>(fitResult->CovMatrixStatus()) );
+      // if ( static_cast<int>(fitResult) ||static_cast<int>(fitResult->CovMatrixStatus())!=3.) return kFALSE;
+      return kFALSE;
+    }
+    if (fitRangeLow < R3  && R3 < fitRangeHigh){
+      printf(" !!!!!! Roots founded at %f !!!!!! \n", R3);
+      fitFunction->SetParameter(3,a+a*epsilon);
+      printf("Parameter 3 = %f \n",fitFunction->GetParameter(3) );
+      fitFunction->SetParameter(4,b+b*epsilon);
+      printf("Parameter 4 = %f \n",fitFunction->GetParameter(4) );
+      fitResult = fHisto->Fit(fitFunction,fitOption,"");
+      printf("fit Result = %d\n",static_cast<int>(fitResult) );
+      printf("Covariant matrix = %d\n",static_cast<int>(fitResult->CovMatrixStatus()) );
+      // if ( static_cast<int>(fitResult) || static_cast<int>(fitResult->CovMatrixStatus())!=3.) return kFALSE;
+      return kFALSE;
+    }
+  }
+
+  return kTRUE;
+}
+
+//_____________________________________________________________________________
 Bool_t AliAnalysisMuMuJpsiResult::StrongCorrelation(TFitResultPtr& r,
                                                     TF1* fitFunction,
                                                     Int_t npar1,
@@ -6247,9 +8631,9 @@ Bool_t AliAnalysisMuMuJpsiResult::StrongCorrelation(TFitResultPtr& r,
   // return kTRUE if the npar1-th and npar2-th parameters of the fit function
   // are too strongly correlated,
   // and in that case fix the npar2-th parameter's value to fixValueIfWrong
-  
+
   Bool_t strongCorrelation = TMath::Abs(r->GetCorrelationMatrix()(npar1,npar2)) > 0.90;
-  
+
   if ( strongCorrelation )
   {
     fitFunction->FixParameter(npar2,fixValueIfWrong);
@@ -6264,18 +8648,18 @@ Bool_t AliAnalysisMuMuJpsiResult::WrongParameter(TF1* fitFunction, Int_t npar,
 {
   // return kTRUE if npar-th parameter of fit function has a big error,
   // and in that case fix the parameter's value to fixValueIfWrong
-  
+
   Bool_t wrong = (fitFunction->GetParError(npar) > 0.8*TMath::Abs(fitFunction->GetParameter(npar)));
-  
+
   AliWarning(Form("npar %d error %e val %e wrong %d",
                   npar,fitFunction->GetParError(npar),
                   fitFunction->GetParameter(npar),wrong));
-  
+
   if ( wrong )
   {
     AliWarning(Form("Fixing parameter %d of %s to %e",
                     npar,fitFunction->GetName(),fixValueIfWrong));
-    
+
     fitFunction->FixParameter(npar,fixValueIfWrong);
     return kTRUE;
   }
diff --git a/PWG/muondep/AliAnalysisMuMuJpsiResult.h b/PWG/muondep/AliAnalysisMuMuJpsiResult.h
index f8cff58..9df98aa 100644
--- a/PWG/muondep/AliAnalysisMuMuJpsiResult.h
+++ b/PWG/muondep/AliAnalysisMuMuJpsiResult.h
@@ -23,11 +23,11 @@ class TFitResultPtr;
 
 class AliAnalysisMuMuJpsiResult : public AliAnalysisMuMuResult
 {
-  
+
 public:
-  
+
   AliAnalysisMuMuJpsiResult(TRootIOCtor* io);
-  
+
 //  AliAnalysisMuMuJpsiResult(const TH1& hminv);
 
   AliAnalysisMuMuJpsiResult(const char* particle,
@@ -41,24 +41,24 @@ public:
                             const char* pairSelection,
                             const char* centSelection,
                             const AliAnalysisMuMuBinning::Range& bin);
-  
+
   AliAnalysisMuMuJpsiResult(const AliAnalysisMuMuJpsiResult& rhs);
   AliAnalysisMuMuJpsiResult& operator=(const AliAnalysisMuMuJpsiResult& rhs);
-  
+
   virtual ~AliAnalysisMuMuJpsiResult();
 
   virtual TObject* Clone(const char* newname = "") const;
-  
+
   Bool_t Correct(const AliAnalysisMuMuJpsiResult& other, const char* particle, const char* subResultName="");
-  
+
   TH1* Histo() const { return fHisto; }
-  
+
   Int_t NofTriggers() const;
-  
+
   void SetNofTriggers(Int_t n);
-  
+
   void Print(Option_t* opt="") const;
-  
+
   Bool_t AddFit(const char* fitType);
 
   AliAnalysisMuMuJpsiResult* CountJpsi(TH1& h);
@@ -66,62 +66,70 @@ public:
   /** All the fit functions should have a prototype starting like :
 
    AliAnalysisMuMuJpsiResult* FitXXX();
-   
+
    If extra parameters to the specific FitXXX function are needed, they should be given
-   using the SetValue(...) method, and retrieved from the FitXXX method using 
+   using the SetValue(...) method, and retrieved from the FitXXX method using
    the GetValue(...) method.
    */
-  
+
 
   void FitPSICOUNT();
   void FitPSICB2();
   void FitPSINA60NEW();
-  
+
+  // void FitPSICB2VWG();
   void FitPSIPSIPRIMECB2VWG();
+  void FitPSIPSIPRIMECB2VWG2();
+  void FitPSIPSIPRIMECB2POL1POL2();
+  void FitPSIPSIPRIMECB2POL2POL3();
+  void FitPSIPSIPRIMECB2POL2POL3V2();
   void FitPSIPSIPRIMECB2POL2EXP();
   void FitPSIPSIPRIMENA60NEWVWG();
+  void FitPSIPSIPRIMENA60NEWVWG2();
+  void FitPSIPSIPRIMENA60NEWPOL1POL2();
+  void FitPSIPSIPRIMENA60NEWPOL2POL3();
   void FitPSIPSIPRIMENA60NEWPOL2EXP();
-  
+
   void FitPSIPSIPRIMECB2POL4EXP();
   void FitPSIPSIPRIMENA60NEWPOL4EXP();
   void FitPSIPSIPRIMECB2VWGINDEPTAILS();
-  
+
   //** All the mean pt fit methods MUST contain the corresponding name of the inv mass spectra method
   void FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2();
-  void FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP();  
+  void FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL2EXP();
   void FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2();
   void FitMPTPSIPSIPRIMECB2POL2EXP_BKGMPTPOL2EXP();
-  
+
   void FitMPTPSIPSIPRIMECB2VWG_BKGMPTLIN();
   void FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL3();
   void FitMPTPSIPSIPRIMECB2VWG_BKGMPTPOL4();
   void FitMPTPSIPSIPRIMECB2VWGINDEPTAILS_BKGMPTPOL2();
-  
+
 //  void FitMPT2CB2POL2EXP_BKGMPTPOL4();
 //  void FitMPT2CB2POL4EXP_BKGMPTPOL2();
 //  void FitMPT2CB2POL4EXP_BKGMPTPOL4();
-  
+
   void FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2();
   void FitMPTPSIPSIPRIMENA60NEWVWG_BKGMPTPOL2EXP();
   void FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2();
   void FitMPTPSIPSIPRIMENA60NEWPOL2EXP_BKGMPTPOL2EXP();
   void FitMPTPSIPSIPRIMENA60NEWPOL4EXP_BKGMPTPOL2();
-  
+
   void FitPSIPSIPRIMECOMB_CB2VWG_MPTCB2VWG_BKGMPTPOL2();
-  
+
 //  void FitMPT2NA60NEWVWG_BKGMPTPOL4();
 //  void FitMPT2NA60NEWPOL2EXP_BKGMPTPOL4();
 //  void FitMPT2NA60NEWPOL4EXP_BKGMPTPOL4();
 
 
   Int_t NofRuns() const;
-  
+
   void SetNofRuns(int n);
-  
+
   const AliAnalysisMuMuBinning::Range& Bin() const;
 
   void SetBin(const AliAnalysisMuMuBinning::Range& bin);
-  
+
   void SetNofInputParticles(const char* particle, int n);
 
   void SetNofInputParticles(const TH1& hminv);
@@ -131,7 +139,7 @@ public:
   Long64_t Merge(TCollection* list);
 
   static Double_t CountParticle(const TH1& hminv, const char* particle, Double_t sigma=-1.0);
-  
+
   virtual AliAnalysisMuMuJpsiResult* Mother() const { return static_cast<AliAnalysisMuMuJpsiResult*>(AliAnalysisMuMuResult::Mother()); }
 
   void PrintValue(const char* key, const char* opt, Double_t value, Double_t errorStat, Double_t rms=0.0) const;
@@ -143,13 +151,13 @@ public:
   TString FitFunctionName() const { return fFitFunction; }
 
   TString GetFitFunctionMethodName() const;
-  
+
   void Draw(Option_t* opt="");
-  
-  const char* GetParticle() { return fParticle; } 
-  
+
+  const char* GetParticle() { return fParticle; }
+
 private:
-  
+
   enum EIndex
   {
     kValue=0,
@@ -157,104 +165,130 @@ private:
   };
 
   void DecodeFitType(const char* fitType);
-  
+
   void PrintParticle(const char* particle, const char* opt) const;
-  
+
   Double_t FitFunctionBackgroundLin(Double_t *x, Double_t *par);
 
-  Double_t FitFunctionBackgroundPol2Exp(Double_t* x, Double_t* par);
+  Double_t FitFunctionBackgroundPol1Pol2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionBackgroundPol2Pol3(Double_t *x, Double_t *par);
   
+  Double_t FitFunctionBackgroundPol2Pol3V2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionBackgroundPol2Exp(Double_t* x, Double_t* par);
+
   Double_t FitFunctionBackgroundPol4Exp(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionBackgroundPol2(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionBackgroundPol3(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionBackgroundPol4(Double_t *x, Double_t *par);
 
   Double_t FitFunctionBackgroundVWG(Double_t* x, Double_t* par);
+  
+  Double_t FitFunctionBackgroundVWG2(Double_t* x, Double_t* par);
 
   Double_t FitFunctionSignalCrystalBallExtended(Double_t *x,Double_t *par);
-  
+
   Double_t FitFunctionNA60New(Double_t *x,Double_t *par);
-  
+
+  // Double_t FitFunctionTotalOneCB2VWG(Double_t *x,Double_t *par); // Correction here
+
   Double_t FitFunctionTotalTwoNA60NewVWG(Double_t *x, Double_t *par);
   
+  Double_t FitFunctionTotalTwoNA60NewVWG2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionTotalTwoNA60NewPol1Pol2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionTotalTwoNA60NewPol2Pol3(Double_t *x, Double_t *par);
+
   Double_t FitFunctionTotalTwoNA60NewPol2Exp(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionTotalTwoNA60NewPol4Exp(Double_t *x, Double_t *par);
 
   Double_t FitFunctionTotalTwoCB2Pol2Exp(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionTotalTwoCB2Pol1Pol2(Double_t *x, Double_t *par);
+
+  Double_t FitFunctionTotalTwoCB2Pol2Pol3(Double_t *x, Double_t *par);
   
+  Double_t FitFunctionTotalTwoCB2Pol2Pol3V2(Double_t *x, Double_t *par);
+
   Double_t FitFunctionTotalTwoCB2Pol4Exp(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionTotalTwoCB2VWG(Double_t *x, Double_t *par);
   
+  Double_t FitFunctionTotalTwoCB2VWG2(Double_t *x, Double_t *par);
+
   Double_t FitFunctionTotalTwoCB2Lin(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionTotalTwoCB2VWGINDEPTAILS(Double_t *x, Double_t *par);
-  
+
   Double_t alphaCB2VWG(Double_t*x, Double_t* par);
-  
+
   Double_t alphaCB2POL2EXP(Double_t*x, Double_t* par);
-  
+
   Double_t alphaNA60NEWVWG(Double_t*x, Double_t* par);
-  
+
   Double_t alphaNA60NEWPOL2EXP(Double_t*x, Double_t* par);
-  
+
   Double_t FitFunctionMeanPtSCB2Lin(Double_t* x, Double_t* par);
-  
+
   Double_t FitFunctionMeanPtS2CB2Lin(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtSCB2VWGPOL2(Double_t* x, Double_t* par);
-  
-  
-  
+
+
+
   Double_t FitFunctionMeanPtS2CB2VWGPOL2(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2CB2VWGPOL2EXP(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2CB2POL2EXPPOL2(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2CB2POL2EXPPOL2EXP(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2NA60NEWVWGPOL2(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2NA60NEWVWGPOL2EXP(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2NA60NEWPOL2EXPPOL2EXP(Double_t *x, Double_t *par);
-  
- 
-  
+
+
+
   Double_t FitFunctionMeanPtS2CB2VWGPOL3(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2CB2VWGPOL2INDEPTAILS(Double_t *x, Double_t *par);
-  
+
   Double_t FitFunctionMeanPtS2CB2VWGPOL4(Double_t *x, Double_t *par);
 
   void SetFitRejectRange(Double_t a=TMath::Limits<Double_t>::Max(),
                          Double_t b=TMath::Limits<Double_t>::Max());
 
   void AttachFunctionsToHisto(TF1* signal, TF1* bck, TF1* total, Double_t xmin, Double_t xmax); //Might be unnecesary since we have the one with 2 signals
-  
+
   void AttachFunctionsToHisto(TF1* signal1, TF1* signal2, TF1* bck, TF1* total,Double_t xmin, Double_t xmax);
 
   void SetParameter(TF1* func, Int_t npar, Double_t fix, Double_t initialValue,
                     Double_t min, Double_t max) const;
 
+  Bool_t CheckRoots(TFitResultPtr &fitResult, TF1* fitFunction, Int_t deg, Double_t a, Double_t b, Double_t c, Double_t d, const char* fitOption );
+
   Bool_t WrongParameter(TF1* fitFunction, Int_t npar, Double_t fixValueIfWrong);
-  
+
   Bool_t StrongCorrelation(TFitResultPtr& fitResult, TF1* fitFunction, Int_t npar1, Int_t npar2, Double_t fixValueIfWrong);
 
-  
+
 private:
   Int_t fNofRuns; // number of runs used to get this result
   Int_t fNofTriggers; // number of trigger analyzed
   TH1* fHisto; // invariant mass spectrum
   AliAnalysisMuMuBinning::Range fBin; // bin range
-  
+
   TString fTriggerClass; // trigger class for this result
   TString fEventSelection; // event selection for this result
   TString fPairSelection; // pair selection for this result
@@ -264,10 +298,10 @@ private:
   Double_t fFitRejectRangeLow; // fit range to reject
   Double_t fFitRejectRangeHigh; // fit range to reject
   Bool_t fRejectFitPoints; // whether or not some fit points should be rejected
-  
+
   TString fParticle;
   TString fMinvRS; // minv spectra range and sigmaPsiP factor for the mpt fits
-  
+
   ClassDef(AliAnalysisMuMuJpsiResult,8) // a class to hold invariant mass analysis results (counts, yields, AccxEff, R_AB, etc...)
 };
 
diff --git a/PWG/muondep/AliAnalysisMuMuSpectra.cxx b/PWG/muondep/AliAnalysisMuMuSpectra.cxx
index 9211ec9..843f6bd 100644
--- a/PWG/muondep/AliAnalysisMuMuSpectra.cxx
+++ b/PWG/muondep/AliAnalysisMuMuSpectra.cxx
@@ -457,9 +457,12 @@ TH1* AliAnalysisMuMuSpectra::Plot(const char* what, const char* subresult, Bool_
       std::cout << b.AsString();
       r->PrintValue(swhat.Data(),"",y,yerr);
       
+      //__________Config. Histo
       h->SetBinContent(j+1,y);
       h->SetBinError(j+1,yerr);
       h->GetXaxis()->SetBinLabel(j+1,b.AsString().Data());
+      h->GetYaxis()->SetTitle(swhat.Data());
+      //__________
     }
   }
   
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
new file mode 100644
index 0000000..b5acd38
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.cxx
@@ -0,0 +1,201 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Mother class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsule)
+
+
+#include "AliLog.h"
+#include "TObject.h"
+#include <TString.h>
+#include <iostream>
+#include <string>
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "TObjArray.h"
+#include "TString.h"
+#include <fstream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsule::AliAnalysisMuMuSpectraCapsule() : TObject()
+{
+  /// Default ctor
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsule::~AliAnalysisMuMuSpectraCapsule()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(const char* file, Double_t* constantArray, const TString* spectraName)
+{
+  /**
+   *
+   * Set member constants depending on centrality bin from an ewternfile.
+   *
+   */
+
+    // Reset on fConstant
+    for (int i = 0; i < 13; ++i) constantArray[i]=0.;
+    Bool_t ok= kFALSE;
+    AliDebug(1,Form("Reading from file %s",file));
+
+    //________Open file
+    ifstream infile(file,std::ios::in);
+    TString line;
+    TObjArray* lineArray;
+
+    if (infile){
+        AliDebug(1, " ==== opening file ==== ");
+        // Loop until end of file is reached
+        while(infile.eof()!=kTRUE){
+
+            //read the line
+            line.ReadLine(infile,kFALSE);
+            if (line.BeginsWith("#"))continue;
+            AliDebug(1,Form(" Read line : %s",line.Data()));
+
+            // Put the line in a TObjArray
+            lineArray = line.Tokenize(" ");
+
+
+            // Select the good interval. Since interval is written in <binAsString>, just need them to match
+            TString centrality   =  static_cast<TObjString*>(lineArray->At(0))->String().Data();
+            TString intervalLow  =  TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(1))->String().Atof());
+            TString intervalHigh =  TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(2))->String().Atof());
+             AliDebug(1,Form(" --__--__-- interval low = %s",intervalLow.Data()));
+              AliDebug(1,Form(" --__--__-- interval high = %s",intervalHigh.Data()));
+            if (intervalLow.EqualTo("0.00")) intervalLow ="00.00";
+
+            // Select the good interval. Since interval is written in <binAsString>, just need them to match
+            if(spectraName->Contains(Form("%s",centrality.Data()))&& spectraName->Contains(Form("%s_%s",intervalLow.Data(),intervalHigh.Data())) && spectraName->Contains(Form("%s_%s",centrality.Data(),intervalLow.Data()))){
+                AliDebug(1,Form(" spectraName = %s",spectraName->Data()));
+                AliDebug(1,Form(" -- line selected -- "));
+                ok = kTRUE;
+                break;
+            }
+            else continue;
+        }
+        infile.close();
+        AliDebug(1, " ==== closing file ==== ");
+
+        // Store the value
+        for (int i =0 ; i<13 ; i++) {
+            constantArray[i]= static_cast<TObjString*>(lineArray->At(i+3))->String().Atof();
+        }
+        return ok;
+    }
+    else return ok;
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsule::PrintNofWhat(const char* what) const
+{
+  /// Print whar number for each results on terminal.
+
+
+  //Check point
+  if(!GetSpectra() || strcmp(what,"")==1 )
+    {
+      AliError("No Spectra or no arguments given !");
+      return ;
+    }
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+  // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  //Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    Int_t nofSubResult = 0; // Counter for subresult
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+
+    //Some variables
+    TString  binAsString(r->AsString());// Usefull for the coming loop
+
+    cout << Form(" -_-_-_-_- %s_%s -_-_-_-_- ",binAsString.Data(),GetSpectraName().Data()) << endl;
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+        AliError(Form("Cannot find subresult "));
+        return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      //Get quantities
+      Double_t NofJPsiSub      = subresult->GetValue(what);
+      Double_t NofJPsiErrorStat = subresult->GetErrorStat(what);
+
+      //Output messages
+      cout << Form(" -------- ") << endl;
+      cout << Form(" -- subresult %s :  %.0f +/- %.0f ",sr->GetName(),NofJPsiSub,NofJPsiErrorStat) << endl;
+      nofSubResult++;
+
+    }
+    cout << Form(" -------- ") << endl;
+    cout << Form(" ------ Mean :  %.0f +/- %.0f +/- %.0f ------ ",result->GetValue(what),result->GetErrorStat(what),result->GetRMS(what)) << endl;
+    cout << "" << endl;
+    nofResult++;
+  }
+}
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
new file mode 100644
index 0000000..89a039c
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsule.h
@@ -0,0 +1,67 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULE_H
+#define ALINANALYSISMUMUSPECTRACAPSULE_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsule : mother class to all capsule class.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include <TString.h>
+#include "TObject.h"
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectraCapsule : public TObject
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsule();
+  //dctor
+  virtual ~AliAnalysisMuMuSpectraCapsule();
+  // Compute Yield
+  virtual TGraphErrors* ComputeYield(const char* what, const TH1* histo, const char* sResName) = 0;
+  // Draw fit results and save them if wanted
+  virtual void DrawResults(const char* particle,const char* subresults)const = 0 ;
+  // Print some data members
+  virtual void Print(Option_t* opt) const = 0;
+  // Print constants used
+  virtual void PrintConst() const = 0;
+  // Number of "what" for all subresults
+  void PrintNofWhat(const char* what="") const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file, Double_t* constantArray, const TString* spectraName);
+
+  // Protection to be sure each daughter class returns data members
+  const virtual Double_t              * GetConstArray()   const =0;
+
+  const virtual AliAnalysisMuMuSpectra* GetSpectra()      const =0;
+
+  const virtual TString                 GetSpectraName() const  =0;
+
+  private:
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsule(const AliAnalysisMuMuSpectraCapsule& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsule& operator=(const AliAnalysisMuMuSpectraCapsule& rhs);// not implemented on purpose
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsule,1)
+/// \endcond;
+};
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx
new file mode 100644
index 0000000..2509fe9
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.cxx
@@ -0,0 +1,463 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePP.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePP)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePP.h"
+#include <fstream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+namespace
+{
+  const Double_t BR           = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME                     : Fnorm store in TH1, make in general
+  // const Double_t Fnorm        = 11.827;    // Normalization
+  // const Double_t FnormStat    = 0.011;     // Normalization
+  // const Double_t FnormSyst    = 0.01;     // Normalization
+  //luminosity
+  const Double_t lumi         = 104.35; // nb^-1
+  const Double_t lumiStat     = 1.52; // nb^-1
+  const Double_t lumiSys      = 5./100; // nb^-1
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError = 3./100;
+  // Corr. error for centrality
+  const Double_t Traj         = 1./100.;
+  const Double_t Trigg        = 1./100.;
+  const Double_t Pair         = 1./100.;
+  const Double_t Tails        = 2./100.;
+  // Corr. error for pt case
+  const Double_t TrajPT       = 1./100.;
+  const Double_t TriggPT      = 1./100.;
+  const Double_t PairPt       = 1./100.;
+  // Corr. error for y case
+  const Double_t TrajY        = 2./100.;
+  const Double_t TriggY       = 1./100.;
+  const Double_t PairY        = 1./100.;
+}
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePP::AliAnalysisMuMuSpectraCapsulePP(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+  for (int i = 0; i < 10; ++i) fConstArray[i]=0.;
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePP::~AliAnalysisMuMuSpectraCapsulePP() 
+{
+  // dtor
+}
+
+TList* AliAnalysisMuMuSpectraCapsulePP::ComputePPCrossSection(const char* what) const
+{
+  /// Compute the PP cross section
+
+
+  AliAnalysisMuMuBinning* binning = fSpectra->Binning();
+  TObjArray* bins = binning->CreateBinObjArray();
+  TIter nextBin(bins);
+  AliAnalysisMuMuBinning::Range* bin;
+  Int_t i(0);
+  AliAnalysisMuMuResult* r;
+
+  const Double_t * binArrayX = binning->CreateBinArrayX();
+  Int_t nBinX = binning->GetNBinsX();
+
+  TGraphErrors * gCrossSection = new TGraphErrors(nBinX);
+  TGraphErrors * gSys = new TGraphErrors(nBinX);
+  TString sbin;
+
+  int j= 1;
+  while ( ( bin = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin()) ) )
+  {
+      r = static_cast<AliAnalysisMuMuResult*>(fSpectra->GetResultForBin(bin->AsString()));
+      if(j==1 && bin->AsString().Contains("PT"))      sbin ="PT";
+      else if(j==1 && bin->AsString().Contains("Y"))  sbin ="Y";
+
+      if(sbin.Contains("PT") || sbin.Contains("Y")){ // PT and Y bin
+        Double_t sigma        =0.;
+        Double_t sigmaerror   =0.;
+        
+        Double_t CorrNofJPsi  =0.;
+        Double_t NofJPsi      =0.;
+        Double_t NofJPsiError =0.;
+        // Get Jpsi numbers
+        CorrNofJPsi  =r->GetValue(what);
+        NofJPsi      =r->GetValue("NofJPsi");
+        NofJPsiError =r->GetErrorStat("NofJPsi");
+
+        if(CorrNofJPsi==0. || NofJPsi ==0.){
+          printf(" cannot found Corrected NofJpsi or NofJpsi, did you compute AccEff ? Abording...");
+          continue;
+        }
+
+        sigma      = r->GetValue(what)/(lumi*BR*1000.*bin->WidthX());
+        sigmaerror = sigma*TMath::Sqrt(  
+          r->GetErrorStat("NofJPsi")*r->GetErrorStat("NofJPsi")/r->GetValue("NofJPsi")/r->GetValue("NofJPsi") 
+          //                                    Signal stat.
+        + lumiStat*lumiStat/lumi/lumi );
+          //                                    Lumi  stat.
+        
+         // Get X
+        Double_t xmin = bin->Xmin();
+        Double_t xmax = bin->Xmax();
+        Double_t x    = xmin + (xmax-xmin)/2;
+
+        // Uncorrelated
+        Double_t UncError =
+          (r->GetRMS("NofJPsi")/r->GetValue("NofJPsi"))*(r->GetRMS("NofJPsi")/r->GetValue("NofJPsi")) + TrajPT*TrajPT + TriggPT*TriggPT + PairPt*PairPt;
+        //          Signal                                                                                Tracking        Trigger           matching
+        
+        // Correlated
+        Double_t CorrError = lumiSys*lumiSys;
+        //                        lumi (%)  
+        
+        printf("  -------- cross section for bin %s = %f +/- %f (stat. %f %%) +/- %f (uncorr. %f %%) +/- %f (corr. %f %%)  -------- \n"
+          ,bin->AsString().Data(),sigma,sigmaerror,100*sigmaerror/sigma,sigma*TMath::Sqrt(UncError),100*TMath::Sqrt(UncError),TMath::Sqrt(CorrError),100*TMath::Sqrt(CorrError));
+
+        gCrossSection->SetPoint(j,x,sigma);
+        gCrossSection->SetPointError(j,bin->WidthX()/2,sigmaerror);
+
+        gSys->SetPoint(j,x,sigma);
+        gSys->SetPointError(j,bin->WidthX()/2,sigma*TMath::Sqrt(UncError));
+
+        j++;
+      } else { // Integrated
+
+         Double_t jpsi      = fSpectra->GetResultForBin("INTEGRATED")->GetValue("NofJPsi");
+         Double_t corrjpsi  = fSpectra->GetResultForBin("INTEGRATED")->GetValue(what);
+         
+         Double_t jpsisys   = fSpectra->GetResultForBin("INTEGRATED")->GetRMS("NofJPsi");
+         Double_t jpsistat  = fSpectra->GetResultForBin("INTEGRATED")->GetErrorStat("NofJPsi");
+         
+         Double_t sigma     = corrjpsi/(lumi*BR*1000.);
+         Double_t sigmastat = sigma*AliAnalysisMuMuResult::ErrorAB(jpsi,jpsistat,lumi,lumiStat);
+         //                                                           Signal          lumi
+         Double_t sigmasys2 = jpsisys/jpsi*jpsisys/jpsi  +Traj*Traj +    Pair*Pair +    Trigg*Trigg +   Tails*Tails + lumiSys*lumiSys ;
+         //                                               Tracking       Matching       Trigger          tails         lumi          
+
+          printf("integrated cross section for  %s = %f +/- %f +/- %f #mubarn\n",fSpectra->GetName(),sigma,sigmastat,sigma*TMath::Sqrt(sigmasys2) );
+          return 0x0;
+      }
+  }
+
+
+  //Add and merge all Graph
+  TList* l = new TList();
+  l->SetOwner(kTRUE);
+  l->Add(gCrossSection);
+  l->Add(gSys);
+
+  delete binArrayX;
+
+  return l ;  
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePP::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+
+ printf("Not implemented yet \n");
+ return 0x0;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePP::DrawResults( const char* particle,const char* subresults) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+  const TString sres(subresults);
+
+  //Pointer for functions
+    TF1* f1 = 0x0;
+    TF1* f2 = 0x0;
+    TF1* f3 = 0x0;
+    TF1* f4 = 0x0;
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+  if ( fSpectraName.Contains(particle))
+      {
+      xmin = 2;
+      xmax = 6;
+      }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      if(!sres.IsNull() && !sres.Contains(sr->GetName())) continue;
+
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) {histos->Add(h);}
+      else
+      {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 )
+      {
+      nx = 2;
+      ny=0;
+      }
+  else if ( nofResult > 2 )
+      {
+      ny = TMath::Nint(TMath::Sqrt(nofResult));
+      nx = TMath::Nint((nofResult/ny) +0.6);
+      }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny,0,0);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      gPad->SetLogy();
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->GetXaxis()->SetRangeUser(1.,5.);
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      f1 = h->GetFunction("signal");
+      if(f1) f1->DrawCopy("same");
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  delete bins;
+  delete histos;
+}
+
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePP::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePP::PrintConst() const
+{
+    ///
+    /// Print member constants on the terminal
+    ///
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else{
+      cout <<      " ================================================================ " << endl;
+      cout << Form("      Constants for Spectra %s",fSpectraName.Data()) << endl;
+      cout <<      " ================================================================ " << endl;
+      cout <<  "   Branching ratio = " <<  5.93/100 << endl; // 
+      //Normalization factor
+      //FIXME                                               : Fnorm store in TH1, make in general
+      // cout <<  "   FNorm                                    = " <<  Fnorm << endl;    // 
+      // cout <<  "   FNorm stat.                              = " <<  FnormStat << endl;     // Normalization
+      // cout <<  "   FNorm syst.                              = " <<  FnormSyst << endl;     // Normalization
+      
+      // Corr. error for pt case
+      cout <<  "  TrajPt. error                             = " <<  TrajPT << endl;
+      cout <<  "   TriggPt. error                           = " <<  TriggPT << endl;
+      cout <<  "    PairPt. error                           = " <<  PairPt << endl;
+      // Corr. error for y case
+      cout <<  "  TrajY. error                              = " <<  TrajY << endl;
+      cout <<  "   TriggY. error                            = " <<  TriggY << endl;
+      cout <<  "    PariY. error                            = " <<  PairY << endl;
+      
+      cout << Form(" -- Value of <Npart>                    = %f",fConstArray[0]) << endl;
+      cout << Form(" -- Value of d<Npart>                   = %f",fConstArray[1]) << endl;
+      cout << Form(" -- Value of TAA                        = %f",fConstArray[2]) << endl;
+      cout << Form(" -- Value of dTAA                       = %f",fConstArray[3]) << endl;
+      cout << Form(" -- Value of sys.AP                     = %f",fConstArray[4]) << endl;
+      cout << Form(" -- Value of Traj. err.                 = %f",fConstArray[5]) << endl;
+      cout << Form(" -- Value of Trigg. err.                = %f",fConstArray[6]) << endl;
+      cout << Form(" -- Value of Pair. err.                 = %f",fConstArray[7]) << endl;
+      cout << Form(" -- Value of AccEff                     = %f",fConstArray[8]) << endl;
+      cout << Form(" -- Value of dAccEff                    = %f",fConstArray[9]) << endl;
+      cout << Form(" -- Value of NofJpsi from exterfile     = %f",fConstArray[10]) << endl;
+      cout << Form(" -- Value of StatNofJpsi from exterfile = %f",fConstArray[11]) << endl;
+      cout << Form(" -- Value of SystNofJpsi from exterfile = %f",fConstArray[12]) << endl;
+  }
+}
+
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h
new file mode 100644
index 0000000..36cbf1a
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePP.h
@@ -0,0 +1,80 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPP_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPP_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbPb : helper class to deal with results stored in a spectra with PbPb methods.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePP : public AliAnalysisMuMuSpectraCapsule
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePP(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePP();
+  // Compute Yield
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Compute Cross-Section
+  TList* ComputePPCrossSection(const char* what ="CorrNofJPsi") const ;
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* particle="PSI",const char* subresults="")const;
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const AliAnalysisMuMuSpectra* GetSpectra()       const {return fSpectra;};
+  const TString                GetSpectraName()    const {return fSpectraName;};
+   const Double_t              * GetConstArray()     const {return fConstArray;};
+
+private:
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePP(const AliAnalysisMuMuSpectraCapsulePP& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePP& operator=(const AliAnalysisMuMuSpectraCapsulePP& rhs);// not implemented on purpose
+
+
+private:
+
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+  Double_t fConstArray[13]; // Array to store constant according to centrality bins
+
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePP,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
new file mode 100644
index 0000000..35ad557
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.cxx
@@ -0,0 +1,821 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePbP)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePbP.h"
+#include <iostream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+namespace
+{
+
+  const Double_t BR             = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME : Fnorm store in TH1, make in general
+  const Double_t Fnorm          = 27.51;    // Normalization
+  const Double_t FnormStat      = 0.01;     // Normalization
+  const Double_t FnormSyst      = 0.97;     // Normalization
+  //pp Cross-section integrated in pt,y
+  const Double_t sigmaPP        = 3.343;    // for fully integrated case
+  const Double_t dsigmaPP       = 0.033;    // idem
+  const Double_t dsigmaPPCorr   = 0.022;    // for fully integrated case
+  const Double_t dsigmaPPUncorr = 0.021;    // idem
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError   = 3/100;
+  // Corr. error for centrality
+  const Double_t TrajCENT       = 11/100;
+  const Double_t TriggCENT      = 2/100;
+  const Double_t PairCENT       = 1/100;
+  // Corr. error for pt case
+  const Double_t TrajPT         = 1/100;
+  const Double_t TriggPT        = 1/100;
+  const Double_t PairPt         = 1/100;
+  // Corr. error for y case
+  const Double_t TrajY          = 1/100;
+  const Double_t TriggY         = 1/100;
+  const Double_t PairY          = 1/100;
+}
+
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePbP::AliAnalysisMuMuSpectraCapsulePbP(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath,
+const char                  * externFile,
+const char                  * externFile2)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath),
+  fExternFile(externFile),
+  fExternFile2(externFile2)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+
+  if(!AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(fExternFile2,&fConstArray[0],&fSpectraName))
+  {
+    AliWarning(Form("No extern file readed"));
+  }
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePbP::~AliAnalysisMuMuSpectraCapsulePbP()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePbP::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+
+  if(!GetSpectra() || histo==0x0|| strcmp(what,"")==1) return 0x0;
+
+  // Some constants
+  const TString graphTitle = Form("%s-YIELD",GetSpectraName().Data());
+  TString sres(sResName);
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  // TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (GetSpectraName().Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    // graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (GetSpectraName().Contains("-PT")|| GetSpectraName().Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    // graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Store quantities
+    Double_t NofWhattTot = result->GetValue(what,sres.Data());
+    Double_t NofWhattTotError = result->GetErrorStat(what,sres.Data());
+
+    Double_t nEqMBTot      = histo->GetBinContent(nofResult+1);
+    Double_t nEqMBTotError = histo->GetBinError(nofResult+1);
+
+    AliDebug(1,Form("histo used    : %s",histo->GetTitle()));
+    AliDebug(1,Form("%s            = %f",what,NofWhattTot));
+    AliDebug(1,Form("%s error      = %f",what,NofWhattTotError));
+    AliDebug(1,Form("nEqMBTot      = %f",nEqMBTot));
+    AliDebug(1,Form("nEqMBTotError = %f",nEqMBTotError));
+
+    if( NofWhattTot==0||NofWhattTotError==0||nEqMBTot==0||nEqMBTotError==0)
+    {
+      AliError("Cannot set quantities properly");
+      return 0x0;
+    }
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(GetSpectraName().Contains("-INTEGRATED"))
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],yieldInt);
+      graph->SetPointError(nofResult,fConstArray[1],yieldIntError);
+      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult];
+      graph->SetPoint(nofResult,binCenter,yieldInt);
+      graph->SetPointError(nofResult,r->WidthX()/5,yieldInt);
+      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(GetSpectraName().Contains("-INTEGRATED"))graph->GetXaxis()->SetTitle(Form("INTEGRATED"));
+  else if (GetSpectraName().Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (GetSpectraName().Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("Yield");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+ return graph ;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::DrawResults( const char* particle,const char* subresults) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+
+  //Pointer for functions
+    TF1* f1 = 0x0;
+    TF1* f2 = 0x0;
+    TF1* f3 = 0x0;
+    TF1* f4 = 0x0;
+
+    const TString sres(subresults);
+
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+  if ( fSpectraName.Contains(particle))
+      {
+      xmin = 2;
+      xmax = 6;
+      }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult)
+      {
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+
+      if(!sres.IsNull() && !sres.Contains(sr->GetName())) continue;
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) {histos->Add(h);}
+      else
+      {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 )
+      {
+      nx = 2;
+      ny=0;
+      }
+  else if ( nofResult > 2 )
+      {
+      ny = TMath::Nint(TMath::Sqrt(nofResult));
+      nx = TMath::Nint((nofResult/ny) +0.6);
+      }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  delete bins;
+  delete histos;
+}
+
+
+//_____________________________________________________________________________
+TGraphErrors * AliAnalysisMuMuSpectraCapsulePbP::RpAAsGraphic(Double_t MUL) const
+{
+  /**
+   *
+   * Run over each bin, calculate R_pA according to fBinType throught GetValuesFromExternFiles() :
+   * Return a graph to be deleted by owner.
+   *
+   */
+
+  // Some constants
+  const TString histoName = Form("%s",fSpectraName.Data());
+
+  //Check point
+  if(!GetSpectra() || fExternFile.IsNull() ) return 0x0 ;
+
+  //Check point
+  if (MUL==0)
+  {
+    AliError(Form("NofMUL is null"));
+    return 0x0;
+  }
+
+  AliError("To be implemented !");
+  return 0x0;
+
+
+ //  // Pointers to handle results and subresults and binning
+ //  AliAnalysisMuMuResult    * result;
+ //  AliAnalysisMuMuBinning   ::Range* r;
+
+ // // Array to store bins for the while loop
+ //  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+ //  if (!bins)
+ //  {
+ //    AliError(Form("Cannot find bins"));
+ //    return 0x0;
+ //  }
+ //  // Array for listed quantities
+ //  Double_t num[8]={0.};
+ //  //  num[0]   ,  num[1]   ,   num[2]   ,   num[3]  ,  num[4] ,  num[5]  ,   num[6]   ,   num[7]
+ //  //  NofJpsi     JPsiStat     JPsiSyst     NormTot    RAA       StatErr     SystCorrErr  SystUnCorrErr
+ //  // --------------------------
+
+ //  // Here we define some pointers
+ //  TGraphErrors*graph(0x0);
+ //  // TGraphErrors*graph_sysUncorr(0x0);
+
+ //  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+ //  Int_t binsX = 0;
+
+ //  //________Define histo according to bin type
+ //  if (fSpectraName.Contains("-INTEGRATED"))
+ //  {
+ //    graph           = new TGraphErrors(1);
+ //    // graph_sysUncorr = new TGraphErrors(1);
+ //    graph->SetTitle(histoName.Data());
+ //    graph->SetMinimum(0.);
+ //    graph->SetMaximum(1.2);
+ //    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+ //  }
+ //  else if (fSpectraName.Contains("-PT")|| fSpectraName.Contains("-Y"))
+ //  {
+ //    binArray =GetSpectra()->Binning()->CreateBinArray();
+ //    binsX    = GetSpectra()->Binning()->GetNBinsX();
+
+ //    if (!binArray)
+ //    {
+ //      AliError(Form("Cannot set binArray"));
+ //      return 0x0;
+ //    }
+ //    if (binsX==0)
+ //    {
+ //      AliError(Form("Cannot set binsX"));
+ //      return 0x0;
+ //    }
+
+ //    graph           = new TGraphErrors(binsX);
+ //    // graph_sysUncorr = new TGraphErrors(binsX);
+ //    graph->SetTitle(histoName.Data());
+ //    graph->SetMinimum(0.);
+ //    graph->SetMaximum(1.2);
+ //    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+ //  }
+ //  else
+ //  {
+ //    cout << "Unknowned Bin type !" << endl;
+ //    return 0x0;
+ //  }
+ //  //________
+
+ //  //________Counters and Iterator for bin
+ //  Int_t nofResult = 0;
+ //  TIter nextBin(bins);
+ //  nextBin.Reset();
+ //  //________
+
+ //  // Loop on bins
+ //  //==============================================================================
+ //  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+ //  {
+ //    //________Make bin a MuMuResult
+ //    result = GetSpectra()->GetResultForBin(*r);
+ //    if (!result)
+ //    {
+ //      AliError(Form("Cannot find result "));
+ //      return 0x0;
+ //    }
+ //    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+ //    //________
+
+ //    // Get a string with bin name
+ //    TString binAsString = r->AsString();
+
+ //    // Store quantities
+ //    num[0] = result->GetValue("NofJPsi");
+ //    num[1] = result->GetErrorStat("NofJPsi");
+ //    num[2] = result->GetRMS("NofJPsi");
+
+ //    GetValuesFromExternFile(binAsString,&num[0],MUL);
+
+ //    //________Compute R_AA in case of fully integrated spectra
+ //    if(fSpectraName.Contains("-INTEGRATED"))
+ //    {
+ //      //Output messages
+ //      cout << Form("") << endl;
+ //      cout << Form("  |    %s    |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+
+ //      // Add results to TGraphs
+ //      graph->SetPoint(nofResult,fConstArray[0],num[4]);
+ //      graph->SetPointError(nofResult,fConstArray[1],num[5]);
+ //      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+ //      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+ //    }
+ //    else
+ //    {
+ //      num[4]=num[4]/(r->WidthX());
+ //      cout << Form("") << endl;
+ //      cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.0f   %.0f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+ //      //Fill graph
+ //      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult] ;
+ //      graph->SetPoint(nofResult,binCenter,num[4]);
+ //      graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+ //      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+ //      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+ //    }
+ //    //________
+
+ //    nofResult++;
+ //  }
+
+ //  // Config. graphics
+ //  if(fSpectraName.Contains("INTEGRATED"))graph->GetXaxis()->SetTitle(Form("<NPart>"));
+ //  else if (fSpectraName.Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+ //  else if (fSpectraName.Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+ //  graph->GetYaxis()->SetTitle("R_{pA}");
+ //  graph->SetMarkerColor(4);
+ //  graph->SetMarkerStyle(21);
+
+ //  // delete graph;
+ //  // delete graph_sysUncorr;
+ //  delete bins;
+ //  delete binArray;
+
+ // return graph ;
+}
+
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::GetValuesFromExternFile(TString sbin, Double_t numArray[], Double_t MUL) const
+{
+  /**
+   *
+   * Checks bin type and read files (or not) accordingly. Then computes and stores several results in numArray.
+   *
+   */
+
+  AliWarning("INNER NORMALIZATION FACTOR, YOU MIGHT CHECK THE CODE !!");
+
+  AliError("To be implemented !");
+  return;
+
+  // //________PT and Y case
+  // if (fSpectraName.Contains("-PT") || fSpectraName.Contains("-Y"))
+  // {
+  //   char status;
+
+  //    //________Arrays to store quantities from externFile
+  //   float intervalArray[2];
+  //   // intervalLow , intervalHight
+  //   //      0      ,      1
+  //   float valueArray[10];
+  //   //    sigmapp   dsigmapp   dsigmappCorr   dsigmappUncorr  AccEff   dAccEff  sysMC   TrajEffError  TriggerError   PairError
+  //   //________
+
+  //   //________Open file
+  //   FILE*  infile;
+  //   infile = fopen(fExternFile.Data(),"rb") ;
+
+  //   if (infile != NULL)
+  //   {
+  //     AliDebug(1, " ==== opening file ==== ");
+  //     // Loop until end of file is reached
+  //     while(!feof(infile))
+  //     {
+  //       // Reminder :
+  //       // intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff sysMC TrajEffError  TriggerError   PairError;
+  //       // Store value in array
+  //       fscanf(infile,"%s %f_%f %f %f %f %f %f %f %f %f %f %f",&status,&intervalArray[0],&intervalArray[1],
+  //                                                  &valueArray[0],&valueArray[1],&valueArray[2],&valueArray[3],&valueArray[4],
+  //                                                  &valueArray[5],&valueArray[6],&valueArray[7],&valueArray[8],&valueArray[9]);
+  //       if(status == 'F') continue; // F = false, T =true
+  //       // Make intervalArray a string
+  //       TString intervalLow  = TString::Format("%.2f",intervalArray[0]);
+  //       TString intervalHigh = TString::Format("%.2f",intervalArray[1]);
+
+  //       // Select the good interval. Since interval is written in <binAsString>, just need them to match
+  //       if(sbin.Contains(Form("%s",intervalLow.Data())) && sbin.Contains(Form("%s",intervalHigh.Data())))
+  //       {
+  //         // Check Point
+  //         AliDebug(1,Form(" -- Selected line :"));
+  //         AliDebug(1,Form(" -- intervalLow  intervalHight  sigma_pp  dsigma_pp  dsigma_pp_Correl  dsigma_pp_Uncorrel  AccEff  dAccEff  sysMC TrajEffError  TriggerError   PairError"));
+  //         AliDebug(1,Form(" --  %.2f  %.2f  %f  %f  %f  %f  %f  %f  %f  %f  %f  %f ",
+  //         intervalArray[0],intervalArray[1],valueArray[0],valueArray[1],valueArray[2],valueArray[3],valueArray[4],valueArray[5],valueArray[6],valueArray[7],valueArray[8],valueArray[9]));
+
+  //         //Normalization according to centrality bin
+  //         if (fSpectraName.Contains("V0M_00.00_90.00"))
+  //         {
+  //           numArray[3] = fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+  //         }
+  //         else
+  //         {
+  //           numArray[3] = (1./9.)*fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+  //         }
+
+  //         numArray[4] = numArray[0]/numArray[3];
+
+  //       }
+  //       else
+  //       {
+  //         AliDebug(1,Form("Not the good interval, so continue ...."));
+  //         continue;
+  //       }
+  //     }
+  //     fclose(infile);
+  //     AliDebug(1, " ==== Closing file ==== ");
+  //   }
+  //   else
+  //   {
+  //     cout << Form("Cannot open configuration file %s ",fExternFile.Data()) << endl;
+  //     return;
+  //   }
+  //   //________
+
+  //   if (fSpectraName.Contains("-PT") )
+  //   {
+  //     // Normalization factor due to how PP cross-section are calculated
+  //     numArray[4] = numArray[4]/1.5;
+
+  //     //Corr
+  //     numArray[6] = numArray[4] * TMath::Sqrt(TrajPT                       *TrajPT                       + // Traj. reconstruction Eff.
+  //                                             TriggPT                      *TriggPT                      + // Trigg Eff.
+  //                                             FnormSyst/Fnorm              *FnormSyst/Fnorm              + // Fnorm Syst
+  //                                             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2]+ // TAA syst.
+  //                                             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);  // dsigma_pp_Corr/sigma_pp
+
+
+  //   }
+  //   else if (fSpectraName.Contains("-Y"))
+  //   {
+  //     //Corr
+  //     numArray[6] = numArray[4] * TMath::Sqrt(TrajY                        *TrajY                         + // Traj. reconstruction Eff.
+  //                                             TriggY                       *TriggY                        + // Trigg Eff.
+  //                                             FnormSyst/Fnorm              *FnormSyst/Fnorm               + // Fnorm Syst
+  //                                             fConstArray[3]/fConstArray[2]*fConstArray[3]/fConstArray[2] + // TAA syst.
+  //                                             valueArray[2]/valueArray[0]  *valueArray[2]/valueArray[0]);   // dsigma_pp_Corr/sigma_pp
+
+  //   }
+  //   else
+  //   {
+  //     AliError("Unowned bin type... I Told you !");
+  //     return;
+  //   }
+
+  //   //Stat
+  //   numArray[5] = numArray[4] * TMath::Sqrt(numArray[1]/numArray[0]    *numArray[1]/numArray[0]     + // Jpsi extraction
+  //                                           valueArray[1]/valueArray[0]*valueArray[1]/valueArray[0] ); // dsigma_pp/sigma_pp
+
+  //   //UnCorr
+  //   numArray[7] = numArray[4] * TMath::Sqrt(valueArray[6]             *valueArray[6]                   + // MC param.
+  //                                           numArray[2]/numArray[0]   *numArray[2]/numArray[0]         + // Signal extraction
+  //                                           valueArray[7]             *valueArray[7]                   + // Traj. Eff.
+  //                                           valueArray[8]             *valueArray[8]                   + // Trigg. Eff.
+  //                                           valueArray[9]             *valueArray[9]                   + // Pair. Eff.
+  //                                           valueArray[3]/valueArray[0]*valueArray[3]/valueArray[0]);     // dsigma_pp_Uncorr/sigma_pp
+  // }
+
+  // //________Compute R_AA in case of integrated spectra in PT and Y
+  // else if(fSpectraName.Contains("-INTEGRATED"))
+  // {
+  //   //Get quantities
+
+  //   //Normalization according to centrality bin
+  //   if (!fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = BR*fConstArray[2]*(Fnorm*MUL/9)*(sigmaPP/1000)*(fConstArray[8]);
+  //   else                                           numArray[3] = BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+  //   numArray[4] = numArray[0]/numArray[3];
+
+  //   //Stat error
+  //   numArray[5] = numArray[4] * TMath::Sqrt((numArray[1]/numArray[0])*(numArray[1]/numArray[0]) + // Jpsi extraction
+  //                                                    dsigmaPP/sigmaPP*dsigmaPP/sigmaPP          ); // dsigma_pp/sigma_pp
+  //   //Corr error
+  //   numArray[6] = numArray[4] * TMath::Sqrt(MCParamError        *MCParamError         + // MCParamError
+  //                                           fConstArray[4]      *fConstArray[4]       + // Traj. reconstruction Eff.
+  //                                           fConstArray[5]      *fConstArray[5]       + // Trig. Eff.
+  //                                           fConstArray[6]      *fConstArray[6]       + // Pair Reconst. Eff.
+  //                                           dsigmaPPCorr/sigmaPP*dsigmaPPCorr/sigmaPP + // dsigma_pp_Corr/sigma_pp
+  //                                           FnormSyst/Fnorm     *FnormSyst/Fnorm);      // Fnorm Syst
+  //   //Uncorr error
+  //   numArray[7] = numArray[4] * TMath::Sqrt(numArray[2]/numArray[0]      *numArray[2]/numArray[0]      + // Signal extraction
+  //                                           fConstArray[1]/fConstArray[0]*fConstArray[1]/fConstArray[0]);// TAA syst.
+  // }
+  // else
+  // {
+  //   AliError("Unowned bin type... I Told you !");
+  //   return;
+  // }
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbP::PrintConst() const
+{
+  /**
+   *
+   * Print member constants
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else
+  {
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" Constants for Spectra %s",fSpectraName.Data()) << endl;
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" -- Value of <Npart>                    = %f",fConstArray[0]) << endl;
+    cout << Form(" -- Value of d<Npart>                   = %f",fConstArray[1]) << endl;
+    cout << Form(" -- Value of TAA                        = %f",fConstArray[2]) << endl;
+    cout << Form(" -- Value of dTAA                       = %f",fConstArray[3]) << endl;
+    cout << Form(" -- Value of sys.AP                     = %f",fConstArray[4]) << endl;
+    cout << Form(" -- Value of Traj. err.                 = %f",fConstArray[5]) << endl;
+    cout << Form(" -- Value of Trigg. err.                = %f",fConstArray[6]) << endl;
+    cout << Form(" -- Value of Pair. err.                 = %f",fConstArray[7]) << endl;
+    cout << Form(" -- Value of AccEff                     = %f",fConstArray[8]) << endl;
+    cout << Form(" -- Value of dAccEff                    = %f",fConstArray[9]) << endl;
+    cout << Form(" -- Value of NofJpsi from exterfile     = %f",fConstArray[10]) << endl;
+    cout << Form(" -- Value of StatNofJpsi from exterfile = %f",fConstArray[11]) << endl;
+    cout << Form(" -- Value of SystNofJpsi from exterfile = %f",fConstArray[12]) << endl;
+  }
+}
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
new file mode 100644
index 0000000..fa5a8a8
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbP.h
@@ -0,0 +1,87 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPBP_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPBP_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbP : helper class to deal with results stored in a spectra with pPb methods.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePbP : public AliAnalysisMuMuSpectraCapsule
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePbP(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="",
+                             const char                              * externFile="",
+                             const char                              * externFile2="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePbP();
+  // Compute Yield
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* particle="PSI",const char* subresults="")const;
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+  // Compute R_pA
+  TGraphErrors* RpAAsGraphic(Double_t MUL) const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const Double_t              * GetConstArray() const {return fConstArray;};
+  const AliAnalysisMuMuSpectra* GetSpectra()    const {return fSpectra;};
+  const TString                GetSpectraName() const {return fSpectraName;};
+
+private:
+  // Read and compute values from extern file
+  void GetValuesFromExternFile(TString sbin, Double_t numArray[],Double_t MUL) const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file);
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePbP(const AliAnalysisMuMuSpectraCapsulePbP& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePbP& operator=(const AliAnalysisMuMuSpectraCapsulePbP& rhs);// not implemented on purpose
+
+
+private:
+  TString fExternFile;      // name of spectra selected
+  TString fExternFile2;     // name of spectra selected
+  Double_t fConstArray[13]; // Array to store constant according to centrality bins
+
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePbP,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
new file mode 100644
index 0000000..4b3e3c0
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.cxx
@@ -0,0 +1,843 @@
+/**************************************************************************
+ * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ *                                                                        *
+ * Author: The ALICE Off-line Project.                                    *
+ * Contributors are mentioned in the code where appropriate.              *
+ *                                                                        *
+ * Permission to use, copy, modify and distribute this software and its   *
+ * documentation strictly for non-commercial purposes is hereby granted   *
+ * without fee, provided that the above copyright notice appears in all   *
+ * copies and that both the copyright notice and this permission notice   *
+ * appear in the supporting documentation. The authors make no claims     *
+ * about the suitability of this software for any purpose. It is          *
+ * provided "as is" without express or implied warranty.                  *
+ **************************************************************************/
+
+///
+/// Class to deal with Spectra after the fitting procedure.
+///
+/// author: Benjamin Audurier (Subatech)
+///
+
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+
+ClassImp(AliAnalysisMuMuSpectraCapsulePbPb)
+
+#include "TF1.h"
+#include "TProfile.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TGraph.h"
+#include "TGraph2D.h"
+#include "TGraphErrors.h"
+#include "THashList.h"
+#include "TLegend.h"
+#include "TLine.h"
+#include "TList.h"
+#include "TMath.h"
+#include "TObjArray.h"
+#include "AliAnalysisMuMuBinning.h"
+#include "AliLog.h"
+#include "TCanvas.h"
+#include "TStyle.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliAnalysisMuMuResult.h"
+#include "AliAnalysisMuMuJpsiResult.h"
+#include "AliAnalysisMuMuSpectraCapsulePbPb.h"
+#include <fstream>
+#include <string>
+
+using std::cout;
+using std::endl;
+using std::ifstream;
+
+
+namespace
+{
+  const Double_t BR             = 5.93/100; // Branching ratio
+  //Normalization factor
+  //FIXME : Fnorm store in TH1, make in general
+  const Double_t Fnorm          = 11.842;    // Normalization
+  const Double_t FnormStat      = 0.00095;     // Normalization
+  const Double_t FnormSyst      = 0.059;     // Normalization
+  //pp Cross-section integrated in pt,y
+  // const Double_t sigmaPP         = 5.958055;    // for fully integrated case
+  // const Double_t dsigmaPP        = 0.125539;    // idem
+  // const Double_t dsigmaPPCorr    = 0.340055;    // for fully integrated case
+
+  //pp Cross-section integrated in pt>0.3,y
+  const Double_t sigmaPP        = 5.990677;    // for fully integrated case
+  const Double_t dsigmaPP       = 0.166477;    // idem
+  const Double_t dsigmaPPCorr   = 0.342589;    // for fully integrated case
+  
+  // Global MC sys. err. for centrality integrated in pt and Y
+  const Double_t MCParamError   = 1.6;//%
+  // Corr. error for pt case
+  const Double_t TrajPT         = 4.;//%
+  const Double_t TriggPT        = 2.;//%
+  const Double_t PairPt         = 1.;//%
+  // Corr. error for y case
+  const Double_t TrajY          = 4.;//%
+  const Double_t TriggY         = 2.;//%
+  const Double_t PairY          = 1.;//%
+  
+  // NofMUL correspondind to signal extraction from 2015
+  const Double_t Mul2015        = 126148800;
+  // Syst. associated to tails param
+  const Double_t tailsErro      = 2.;//%
+  // Syst. associated to pairing
+  const Double_t pairError      = 2.;//%
+
+  
+}
+
+
+//_____________________________________________________________________________
+ AliAnalysisMuMuSpectraCapsulePbPb::AliAnalysisMuMuSpectraCapsulePbPb(
+const AliAnalysisMuMuSpectra*  spectra,
+const TString                 spectraPath,
+const char                  * externFile,
+const char                  * externFile2)
+:
+  AliAnalysisMuMuSpectraCapsule(),
+  fSpectra(spectra),
+  fSpectraName(spectraPath),
+  fExternFile(externFile),
+  fExternFile2(externFile2)
+{
+  //Check point
+  if (!fSpectra)
+  {
+    AliError(Form("Cannot find spectra wih name %s Please check the name",fSpectra->GetName()));
+    return;
+  }
+  AliDebug(1, Form(" - spectra(%s) = %p ",fSpectra->GetName(),fSpectra));
+
+
+  if (fSpectraName.IsNull())
+  {
+    AliWarning(Form("No spectra name ! "));
+    return;
+  }
+
+  if(!AliAnalysisMuMuSpectraCapsule::SetConstantFromExternFile(fExternFile2,&fConstArray[0],&fSpectraName))
+  {
+    AliWarning(Form("No extern file readed"));
+  }
+
+}
+
+//_____________________________________________________________________________
+AliAnalysisMuMuSpectraCapsulePbPb::~AliAnalysisMuMuSpectraCapsulePbPb()
+{
+  // dtor
+}
+
+//_____________________________________________________________________________
+TGraphErrors* AliAnalysisMuMuSpectraCapsulePbPb::ComputeYield( const char* what, const TH1* histo, const char* sResName)
+{
+  /// Compute Yield.
+  /// Arguments :
+  ///   - what : the yield nominator, i.e NofJPsi, meanPT etc. (null by default)
+  ///   - histo : histogramme of Equivalent MinBias
+
+  if(!GetSpectra() || histo==0x0|| strcmp(what,"")==1) return 0x0;
+
+  // Some constants
+  const TString graphTitle = Form("%s-YIELD",GetSpectraName().Data());
+  TString sres(sResName);
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  // TGraphErrors*graph_sysUncorr(0x0);
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (GetSpectraName().Contains("-INTEGRATED"))
+  {
+    graph           = new TGraphErrors(1);
+    // graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else if (GetSpectraName().Contains("-PT")|| GetSpectraName().Contains("-Y"))
+  {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray)
+    {
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0)
+    {
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+
+    graph           = new TGraphErrors(binsX);
+    // graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(graphTitle.Data());
+
+    // graph_sysUncorr->SetFillColorAlpha(5,0.05);
+  }
+  else
+  {
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Store quantities
+    Double_t NofWhattTot = result->GetValue(what,sres.Data());
+    Double_t NofWhattTotError = result->GetErrorStat(what,sres.Data());
+
+    Double_t nEqMBTot      = histo->GetBinContent(nofResult+1);
+    Double_t nEqMBTotError = histo->GetBinError(nofResult+1);
+
+    AliDebug(1,Form("histo used    : %s",histo->GetTitle()));
+    AliDebug(1,Form("%s            = %f",what,NofWhattTot));
+    AliDebug(1,Form("%s error      = %f",what,NofWhattTotError));
+    AliDebug(1,Form("nEqMBTot      = %f",nEqMBTot));
+    AliDebug(1,Form("nEqMBTotError = %f",nEqMBTotError));
+
+    if( NofWhattTot==0||NofWhattTotError==0||nEqMBTot==0||nEqMBTotError==0)
+    {
+      AliError("Cannot set quantities properly");
+      return 0x0;
+    }
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(GetSpectraName().Contains("-INTEGRATED"))
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],yieldInt);
+      graph->SetPointError(nofResult,fConstArray[1],yieldIntError);
+      // graph_sysUncorr->SetPoint(nofResult,0,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else
+    {
+      Double_t yieldInt = NofWhattTot/(nEqMBTot*BR);
+      Double_t yieldIntError = yieldInt*AliAnalysisMuMuResult::ErrorAB(NofWhattTot,NofWhattTotError,nEqMBTot,TMath::Sqrt(nEqMBTot));
+
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult];
+      graph->SetPoint(nofResult,binCenter,yieldInt);
+      graph->SetPointError(nofResult,r->WidthX()/5,yieldInt);
+      // graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      // graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(GetSpectraName().Contains("-INTEGRATED"))graph->GetXaxis()->SetTitle(Form("INTEGRATED"));
+  else if (GetSpectraName().Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (GetSpectraName().Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("Yield");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  // delete graph;
+  // delete graph_sysUncorr;
+  delete bins;
+  delete binArray;
+
+ return graph ;
+
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::DrawResults( const char* particle,const char* subresults) const
+{
+  /**
+   *
+   * Print fit results on a single canvas
+   *
+   */
+
+  //Check point
+  if(!GetSpectra() ) return ;
+
+  // Pointers to handle results and subresults
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuJpsiResult* subresult;
+  AliAnalysisMuMuResult    * sr;
+  AliAnalysisMuMuBinning   ::Range* r;
+  TH1 * h = 0x0;
+
+  const TString sres(subresults);
+
+  //Pointer for functions
+  TF1* f1 = 0x0;
+  TF1* f2 = 0x0;
+  TF1* f3 = 0x0;
+  TF1* f4 = 0x0;
+
+  // Arrays
+  TObjArray* histos = new TObjArray(0x0);// Array to store histograms
+  TObjArray* bins=GetSpectra()->Binning()->CreateBinObjArray();// Array to store bins
+
+  if (!bins){
+    AliError(Form("Cannot find bins"));
+    return;
+  }
+
+  // Settings for histo
+  Double_t xmin(-1);
+  Double_t xmax(-1);
+
+  if ( fSpectraName.Contains(particle)){
+    xmin = 2;
+    xmax = 6;
+  }
+
+  //Iterator for bin
+  TIter nextBin(bins);
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    // Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result)
+    {
+      AliError(Form("Cannot find result "));
+      return;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+
+    TIter nextSubResult(result->SubResults());// Iterator for subresults
+    nextSubResult.Reset();
+    // Loop on subresults
+    //==============================================================================
+    while ((sr = static_cast<AliAnalysisMuMuResult*>(nextSubResult())))
+    {
+      // Get our final result
+      subresult = static_cast<AliAnalysisMuMuJpsiResult*>(result->SubResult(Form("%s",sr->GetName())));
+      if (!subresult){
+      AliError(Form("Cannot find subresult "));
+      return;
+      }
+      AliDebug(1,Form("subresult(%s) = %p",sr->GetName(),subresult));
+      if(!sres.IsNull() && !sres.Contains(sr->GetName())) continue;
+
+      // Get histo
+      if ( subresult ) h = (TH1*)subresult->Histo();
+      AliDebug(1, Form(" - Histo(%s) = %p ",h->GetTitle(),h));
+
+      // Store it
+      if(h) histos->Add(h);
+      else {
+        AliError(Form("Cannot set histo result "));
+        return;
+      }
+    }
+  }
+  //Configure canvas
+  Int_t nx(1);
+  Int_t ny(1);
+  Int_t nofResult = histos->GetEntries(); // # of histo
+  if ( nofResult == 2 ){
+    nx = 2;
+    ny=0;
+  }
+  else if ( nofResult > 2 ){
+    ny = TMath::Nint(TMath::Sqrt(nofResult));
+    nx = TMath::Nint((nofResult/ny) +0.6);
+  }
+  TCanvas *c = new TCanvas;
+  c->Draw();
+  c->Divide(nx,ny,0,0);
+  c->SetTitle(Form("%s",fSpectraName.Data()));
+  gStyle->SetOptFit(1112);
+  AliDebug(1, Form(" Canvas divided in %dx%d",nx,ny));
+
+  //Iterator on histos + counter
+  TIter nextHisto(histos);
+  TH1 * h2;
+  Int_t n=0;
+  // Loop on Pad
+  while ((h2 = static_cast<TH1*>(nextHisto())))
+  {
+    AliDebug(1,Form(" - subcanvas = %d",n));
+    h = static_cast<TH1*>(histos->At(n));
+    if (h)
+    {
+      ++n;
+      c->cd(n);// got to pad
+      gPad->SetLogy();
+      if (xmin>0)
+        {
+          // Loop to configure the pad as you like
+          h->GetXaxis()->SetRangeUser(xmin,xmax);
+          h->SetTitleSize(10);
+        }
+      h->GetXaxis()->SetRangeUser(1.,5.);
+      h->DrawCopy("histes");
+
+      //Get fitting functions and draw them
+      f1 = h->GetFunction("signal+bck");
+      f2 = h->GetFunction("signalJPsi");
+      f3 = h->GetFunction("signalPsiP");
+      f4 = h->GetFunction("bck");
+      if(f1) f1->DrawCopy("same");
+      if(f2) f2->DrawCopy("same");
+      if(f3) f3->DrawCopy("same");
+      if(f4)
+          {
+            f4->SetLineColor(kBlue);
+            f4->SetLineStyle(16);
+            f4->DrawCopy("same");
+          }
+      f1 = h->GetFunction("signal");
+      if(f1) f1->DrawCopy("same");
+      gPad->Modified();
+      gPad->Update();
+    }
+    else
+    {
+      AliError(Form("Cannot find histogram stored at %d ",n));
+      continue;
+    }
+  }
+  delete bins;
+  delete histos;
+}
+
+
+//_____________________________________________________________________________
+TList * AliAnalysisMuMuSpectraCapsulePbPb::RAAasGraphic(Double_t MUL) const
+{
+  /**
+   *
+   * Run over each bin, calculate RAA according to fBinType throught GetValuesFromExternFiles() :
+   * Return a graph to be deleted by owner.
+   *
+   */
+
+  // Some constants
+  const TString histoName = Form("%s",fSpectraName.Data());
+
+  //Check point
+  if(!GetSpectra() || fExternFile.IsNull() ) return 0x0 ;
+
+  //Check point
+  if (MUL==0)
+  {
+    AliError(Form("NofMUL is null"));
+    return 0x0;
+  }
+
+  // Pointers to handle results and subresults and binning
+  AliAnalysisMuMuResult    * result;
+  AliAnalysisMuMuBinning   ::Range* r;
+
+ // Array to store bins for the while loop
+  TObjArray * bins=GetSpectra()->Binning()->CreateBinObjArray();// (intrinseque 'new')
+  if (!bins)
+  {
+    AliError(Form("Cannot find bins"));
+    return 0x0;
+  }
+  // Array for listed quantities
+  Double_t num[8]={0.};
+  //  num[0]   ,  num[1]   ,   num[2]   ,   num[3]  ,  num[4] ,  num[5]  ,   num[6]   ,   num[7]
+  //  NofJpsi     JPsiStat     JPsiSyst     NormTot    RAA       StatErr     SystCorrErr  SystUnCorrErr
+  // --------------------------
+
+  // Here we define some pointers
+  TGraphErrors*graph(0x0);
+  TGraphErrors*graph_sysUncorr(0x0);
+  
+  // One graph with one point for all the bins
+  TGraphErrors*graph_syscorr(0x0);
+  graph_syscorr = new TGraphErrors(1);
+
+
+  Double_t    * binArray(0x0) ;// (intrinseque 'new')
+  Int_t binsX = 0;
+
+  //________Define histo according to bin type
+  if (fSpectraName.Contains("-INTEGRATED")){
+    graph           = new TGraphErrors(1);
+    graph_sysUncorr = new TGraphErrors(1);
+    graph->SetTitle(histoName.Data());
+    graph_sysUncorr->SetFillColorAlpha(5,0.05);
+    graph_syscorr->SetFillColorAlpha(6,0.05);
+  } 
+  else if (fSpectraName.Contains("-PT")|| fSpectraName.Contains("-Y")) {
+    binArray =GetSpectra()->Binning()->CreateBinArray();
+    binsX    = GetSpectra()->Binning()->GetNBinsX();
+
+    if (!binArray){// Protection
+      AliError(Form("Cannot set binArray"));
+      return 0x0;
+    }
+    if (binsX==0){// Protection
+      AliError(Form("Cannot set binsX"));
+      return 0x0;
+    }
+    graph           = new TGraphErrors(binsX);
+    graph_sysUncorr = new TGraphErrors(binsX);
+    graph->SetTitle(histoName.Data());
+    graph->SetMinimum(0.);
+    graph->SetMaximum(1.2);
+    graph_sysUncorr->SetFillColorAlpha(5,0.05);
+    graph_syscorr->SetFillColorAlpha(6,0.05);
+  }
+  else{// protection
+    cout << "Unknowned Bin type !" << endl;
+    return 0x0;
+  }
+  //________
+
+  //________Counters and Iterator for bin
+  Int_t nofResult = 0;
+  TIter nextBin(bins);
+  nextBin.Reset();
+  //________
+
+  // Loop on bins
+  //==============================================================================
+  while ((r = static_cast<AliAnalysisMuMuBinning::Range*>(nextBin())))
+  {
+    //________Make bin a MuMuResult
+    result = GetSpectra()->GetResultForBin(*r);
+    if (!result){
+      AliError(Form("Cannot find result "));
+      return 0x0;
+    }
+    AliDebug(1, Form("result(%s) = %p ",result->GetName(),result));
+    //________
+
+    // Get a string with bin name
+    TString binAsString = r->AsString();
+
+    // Store quantities
+    num[0] = result->GetValue("NofJPsi");
+    num[1] = result->GetErrorStat("NofJPsi");
+    num[2] = result->GetRMS("NofJPsi");
+
+    //Main methods
+    if(!ComputeRAA(binAsString,&num[0],MUL)) continue;
+
+    // Set the corr. syst. point at  x=0.5,y=1. Computing for each results, maybe a cleaver way to do...
+    graph_syscorr->SetPoint(0,1.,1.);
+    graph_syscorr->SetPointError(0,1.,num[6]);
+
+    //________Compute R_AA in case of fully integrated spectra
+    if(fSpectraName.Contains("-INTEGRATED")){
+      //Output messages
+      cout << Form("") << endl;
+      cout << Form("  |    %s    |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.1f   %.1f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+
+      // Add results to TGraphs
+      graph->SetPoint(nofResult,fConstArray[0],num[4]);
+      graph->SetPointError(nofResult,fConstArray[1],num[5]);
+      graph_sysUncorr->SetPoint(nofResult,fConstArray[0],num[4]);
+      graph_sysUncorr->SetPointError(nofResult,0.2,num[7]);
+    }
+    else if (fSpectraName.Contains("-PT")){
+      num[4]=num[4]/(r->WidthX());
+      cout << Form("") << endl;
+      cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.1f   %.1f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+      //Fill graph
+      Double_t binCenter = (binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult] ;
+      graph->SetPoint(nofResult,binCenter,num[4]);
+      graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+      graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    else if (fSpectraName.Contains("-Y")){
+      num[4]=num[4]/(r->WidthX());
+      cout << Form("") << endl;
+      cout << Form("  | %s |   %.0f  %.0f  %.0f  |  %.3f  %.3f  %.3f  |  %.1f   %.1f  |"  ,binAsString.Data(),num[0],num[1],num[2],num[4],num[5],num[7],fConstArray[0],fConstArray[1]) << endl;
+      //Fill graph
+      Double_t binCenter = -((binArray[nofResult+1]-binArray[nofResult])/2 + binArray[nofResult]) ;
+      graph->SetPoint(nofResult,binCenter,num[4]);
+      graph->SetPointError(nofResult,r->WidthX()/5,num[5]);
+      graph_sysUncorr->SetPoint(nofResult,binCenter,num[4]);
+      graph_sysUncorr->SetPointError(nofResult,r->WidthX()/5,num[7]);
+    }
+    else return 0x0;
+    //________
+
+    nofResult++;
+  }
+
+  // Config. graphics
+  if(fSpectraName.Contains("INTEGRATED"))graph->GetXaxis()->SetTitle(Form("<NPart>"));
+  else if (fSpectraName.Contains("-PT"))graph->GetXaxis()->SetTitle(Form("PT"));
+  else if (fSpectraName.Contains("-Y"))graph->GetXaxis()->SetTitle(Form("Y"));
+  graph->GetYaxis()->SetTitle("R_{AA}");
+  graph->SetMarkerColor(4);
+  graph->SetMarkerStyle(21);
+
+  //Add and merge all Graph
+  TList* l = new TList();
+  l->SetOwner(kTRUE);
+  l->Add(graph);
+  l->Add(graph_sysUncorr);
+  l->Add(graph_syscorr);
+
+  delete bins;
+  delete binArray;
+
+  return l ;
+}
+
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsulePbPb::ComputeRAA(TString sbin, Double_t numArray[], Double_t MUL) const
+{
+  /**
+   *
+   * Checks bin type and read files (or not) accordingly. Then computes and stores several results in numArray.
+   *
+   */
+
+  AliWarning("INNER NORMALIZATION FACTOR, YOU MIGHT CHECK THE CODE !!");
+
+  //________PT and Y case
+  if (fSpectraName.Contains("-PT") || fSpectraName.Contains("-Y"))
+  {
+    // read exterfile and get the correct value
+    float valueArray[13];
+    //  valueArray[0], valueArray[1], valueArray[2], valueArray[3],  valueArray[4], valueArray[5], valueArray[6], valueArray[7], valueArray[8], valueArray[9], valueArray[10], valueArray[11] valueArray[12]
+    //  sigmapp         dsigmapp      dsigmappCorr   dsigmappUncorr  AccEff         dAccEff        sysMC          TrajEffError    TriggerError  PairError,      NofJpsi      , NofJpsiStat,    NofJpsiSys
+
+    if(ReadFromFile(sbin,&valueArray[0])==kFALSE) return kFALSE;
+    AliDebug(1, " Values correctly read from extern file");
+    
+    //Select the source of NofJpsi
+    if(valueArray[10]!=0.)numArray[0]=valueArray[10];
+    if(valueArray[11]!=0.)numArray[1]=valueArray[11];
+    if(valueArray[12]!=0.)numArray[2]=valueArray[12];
+    
+    // Taking 2015 value
+    if(Mul2015!=0) MUL= Mul2015;
+
+    //Normalization according to centrality bin
+    if (fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+    else numArray[3] = (1./9.)*fConstArray[2]*BR*MUL*Fnorm*(valueArray[0]/1000.)*(valueArray[4]);
+
+    AliDebug(1,Form("BR                 = %f\n", BR));
+    AliDebug(1,Form("Fnorm              = %f\n", Fnorm));
+    AliDebug(1,Form("sigma pp           = %f ub \n", valueArray[0]));
+    AliDebug(1,Form("AccEff             = %f\n", valueArray[4]));
+    AliDebug(1,Form("TAA                = %f\n", fConstArray[2]));
+    AliDebug(1,Form("MUL                = %f\n", MUL));
+    AliDebug(1,Form("denominator        = %f\n", numArray[3]));
+    AliDebug(1,Form("NofJpsi extern     = %f\n", valueArray[10]));
+    AliDebug(1,Form("NofJpsiStat extern = %f\n", valueArray[11]));
+    AliDebug(1,Form("NofJpsiSys extern  = %f\n", valueArray[12]));
+
+    //Compute RAA accoroding to NofJpsi entry type
+    if(valueArray[10]==0.)numArray[4] = numArray[0]/numArray[3];
+    else numArray[4] = valueArray[10]/numArray[3];
+
+    //Corr
+    if (fSpectraName.Contains("-PT") ) numArray[6]    = numArray[4] * AliAnalysisMuMuResult::ErrorABCDE(100.,TrajPT,100.,TriggPT,Fnorm,FnormSyst,fConstArray[2],fConstArray[3],valueArray[0],valueArray[2]);
+    else if (fSpectraName.Contains("-Y")) numArray[6] = numArray[4] * AliAnalysisMuMuResult::ErrorABCDE(100.,TrajY,100.,TriggY,Fnorm,FnormSyst,fConstArray[2],fConstArray[3],valueArray[0],valueArray[2]);
+    else {
+      AliError("Unowned bin type... I Told you !");
+      return kFALSE;
+    }
+
+    //Stat error
+    numArray[5] = numArray[4] * AliAnalysisMuMuResult::ErrorAB(numArray[0],numArray[1],Fnorm,FnormStat);
+    //                                                                      signal          FNorm
+    
+    //Corr error
+    numArray[6]     =  TMath::Sqrt(  
+    + fConstArray[4]*fConstArray[4]                                       // syst. AP
+    + 100*100*fConstArray[3]*fConstArray[3]/fConstArray[2]/fConstArray[2] // Taa
+    + 100*100*valueArray[2]*valueArray[2]/sigmaPP/sigmaPP                 // pp cross-section
+    + tailsErro*tailsErro                                                 // Tails
+    + 100*100*FnormSyst*FnormSyst/Fnorm/Fnorm);                           // FNorm
+
+    //UnCorr error
+      numArray[7] = numArray[4] * AliAnalysisMuMuResult::ErrorABCD(100.,valueArray[6],numArray[0],numArray[2],100.,valueArray[7],100.,valueArray[8])
+    //                                                                sysMC                 signal           TrajEffError      TriggerError
+                  + numArray[4] * AliAnalysisMuMuResult::ErrorABC(100.,valueArray[9],valueArray[0],valueArray[2],valueArray[0],valueArray[1]);
+    //                                                                pair                  sigmapp
+
+  }
+  //________Integrated case
+  else if(fSpectraName.Contains("-INTEGRATED")){
+
+    if(fConstArray[10]!=0.)numArray[0]=fConstArray[10];
+    if(fConstArray[11]!=0.)numArray[1]=fConstArray[11];
+    if(fConstArray[12]!=0.)numArray[2]=fConstArray[12];
+
+    //Normalization according to centrality bin
+    if (!fSpectraName.Contains("V0M_00.00_90.00")) numArray[3] = (1./9.)*BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+    else                                           numArray[3] = BR*fConstArray[2]*Fnorm*MUL*(sigmaPP/1000)*(fConstArray[8]);
+    numArray[4] = numArray[0]/numArray[3];
+    //Stat error
+    numArray[5] = numArray[4] * numArray[1]/numArray[0];
+    //                             signal 
+    //Corr error
+    numArray[6]     =  TMath::Sqrt( 
+    MCParamError    *MCParamError                       // MC 
+    + fConstArray[5]*fConstArray[5]                     // Traj.
+    + fConstArray[6]*fConstArray[6]                     // Trigg.
+    + tailsErro*tailsErro                               // Tails.
+    + pairError*pairError                               // Pairing.
+    + 100*100*dsigmaPP*dsigmaPP/sigmaPP/sigmaPP         // pp stat
+    + 100*100*dsigmaPPCorr*dsigmaPPCorr/sigmaPP/sigmaPP // pp cross-section
+    + 100*100*FnormSyst*FnormSyst/Fnorm/Fnorm);         // FNorm
+
+    numArray[7] = numArray[4] * AliAnalysisMuMuResult::ErrorABC(numArray[0],numArray[2],fConstArray[2],fConstArray[3], 100.,fConstArray[4]);
+    //                                                                  signal                       TAA                       AP
+  }
+  else {
+    AliError("Unowned bin type... I Told you !");
+    return kFALSE;
+  }
+ 
+ return kTRUE;
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::Print(Option_t* opt) const
+{
+  /**
+   *
+   * Print spectra
+   *
+   */
+
+  //Check point
+  if(!GetSpectra()) return ;
+  GetSpectra()->Print(opt);
+}
+
+//_____________________________________________________________________________
+void AliAnalysisMuMuSpectraCapsulePbPb::PrintConst() const
+{
+    ///
+    /// Print member constants on the terminal
+    ///
+
+  //Check point
+  if(!GetSpectra()) return ;
+  else{
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" Constants for Spectra %s",fSpectraName.Data()) << endl;
+    cout <<      " ================================================================ " << endl;
+    cout << Form(" -- Value of <Npart>                    = %f",fConstArray[0]) << endl;
+    cout << Form(" -- Value of d<Npart>                   = %f",fConstArray[1]) << endl;
+    cout << Form(" -- Value of TAA                        = %f",fConstArray[2]) << endl;
+    cout << Form(" -- Value of dTAA                       = %f",fConstArray[3]) << endl;
+    cout << Form(" -- Value of sys.AP                     = %f",fConstArray[4]) << endl;
+    cout << Form(" -- Value of Traj. err.                 = %f",fConstArray[5]) << endl;
+    cout << Form(" -- Value of Trigg. err.                = %f",fConstArray[6]) << endl;
+    cout << Form(" -- Value of Pair. err.                 = %f",fConstArray[7]) << endl;
+    cout << Form(" -- Value of AccEff                     = %f",fConstArray[8]) << endl;
+    cout << Form(" -- Value of dAccEff                    = %f",fConstArray[9]) << endl;
+    cout << Form(" -- Value of NofJpsi from exterfile     = %f",fConstArray[10]) << endl;
+    cout << Form(" -- Value of StatNofJpsi from exterfile = %f",fConstArray[11]) << endl;
+    cout << Form(" -- Value of SystNofJpsi from exterfile = %f",fConstArray[12]) << endl;
+  }
+}
+
+//_____________________________________________________________________________
+Bool_t AliAnalysisMuMuSpectraCapsulePbPb::ReadFromFile(TString sbin, float valueArray[]) const
+{
+    ///
+    /// Read extern file lines and store associated values. Exemple of line :
+    /// #intervalLow    intervalHight   sigmapp dsigmapp    dsigmappCorr    dsigmappUncorr  AccEff dAccEff  sysMC TrajEffError  TriggerError    PairError
+    /// 00              01              0.6413  0.02611     0.000           0.000           0.1435 0.0009   0.000 0.000         0.04            0.00
+    ///
+    /// All white space must be single whitespace, i.e " " and not "<tab>"
+
+    Bool_t ok =kFALSE;
+
+    //________Open file
+    ifstream infile(fExternFile.Data(),std::ios::in);
+    TString line;
+    TObjArray* lineArray;
+
+    if (infile)
+    {
+      AliDebug(1, " ==== opening file ==== ");
+      // Loop until end of file is reached
+      while(infile.eof()!=kTRUE){
+
+        //read the line
+        line.ReadLine(infile,kFALSE);
+        if (line.BeginsWith("#"))continue;
+        AliDebug(1,Form(" Read line : %s",line.Data()));
+
+        // Put the line in a TObjArray
+        lineArray = line.Tokenize(" ");
+
+        // Select the good interval. Since interval is written in <binAsString>, just need them to match
+        TString intervalLow  = TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(0))->String().Atof());
+        TString intervalHigh = TString::Format("%.2f",static_cast<TObjString*>(lineArray->At(1))->String().Atof());
+        if(sbin.Contains(Form("%s",intervalLow.Data())) && sbin.Contains(Form("%s",intervalHigh.Data()))){
+            AliDebug(1,Form(" -- line selected -- "));
+            ok = kTRUE;
+            break;
+        }
+        else continue;
+      }
+      infile.close();
+      AliDebug(1, " ==== closing file ==== ");
+
+      // Store the value
+        for (int i =0 ; i<13 ; i++) {
+            valueArray[i]= static_cast<TObjString*>(lineArray->At(i+2))->String().Atof();
+        }
+        return ok;
+    }
+    else return ok;
+}
diff --git a/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h
new file mode 100644
index 0000000..b1148b7
--- /dev/null
+++ b/PWG/muondep/AliAnalysisMuMuSpectraCapsulePbPb.h
@@ -0,0 +1,89 @@
+
+#ifndef ALINANALYSISMUMUSPECTRACAPSULEPBPB_H
+#define ALINANALYSISMUMUSPECTRACAPSULEPBPB_H
+
+
+/* Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
+ * See cxx source for full Copyright notice                               */
+
+// $Id$
+
+///
+/// AliAnalysisMuMuSpectraCapsulePbPb : helper class to deal with results stored in a spectra with PbPb methods.
+///
+/// author : Benjamin Audurier (Subatech)
+
+
+
+#include "TNamed.h"
+#include "TMath.h"
+#include <TString.h>
+#include "TGraphErrors.h"
+#include "AliAnalysisMuMuSpectra.h"
+#include "AliCounterCollection.h"
+#include "AliMergeableCollection.h"
+#include "AliAnalysisMuMuSpectraCapsule.h"
+
+class TGraphErrors;
+class AliAnalysisMuMuSpectra;
+class AliAnalysisMuMuSpectraCapsulePbPb : public AliAnalysisMuMuSpectraCapsule
+{
+
+public:
+  //ctor
+  AliAnalysisMuMuSpectraCapsulePbPb(
+                             const AliAnalysisMuMuSpectra            *  spectra=0x0,
+                             const TString                           spectraPath ="",
+                             const char                              * externFile="",
+                             const char                              * externFile2="");
+  // dtor
+  virtual ~AliAnalysisMuMuSpectraCapsulePbPb();
+  // Compute Yield
+  TGraphErrors* ComputeYield(const char* what="", const TH1* histo=0x0, const char* sResName="");
+  // Draw fit results and save them if wanted
+  void DrawResults(const char* particle="PSI",const char* subresults="")const;
+  // Print some data members
+  void Print(Option_t* opt="") const;
+  // Print constants used
+  void PrintConst() const;
+  // Compute quantities linked to RAA
+  TList* RAAasGraphic(Double_t MUL) const;
+
+
+  // Return some data member. Double "const" on purpose to avoid leverage on data members
+  const Double_t              * GetConstArray()     const {return fConstArray;};
+  const AliAnalysisMuMuSpectra* GetSpectra()       const {return fSpectra;};
+  const TString                GetSpectraName()    const {return fSpectraName;};
+
+private:
+  // Read and compute values from extern file
+  Bool_t ComputeRAA(TString sbin, Double_t numArray[],Double_t MUL) const;
+  // Read exterfil for Pt and Y case
+  Bool_t ReadFromFile(TString sbin, float valueArray[]) const;
+  // Set global constants according to centrality
+  Bool_t SetConstantFromExternFile(const char* file);
+  // Equality operator
+  AliAnalysisMuMuSpectraCapsulePbPb(const AliAnalysisMuMuSpectraCapsulePbPb& rhs);// not implemented on purpose
+  AliAnalysisMuMuSpectraCapsulePbPb& operator=(const AliAnalysisMuMuSpectraCapsulePbPb& rhs);// not implemented on purpose
+
+
+private:
+  TString fExternFile;      // name of spectra selected
+  TString fExternFile2;     // name of spectra selected
+  Double_t fConstArray[13]; // Array to store constant according to centrality bins
+
+  const AliAnalysisMuMuSpectra* fSpectra;// Spectra with result and subresults
+  const TString               fSpectraName;     // SpectraName
+
+/// \cond CLASSIMP
+ClassDef(AliAnalysisMuMuSpectraCapsulePbPb,1);
+/// \endcond
+};
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/PWG/muondep/AliMuonAccEffSubmitter.cxx b/PWG/muondep/AliMuonAccEffSubmitter.cxx
index 6fca74c..8a8a05b 100644
--- a/PWG/muondep/AliMuonAccEffSubmitter.cxx
+++ b/PWG/muondep/AliMuonAccEffSubmitter.cxx
@@ -152,6 +152,20 @@ fUseAODMerging(kFALSE)
   SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P2","0.141776");
   SetVar("VAR_GENPARAMCUSTOMSINGLE_Y_P3","0.0130173");
 
+  // some default values for single muons ben
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PTMIN","0.35");
+
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P0","135.137");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P1","0.555323");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P2","0.578374");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P3","10.1345");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P4","0.000232233");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_PT_P5","-0.924726");
+
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P0","1.95551");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P1","-0.104761");
+  SetVar("VAR_GENPARAMCUSTOMSINGLEBEN_Y_P2","0.00311324");
+
   // some default values for GenBox
   
   SetVar("VAR_GENMUBOX_PTMIN","0");
diff --git a/PWG/muondep/CMakeLists.txt b/PWG/muondep/CMakeLists.txt
index bc35348..2ef25b5 100644
--- a/PWG/muondep/CMakeLists.txt
+++ b/PWG/muondep/CMakeLists.txt
@@ -35,8 +35,12 @@ set(SRCS
   AliAnalysisTriggerScalers.cxx
   AliAnalysisMuMu.cxx
   AliAnalysisMuMuConfig.cxx
-  AliAnalysisMuMuResult.cxx
   AliAnalysisMuMuJpsiResult.cxx
+  AliAnalysisMuMuResult.cxx
+  AliAnalysisMuMuSpectraCapsule.cxx
+  AliAnalysisMuMuSpectraCapsulePbPb.cxx
+  AliAnalysisMuMuSpectraCapsulePbP.cxx
+  AliAnalysisMuMuSpectraCapsulePP.cxx
   AliAnalysisMuMuFnorm.cxx
   AliAnalysisMuMuGraphUtil.cxx
   AliAnalysisMuMuSpectra.cxx
diff --git a/PWG/muondep/PWGmuondepLinkDef.h b/PWG/muondep/PWGmuondepLinkDef.h
index 53f8b36..43f8607 100644
--- a/PWG/muondep/PWGmuondepLinkDef.h
+++ b/PWG/muondep/PWGmuondepLinkDef.h
@@ -14,6 +14,10 @@
 #pragma link C++ class AliAnalysisMuMuConfig+;
 #pragma link C++ class AliAnalysisMuMuResult+;
 #pragma link C++ class AliAnalysisMuMuJpsiResult+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsule+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePbPb+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePbP+;
+#pragma link C++ class AliAnalysisMuMuSpectraCapsulePP+;
 #pragma link C++ class AliAnalysisMuMuFnorm+;
 #pragma link C++ class AliAnalysisMuMuGraphUtil+;
 #pragma link C++ class AliAnalysisMuMuSpectra+;
-- 
2.7.4 (Apple Git-66)

